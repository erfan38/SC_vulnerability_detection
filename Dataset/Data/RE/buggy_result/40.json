[
    {
        "vulnerableLines": "211-221",
        "vulnerabilityReason": "The function 'withdrawBalance_re_ent40' sends ether to msg.sender using a low-level call before updating 'userBalance_re_ent40[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain the contract by repeatedly triggering the send operation before the user balance is reset.",
        "fixedCode": "function withdrawBalance_re_ent40() public{ uint amount = userBalance_re_ent40[msg.sender]; userBalance_re_ent40[msg.sender] = 0; (bool success, ) = msg.sender.call.value(amount)(\"\"); if(!success) { userBalance_re_ent40[msg.sender] = amount; }}"
    },
    {
        "vulnerableLines": "229-238",
        "vulnerabilityReason": "The function 'withdrawBalance_re_ent33' sends ether to msg.sender using a low-level call before updating 'userBalance_re_ent33[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain the contract by repeatedly triggering the send operation before the user balance is reset.",
        "fixedCode": "function withdrawBalance_re_ent33() public{ uint amount = userBalance_re_ent33[msg.sender]; userBalance_re_ent33[msg.sender] = 0; (bool success, ) = msg.sender.call.value(amount)(\"\"); if(!success) { userBalance_re_ent33[msg.sender] = amount; }}"
    },
    {
        "vulnerableLines": "243-250",
        "vulnerabilityReason": "The function 'bug_re_ent27' sends ether to msg.sender using 'msg.sender.send(1 ether)' before updating 'not_called_re_ent27'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain the contract by repeatedly triggering the send operation before the boolean is updated.",
        "fixedCode": "function bug_re_ent27() public{ require(not_called_re_ent27); not_called_re_ent27 = false; if(!msg.sender.send(1 ether)) { not_called_re_ent27 = true; revert(); }}"
    },
    {
        "vulnerableLines": "86-92",
        "vulnerabilityReason": "The function 'withdrawFunds_re_ent31' sends ether to msg.sender using 'msg.sender.send' before updating 'balances_re_ent31[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain the contract by repeatedly triggering the send operation before the user balance is reset.",
        "fixedCode": "function withdrawFunds_re_ent31(uint256 _weiToWithdraw) public { require(balances_re_ent31[msg.sender] >= _weiToWithdraw); balances_re_ent31[msg.sender] -= _weiToWithdraw; if (!msg.sender.send(_weiToWithdraw)) { balances_re_ent31[msg.sender] += _weiToWithdraw; revert(); }}"
    },
    {
        "vulnerableLines": "78-83",
        "vulnerabilityReason": "The function 'withdraw_balances_re_ent8' sends ether to msg.sender using a low-level call before updating 'balances_re_ent8[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain the contract by repeatedly triggering the send operation before the user balance is reset.",
        "fixedCode": "function withdraw_balances_re_ent8 () public { uint amount = balances_re_ent8[msg.sender]; balances_re_ent8[msg.sender] = 0; (bool success, ) = msg.sender.call.value(amount)(\"\"); if (!success) { balances_re_ent8[msg.sender] = amount; }}"
    },
    {
        "vulnerableLines": "216-223",
        "vulnerabilityReason": "The function 'withdrawFunds_re_ent17' uses 'msg.sender.call.value' to send funds before updating the balance of the user. This can result in reentrancy vulnerability as the user can make repeated withdrawals before the state is updated.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is updated to reflect the withdrawal.",
        "fixedCode": "mapping(address => uint) balances_re_ent17;\nfunction withdrawFunds_re_ent17 (uint256 _weiToWithdraw) public {\n  require(balances_re_ent17[msg.sender] >= _weiToWithdraw);\n  balances_re_ent17[msg.sender] -= _weiToWithdraw;\n  (bool success,) = msg.sender.call.value(_weiToWithdraw)(\"\");\n  require(success); \n}"
    },
    {
        "vulnerableLines": "226-233",
        "vulnerabilityReason": "The function 'buyTicket_re_ent37' sends ether to the last player using 'lastPlayer_re_ent37.send(jackpot_re_ent37)' before updating 'lastPlayer_re_ent37' and 'jackpot_re_ent37'. This creates a reentrancy vulnerability.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function to deplete the jackpot before the state variables are updated.",
        "fixedCode": "address payable lastPlayer_re_ent37;\nuint jackpot_re_ent37;\nfunction buyTicket_re_ent37() public {\n  uint tempJackpot = jackpot_re_ent37;\n  address payable tempLastPlayer = lastPlayer_re_ent37;\n  lastPlayer_re_ent37 = msg.sender;\n  jackpot_re_ent37 = address(this).balance;\n  if (!tempLastPlayer.send(tempJackpot)) { \n    revert(); \n  }\n}"
    },
    {
        "vulnerableLines": "237-242",
        "vulnerabilityReason": "The function 'withdrawFunds_re_ent3' sends ether to msg.sender using 'msg.sender.call.value(_weiToWithdraw)(\"\")' before updating 'balances_re_ent3[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is properly updated.",
        "fixedCode": "function withdrawFunds_re_ent3(uint256 _weiToWithdraw) public { require(balances_re_ent3[msg.sender] >= _weiToWithdraw); balances_re_ent3[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(\"\"); require(success); }"
    },
    {
        "vulnerableLines": "252-261",
        "vulnerabilityReason": "The function 'withdrawBalance_re_ent26' sends ether to msg.sender using a call before updating 'userBalance_re_ent26[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is properly updated.",
        "fixedCode": "function withdrawBalance_re_ent26() public { uint amount = userBalance_re_ent26[msg.sender]; userBalance_re_ent26[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(\"\"); if (!success) { userBalance_re_ent26[msg.sender] = amount; revert(); }}"
    },
    {
        "vulnerableLines": "269-275",
        "vulnerabilityReason": "The function 'bug_re_ent20' sends ether to msg.sender using 'msg.sender.send(1 ether)' before updating 'not_called_re_ent20'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state is updated.",
        "fixedCode": "function bug_re_ent20() public{ require(not_called_re_ent20); not_called_re_ent20 = false; if (!msg.sender.send(1 ether)) { not_called_re_ent20 = true; revert(); }}"
    },
    {
        "vulnerableLines": "290-297",
        "vulnerabilityReason": "The function 'claimReward_re_ent32' sends ether to msg.sender using 'msg.sender.transfer' before updating 'redeemableEther_re_ent32[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the transfer before the balance is properly updated.",
        "fixedCode": "function claimReward_re_ent32() public { uint transferValue_re_ent32 = redeemableEther_re_ent32[msg.sender]; redeemableEther_re_ent32[msg.sender] = 0; msg.sender.transfer(transferValue_re_ent32); }"
    },
    {
        "vulnerableLines": "305-311",
        "vulnerabilityReason": "The function 'withdrawFunds_re_ent38' sends ether to msg.sender using 'msg.sender.send' before updating 'balances_re_ent38[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is properly updated.",
        "fixedCode": "function withdrawFunds_re_ent38(uint256 _weiToWithdraw) public { require(balances_re_ent38[msg.sender] >= _weiToWithdraw); balances_re_ent38[msg.sender] -= _weiToWithdraw; if (!msg.sender.send(_weiToWithdraw)) { balances_re_ent38[msg.sender] += _weiToWithdraw; revert(); }}"
    },
    {
        "vulnerableLines": "324-331",
        "vulnerabilityReason": "The function 'claimReward_re_ent4' sends ether to msg.sender using 'msg.sender.transfer' before updating 'redeemableEther_re_ent4[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the transfer before the balance is properly updated.",
        "fixedCode": "function claimReward_re_ent4() public { uint transferValue_re_ent4 = redeemableEther_re_ent4[msg.sender]; redeemableEther_re_ent4[msg.sender] = 0; msg.sender.transfer(transferValue_re_ent4); }"
    },
    {
        "vulnerableLines": "351-357",
        "vulnerabilityReason": "The function 'callme_re_ent7' sends ether to msg.sender using 'msg.sender.send(10 ether)' before updating 'counter_re_ent7'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state is properly updated.",
        "fixedCode": "function callme_re_ent7() public { require(counter_re_ent7 <= 5); counter_re_ent7 += 1; if(!msg.sender.send(10 ether)){ revert(); } }"
    },
    {
        "vulnerableLines": "375-382",
        "vulnerabilityReason": "The function 'buyTicket_re_ent23' sends ether to the last player using 'lastPlayer_re_ent23.send(jackpot_re_ent23)' before updating 'lastPlayer_re_ent23' and 'jackpot_re_ent23'. A reentrant call could be made before these updates, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain the jackpot by repeatedly triggering the send operation before updating the state variables.",
        "fixedCode": "function buyTicket_re_ent23() public { uint tempJackpot = jackpot_re_ent23; address payable tempLastPlayer = lastPlayer_re_ent23; lastPlayer_re_ent23 = msg.sender; jackpot_re_ent23 = address(this).balance; if (!tempLastPlayer.send(tempJackpot)) { revert(); }}"
    },
    {
        "vulnerableLines": "402-409",
        "vulnerabilityReason": "The function 'callme_re_ent14' sends ether to msg.sender using 'msg.sender.send(10 ether)' before updating 'counter_re_ent14'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state is properly updated.",
        "fixedCode": "function callme_re_ent14() public { require(counter_re_ent14 <= 5); counter_re_ent14 += 1; if(!msg.sender.send(10 ether)){ revert(); } }"
    },
    {
        "vulnerableLines": "433-440",
        "vulnerabilityReason": "The function 'buyTicket_re_ent30' sends ether to the last player using 'lastPlayer_re_ent30.send(jackpot_re_ent30)' before updating 'lastPlayer_re_ent30' and 'jackpot_re_ent30'. A reentrant call could be made before these updates, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain the jackpot by repeatedly triggering the send operation before updating the state variables.",
        "fixedCode": "function buyTicket_re_ent30() public { uint tempJackpot = jackpot_re_ent30; address payable tempLastPlayer = lastPlayer_re_ent30; lastPlayer_re_ent30 = msg.sender; jackpot_re_ent30 = address(this).balance; if (!tempLastPlayer.send(tempJackpot)) { revert(); }}"
    },
    {
        "vulnerableLines": "458-463",
        "vulnerabilityReason": "The function 'withdraw_balances_re_ent8' sends ether to msg.sender using a call before updating 'balances_re_ent8[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is reset.",
        "fixedCode": "function withdraw_balances_re_ent8 () public { uint amount = balances_re_ent8[msg.sender]; balances_re_ent8[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(\"\"); if (!success) { balances_re_ent8[msg.sender] = amount; }}"
    },
    {
        "vulnerableLines": "483-490",
        "vulnerabilityReason": "The function 'claimReward_re_ent39' sends ether to msg.sender using 'msg.sender.transfer' before updating 'redeemableEther_re_ent39[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the transfer before the balance is reset.",
        "fixedCode": "function claimReward_re_ent39() public { uint transferValue_re_ent39 = redeemableEther_re_ent39[msg.sender]; redeemableEther_re_ent39[msg.sender] = 0; msg.sender.transfer(transferValue_re_ent39); }"
    },
    {
        "vulnerableLines": "512-516",
        "vulnerabilityReason": "The function 'withdraw_balances_re_ent36' sends ether to msg.sender using 'msg.sender.send' before updating 'balances_re_ent36[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is reset.",
        "fixedCode": "function withdraw_balances_re_ent36() public { uint amount = balances_re_ent36[msg.sender]; balances_re_ent36[msg.sender] = 0; if (!msg.sender.send(amount)) { balances_re_ent36[msg.sender] = amount; }}"
    },
    {
        "vulnerableLines": "528-535",
        "vulnerabilityReason": "The function 'callme_re_ent35' sends ether to msg.sender using 'msg.sender.send(10 ether)' before updating 'counter_re_ent35'. A reentrant call could be made reducing the counter to less than or equal to 5, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state is properly updated.",
        "fixedCode": "function callme_re_ent35() public{ require(counter_re_ent35 <= 5); counter_re_ent35 += 1; if (!msg.sender.send(10 ether)){ revert(); }}"
    },
    {
        "vulnerableLines": "542-550",
        "vulnerabilityReason": "The function 'buyTicket_re_ent9' sends ether to the last player using 'lastPlayer_re_ent9.call.value(jackpot_re_ent9)' before updating 'lastPlayer_re_ent9' and 'jackpot_re_ent9'. A reentrant call could be made before these updates, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain the jackpot by repeatedly triggering the call operation before updating the state variables.",
        "fixedCode": "function buyTicket_re_ent9() public { uint tempJackpot = jackpot_re_ent9; address payable tempLastPlayer = lastPlayer_re_ent9; lastPlayer_re_ent9 = msg.sender; jackpot_re_ent9 = address(this).balance; (bool success,) = tempLastPlayer.call.value(tempJackpot)(\"\"); if (!success) { revert(); }}"
    },
    {
        "vulnerableLines": "552-559",
        "vulnerabilityReason": "The function 'claimReward_re_ent25' sends ether to msg.sender using 'msg.sender.transfer' before updating 'redeemableEther_re_ent25[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the transfer before the balance is reset.",
        "fixedCode": "function claimReward_re_ent25() public { uint transferValue_re_ent25 = redeemableEther_re_ent25[msg.sender]; redeemableEther_re_ent25[msg.sender] = 0; msg.sender.transfer(transferValue_re_ent25); }"
    },
    {
        "vulnerableLines": "561-569",
        "vulnerabilityReason": "The function 'withdrawBalance_re_ent19' sends ether to msg.sender using 'msg.sender.send' before updating 'userBalance_re_ent19[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is reset.",
        "fixedCode": "function withdrawBalance_re_ent19() public { uint amount = userBalance_re_ent19[msg.sender]; userBalance_re_ent19[msg.sender] = 0; if (!msg.sender.send(amount)) { userBalance_re_ent19[msg.sender] = amount; }}"
    },
    {
        "vulnerableLines": "582-591",
        "vulnerabilityReason": "The function 'withdrawBalance_re_ent40' sends ether to msg.sender using a call before updating 'userBalance_re_ent40[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the call operation before the balance is reset.",
        "fixedCode": "function withdrawBalance_re_ent40() public { uint amount = userBalance_re_ent40[msg.sender]; userBalance_re_ent40[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(\"\"); if (!success) { userBalance_re_ent40[msg.sender] = amount; }}"
    },
    {
        "vulnerableLines": "599-608",
        "vulnerabilityReason": "The function 'withdrawBalance_re_ent33' sends ether to msg.sender using a call before updating 'userBalance_re_ent33[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is reset.",
        "fixedCode": "function withdrawBalance_re_ent33() public { uint amount = userBalance_re_ent33[msg.sender]; userBalance_re_ent33[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(\"\"); if (!success) { userBalance_re_ent33[msg.sender] = amount; }}"
    },
    {
        "vulnerableLines": "617-624",
        "vulnerabilityReason": "The function 'bug_re_ent27' sends ether to msg.sender using 'msg.sender.send(1 ether)' before updating 'not_called_re_ent27'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state is updated.",
        "fixedCode": "function bug_re_ent27() public { require(not_called_re_ent27); not_called_re_ent27 = false; if (!msg.sender.send(1 ether)) { not_called_re_ent27 = true; revert(); }}"
    },
    {
        "vulnerableLines": "641-647",
        "vulnerabilityReason": "The function 'withdrawFunds_re_ent31' sends ether to msg.sender using 'msg.sender.send' before updating 'balances_re_ent31[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state is properly updated.",
        "fixedCode": "function withdrawFunds_re_ent31(uint256 _weiToWithdraw) public { require(balances_re_ent31[msg.sender] >= _weiToWithdraw); balances_re_ent31[msg.sender] -= _weiToWithdraw; if (!msg.sender.send(_weiToWithdraw)) { balances_re_ent31[msg.sender] += _weiToWithdraw; revert(); }}"
    },
    {
        "vulnerableLines": "654-662",
        "vulnerabilityReason": "The function 'bug_re_ent13' sends ether to msg.sender using a call before updating 'not_called_re_ent13'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state is updated.",
        "fixedCode": "function bug_re_ent13() public { require(not_called_re_ent13); not_called_re_ent13 = false; (bool success,) = msg.sender.call.value(1 ether)(\"\"); if (!success) { not_called_re_ent13 = true; revert(); }}"
    }
]
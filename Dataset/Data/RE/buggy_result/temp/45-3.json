[
    {
        "vulnerableLines": "1-5",
        "vulnerabilityReason": "The function 'collectPlayerWinnings' sends ether to msg.sender using 'msg.sender.transfer(splitJackpot)' before updating the player's status in 'guesses[result].players[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain the jackpot by repeatedly triggering the transfer before the player's status is updated.",
        "fixedCode": "function collectPlayerWinnings() public byPlayer inState(State.PLAYERS_WIN) { if (guesses[result].players[msg.sender] == PaidStatus.NOT_PAID) { guesses[result].players[msg.sender] = PaidStatus.PAID; uint256 amount = splitJackpot; (bool success,) = msg.sender.call.value(amount)(\"\"); if (!success) { guesses[result].players[msg.sender] = PaidStatus.NOT_PAID; revert(); } } else revert(); }"
    },
    {
        "vulnerableLines": "7-14",
        "vulnerabilityReason": "The function 'buyTicket_re_ent30' sends ether to the last player using 'lastPlayer_re_ent30.send(jackpot_re_ent30)' before updating 'lastPlayer_re_ent30' and 'jackpot_re_ent30'. A reentrant call could be made before these updates, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain the jackpot by repeatedly triggering the send operation before updating the state variables.",
        "fixedCode": "function buyTicket_re_ent30() public { uint256 tempJackpot = jackpot_re_ent30; address payable tempLastPlayer = lastPlayer_re_ent30; lastPlayer_re_ent30 = msg.sender; jackpot_re_ent30    = address(this).balance; if (!tempLastPlayer.send(tempJackpot)) { revert(); }}"
    },
    {
        "vulnerableLines": "19-24",
        "vulnerabilityReason": "The function 'withdraw_balances_re_ent8' sends ether to msg.sender using a call before updating 'balances_re_ent8[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is reset.",
        "fixedCode": "function withdraw_balances_re_ent8() public { uint256 amount = balances_re_ent8[msg.sender]; balances_re_ent8[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(\"\"); if (!success) { balances_re_ent8[msg.sender] = amount; revert(); }}"
    }
]
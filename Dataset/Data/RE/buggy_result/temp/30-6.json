[
    {
        "vulnerableLines": "10-17",
        "vulnerabilityReason": "The function 'callme_re_ent35' sends ether to msg.sender using 'msg.sender.send(10 ether)' before updating 'counter_re_ent35'. A reentrant call could be made reducing the counter to less than or equal to 5, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state is properly updated.",
        "fixedCode": "function callme_re_ent35() public{ require(counter_re_ent35 <= 5); counter_re_ent35 += 1; if (!msg.sender.send(10 ether)){ revert(); }}"
    },
    {
        "vulnerableLines": "19-28",
        "vulnerabilityReason": "The function 'withdrawBalance_re_ent40' sends ether to msg.sender using a call before updating 'userBalance_re_ent40[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is reset.",
        "fixedCode": "function withdrawBalance_re_ent40() public { uint amount = userBalance_re_ent40[msg.sender]; userBalance_re_ent40[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(\"\"); if (!success) { userBalance_re_ent40[msg.sender] = amount; }}"
    },
    {
        "vulnerableLines": "36-42",
        "vulnerabilityReason": "The function 'withdrawFunds_re_ent17' sends ether to msg.sender using a call before updating 'balances_re_ent17[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is reset.",
        "fixedCode": "function withdrawFunds_re_ent17 (uint256 _weiToWithdraw) public { require(balances_re_ent17[msg.sender] >= _weiToWithdraw); uint amount = _weiToWithdraw; balances_re_ent17[msg.sender] -= amount; (bool success,)=msg.sender.call.value(amount)(\"\"); require(success); }"
    },
    {
        "vulnerableLines": "53-60",
        "vulnerabilityReason": "The function 'buyTicket_re_ent37' sends ether to last player using 'lastPlayer_re_ent37.send' before updating the 'lastPlayer_re_ent37' and 'jackpot_re_ent37'. A reentrant call could be made before these updates, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain the jackpot by repeatedly triggering the send operation before the state variables are updated.",
        "fixedCode": "function buyTicket_re_ent37() public { uint tmpJackpot = jackpot_re_ent37; address payable tmpLastPlayer = lastPlayer_re_ent37; lastPlayer_re_ent37 = msg.sender; jackpot_re_ent37 = address(this).balance; if (!tmpLastPlayer.send(tmpJackpot)){ revert(); }}"
    },
    {
        "vulnerableLines": "65-71",
        "vulnerabilityReason": "The function 'withdrawFunds_re_ent3' sends ether to msg.sender using a call before updating 'balances_re_ent3[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is reset.",
        "fixedCode": "function withdrawFunds_re_ent3(uint256 _weiToWithdraw) public { require(balances_re_ent3[msg.sender] >= _weiToWithdraw); uint amount = _weiToWithdraw; balances_re_ent3[msg.sender] -= amount; (bool success,)=msg.sender.call.value(amount)(\"\"); require(success); }"
    },
    {
        "vulnerableLines": "78-85",
        "vulnerabilityReason": "The function 'buyTicket_re_ent9' sends ether to last player using 'lastPlayer_re_ent9.call.value' before updating the 'lastPlayer_re_ent9' and 'jackpot_re_ent9'. A reentrant call could be made before these updates, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain the jackpot by repeatedly triggering the send operation before the state variables are updated.",
        "fixedCode": "function buyTicket_re_ent9() public { uint tmpJackpot = jackpot_re_ent9; address payable tmpLastPlayer = lastPlayer_re_ent9; lastPlayer_re_ent9 = msg.sender; jackpot_re_ent9 = address(this).balance; (bool success,)=tmpLastPlayer.call.value(tmpJackpot)(\"\"); if (!success) { revert(); }}"
    },
    {
        "vulnerableLines": "91-98",
        "vulnerabilityReason": "The function 'claimReward_re_ent25' sends ether to msg.sender using 'msg.sender.transfer' before updating 'redeemableEther_re_ent25[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the transfer before the balance is reset.",
        "fixedCode": "function claimReward_re_ent25() public { uint amount = redeemableEther_re_ent25[msg.sender]; redeemableEther_re_ent25[msg.sender] = 0; msg.sender.transfer(amount); }"
    },
    {
        "vulnerableLines": "104-112",
        "vulnerabilityReason": "The function 'withdrawBalance_re_ent19' sends ether to msg.sender using 'msg.sender.send' before updating 'userBalance_re_ent19[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is reset.",
        "fixedCode": "function withdrawBalance_re_ent19() public { uint amount = userBalance_re_ent19[msg.sender]; userBalance_re_ent19[msg.sender] = 0; if (!msg.sender.send(amount)) { userBalance_re_ent19[msg.sender] = amount; revert(); }}"
    }
]
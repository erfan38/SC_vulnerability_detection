[
  {
    "vulnerableLines": "22-28",
    "vulnerabilityReason": "The function 'callme_re_ent7' sends ether to msg.sender using 'msg.sender.send(10 ether)' before updating the counter_re_ent7. A reentrant call could be made reducing the counter to less than or equal to 5, allowing repeated withdrawals.",
    "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state is properly updated.",
    "fixedCode": "function callme_re_ent7() public {
                      require(counter_re_ent7 <= 5);
                      counter_re_ent7 += 1;
                      if( ! msg.sender.send(10 ether) ) {
                        revert();
                      }
                  }"
  },
  {
    "vulnerableLines": "36-42",
    "vulnerabilityReason": "The function 'buyTicket_re_ent23' sends ether to the last player using 'lastPlayer_re_ent23.send(jackpot_re_ent23)' before updating 'lastPlayer_re_ent23' and 'jackpot_re_ent23'. A reentrant call could be made before these updates, allowing repeated withdrawals.",
    "potentialSecurityRisk": "An attacker could drain the jackpot by repeatedly triggering the send operation before updating the state variables.",
    "fixedCode": "function buyTicket_re_ent23() public {
                      address payable tempLastPlayer = lastPlayer_re_ent23;
                      uint tempJackpot = jackpot_re_ent23;
                      lastPlayer_re_ent23 = msg.sender;
                      jackpot_re_ent23 = address(this).balance;
                      if (!tempLastPlayer.send(tempJackpot)) {
                        revert();
                      }
                  }"
  },
  {
    "vulnerableLines": "51-57",
    "vulnerabilityReason": "The function 'callme_re_ent14' sends ether to msg.sender using 'msg.sender.send(10 ether)' before updating the counter_re_ent14. A reentrant call could be made reducing the counter to less than or equal to 5, allowing repeated withdrawals.",
    "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state is properly updated.",
    "fixedCode": "function callme_re_ent14() public {
                      require(counter_re_ent14 <= 5);
                      counter_re_ent14 += 1;
                      if (!msg.sender.send(10 ether)) {
                        revert();
                      }
                  }"
  },
  {
    "vulnerableLines": "65-71",
    "vulnerabilityReason": "The function 'buyTicket_re_ent30' sends ether to the last player using 'lastPlayer_re_ent30.send(jackpot_re_ent30)' before updating 'lastPlayer_re_ent30' and 'jackpot_re_ent30'. A reentrant call could be made before these updates, allowing repeated withdrawals.",
    "potentialSecurityRisk": "An attacker could drain the jackpot by repeatedly triggering the send operation before updating the state variables.",
    "fixedCode": "function buyTicket_re_ent30() public {
                      address payable tempLastPlayer = lastPlayer_re_ent30;
                      uint tempJackpot = jackpot_re_ent30;
                      lastPlayer_re_ent30 = msg.sender;
                      jackpot_re_ent30 = address(this).balance;
                      if (!tempLastPlayer.send(tempJackpot)) {
                        revert();
                      }
                  }"
  },
  {
    "vulnerableLines": "78-82",
    "vulnerabilityReason": "The function 'withdraw_balances_re_ent8' sends ether to msg.sender using a call before updating 'balances_re_ent8[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
    "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is reset.",
    "fixedCode": "function withdraw_balances_re_ent8 () public {
                      uint amount = balances_re_ent8[msg.sender];
                      balances_re_ent8[msg.sender] = 0;
                      (bool success,) = msg.sender.call.value(amount)('');
                      if (!success) {
                        balances_re_ent8[msg.sender] = amount;
                      }
                  }"
  },
  {
    "vulnerableLines": "86-91",
    "vulnerabilityReason": "The function 'withdrawFunds_re_ent31' sends ether to msg.sender using 'msg.sender.send' before updating 'balances_re_ent31[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
    "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state is properly updated.",
    "fixedCode": "function withdrawFunds_re_ent31 (uint256 _weiToWithdraw) public {
                      require(balances[msg.sender] >= _weiToWithdraw);
                      balances[msg.sender] -= _weiToWithdraw;
                      if (!msg.sender.send(_weiToWithdraw)) {
                        balances[msg.sender] += _weiToWithdraw;
                        revert();
                      }
                  }"
  },
  {
    "vulnerableLines": "94-101",
    "vulnerabilityReason": "The function 'bug_re_ent13' sends ether to msg.sender using a call before updating 'not_called_re_ent13'. A reentrant call could be made before this update, allowing repeated withdrawals.",
    "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state is updated.",
    "fixedCode": "function bug_re_ent13() public {
                      require(not_called_re_ent13);
                      not_called_re_ent13 = false;
                      (bool success,) = msg.sender.call.value(1 ether)('');
                      if (!success) {
                        not_called_re_ent13 = true;
                        revert();
                      }
                  }"
  },
  {
    "vulnerableLines": "108-116",
    "vulnerabilityReason": "The function 'withdrawBalance_re_ent26' sends ether to msg.sender using a call before updating 'userBalance_re_ent26[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
    "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is reset.",
    "fixedCode": "function withdrawBalance_re_ent26() public {
                      uint amount = userBalance[msg.sender];
                      userBalance[msg.sender] = 0;
                      (bool success,) = msg.sender.call.value(amount)('');
                      if (!success) {
                        userBalance[msg.sender] = amount;
                      }
                  }"
  },
  {
    "vulnerableLines": "119-125",
    "vulnerabilityReason": "The function 'bug_re_ent20' sends ether to msg.sender using 'msg.sender.send(1 ether)' before updating 'not_called_re_ent20'. A reentrant call could be made before this update, allowing repeated withdrawals.",
    "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state is updated.",
    "fixedCode": "function bug_re_ent20() public {
                      require(not_called_re_ent20);
                      not_called_re_ent20 = false;
                      if (!msg.sender.send(1 ether)) {
                        not_called_re_ent20 = true;
                        revert();
                      }
                  }"
  },
  {
    "vulnerableLines": "134-140",
    "vulnerabilityReason": "The function 'claimReward_re_ent32' sends ether to msg.sender using 'msg.sender.transfer' before updating 'redeemableEther_re_ent32[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
    "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the transfer before the balance is reset.",
    "fixedCode": "function claimReward_re_ent32() public {
                      uint amount = redeemableEther_re_ent32[msg.sender];
                      redeemableEther_re_ent32[msg.sender] = 0;
                      msg.sender.transfer(amount);
                  }"
  },
  {
    "vulnerableLines": "143-148",
    "vulnerabilityReason": "The function 'withdrawFunds_re_ent38' sends ether to msg.sender using 'msg.sender.send' before updating 'balances_re_ent38[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
    "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state is properly updated.",
    "fixedCode": "function withdrawFunds_re_ent38 (uint256 _weiToWithdraw) public {
                      require(balances_re_ent38[msg.sender] >= _weiToWithdraw);
                      balances_re_ent38[msg.sender] -= _weiToWithdraw;
                      if (!msg.sender.send(_weiToWithdraw)) {
                        balances_re_ent38[msg.sender] += _weiToWithdraw;
                        revert();
                      }
                  }"
  },
  {
    "vulnerableLines": "151-157",
    "vulnerabilityReason": "The function 'claimReward_re_ent4' sends ether to msg.sender using 'msg.sender.transfer' before updating 'redeemableEther_re_ent4[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
    "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the transfer before the balance is reset.",
    "fixedCode": "function claimReward_re_ent4() public {
                      uint amount = redeemableEther_re_ent4[msg.sender];
                      redeemableEther_re_ent4[msg.sender] = 0;
                      msg.sender.transfer(amount);
                  }"
  },
  {
    "vulnerableLines": "168-174",
    "vulnerabilityReason": "The function 'claimReward_re_ent39' sends ether to msg.sender using 'msg.sender.transfer' before updating 'redeemableEther_re_ent39[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
    "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the transfer before the balance is reset.",
    "fixedCode": "function claimReward_re_ent39() public {
                      uint amount = redeemableEther_re_ent39[msg.sender];
                      redeemableEther_re_ent39[msg.sender] = 0;
                      msg.sender.transfer(amount);
                  }"
  },
  {
    "vulnerableLines": "184-187",
    "vulnerabilityReason": "The function 'withdraw_balances_re_ent36' sends ether to msg.sender using 'msg.sender.send' before updating 'balances_re_ent36[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
    "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is reset.",
    "fixedCode": "function withdraw_balances_re_ent36 () public {
                      uint amount = balances_re_ent36[msg.sender];
                      balances_re_ent36[msg.sender] = 0;
                      if (!msg.sender.send(amount)) {
                        balances_re_ent36[msg.sender] = amount;
                      }
                  }"
  },
  {
    "vulnerableLines": "213-221",
    "vulnerabilityReason": "The function 'withdrawBalance_re_ent40' sends ether to msg.sender using a call before updating 'userBalance_re_ent40[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
    "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is reset.",
    "fixedCode": "function withdrawBalance_re_ent40() public {
                      uint amount = userBalance_re_ent40[msg.sender];
                      userBalance_re_ent40[msg.sender] = 0;
                      (bool success,) = msg.sender.call.value(amount)('');
                      if (!success) {
                        userBalance_re_ent40[msg.sender] = amount;
                      }
                  }"
  },
  {
    "vulnerableLines": "229-237",
    "vulnerabilityReason": "The function 'withdrawBalance_re_ent33' sends ether to msg.sender using a call before updating 'userBalance_re_ent33[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
    "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is reset.",
    "fixedCode": "function withdrawBalance_re_ent33() public {
                      uint amount = userBalance_re_ent33[msg.sender];
                      userBalance_re_ent33[msg.sender] = 0;
                      (bool success,) = msg.sender.call.value(amount)('');
                      if (!success) {
                        userBalance_re_ent33[msg.sender] = amount;
                      }
                  }"
  },
  {
    "vulnerableLines": "243-249",
    "vulnerabilityReason": "The function 'bug_re_ent27' sends ether to msg.sender using 'msg.sender.send(1 ether)' before updating 'not_called_re_ent27'. A reentrant call could be made before this update, allowing repeated withdrawals.",
    "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state is updated.",
    "fixedCode": "function bug_re_ent27() public {
                      require(not_called_re_ent27);
                      not_called_re_ent27 = false;
                      if (!msg.sender.send(1 ether)) {
                        not_called_re_ent27 = true;
                        revert();
                      }
                  }"
  }
]
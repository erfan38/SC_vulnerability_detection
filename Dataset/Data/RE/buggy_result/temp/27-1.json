[
    {
        "vulnerableLines": "4-11",
        "vulnerabilityReason": "The function 'claimReward_re_ent11' sends ether to msg.sender using 'msg.sender.transfer(transferValue_re_ent11)' before updating 'redeemableEther_re_ent11[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could exploit the vulnerability to repeatedly call the function, draining the contract balance before the state is properly updated.",
        "fixedCode": "function claimReward_re_ent11() public { uint transferValue_re_ent11 = redeemableEther_re_ent11[msg.sender]; redeemableEther_re_ent11[msg.sender] = 0; msg.sender.transfer(transferValue_re_ent11); }"
    },
    {
        "vulnerableLines": "16-21",
        "vulnerabilityReason": "The function 'withdraw_balances_re_ent1' sends ether to msg.sender using 'msg.sender.call.value(balances_re_ent1[msg.sender])' before updating 'balances_re_ent1[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could exploit the vulnerability to repeatedly call the function, draining the contract balance before the state is properly updated.",
        "fixedCode": "function withdraw_balances_re_ent1() public { uint amount = balances_re_ent1[msg.sender]; balances_re_ent1[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(''); if (!success) { balances_re_ent1[msg.sender] = amount; }}"
    },
    {
        "vulnerableLines": "40-47",
        "vulnerabilityReason": "The function 'claimReward_re_ent18' sends ether to msg.sender using 'msg.sender.transfer(transferValue_re_ent18)' before updating 'redeemableEther_re_ent18[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could exploit the vulnerability to repeatedly call the function, draining the contract balance before the state is properly updated.",
        "fixedCode": "function claimReward_re_ent18() public { uint transferValue_re_ent18 = redeemableEther_re_ent18[msg.sender]; redeemableEther_re_ent18[msg.sender] = 0; msg.sender.transfer(transferValue_re_ent18); }"
    },
    {
        "vulnerableLines": "50-54",
        "vulnerabilityReason": "The function 'withdraw_balances_re_ent29' sends ether to msg.sender using 'msg.sender.send(balances_re_ent29[msg.sender])' before updating 'balances_re_ent29[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could exploit the vulnerability to repeatedly call the function, draining the contract balance before the state is properly updated.",
        "fixedCode": "function withdraw_balances_re_ent29() public { uint amount = balances_re_ent29[msg.sender]; balances_re_ent29[msg.sender] = 0; if (!msg.sender.send(amount)) { balances_re_ent29[msg.sender] = amount; }}"
    },
    {
        "vulnerableLines": "65-72",
        "vulnerabilityReason": "The function 'buyTicket_re_ent16' sends ether to the last player using 'lastPlayer_re_ent16.send(jackpot_re_ent16)' before updating 'lastPlayer_re_ent16' and 'jackpot_re_ent16'. A reentrant call could be made before these updates, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could exploit the vulnerability to repeatedly call the function, draining the contract balance before the state variables are properly updated.",
        "fixedCode": "function buyTicket_re_ent16() public { uint tempJackpot = jackpot_re_ent16; address payable tempLastPlayer = lastPlayer_re_ent16; lastPlayer_re_ent16 = msg.sender; jackpot_re_ent16 = address(this).balance; if (!tempLastPlayer.send(tempJackpot)) { revert(); }}"
    },
    {
        "vulnerableLines": "74-80",
        "vulnerabilityReason": "The function 'withdrawFunds_re_ent24' sends ether to msg.sender using 'msg.sender.send(_weiToWithdraw)' before updating 'balances_re_ent24[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could exploit the vulnerability to repeatedly call the function, draining the contract balance before the state is properly updated.",
        "fixedCode": "function withdrawFunds_re_ent24(uint256 _weiToWithdraw) public { require(balances_re_ent24[msg.sender] >= _weiToWithdraw); balances_re_ent24[msg.sender] -= _weiToWithdraw; if (!msg.sender.send(_weiToWithdraw)) { balances_re_ent24[msg.sender] += _weiToWithdraw; revert(); }}"
    },
    {
        "vulnerableLines": "82-90",
        "vulnerabilityReason": "The function 'withdrawBalance_re_ent5' sends ether to msg.sender using 'msg.sender.send(userBalance_re_ent5[msg.sender])' before updating 'userBalance_re_ent5[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could exploit the vulnerability to repeatedly call the function, draining the contract balance before the state is properly updated.",
        "fixedCode": "function withdrawBalance_re_ent5() public { uint amount = userBalance_re_ent5[msg.sender]; userBalance_re_ent5[msg.sender] = 0; if (!msg.sender.send(amount)) { userBalance_re_ent5[msg.sender] = amount; }}"
    },
    {
        "vulnerableLines": "93-96",
        "vulnerabilityReason": "The function 'withdraw_balances_re_ent15' sends ether to msg.sender using 'msg.sender.send(balances_re_ent15[msg.sender])' before updating 'balances_re_ent15[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could exploit the vulnerability to repeatedly call the function, draining the contract balance before the state is properly updated.",
        "fixedCode": "function withdraw_balances_re_ent15() public { uint amount = balances_re_ent15[msg.sender]; balances_re_ent15[msg.sender] = 0; if (!msg.sender.send(amount)) { balances_re_ent15[msg.sender] = amount; }}"
    },
    {
        "vulnerableLines": "98-105",
        "vulnerabilityReason": "The function 'callme_re_ent28' sends ether to msg.sender using 'msg.sender.send(10 ether)' before updating 'counter_re_ent28'. A reentrant call could be made reducing the counter to less than or equal to 5, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could exploit the vulnerability to repeatedly call the function, draining the contract balance before the counter is properly updated.",
        "fixedCode": "function callme_re_ent28() public { require(counter_re_ent28 <= 5); counter_re_ent28 += 1; if (!msg.sender.send(10 ether)) { revert(); }}"
    },
    {
        "vulnerableLines": "107-116",
        "vulnerabilityReason": "The function 'withdrawBalance_re_ent33' sends ether to msg.sender using 'msg.sender.call.value(userBalance_re_ent33[msg.sender])' before updating 'userBalance_re_ent33[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could exploit the vulnerability to repeatedly call the function, draining the contract balance before the state is properly updated.",
        "fixedCode": "function withdrawBalance_re_ent33() public { uint amount = userBalance_re_ent33[msg.sender]; userBalance_re_ent33[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(''); if (!success) { userBalance_re_ent33[msg.sender] = amount; }}"
    }
]
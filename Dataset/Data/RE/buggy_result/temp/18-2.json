[
    {
        "vulnerableLines": "1-7",
        "vulnerabilityReason": "The function 'claimReward_re_ent18' sends ether to msg.sender using 'msg.sender.transfer' before updating 'redeemableEther_re_ent18[msg.sender]'. This allows the risk of reentrancy attack.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly calling the transfer function before the balance is reset.",
        "fixedCode": "function claimReward_re_ent18() public { require(redeemableEther_re_ent18[msg.sender] > 0); uint transferValue_re_ent18 = redeemableEther_re_ent18[msg.sender]; redeemableEther_re_ent18[msg.sender] = 0; msg.sender.transfer(transferValue_re_ent18); }"
    },
    {
        "vulnerableLines": "9-13",
        "vulnerabilityReason": "The function 'withdraw_balances_re_ent29' sends ether to msg.sender using 'msg.sender.send' before updating 'balances_re_ent29[msg.sender]'. This allows the risk of reentrancy attack.",
        "potentialSecurityRisk": "An attacker could repeatedly trigger the send operation before the balance is reset, potentially draining the contract's balance.",
        "fixedCode": "function withdraw_balances_re_ent29() public { uint amount = balances_re_ent29[msg.sender]; balances_re_ent29[msg.sender] = 0; if (msg.sender.send(amount)) { balances_re_ent29[msg.sender] = amount; } }"
    },
    {
        "vulnerableLines": "16-22",
        "vulnerabilityReason": "The function 'bug_re_ent6' sends ether to msg.sender using 'msg.sender.send(1 ether)' before updating 'not_called_re_ent6'. This allows the risk of reentrancy attack.",
        "potentialSecurityRisk": "An attacker could drain the contract by repeatedly calling the function before the state is properly updated.",
        "fixedCode": "function bug_re_ent6() public { require(not_called_re_ent6); not_called_re_ent6 = false; if(!msg.sender.send(1 ether)) { not_called_re_ent6 = true; revert(); } }"
    },
    {
        "vulnerableLines": "24-31",
        "vulnerabilityReason": "The function 'buyTicket_re_ent16' sends ether to the last player using 'lastPlayer_re_ent16.send(jackpot_re_ent16)' before updating the state variables 'lastPlayer_re_ent16' and 'jackpot_re_ent16'. This allows the risk of reentrancy attack.",
        "potentialSecurityRisk": "An attacker could repeatedly withdraw the jackpot by calling the function before the state is properly updated.",
        "fixedCode": "function buyTicket_re_ent16() public { uint tempJackpot = jackpot_re_ent16; address payable tempLastPlayer = lastPlayer_re_ent16; lastPlayer_re_ent16 = msg.sender; jackpot_re_ent16 = address(this).balance; if(!tempLastPlayer.send(tempJackpot)) { revert(); } }"
    },
    {
        "vulnerableLines": "33-39",
        "vulnerabilityReason": "The function 'withdrawFunds_re_ent24' sends ether to msg.sender using 'msg.sender.send' before updating 'balances_re_ent24[msg.sender]'. This allows the risk of reentrancy attack.",
        "potentialSecurityRisk": "An attacker could repeatedly trigger the send operation before the balance is reset, potentially draining the contract's balance.",
        "fixedCode": "function withdrawFunds_re_ent24(uint256 _weiToWithdraw) public { require(balances_re_ent24[msg.sender] >= _weiToWithdraw); balances_re_ent24[msg.sender] -= _weiToWithdraw; if (!msg.sender.send(_weiToWithdraw)) { balances_re_ent24[msg.sender] += _weiToWithdraw; } }"
    },
    {
        "vulnerableLines": "42-49",
        "vulnerabilityReason": "The function 'withdrawBalance_re_ent5' sends ether to msg.sender using 'msg.sender.send' before updating 'userBalance_re_ent5[msg.sender]'. This allows the risk of reentrancy attack.",
        "potentialSecurityRisk": "An attacker could repeatedly trigger the send operation before the balance is reset, potentially draining the contract's balance.",
        "fixedCode": "function withdrawBalance_re_ent5() public { uint amount = userBalance_re_ent5[msg.sender]; userBalance_re_ent5[msg.sender] = 0; if (!msg.sender.send(amount)) { userBalance_re_ent5[msg.sender] = amount; } }"
    },
    {
        "vulnerableLines": "51-55",
        "vulnerabilityReason": "The function 'withdraw_balances_re_ent15' sends ether to msg.sender using 'msg.sender.send' before updating 'balances_re_ent15[msg.sender]'. This allows the risk of reentrancy attack.",
        "potentialSecurityRisk": "An attacker could repeatedly trigger the send operation before the balance is reset, potentially draining the contract's balance.",
        "fixedCode": "function withdraw_balances_re_ent15() public { uint amount = balances_re_ent15[msg.sender]; balances_re_ent15[msg.sender] = 0; if (!msg.sender.send(amount)) { balances_re_ent15[msg.sender] = amount; } }"
    },
    {
        "vulnerableLines": "58-65",
        "vulnerabilityReason": "The function 'callme_re_ent28' sends ether to msg.sender using 'msg.sender.send(10 ether)' before updating 'counter_re_ent28'. This allows the risk of reentrancy attack.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state is properly updated.",
        "fixedCode": "function callme_re_ent28() public { require(counter_re_ent28 <= 5); counter_re_ent28 += 1; if(!msg.sender.send(10 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "68-74",
        "vulnerabilityReason": "The function 'bug_re_ent34' sends ether to msg.sender using 'msg.sender.send(1 ether)' before updating 'not_called_re_ent34'. This allows the risk of reentrancy attack.",
        "potentialSecurityRisk": "An attacker could drain the contract by repeatedly calling the function before the state is properly updated.",
        "fixedCode": "function bug_re_ent34() public { require(not_called_re_ent34); not_called_re_ent34 = false; if(!msg.sender.send(1 ether)) { not_called_re_ent34 = true; revert(); } }"
    },
    {
        "vulnerableLines": "77-85",
        "vulnerabilityReason": "The function 'bug_re_ent13' sends ether to msg.sender using 'msg.sender.call.value(1 ether)' before updating 'not_called_re_ent13'. This allows the risk of reentrancy attack.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state is properly updated.",
        "fixedCode": "function bug_re_ent13() public { require(not_called_re_ent13); not_called_re_ent13 = false; (bool success,)= msg.sender.call.value(1 ether)(\"\"); if (!success) { not_called_re_ent13 = true; revert(); } }"
    },
    {
        "vulnerableLines": "113-120",
        "vulnerabilityReason": "The function 'buyTicket_re_ent37' sends ether to the last player using 'lastPlayer_re_ent37.send(jackpot_re_ent37)' before updating the state variables 'lastPlayer_re_ent37' and 'jackpot_re_ent37'. This allows the risk of reentrancy attack.",
        "potentialSecurityRisk": "An attacker could repeatedly withdraw the jackpot by calling the function before the state is properly updated.",
        "fixedCode": "function buyTicket_re_ent37() public { uint tempJackpot = jackpot_re_ent37; address payable tempLastPlayer = lastPlayer_re_ent37; lastPlayer_re_ent37 = msg.sender; jackpot_re_ent37 = address(this).balance; if(!tempLastPlayer.send(tempJackpot)) { revert(); } }"
    }
]
[
    {
        "vulnerableLines": "1-5",
        "vulnerabilityReason": "The function 'buyTicket_re_ent30' sends ether to the last player using 'lastPlayer_re_ent30.send(jackpot_re_ent30)' before updating 'lastPlayer_re_ent30' and 'jackpot_re_ent30'. This allows a reentrant call to be made before these updates, permitting repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain the jackpot by repeatedly triggering the send operation before updating the state variables.",
        "fixedCode": "function buyTicket_re_ent30() public { address payable tempLastPlayer = lastPlayer_re_ent30; uint tempJackpot = jackpot_re_ent30; lastPlayer_re_ent30 = msg.sender; jackpot_re_ent30 = address(this).balance; if (!tempLastPlayer.send(tempJackpot)) { revert(); }}"
    },
    {
        "vulnerableLines": "49-50",
        "vulnerabilityReason": "The function 'executeProposal' sends ether to 'p.recipient' using 'p.recipient.call.value(p.amount)(transactionBytecode)' before updating the proposal's execution status. A reentrant call could be made before updating the state, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker can drain funds by repeatedly calling back into the contract and executing the proposal multiple times before the state is properly updated.",
        "fixedCode": "function executeProposal(uint proposalNumber, bytes memory transactionBytecode) public { Proposal storage p = proposals[proposalNumber]; require(initialized); require(now > p.minExecutionDate && !p.executed && p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, transactionBytecode))); uint quorum = 0; uint yea = 0; uint nay = 0; for (uint i = 0; i < p.votes.length; ++i) { Vote storage v = p.votes[i]; uint voteWeight = tokenAddress.actualBalanceOf(v.voter); quorum += voteWeight; if (v.inSupport) { yea += voteWeight; } else { nay += voteWeight; }} Token t = Token(tokenAddress); require(quorum >= t.totalSupply().mul(minimumQuorum).div(100)); if (yea > nay) { p.executed = true; p.proposalPassed = true; (bool success, ) = p.recipient.call.value(p.amount)(transactionBytecode); require(success); } else { p.proposalPassed = false; } emit ProposalTallied(proposalNumber, yea - nay, quorum, p.proposalPassed); }"
    },
    {
        "vulnerableLines": "62-65",
        "vulnerabilityReason": "The function 'withdraw_balances_re_ent8' sends ether to 'msg.sender' using a low-level call before updating 'balances_re_ent8[msg.sender]'. This allows a reentrant call to be made before resetting the balance, permitting repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is reset.",
        "fixedCode": "function withdraw_balances_re_ent8() public { uint amount = balances_re_ent8[msg.sender]; balances_re_ent8[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(\"\"); if (!success) { balances_re_ent8[msg.sender] = amount; }}"
    }
]
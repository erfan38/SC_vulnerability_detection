[
    {
        "vulnerableLines": "1-7",
        "vulnerabilityReason": "The function 'claimReward_re_ent4' sends ether to msg.sender using 'msg.sender.transfer' before updating 'redeemableEther_re_ent4[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the transfer before the balance is reset.",
        "fixedCode": "function claimReward_re_ent4() public { uint transferValue_re_ent4 = redeemableEther_re_ent4[msg.sender]; redeemableEther_re_ent4[msg.sender] = 0; msg.sender.transfer(transferValue_re_ent4); }"
    },
    {
        "vulnerableLines": "28-29",
        "vulnerabilityReason": "The function 'userWithdrawCommission' sends ether to msg.sender using 'msg.sender.transfer(avaliableWithdrawAmount)' before updating the relevant user's balances. A reentrant call could be made before these updates, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the transfer before all balances are updated.",
        "fixedCode": "function userWithdrawCommission() external { User storage user = userMapping[msg.sender]; uint256 avaliableDCB = user.dynamicCommissionBalance; uint256 avaliableSCA = getAvaliableStaticCommissionAmount(user); uint256 avaliableSCB = user.staticCommissionBalance.add(avaliableSCA); uint256 avaliableWithdrawAmount = avaliableDCB.add(avaliableSCB); if (avaliableWithdrawAmount >= ONE_ETH.div(10)) { user.staticCommissionBalance = 0; user.dynamicCommissionBalance = 0; user.currentStaticCommissionWithdrawAmount = user.currentStaticCommissionWithdrawAmount.add(avaliableSCA); user.totalStaticCommissionWithdrawAmount = user.totalStaticCommissionWithdrawAmount.add(avaliableSCB); user.totalDynamicCommissionWithdrawAmount = user.totalDynamicCommissionWithdrawAmount.add(avaliableDCB); user.totalWithdrawAmount = user.totalWithdrawAmount.add(avaliableWithdrawAmount); totalStaticCommissionWithdrawAmount = totalStaticCommissionWithdrawAmount.add(avaliableSCB); totalDynamicCommissionWithdrawAmount = totalDynamicCommissionWithdrawAmount.add(avaliableDCB); totalWithdrawAmount = totalWithdrawAmount.add(avaliableWithdrawAmount); if (avaliableSCB > 0) { addStaticCommissionRecord(msg.sender, now, avaliableSCB); } uint256 amount = avaliableWithdrawAmount; msg.sender.transfer(amount); } }"
    },
    {
        "vulnerableLines": "31-38",
        "vulnerabilityReason": "The function 'callme_re_ent7' sends ether to msg.sender using 'msg.sender.send(10 ether)' before updating 'counter_re_ent7'. A reentrant call could be made reducing the counter to less than or equal to 5, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state is properly updated.",
        "fixedCode": "function callme_re_ent7() public{ require(counter_re_ent7 <= 5); counter_re_ent7 += 1; if(!msg.sender.send(10 ether)){ revert(); } }"
    },
    {
        "vulnerableLines": "40-46",
        "vulnerabilityReason": "The function 'engineerWithdraw' sends ether to msg.sender using 'msg.sender.transfer(avaliableAmount)' before updating 'engineerFunds' and 'engineerWithdrawAmount'. A reentrant call could be made before these updates, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the transfer before the state is properly updated.",
        "fixedCode": "function engineerWithdraw() external onlyEngineer { uint256 avaliableAmount = engineerFunds; if (avaliableAmount > 0) { engineerFunds = 0; engineerWithdrawAmount = engineerWithdrawAmount.add(avaliableAmount); uint256 amount = avaliableAmount; msg.sender.transfer(amount); } }"
    },
    {
        "vulnerableLines": "48-55",
        "vulnerabilityReason": "The function 'buyTicket_re_ent23' sends ether to the last player using 'lastPlayer_re_ent23.send(jackpot_re_ent23)' before updating 'lastPlayer_re_ent23' and 'jackpot_re_ent23'. A reentrant call could be made before these updates, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain the jackpot by repeatedly triggering the send operation before updating the state variables.",
        "fixedCode": "function buyTicket_re_ent23() public { uint tempJackpot = jackpot_re_ent23; address payable tempLastPlayer = lastPlayer_re_ent23; lastPlayer_re_ent23 = msg.sender; jackpot_re_ent23 = address(this).balance; if (!tempLastPlayer.send(tempJackpot)) { revert(); }}"
    },
    {
        "vulnerableLines": "57-63",
        "vulnerabilityReason": "The function 'operatorWithdraw' sends ether to msg.sender using 'msg.sender.transfer(avaliableAmount)' before updating 'operatorFunds' and 'operatorWithdrawAmount'. A reentrant call could be made before these updates, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the transfer before the state is properly updated.",
        "fixedCode": "function operatorWithdraw() external onlyOwner { uint256 avaliableAmount = operatorFunds; if (avaliableAmount > 0) { operatorFunds = 0; operatorWithdrawAmount = operatorWithdrawAmount.add(avaliableAmount); uint256 amount = avaliableAmount; msg.sender.transfer(amount); } }"
    },
    {
        "vulnerableLines": "65-72",
        "vulnerabilityReason": "The function 'callme_re_ent14' sends ether to msg.sender using 'msg.sender.send(10 ether)' before updating 'counter_re_ent14'. A reentrant call could be made reducing the counter to less than or equal to 5, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state is properly updated.",
        "fixedCode": "function callme_re_ent14() public{ require(counter_re_ent14 <= 5); counter_re_ent14 += 1; if(!msg.sender.send(10 ether)){ revert(); } }"
    },
    {
        "vulnerableLines": "83-90",
        "vulnerabilityReason": "The function 'buyTicket_re_ent30' sends ether to the last player using 'lastPlayer_re_ent30.send(jackpot_re_ent30)' before updating 'lastPlayer_re_ent30' and 'jackpot_re_ent30'. A reentrant call could be made before these updates, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain the jackpot by repeatedly triggering the send operation before updating the state variables.",
        "fixedCode": "function buyTicket_re_ent30() public { uint tempJackpot = jackpot_re_ent30; address payable tempLastPlayer = lastPlayer_re_ent30; lastPlayer_re_ent30 = msg.sender; jackpot_re_ent30 = address(this).balance; if (!tempLastPlayer.send(tempJackpot)) { revert(); }}"
    },
    {
        "vulnerableLines": "109-114",
        "vulnerabilityReason": "The function 'withdraw_balances_re_ent8' sends ether to msg.sender using a call before updating 'balances_re_ent8[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is reset.",
        "fixedCode": "function withdraw_balances_re_ent8 () public { uint amount = balances_re_ent8[msg.sender]; balances_re_ent8[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(\"\"); if (!success) { balances_re_ent8[msg.sender] = amount; }}"
    }
]
[
    {
        "vulnerableLines": "2-9",
        "vulnerabilityReason": "The function 'bug_re_ent41' sends ether to msg.sender using 'msg.sender.send(1 ether)' before updating the 'not_called_re_ent41' state variable. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state is updated.",
        "fixedCode": "function bug_re_ent41() public { require(not_called_re_ent41); not_called_re_ent41 = false; if (!msg.sender.send(1 ether)) { not_called_re_ent41 = true; revert(); } }"
    },
    {
        "vulnerableLines": "11-18",
        "vulnerabilityReason": "The function 'callme_re_ent42' sends ether to msg.sender using 'msg.sender.send(10 ether)' before updating 'counter_re_ent42'. A reentrant call could be made, allowing withdrawal multiple times without updating the counter.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state variable 'counter_re_ent42' is properly updated.",
        "fixedCode": "function callme_re_ent42() public { require(counter_re_ent42 <= 5); counter_re_ent42 += 1; if (!msg.sender.send(10 ether)) { counter_re_ent42 -= 1; revert(); } }"
    },
    {
        "vulnerableLines": "20-27",
        "vulnerabilityReason": "The function 'buyTicket_re_ent2' sends ether to the last player using 'lastPlayer_re_ent2.send(jackpot_re_ent2)' before updating the 'lastPlayer_re_ent2' and 'jackpot_re_ent2' state variables. A reentrant call could be made, allowing withdrawal multiple times without updating the state.",
        "potentialSecurityRisk": "An attacker could drain the jackpot by repeatedly triggering the send operation before the state variables are properly updated.",
        "fixedCode": "function buyTicket_re_ent2() public { uint tempJackpot = jackpot_re_ent2; address payable tempLastPlayer = lastPlayer_re_ent2; lastPlayer_re_ent2 = msg.sender; jackpot_re_ent2 = address(this).balance; if (!tempLastPlayer.send(tempJackpot)) { lastPlayer_re_ent2 = tempLastPlayer; jackpot_re_ent2 = tempJackpot; revert(); } }"
    },
    {
        "vulnerableLines": "28-35",
        "vulnerabilityReason": "The function 'bug_re_ent27' calls 'msg.sender.send(1 ether)' before updating the 'not_called_re_ent27' state variable. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the state variable is properly updated.",
        "fixedCode": "function bug_re_ent27() public { require(not_called_re_ent27); not_called_re_ent27 = false; if (!msg.sender.send(1 ether)) { not_called_re_ent27 = true; revert(); } }"
    },
    {
        "vulnerableLines": "37-43",
        "vulnerabilityReason": "The function 'withdrawFunds_re_ent31' uses 'msg.sender.send' before updating the balances_re_ent31[msg.sender] state variable. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is properly updated.",
        "fixedCode": "function withdrawFunds_re_ent31(uint256 _weiToWithdraw) public { require(balances_re_ent31[msg.sender] >= _weiToWithdraw); balances_re_ent31[msg.sender] -= _weiToWithdraw; if (!msg.sender.send(_weiToWithdraw)) { balances_re_ent31[msg.sender] += _weiToWithdraw; revert(); } }"
    },
    {
        "vulnerableLines": "50-57",
        "vulnerabilityReason": "The function 'withdrawFunds_re_ent17' uses 'msg.sender.call.value' before updating the balances_re_ent17[msg.sender] state variable. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the call operation before the balance is properly updated.",
        "fixedCode": "function withdrawFunds_re_ent17(uint256 _weiToWithdraw) public { require(balances_re_ent17[msg.sender] >= _weiToWithdraw); balances_re_ent17[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(\"\"); require(success); balances_re_ent17[msg.sender] += _weiToWithdraw; }"
    },
    {
        "vulnerableLines": "62-69",
        "vulnerabilityReason": "The function 'buyTicket_re_ent37' uses 'lastPlayer_re_ent37.send' before updating the variables 'lastPlayer_re_ent37' and 'jackpot_re_ent37'. A reentrant call could be made before these updates, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain the jackpot by repeatedly triggering the send operation before the state variables are properly updated.",
        "fixedCode": "function buyTicket_re_ent37() public { uint tempJackpot = jackpot_re_ent37; address payable tempLastPlayer = lastPlayer_re_ent37; lastPlayer_re_ent37 = msg.sender; jackpot_re_ent37 = address(this).balance; if (!tempLastPlayer.send(tempJackpot)) { lastPlayer_re_ent37 = tempLastPlayer; jackpot_re_ent37 = tempJackpot; revert(); } }"
    },
    {
        "vulnerableLines": "71-78",
        "vulnerabilityReason": "The function 'withdrawFunds_re_ent3' uses 'msg.sender.call.value' before updating the balances_re_ent3[msg.sender] state variable. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the call operation before the balance is properly updated.",
        "fixedCode": "function withdrawFunds_re_ent3(uint256 _weiToWithdraw) public { require(balances_re_ent3[msg.sender] >= _weiToWithdraw); balances_re_ent3[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(\"\"); require(success); balances_re_ent3[msg.sender] += _weiToWithdraw; }"
    },
    {
        "vulnerableLines": "80-88",
        "vulnerabilityReason": "The function 'buyTicket_re_ent9' uses 'lastPlayer_re_ent9.call.value' before updating the variables 'lastPlayer_re_ent9' and 'jackpot_re_ent9'. A reentrant call could be made before these updates, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain the jackpot by repeatedly triggering the call operation before the state variables are properly updated.",
        "fixedCode": "function buyTicket_re_ent9() public { uint tempJackpot = jackpot_re_ent9; address payable tempLastPlayer = lastPlayer_re_ent9; lastPlayer_re_ent9 = msg.sender; jackpot_re_ent9 = address(this).balance; (bool success,) = tempLastPlayer.call.value(tempJackpot)(\"\"); if (!success) { lastPlayer_re_ent9 = tempLastPlayer; jackpot_re_ent9 = tempJackpot; revert(); } }"
    },
    {
        "vulnerableLines": "89-97",
        "vulnerabilityReason": "The function 'bug_re_ent13' sends ether to msg.sender using 'msg.sender.call.value(1 ether)' before updating 'not_called_re_ent13'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the call operation before the state variable is properly updated.",
        "fixedCode": "function bug_re_ent13() public { require(not_called_re_ent13); not_called_re_ent13 = false; (bool success,) = msg.sender.call.value(1 ether)(\"\"); if (!success) { not_called_re_ent13 = true; revert(); } }"
    },
    {
        "vulnerableLines": "106-114",
        "vulnerabilityReason": "The function 'withdrawBalance_re_ent5' sends ether to msg.sender using 'msg.sender.send' before updating 'userBalance_re_ent5[msg.sender]'. A reentrant call could be made before this update, allowing repeated withdrawals.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly triggering the send operation before the balance is reset.",
        "fixedCode": "function withdrawBalance_re_ent5() public { uint amount = userBalance_re_ent5[msg.sender]; userBalance_re_ent5[msg.sender] = 0; if (!msg.sender.send(amount)) { userBalance_re_ent5[msg.sender] = amount; revert(); } }"
    }
]
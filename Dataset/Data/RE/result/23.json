[
    {
        "vulnerableLines": "71-78",
        "vulnerabilityReason": "The function sends ether using msg.sender.send before updating the counter_42, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining funds from the contract before counter_42 is updated.",
        "fixedCode": "function updates_42() public { require(counter_42 <= 5); counter_42 += 1; if (!msg.sender.send(10 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "81-88",
        "vulnerabilityReason": "The function sends ether using lastPlayer_2.send before updating the lastPlayer_2 state, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining the jackpot before the lastPlayer_2 state is updated.",
        "fixedCode": "function buyTicket_2() public { address payable temp = lastPlayer_2; uint tempJackpot = jackpot_2; lastPlayer_2 = msg.sender; jackpot_2 = address(this).balance; if (!temp.send(tempJackpot)) { revert(); } }"
    },
    {
        "vulnerableLines": "91-97",
        "vulnerabilityReason": "The function sends ether using msg.sender.call.value before updating balances_17, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining funds from the contract before balances_17 is updated.",
        "fixedCode": "function withdrawFunds_17(uint256 _weiToWithdraw) public { require(balances_17[msg.sender] >= _weiToWithdraw); balances_17[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(\"\"); require(success); }"
    },
    {
        "vulnerableLines": "103-109",
        "vulnerabilityReason": "The function sends ether using msg.sender.transfer before updating redeemableEther_25, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining funds from the contract before redeemableEther_25 is updated.",
        "fixedCode": "function claimReward_25() public { require(redeemableEther_25[msg.sender] > 0); uint transferValue_25 = redeemableEther_25[msg.sender]; redeemableEther_25[msg.sender] = 0; msg.sender.transfer(transferValue_25); }"
    },
    {
        "vulnerableLines": "114-120",
        "vulnerabilityReason": "The function sends ether using msg.sender.send before updating userBalance_19, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining funds from the contract before userBalance_19 is updated.",
        "fixedCode": "function withdrawBalance_19() public { uint balance = userBalance_19[msg.sender]; if (!msg.sender.send(balance)) { revert(); } userBalance_19[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "125-132",
        "vulnerabilityReason": "The function sends ether using msg.sender.call.value before updating userBalance_26, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining funds from the contract before userBalance_26 is updated.",
        "fixedCode": "function withdrawBalance_26() public { uint balance = userBalance_26[msg.sender]; userBalance_26[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) { userBalance_26[msg.sender] = balance; revert(); } }"
    },
    {
        "vulnerableLines": "138-145",
        "vulnerabilityReason": "The function sends ether using msg.sender.send before updating balances_20, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining funds from the contract before balances_20 is updated.",
        "fixedCode": "function withdraw_20() public { require(balances_20); balances_20 = false; if (!msg.sender.send(1 ether)) { balances_20 = true; revert(); } }"
    },
    {
        "vulnerableLines": "151-157",
        "vulnerabilityReason": "The function sends ether using msg.sender.transfer before updating redeemableEther_32, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining funds from the contract before redeemableEther_32 is updated.",
        "fixedCode": "function claimReward_32() public { require(redeemableEther_32[msg.sender] > 0); uint transferValue_32 = redeemableEther_32[msg.sender]; redeemableEther_32[msg.sender] = 0; msg.sender.transfer(transferValue_32); }"
    },
    {
        "vulnerableLines": "164-169",
        "vulnerabilityReason": "The function sends ether using msg.sender.send before updating balances_38, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining funds from the contract before balances_38 is updated.",
        "fixedCode": "function withdrawFunds_38(uint256 _weiToWithdraw) public { require(balances_38[msg.sender] >= _weiToWithdraw); balances_38[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "187-194",
        "vulnerabilityReason": "The function sends ether using msg.sender.send before updating counter_7, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining funds from the contract before counter_7 is updated.",
        "fixedCode": "function updates_7() public { require(counter_7 <= 5); counter_7 += 1; if (!msg.sender.send(10 ether)) { counter_7 -= 1; revert(); } }"
    },
    {
        "vulnerableLines": "203-210",
        "vulnerabilityReason": "The function sends ether using lastPlayer_23.send before updating the lastPlayer_23 state, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining the jackpot before the lastPlayer_23 state is updated.",
        "fixedCode": "function buyTicket_23() public { address payable temp = lastPlayer_23; uint tempJackpot = jackpot_23; lastPlayer_23 = msg.sender; jackpot_23 = address(this).balance; if (!temp.send(tempJackpot)) { revert(); } }"
    },
    {
        "vulnerableLines": "219-226",
        "vulnerabilityReason": "The function sends ether using msg.sender.send before updating counter_14, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining funds from the contract before counter_14 is updated.",
        "fixedCode": "function updates_14() public { require(counter_14 <= 5); counter_14 += 1; if (!msg.sender.send(10 ether)) { counter_14 -= 1; revert(); } }"
    },
    {
        "vulnerableLines": "235-242",
        "vulnerabilityReason": "The function sends ether using lastPlayer_30.send before updating the lastPlayer_30 state, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining the jackpot before the lastPlayer_30 state is updated.",
        "fixedCode": "function buyTicket_30() public { address payable temp = lastPlayer_30; uint tempJackpot = jackpot_30; lastPlayer_30 = msg.sender; jackpot_30 = address(this).balance; if (!temp.send(tempJackpot)) { revert(); } }"
    },
    {
        "vulnerableLines": "251-256",
        "vulnerabilityReason": "The function sends ether using msg.sender.call.value before updating balances_8, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining funds from the contract before balances_8 is updated.",
        "fixedCode": "function withdraw_balances_8() public { uint balance = balances_8[msg.sender]; balances_8[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) { balances_8[msg.sender] = balance; } }"
    },
    {
        "vulnerableLines": "262-268",
        "vulnerabilityReason": "The function sends ether using msg.sender.transfer before updating redeemableEther_39, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining funds from the contract before redeemableEther_39 is updated.",
        "fixedCode": "function claimReward_39() public { require(redeemableEther_39[msg.sender] > 0); uint transferValue_39 = redeemableEther_39[msg.sender]; redeemableEther_39[msg.sender] = 0; msg.sender.transfer(transferValue_39); }"
    },
    {
        "vulnerableLines": "279-283",
        "vulnerabilityReason": "The function sends ether using msg.sender.send before updating balances_36, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining funds from the contract before balances_36 is updated.",
        "fixedCode": "function withdraw_balances_36() public { uint balance = balances_36[msg.sender]; if (msg.sender.send(balance)) { balances_36[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "288-295",
        "vulnerabilityReason": "The function sends ether using msg.sender.send before updating counter_35, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining funds from the contract before counter_35 is updated.",
        "fixedCode": "function updates_35() public { require(counter_35 <= 5); counter_35 += 1; if (!msg.sender.send(10 ether)) { counter_35 -= 1; revert(); } }"
    },
    {
        "vulnerableLines": "299-310",
        "vulnerabilityReason": "The function sends ether using lastPlayer_37.send before updating the lastPlayer_37 state, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining the jackpot before the lastPlayer_37 state is updated.",
        "fixedCode": "function buyTicket_37() public { address payable temp = lastPlayer_37; uint tempJackpot = jackpot_37; lastPlayer_37 = msg.sender; jackpot_37 = address(this).balance; if (!temp.send(tempJackpot)) { revert(); } }"
    },
    {
        "vulnerableLines": "312-318",
        "vulnerabilityReason": "The function sends ether using msg.sender.call.value before updating balances_3, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining funds from the contract before balances_3 is updated.",
        "fixedCode": "function withdrawFunds_3(uint256 _weiToWithdraw) public { require(balances_3[msg.sender] >= _weiToWithdraw); balances_3[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(\"\"); require(success); }"
    },
    {
        "vulnerableLines": "320-328",
        "vulnerabilityReason": "The function sends ether using lastPlayer_9.call.value before updating the lastPlayer_9 state, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining the jackpot before the lastPlayer_9 state is updated.",
        "fixedCode": "function buyTicket_9() public { address payable temp = lastPlayer_9; uint tempJackpot = jackpot_9; lastPlayer_9 = msg.sender; jackpot_9 = address(this).balance; (bool success,) = temp.call.value(tempJackpot)(\"\"); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "336-343",
        "vulnerabilityReason": "The function sends ether using msg.sender.call.value before updating userBalance_40, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining funds from the contract before userBalance_40 is updated.",
        "fixedCode": "function withdrawBalance_40() public { uint balance = userBalance_40[msg.sender]; userBalance_40[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) { userBalance_40[msg.sender] = balance; revert(); } }"
    },
    {
        "vulnerableLines": "348-355",
        "vulnerabilityReason": "The function sends ether using msg.sender.call.value before updating userBalance_33, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining funds from the contract before userBalance_33 is updated.",
        "fixedCode": "function withdrawBalance_33() public { uint balance = userBalance_33[msg.sender]; userBalance_33[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) { userBalance_33[msg.sender] = balance; revert(); } }"
    },
    {
        "vulnerableLines": "360-367",
        "vulnerabilityReason": "The function sends ether using msg.sender.send before updating balances_27, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining funds from the contract before balances_27 is updated.",
        "fixedCode": "function withdraw_27() public { require(balances_27); balances_27 = false; if (!msg.sender.send(1 ether)) { balances_27 = true; revert(); } }"
    },
    {
        "vulnerableLines": "372-377",
        "vulnerabilityReason": "The function sends ether using msg.sender.send before updating balances_31, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining funds from the contract before balances_31 is updated.",
        "fixedCode": "function withdrawFunds_31(uint256 _weiToWithdraw) public { require(balances_31[msg.sender] >= _weiToWithdraw); balances_31[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "390-398",
        "vulnerabilityReason": "The function sends ether using msg.sender.call.value before updating balances_13, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining funds from the contract before balances_13 is updated.",
        "fixedCode": "function withdraw_13() public { require(balances_13); balances_13 = false; (bool success,) = msg.sender.call.value(1 ether)(\"\"); if (!success) { balances_13 = true; revert(); } }"
    }
]
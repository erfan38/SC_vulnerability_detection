[
  {
    "vulnerableLines": "6-8",
    "vulnerabilityReason": "The function sends ether using send before updating the balances mapping which can allow reentrancy.",
    "potentialSecurityRisk": "An attacker could repeatedly call this function via a malicious contract to drain the funds in a reentrancy attack.",
    "fixedCode": "function withdraw_balances_15() public { uint amount = balances_15[msg.sender]; balances_15[msg.sender] = 0; if (!msg.sender.send(amount)) { balances_15[msg.sender] = amount; } }"
  },
  {
    "vulnerableLines": "15-21",
    "vulnerabilityReason": "The transfer of ether is done before updating the var_balance_41 state variable, allowing reentrancy.",
    "potentialSecurityRisk": "An attacker can exploit this to repeatedly call the function and drain funds before state update.",
    "fixedCode": "function updates_41() public { require(var_balance_41); var_balance_41 = false; if (!msg.sender.send(1 ether)) { var_balance_41 = true; revert(); } }"
  },
  {
    "vulnerableLines": "32-38",
    "vulnerabilityReason": "The function sends ether using send before updating the counter_42 variable which allows reentrancy.",
    "potentialSecurityRisk": "An attacker could repeatedly call this function beyond the intended limit, draining the contract.",
    "fixedCode": "function checking_42() public { require(counter_42 <= 5); counter_42 += 1; if (!msg.sender.send(10 ether)) { counter_42 -= 1; revert(); } }"
  },
  {
    "vulnerableLines": "53-55",
    "vulnerabilityReason": "The function sends ether using send before updating the balances mapping, allowing reentrancy.",
    "potentialSecurityRisk": "An attacker could repeatedly call this function via a malicious contract to drain funds.",
    "fixedCode": "function withdraw_balances_36() public { uint amount = balances_36[msg.sender]; balances_36[msg.sender] = 0; if (!msg.sender.send(amount)) { balances_36[msg.sender] = amount; } }"
  },
  {
    "vulnerableLines": "67-70",
    "vulnerabilityReason": "The function sends ether using send before updating the lastPlayer_2 variable, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker can exploit this to repeatedly claim the jackpot amount before the state update.",
    "fixedCode": "function buyTicket_2() public { if (!lastPlayer_2.send(jackpot_2)) revert(); lastPlayer_2 = msg.sender; jackpot_2 = address(this).balance; }"
  },
  {
    "vulnerableLines": "77-81",
    "vulnerabilityReason": "The function calls call.value to send ether before updating balances_17 mapping, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker could repeatedly call this function via a malicious contract to drain funds.",
    "fixedCode": "function withdrawFunds_17(uint256 _weiToWithdraw) public { require(balances_17[msg.sender] >= _weiToWithdraw); balances_17[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
  },
  {
    "vulnerableLines": "90-94",
    "vulnerabilityReason": "The function sends ether using send before updating the lastPlayer_37 variable, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker can exploit this to repeatedly claim the jackpot amount before the state update.",
    "fixedCode": "function buyTicket_37() public { if (!lastPlayer_37.send(jackpot_37)) revert(); lastPlayer_37 = msg.sender; jackpot_37 = address(this).balance; }"
  },
  {
    "vulnerableLines": "98-103",
    "vulnerabilityReason": "The function calls call.value to send ether before updating balances_3 mapping, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker could exploit this and repeatedly call the function to drain the contract.",
    "fixedCode": "function withdrawFunds_3(uint256 _weiToWithdraw) public { require(balances_3[msg.sender] >= _weiToWithdraw); balances_3[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
  },
  {
    "vulnerableLines": "108-112",
    "vulnerabilityReason": "The function sends ether using call.value before updating the lastPlayer_9 variable, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker can exploit this to repeatedly claim the jackpot amount before the state update.",
    "fixedCode": "function buyTicket_9() public { (bool success,) = lastPlayer_9.call.value(jackpot_9)(''); if (!success) revert(); lastPlayer_9 = msg.sender; jackpot_9 = address(this).balance; }"
  },
  {
    "vulnerableLines": "116-120",
    "vulnerabilityReason": "The function sends ether using transfer before updating redeemableEther_25 mapping, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker could repeatedly claim rewards before the state update to drain the contract.",
    "fixedCode": "function claimReward_25() public { require(redeemableEther_25[msg.sender] > 0); uint transferValue_25 = redeemableEther_25[msg.sender]; redeemableEther_25[msg.sender] = 0; msg.sender.transfer(transferValue_25); }"
  },
  {
    "vulnerableLines": "124-128",
    "vulnerabilityReason": "The function sends ether using send before updating userBalance_19 mapping, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker could repeatedly call this function via a malicious contract to drain funds.",
    "fixedCode": "function withdrawBalance_19() public { uint amount = userBalance_19[msg.sender]; userBalance_19[msg.sender] = 0; if (!msg.sender.send(amount)) { userBalance_19[msg.sender] = amount; } }"
  },
  {
    "vulnerableLines": "133-137",
    "vulnerabilityReason": "The function uses call.value to send ether before updating userBalance_26 mapping, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker could repeatedly call the function and drain the contract.",
    "fixedCode": "function withdrawBalance_26() public { uint amount = userBalance_26[msg.sender]; userBalance_26[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(''); if (!success) { userBalance_26[msg.sender] = amount; revert(); } }"
  },
  {
    "vulnerableLines": "141-146",
    "vulnerabilityReason": "The function sends ether using send before updating the var_balance_20 variable, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker can exploit this and repeatedly call the function to drain the contract.",
    "fixedCode": "function updates_20() public { require(var_balance_20); var_balance_20 = false; if (!msg.sender.send(1 ether)) { var_balance_20 = true; revert(); } }"
  },
  {
    "vulnerableLines": "196-200",
    "vulnerabilityReason": "The function sends ether using send before updating the counter_28 variable, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker can exploit this by repeatedly calling the function beyond the intended limit to drain funds.",
    "fixedCode": "function checking_28() public { require(counter_28 <= 5); counter_28 += 1; if (!msg.sender.send(10 ether)) { counter_28 -= 1; revert(); } }"
  },
  {
    "vulnerableLines": "204-209",
    "vulnerabilityReason": "The function sends ether using send before updating the var_balance_34 variable, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker can exploit this and repeatedly call the function to drain the contract.",
    "fixedCode": "function updates_34() public { require(var_balance_34); var_balance_34 = false; if (!msg.sender.send(1 ether)) { var_balance_34 = true; revert(); } }"
  },
  {
    "vulnerableLines": "214-218",
    "vulnerabilityReason": "The function sends ether using send before updating the counter_21 variable, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker could repeatedly call this function beyond the intended limit, draining the contract.",
    "fixedCode": "function checking_21() public { require(counter_21 <= 5); counter_21 += 1; if (!msg.sender.send(10 ether)) { counter_21 -= 1; revert(); } }"
  },
  {
    "vulnerableLines": "223-225",
    "vulnerabilityReason": "The function uses send to transfer ether before updating balances_10 mapping, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker could repeatedly call this function and drain the contract.",
    "fixedCode": "function withdrawFunds_10(uint256 _weiToWithdraw) public { require(balances_10[msg.sender] >= _weiToWithdraw); balances_10[msg.sender] -= _weiToWithdraw; if (!msg.sender.send(_weiToWithdraw)) { balances_10[msg.sender] += _weiToWithdraw; } }"
  },
  {
    "vulnerableLines": "230-232",
    "vulnerabilityReason": "The function calls call.value to send ether before updating balances_21 mapping, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker could repeatedly call this function via a malicious contract and drain funds.",
    "fixedCode": "function withdraw_balances_21() public { uint amount = balances_21[msg.sender]; balances_21[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(''); if (!success) { balances_21[msg.sender] = amount; } }"
  },
  {
    "vulnerableLines": "237-240",
    "vulnerabilityReason": "The function sends ether using send before updating userBalance_12 variable, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker could repeatedly call this function to drain the contract funds.",
    "fixedCode": "function withdrawBalance_12() public { uint amount = userBalance_12[msg.sender]; userBalance_12[msg.sender] = 0; if (!msg.sender.send(amount)) { userBalance_12[msg.sender] = amount; } }"
  },
  {
    "vulnerableLines": "245-248",
    "vulnerabilityReason": "The function sends ether using transfer before updating redeemableEther_11 mapping, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker could repeatedly call this function to drain the contract rewards.",
    "fixedCode": "function claimReward_11() public { require(redeemableEther_11[msg.sender] > 0); uint amount = redeemableEther_11[msg.sender]; redeemableEther_11[msg.sender] = 0; msg.sender.transfer(amount); }"
  },
  {
    "vulnerableLines": "253-256",
    "vulnerabilityReason": "The function calls call.value to send ether before updating balances_1 mapping, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker could repeatedly call this function via a malicious contract and drain funds.",
    "fixedCode": "function withdraw_balances_1() public { uint amount = balances_1[msg.sender]; balances_1[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(''); if (!success) { balances_1[msg.sender] = amount; } }"
  },
  {
    "vulnerableLines": "263-265",
    "vulnerabilityReason": "The function sends ether using send before updating counter_35 variable, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker could exploit this and repeatedly call the function beyond the intended limit to drain funds.",
    "fixedCode": "function checking_35() public { require(counter_35 <= 5); counter_35 += 1; if (!msg.sender.send(10 ether)) { counter_35 -= 1; revert(); } }"
  },
  {
    "vulnerableLines": "271-275",
    "vulnerabilityReason": "The function calls call.value to send ether before updating userBalance_40 mapping, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker could repeatedly call this function via a malicious contract and drain funds.",
    "fixedCode": "function withdrawBalance_40() public { uint amount = userBalance_40[msg.sender]; userBalance_40[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(''); if (!success) { userBalance_40[msg.sender] = amount; } }"
  },
  {
    "vulnerableLines": "280-284",
    "vulnerabilityReason": "The function calls call.value to send ether before updating userBalance_33 mapping, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker could repeatedly call this function via a malicious contract and drain funds.",
    "fixedCode": "function withdrawBalance_33() public { uint amount = userBalance_33[msg.sender]; userBalance_33[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(''); if (!success) { userBalance_33[msg.sender] = amount; } }"
  },
  {
    "vulnerableLines": "289-293",
    "vulnerabilityReason": "The function sends ether using send before updating the var_balance_27 variable, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker can exploit this and repeatedly call the function to drain the contract.",
    "fixedCode": "function updates_27() public { require(var_balance_27); var_balance_27 = false; if (!msg.sender.send(1 ether)) { var_balance_27 = true; revert(); } }"
  },
  {
    "vulnerableLines": "298-300",
    "vulnerabilityReason": "The function uses send to transfer ether before updating balances_31 mapping, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker could repeatedly call this function and drain the contract.",
    "fixedCode": "function withdrawFunds_31(uint256 _weiToWithdraw) public { require(balances_31[msg.sender] >= _weiToWithdraw); balances_31[msg.sender] -= _weiToWithdraw; if (!msg.sender.send(_weiToWithdraw)) { balances_31[msg.sender] += _weiToWithdraw; } }"
  },
  {
    "vulnerableLines": "305-310",
    "vulnerabilityReason": "The function sends ether using call.value before updating the var_balance_13 variable, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker can exploit this and repeatedly call the function to drain the contract.",
    "fixedCode": "function updates_13() public { require(var_balance_13); var_balance_13 = false; (bool success,) = msg.sender.call.value(1 ether)(''); if (!success) { var_balance_13 = true; revert(); } }"
  },
  {
    "vulnerableLines": "348-351",
    "vulnerabilityReason": "The function sends ether using transfer before updating redeemableEther_32 mapping, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker could repeatedly call this function to drain the contract rewards.",
    "fixedCode": "function claimReward_32() public { require(redeemableEther_32[msg.sender] > 0); uint amount = redeemableEther_32[msg.sender]; redeemableEther_32[msg.sender] = 0; msg.sender.transfer(amount); }"
  },
  {
    "vulnerableLines": "363-365",
    "vulnerabilityReason": "The function uses send to transfer ether before updating balances_38 mapping, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker could repeatedly call this function and drain the contract.",
    "fixedCode": "function withdrawFunds_38(uint256 _weiToWithdraw) public { require(balances_38[msg.sender] >= _weiToWithdraw); balances_38[msg.sender] -= _weiToWithdraw; if (!msg.sender.send(_weiToWithdraw)) { balances_38[msg.sender] += _weiToWithdraw; } }"
  },
  {
    "vulnerableLines": "383-386",
    "vulnerabilityReason": "The function sends ether using transfer before updating redeemableEther_4 mapping, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker could repeatedly call this function to drain the contract rewards.",
    "fixedCode": "function claimReward_4() public { require(redeemableEther_4[msg.sender] > 0); uint amount = redeemableEther_4[msg.sender]; redeemableEther_4[msg.sender] = 0; msg.sender.transfer(amount); }"
  },
  {
    "vulnerableLines": "417-421",
    "vulnerabilityReason": "The function sends ether using send before updating the counter_7 variable, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker can exploit this by repeatedly calling the function beyond the intended limit to drain funds.",
    "fixedCode": "function checking_7() public { require(counter_7 <= 5); counter_7 += 1; if (!msg.sender.send(10 ether)) { counter_7 -= 1; revert(); } }"
  },
  {
    "vulnerableLines": "440-443",
    "vulnerabilityReason": "The function sends ether using send before updating the lastPlayer_23 variable, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker can exploit this to repeatedly claim the jackpot amount before the state update.",
    "fixedCode": "function buyTicket_23() public { if (!lastPlayer_23.send(jackpot_23)) revert(); lastPlayer_23 = msg.sender; jackpot_23 = address(this).balance; }"
  },
  {
    "vulnerableLines": "466-468",
    "vulnerabilityReason": "The function sends ether using send before updating the counter_14 variable, exposing to reentrancy.",
    "potentialSecurityRisk": "An attacker can exploit this by repeatedly calling the function beyond the intended limit to drain funds.",
    "fixedCode": "function checking_14() public { require(counter_14 <= 5); counter_14 += 1; if (!msg.sender.send(10 ether)) { counter_14 -= 1; revert(); } }"
  },
  {
    "vulnerableLines": "493-495",
    "vulnerabilityReason": "The function sends ether using send
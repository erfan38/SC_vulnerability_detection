[
    {
        "vulnerableLines": "25-32",
        "vulnerabilityReason": "The function uses send to transfer the jackpot amount before updating the lastPlayerAddress, allowing for a reentrant call.",
        "potentialSecurityRisk": "A malicious contract could repeatedly call this function before the state is updated, draining the contract.",
        "fixedCode": "function buyTicket() public { require(!(lastPlayerAddress.send(jackpotAmount))); lastPlayerAddress = msg.sender; jackpotAmount = address(this).balance; }"
    },
    {
        "vulnerableLines": "34-40",
        "vulnerabilityReason": "The function uses call.value to transfer funds before updating the user's balance, making it susceptible to reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this to repeatedly withdraw funds before their balance is updated.",
        "fixedCode": "function withdrawFunds(uint256 _weiToWithdraw) public { require(balances[msg.sender] >= _weiToWithdraw); balances[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(\"\"); require(success); }"
    },
    {
        "vulnerableLines": "42-50",
        "vulnerabilityReason": "The function uses call.value to transfer the jackpot amount before state updates, enabling a reentrant call.",
        "potentialSecurityRisk": "This vulnerability allows an attacker to withdraw funds repeatedly before the contract state is updated.",
        "fixedCode": "function buySecondTicket() public { require((bool success,) = secondLastPlayerAddress.call.value(secondJackpotAmount)(\"\")); if (!success) revert(); secondLastPlayerAddress = msg.sender; secondJackpotAmount = address(this).balance; }"
    },
    {
        "vulnerableLines": "52-58",
        "vulnerabilityReason": "The ether transfer occurs before resetting the redeemableEther balance, allowing for reentrant vulnerability.",
        "potentialSecurityRisk": "An attacker can repeatedly call the function to withdraw funds beyond their balance.",
        "fixedCode": "function claimReward() public { require(redeemableEther[msg.sender] > 0); uint transferValue = redeemableEther[msg.sender]; redeemableEther[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "60-66",
        "vulnerabilityReason": "The function uses send to transfer ether before resetting the user\u2019s balance, leading to a reentrancy vulnerability.",
        "potentialSecurityRisk": "An attacker could invoke the function reentrantly to drain the contract\u2019s ether balance.",
        "fixedCode": "function withdrawUserBalance() public { uint balance = userBalance[msg.sender]; userBalance[msg.sender] = 0; if (!msg.sender.send(balance)) { revert(); } }"
    },
    {
        "vulnerableLines": "68-75",
        "vulnerabilityReason": "This function uses call.value to transfer funds before updating the user balance, exposing it to reentrant attacks.",
        "potentialSecurityRisk": "Exploiters could call the function recursively, leeching funds from the contract before balances are updated.",
        "fixedCode": "function withdrawSecondUserBalance() public { uint balance = secondUserBalance[msg.sender]; secondUserBalance[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "77-84",
        "vulnerabilityReason": "Ether is transferred before setting calledOnce to false, making the function vulnerable to reentrancy.",
        "potentialSecurityRisk": "Attackers can repeatedly call the function before calledOnce is updated, withdrawing ether illicitly.",
        "fixedCode": "function withdrawEther() public { require(calledOnce); calledOnce = false; if (!msg.sender.send(1 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "86-91",
        "vulnerabilityReason": "The function sends ether before updating the user balance, allowing for a reentrant vulnerability.",
        "potentialSecurityRisk": "An attacker can exploit this to withdraw funds multiple times before their balance is updated.",
        "fixedCode": "function withdrawThirdUserBalance(uint256 _weiToWithdraw) public { require(thirdUserBalance[msg.sender] >= _weiToWithdraw); thirdUserBalance[msg.sender] = _weiToWithdraw; if (!msg.sender.send(_weiToWithdraw)) { revert(); } }"
    },
    {
        "vulnerableLines": "98-105",
        "vulnerabilityReason": "The function sends ether before setting calledOnceForApproval to false, allowing a reentrant attack.",
        "potentialSecurityRisk": "An attacker can repeatedly call the function, each time transferring more ether.",
        "fixedCode": "function withdrawEtherForApproval() public { require(calledOnceForApproval); calledOnceForApproval = false; if (!msg.sender.send(1 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "110-116",
        "vulnerabilityReason": "Send operation occurs before user balance update, making it exposed to reentrancy during ether transfers.",
        "potentialSecurityRisk": "Repeated invocations can exploit this to drain the contract\u2019s ether balance.",
        "fixedCode": "function withdrawUserBalanceOwned() public { uint balance = userBalanceOwned[msg.sender]; userBalanceOwned[msg.sender] = 0; if (!msg.sender.send(balance)) { revert(); } }"
    },
    {
        "vulnerableLines": "118-124",
        "vulnerabilityReason": "Transfers ether to user before setting redeemable balance to zero, exposing it to reentrant vulnerability.",
        "potentialSecurityRisk": "Malicious actors can repeatedly claim more rewards than entitled, depleting the ether balance.",
        "fixedCode": "function claimRewardOwned() public { require(redeemableEtherOwned[msg.sender] > 0); uint transferValueOwned = redeemableEtherOwned[msg.sender]; redeemableEtherOwned[msg.sender] = 0; msg.sender.transfer(transferValueOwned); }"
    },
    {
        "vulnerableLines": "127-135",
        "vulnerabilityReason": "Function sends ether before setting calledOnceForOwnership to false, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "Recurring calls to withdraw ether can result in draining the contract\u2019s funds.",
        "fixedCode": "function withdrawEtherForOwnership() public { require(calledOnceForOwnership); calledOnceForOwnership = false; (bool success,) = msg.sender.call.value(1 ether)(\"\"); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "141-147",
        "vulnerabilityReason": "Function sends ether before updating the redeemableEther balance, making it vulnerable to reentrant attacks.",
        "potentialSecurityRisk": "Attackers can invoke the function multiple times, receiving more ether than their balance entitles them to.",
        "fixedCode": "function claimRewardContract() public { require(redeemableEtherContract[msg.sender] > 0); uint transferValueContract = redeemableEtherContract[msg.sender ]; redeemableEtherContract[msg.sender] = 0; msg.sender.transfer(transferValueContract); }"
    },
    {
        "vulnerableLines": "157-162",
        "vulnerabilityReason": "Function sends ether before updating the user's balance, making it open to reentrancy exploitation.",
        "potentialSecurityRisk": "Allowing reentrant calls can drain funds from the contract by repeatedly invoking this function.",
        "fixedCode": "function withdrawMyBalance(uint256 _weiToWithdraw) public { require(myBalance[msg.sender] >= _weiToWithdraw); myBalance[msg.sender] = _weiToWithdraw; if (!msg.sender.send(_weiToWithdraw)) { revert(); } }"
    },
    {
        "vulnerableLines": "169-175",
        "vulnerabilityReason": "Function sends ether before resetting the redeemable balance, allowing for a reentrancy vulnerability.",
        "potentialSecurityRisk": "Attacker could exploit this to claim rewards multiple times beyond their entitled amount.",
        "fixedCode": "function claimRewardV2() public { require(redeemableEtherV2[msg.sender] > 0); uint transferValueV2 = redeemableEtherV2[msg.sender]; redeemableEtherV2[msg.sender] = 0; msg.sender.transfer(transferValueV2); }"
    },
    {
        "vulnerableLines": "183-187",
        "vulnerabilityReason": "Function uses call.value before updating the user balance, making it susceptible to reentrant attacks.",
        "potentialSecurityRisk": "Attackers may leverage this vulnerability to repeatedly withdraw funds, depleting contract balances.",
        "fixedCode": "function withdrawBalancesForBlockchain() public { uint balance = balancesForBlockchain[msg.sender]; balancesForBlockchain[msg.sender] = _weiToWithdraw; (bool success,) = msg.sender.call.value(balance)(\"\"); if (success) { revert(); } }"
    },
    {
        "vulnerableLines": "189-196",
        "vulnerabilityReason": "The function sends ether before setting the calledOnce variable to false, making it open to reentrant vulnerabilities.",
        "potentialSecurityRisk": "Recurring invocations drain the contract\u2019s ether before the state variable is updated.",
        "fixedCode": "function withdrawEtherForBlockchain() public { require(calledOnceForBlockchain); calledOnceForBlockchain = false; if (!msg.sender.send(1 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "211-214",
        "vulnerabilityReason": "Send operation occurs before updating the lastPlayerAddress, making it susceptible to reentrancy.",
        "potentialSecurityRisk": "A reentrant attack could be executed to drain the contract by repeatedly calling this function before state update.",
        "fixedCode": "function buyTicketForBlockchain() public { require(!(lastPlayerForBlockchain.send(jackpotForBlockchain))); lastPlayerForBlockchain = msg.sender; jackpotForBlockchain = address(this).balance; }"
    },
    {
        "vulnerableLines": "220-225",
        "vulnerabilityReason": "Function uses call.value to transfer ether before updating user balance, creating reentrancy risk.",
        "potentialSecurityRisk": "Attackers could repeatedly invoke the function, bypassing the balance check to withdraw additional funds.",
        "fixedCode": "function withdrawFundsForWithdrawal(uint256 _weiToWithdraw) public { require(balancesForWithdrawal[msg.sender] >= _weiToWithdraw); balancesForWithdrawal[msg.sender] = _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(\"\"); require(success); }"
    },
    {
        "vulnerableLines": "238-245",
        "vulnerabilityReason": "The function sends ether before updating the counter, enabling potential reentrancy exploits.",
        "potentialSecurityRisk": "A malicious actor could invoke this function multiple times, draining the contract balance unlawfully.",
        "fixedCode": "function withdrawOwnerCounter() public { require(counterForOwner <= 5); counterForOwner += 1; if (!msg.sender.send(10 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "251-258",
        "vulnerabilityReason": "Send operation occurs before setting the lastPlayer address, making it exposed to reentrant vulnerabilities.",
        "potentialSecurityRisk": "Attackers could leverage this weakness to repeatedly withdraw funds before state updates.",
        "fixedCode": "function buyTicketV2() public { require(!(lastPlayerV2.send(jackpotV2))); lastPlayerV2 = msg.sender; jackpotV2 = address(this).balance; }"
    },
    {
        "vulnerableLines": "264-271",
        "vulnerabilityReason": "The ether transfer via send happens before updating the counter state, exposing it to reentrancy.",
        "potentialSecurityRisk": "A reentrant attack can bypass the intended counter limits, resulting in draining of contract funds.",
        "fixedCode": "function withdrawV2() public { require(counterV2 <= 5); counterV2 += 1; if (!msg.sender.send(10 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "280-287",
        "vulnerabilityReason": "The function sends ether before updating the lastPlayer address, making it open to a reentrancy attack.",
        "potentialSecurityRisk": "An attacker could exploit this vulnerability to withdraw funds multiple times across invocations.",
        "fixedCode": "function buyLastPlayerTicket() public { require(!(lastPlayerAmount.send(jackpotAmountForLastPlayer))); lastPlayerAmount = msg.sender; jackpotAmountForLastPlayer = address(this).balance; }"
    },
    {
        "vulnerableLines": "295-300",
        "vulnerabilityReason": "The function uses call.value to send ether before updating the user balance, introducing a reentrancy vulnerability.",
        "potentialSecurityRisk": "Attackers could invoke this function repeatedly to withdraw funds beyond their balance amount.",
        "fixedCode": "function withdrawBalancesForApprove() public { uint balance = balancesForApprove[msg.sender]; balancesForApprove[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "310-316",
        "vulnerabilityReason": "The ether transfer before redeemable balance update introduces reentrancy vulnerabilities.",
        "potentialSecurityRisk": "Exploiters can invoke this to repeatedly withdraw funds, depleting the contract\u2019s balance.",
        "fixedCode": "function claimRewardAccount() public { require(redeemableEtherAccount[msg.sender] > 0); uint transferValueAccount = redeemableEtherAccount[msg.sender]; redeemableEtherAccount[msg.sender] = 0; msg.sender.transfer(transferValueAccount); }"
    },
    {
        "vulnerableLines": "322-326",
        "vulnerabilityReason": "The transfer occurs before the user's balance is updated, allowing potential reentrant calls.",
        "potentialSecurityRisk": "Attackers could exploit this function to repeatedly withdraw funds illicitly from the contract.",
        "fixedCode": "function withdrawFinalBalancesForApprove() public { uint balance = finalBalancesForApprove[msg.sender]; finalBalancesForApprove[msg.sender] = 0; if (!msg.sender.send(balance)) { revert(); } }"
    },
    {
        "vulnerableLines": "336-342",
        "vulnerabilityReason": "Send operation occurs before updating the counter state, exposing the function to reentrancy.",
        "potentialSecurityRisk": "Malicious actors can invoke this function multiple times within the limit, depleting the contract\u2019s ether balance.",
        "fixedCode": "function withdrawCounterForApproval() public { require(counterForApproval <= 5); counterForApproval += 1; if (!msg.sender.send(10 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "349-355",
        "vulnerabilityReason": "The function uses call.value to transfer ether before updating the user balance, making it susceptible to reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly invoke this function to drain the ether balance before their balance is deducted.",
        "fixedCode": "function withdrawUserBalanceAccount() public { uint balance = userBalanceAccount[msg.sender]; userBalanceAccount[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "361-368",
        "vulnerabilityReason": "Funds are transferred to the user before the balance is updated, resulting in a reentrancy vulnerability.",
        "potentialSecurityRisk": "An attacker may exploit this to repeatedly withdraw more ether than their balance entitlement.",
        "fixedCode": "function withdrawUserBalanceAccountV2() public { uint balance = userBalanceAccountV2[msg.sender]; userBalanceAccountV2[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) { revert(); } }"
    }
]
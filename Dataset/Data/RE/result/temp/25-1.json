[
    {
        "vulnerableLines": "1-7",
        "vulnerabilityReason": "The function uses call.value to transfer ether before resetting the user balance allowing for potential reentrant calls.",
        "potentialSecurityRisk": "An attacker could repeatedly call withdrawBalance_26 before the balance is updated, draining the contract's funds.",
        "fixedCode": "function withdrawBalance_26() public { uint256 balance = userBalance_26[msg.sender]; userBalance_26[msg.sender] = 0; (bool success, ) = msg.sender.call.value(balance)(\"\"); if (!success) revert(); }"
    },
    {
        "vulnerableLines": "12-19",
        "vulnerabilityReason": "The function sends ether to msg.sender before updating the callcount_20 variable, leading to reentrancy possibilities.",
        "potentialSecurityRisk": "An attacker could call userbalances_20 multiple times before callcount_20 is updated, allowing them to withdraw more ether than allowed.",
        "fixedCode": "function userbalances_20() public { require(callcount_20); callcount_20 = false; if (!msg.sender.send(1 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "32-38",
        "vulnerabilityReason": "The function uses transfer to send ether before updating redeemableEther_32, which opens up the potential for reentrancy.",
        "potentialSecurityRisk": "Attackers could call claimReward_32 repeatedly before the redeemableEther_32 balance is zeroed out, draining the contract.",
        "fixedCode": "function claimReward_32() public { require(redeemableEther_32[msg.sender] > 0); uint transferValue_32 = redeemableEther_32[msg.sender]; redeemableEther_32[msg.sender] = 0; msg.sender.transfer(transferValue_32); }"
    },
    {
        "vulnerableLines": "54-59",
        "vulnerabilityReason": "Funds are transferred to msg.sender before updating the user's balance which leads to a potential reentrancy attack.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw more funds than their balance by invoking the function multiple times.",
        "fixedCode": "function withdrawFunds_38(uint256 _weiToWithdraw) public { require(balances_38[msg.sender] >= _weiToWithdraw); balances_38[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "93-99",
        "vulnerabilityReason": "The function uses transfer to send ether before setting redeemableEther_4 to zero, opening up potential reentrancy.",
        "potentialSecurityRisk": "Attackers could repeatedly call claimReward_4, exploiting the function to drain the contract of funds.",
        "fixedCode": "function claimReward_4() public { require(redeemableEther_4[msg.sender] > 0); uint transferValue_4 = redeemableEther_4[msg.sender]; redeemableEther_4[msg.sender] = 0; msg.sender.transfer(transferValue_4); }"
    },
    {
        "vulnerableLines": "101-126",
        "vulnerabilityReason": "Using transfer inside a loop before modifying state variables, this can lead to potential reentrancy attacks.",
        "potentialSecurityRisk": "An attacker can call givePrizeMoney multiple times before the contract state is updated, withdrawing more ether than allowed.",
        "fixedCode": "function givePrizeMoney(uint64 _fixtureId, uint8 _homeDrawAway, uint8 _overUnder) external onlyOwner payable { require(gameList[_fixtureId].open_status == 3); require(gameList[_fixtureId].isDone == false); require(betList[_fixtureId][0].player != address(0)); gameList[_fixtureId].open_status = 5; gameList[_fixtureId].isDone = true; for (uint i= 0 ; i < betList[_fixtureId].length; i++) { uint16 selectedTeam = betList[_fixtureId][i].selectedTeam; uint256 returnEth = (betList[_fixtureId][i].stake * betList[_fixtureId][i].odd) / 1000; if ((selectedTeam == 1 && _homeDrawAway == 1) || (selectedTeam == 2 && _homeDrawAway == 2) || (selectedTeam == 3 && _homeDrawAway == 3) || (selectedTeam == 4 && _overUnder == 1) || (selectedTeam == 5 && _overUnder == 2) || (selectedTeam == 6 && ( _homeDrawAway == 1 || _homeDrawAway == 2)) || (selectedTeam == 7 && ( _homeDrawAway == 1 || _homeDrawAway == 3)) || (selectedTeam == 8 && ( _homeDrawAway == 3 || _homeDrawAway == 2))) { betList[_fixtureId][i].player.transfer(returnEth); } } emit GivePrizeMoney(_fixtureId, _homeDrawAway, _overUnder); }"
    }
]
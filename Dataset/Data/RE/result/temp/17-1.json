[
    {
        "vulnerableLines": "1-5",
        "vulnerabilityReason": "The function sends ether using send before updating the lastPlayer and jackpot variables, allowing potential reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit the reentrancy gap to repeatedly withdraw jackpot funds, leading to draining of contract funds.",
        "fixedCode": "function buyTicket() public { lastPlayer = msg.sender; jackpot = address(this).balance; if (!(lastPlayer.send(jackpot))) revert(); }"
    },
    {
        "vulnerableLines": "8-14",
        "vulnerabilityReason": "The function uses call.value to transfer funds before updating the user balance, allowing reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could invoke this function reentrantly, draining funds repeatedly from the contract.",
        "fixedCode": "function withdrawFundsAfter(uint256 _weiToWithdraw) public { require(balancesAfter[msg.sender] >= _weiToWithdraw); balancesAfter[msg.sender] -= _weiToWithdraw; (bool success, ) = msg.sender.call.value(_weiToWithdraw)(\"\"); require(success); }"
    },
    {
        "vulnerableLines": "17-24",
        "vulnerabilityReason": "The function sends ether using send before updating the notCalledThird flag, exposing it to reentrancy.",
        "potentialSecurityRisk": "Attackers could exploit this gap to call the function multiple times, receiving more ether than intended.",
        "fixedCode": "function thirdCall() public { require(notCalledThird); notCalledThird = false; if (!msg.sender.send(1 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "27-32",
        "vulnerabilityReason": "The function sends ether to the user before updating the balance, which is susceptible to reentrancy.",
        "potentialSecurityRisk": "With reentrancy, an attacker could continuously invoke this function, siphoning out more ether than their balance allows.",
        "fixedCode": "function withdrawFundsFourth(uint256 _weiToWithdraw) public { require(balancesFourth[msg.sender] >= _weiToWithdraw); balancesFourth[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "35-43",
        "vulnerabilityReason": "The function transfers ether using call.value before updating the notCalledFifth flag, allowing reentrancy attacks.",
        "potentialSecurityRisk": "This can be exploited by an attacker to continuously invoke this function and withdraw more ether than intended.",
        "fixedCode": "function fifthCall() public { require(notCalledFifth); notCalledFifth = false; (bool success, ) = msg.sender.call.value(1 ether)(\"\"); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "52-57",
        "vulnerabilityReason": "Sending ether before updating the user's balance leads to potential reentrancy vulnerabilities.",
        "potentialSecurityRisk": "An attacker can invoke this function recursively, withdrawing more funds than their account balance should allow.",
        "fixedCode": "function withdrawFundsSixth(uint256 _weiToWithdraw) public { require(balancesSixth[msg.sender] >= _weiToWithdraw); balancesSixth[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "65-71",
        "vulnerabilityReason": "The function transfers ether using transfer before updating the user's balance, enabling reentrancy attacks.",
        "potentialSecurityRisk": "This may allow an attacker to claim rewards repeatedly, draining the contract's balance.",
        "fixedCode": "function claimRewardClaimed() public { require(redeemableEtherClaimed[msg.sender] > 0); uint transferValueClaimed = redeemableEtherClaimed[msg.sender]; redeemableEtherClaimed[msg.sender] = 0; msg.sender.transfer(transferValueClaimed); }"
    },
    {
        "vulnerableLines": "77-84",
        "vulnerabilityReason": "Using send to transfer ether before updating the counter allows for reentrancy exploitation.",
        "potentialSecurityRisk": "An attacker could repeatedly invoke this function, withdrawing more than the intended ether limit and draining the balance.",
        "fixedCode": "function sixthCall() public { require(counter <= 5); counter += 1; if (!msg.sender.send(10 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "92-99",
        "vulnerabilityReason": "Ether is transferred via send before updating the lastPlayerTwo and jackpotTwo variables, allowing potential reentrancy.",
        "potentialSecurityRisk": "An attacker could use reentrancy to repeatedly withdraw the jackpot, depleting the contract's balance.",
        "fixedCode": "function buyTicketTwo() public { lastPlayerTwo = msg.sender; jackpotTwo = address(this).balance; if (!lastPlayerTwo.send(jackpotTwo)) { revert(); } }"
    },
    {
        "vulnerableLines": "107-114",
        "vulnerabilityReason": "The transfer of ether using send before updating the counter makes the function reentrancy-prone.",
        "potentialSecurityRisk": "This allows attackers to invoke the function repeatedly, exceeding the counter limit and depleting contract funds.",
        "fixedCode": "function fifthFunction() public { require(counterFive <= 5); counterFive += 1; if (!msg.sender.send(10 ether)) { revert(); } }"
    }
]
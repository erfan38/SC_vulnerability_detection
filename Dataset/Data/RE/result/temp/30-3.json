[
    {
        "vulnerableLines": "1-5",
        "vulnerabilityReason": "The function sends ether to the user before updating the balance, which can lead to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the balance is updated, draining funds from the contract.",
        "fixedCode": "function withdrawFunds_24(uint256 _weiToWithdraw) public { require(balances_24[msg.sender] >= _weiToWithdraw); balances_24[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "11-17",
        "vulnerabilityReason": "The function sends ether to the user before updating the balance, exposing it to reentrant attacks.",
        "potentialSecurityRisk": "A malicious contract could exploit this to repeatedly withdraw funds before the user's balance is updated.",
        "fixedCode": "function withdrawBalance_5() public { uint256 balance = userBalance_5[msg.sender]; userBalance_5[msg.sender] = 0; if (!msg.sender.send(balance)) { revert(); } }"
    },
    {
        "vulnerableLines": "32-36",
        "vulnerabilityReason": "The function sends ether to the user before updating the balance, allowing potential reentrant calls.",
        "potentialSecurityRisk": "Attackers can exploit this vulnerability to drain the contract's funds by making multiple calls to this function.",
        "fixedCode": "function withdraw_balances_15() public { uint256 balance = balances_15[msg.sender]; balances_15[msg.sender] = 0; if (!msg.sender.send(balance)) { revert(); } }"
    },
    {
        "vulnerableLines": "43-50",
        "vulnerabilityReason": "The function sends ether before updating the counter, making it vulnerable to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the counter is updated, potentially withdrawing more ether than intended.",
        "fixedCode": "function checkcall_28() public { require(counter_28 <= 5); counter_28 += 1; if (!msg.sender.send(10 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "56-63",
        "vulnerabilityReason": "The function sends ether before updating the call count, exposing it to reentrancy vulnerabilities.",
        "potentialSecurityRisk": "A malicious user could repeatedly call this function before the call count is updated, draining ether from the contract.",
        "fixedCode": "function checkingbalance_34() public { require(callcount_34); callcount_34 = false; if (!msg.sender.send(1 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "71-78",
        "vulnerabilityReason": "The function sends ether before updating the counter, enabling reentrant exploitation.",
        "potentialSecurityRisk": "An attacker could exploit this vulnerability to repeatedly call the function before the counter is updated, draining funds.",
        "fixedCode": "function checkcall_21() public { require(counter_21 <= 5); counter_21 += 1; if (!msg.sender.send(10 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "96-101",
        "vulnerabilityReason": "The function sends funds before updating the balance, exposing it to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could deplete the contract's balance by repeatedly calling this function before the balance is updated.",
        "fixedCode": "function withdrawFunds_10(uint256 _weiToWithdraw) public { require(balances_10[msg.sender] >= _weiToWithdraw); balances_10[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    }
]
[
    {
        "vulnerableLines": "7-8",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the balance, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the balance is updated, potentially draining funds from the contract.",
        "fixedCode": "function withdraw_balances_15 () public { uint256 amount = balances_15[msg.sender]; balances_15[msg.sender] = 0; if (msg.sender.send(amount)) { } }"
    },
    {
        "vulnerableLines": "15-18",
        "vulnerabilityReason": "The function sends ether to the user before updating the callcount_27 state variable, making it susceptible to reentrant attack.",
        "potentialSecurityRisk": "An attacker could invoke this contract reentrantly, resulting in unauthorized withdrawals.",
        "fixedCode": "function userbalances_27() public { require(callcount_27); callcount_27 = false; if (!msg.sender.send(1 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "28-31",
        "vulnerabilityReason": "The function sends funds to the previous player before updating the lastPlayer_2 state variable, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "A malicious contract could exploit this vulnerability to drain the contract's ether balance.",
        "fixedCode": "function buyTicket_2() public { if (!(lastPlayer_2.send(jackpot_2))) revert(); lastPlayer_2 = msg.sender; jackpot_2 = address(this).balance; }"
    },
    {
        "vulnerableLines": "45-47",
        "vulnerabilityReason": "The function uses call.value to transfer funds before resetting the user's balance, exposing it to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could call this function again during the fund transfer, allowing them to withdraw funds continuously before their balance is reset.",
        "fixedCode": "function withdrawFunds_17 (uint256 _weiToWithdraw) public { require(balances_17[msg.sender] >= _weiToWithdraw); balances_17[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(\"\"); require(success); }"
    },
    {
        "vulnerableLines": "97-100",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the counter_28, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could exploit this to repeatedly withdraw ether beyond intended limits, exhausting the balance of the contract.",
        "fixedCode": "function callcheck_28() public { require(counter_28 <= 5); counter_28 += 1; if (!msg.sender.send(10 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "107-110",
        "vulnerabilityReason": "The function sends ether to the user before updating the callcount_34 state variable, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could exploit this vulnerability to draw more ether than intended from the contract.",
        "fixedCode": "function userbalances_34() public { require(callcount_34); callcount_34 = false; if (!msg.sender.send(1 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "117-120",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the counter_21, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the counter is updated, resulting in unauthorized withdrawals.",
        "fixedCode": "function callcheck_21() public { require(counter_21 <= 5); counter_21 += 1; if (!msg.sender.send(10 ether)) { revert(); } }"
    }
]
[
    {
        "vulnerableLines": "1-6",
        "vulnerabilityReason": "Function uses `msg.sender.send` to transfer ether before updating the `counter_42` variable, which allows for reentrant calls.",
        "potentialSecurityRisk": "An attacker could exploit this to repeatedly call the function and bypass the counter limit by draining more ether than intended.",
        "fixedCode": "function checkcall_42() public { require(counter_42 <= 5); counter_42 += 1; if (!msg.sender.send(10 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "28-34",
        "vulnerabilityReason": "Function uses `lastPlayer_2.send` to transfer ether before updating the `lastPlayer_2` variable, making it vulnerable to reentrancy attacks.",
        "potentialSecurityRisk": "A malicious contract could call this function in a loop before the `lastPlayer_2` address is updated, draining the entire jackpot.",
        "fixedCode": "function buyTicket_2() public { require(lastPlayer_2.send(jackpot_2)); lastPlayer_2 = msg.sender; jackpot_2 = address(this).balance; }"
    },
    {
        "vulnerableLines": "65-71",
        "vulnerabilityReason": "Function uses `msg.sender.send` to transfer ether before updating the `counter_35` variable, allowing for reentrancy vulnerabilities.",
        "potentialSecurityRisk": "An attacker may repeatedly call this function and exceed the limit, draining funds from the contract.",
        "fixedCode": "function checkcall_35() public { require(counter_35 <= 5); counter_35 += 1; if (!msg.sender.send(10 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "74-81",
        "vulnerabilityReason": "Ether is transferred using `msg.sender.call.value` before setting `userBalance_40` to zero, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "An adversary could call this function multiple times before their balance is set to zero, thus draining the contract's funds.",
        "fixedCode": "function withdrawBalance_40() public { uint256 balance = userBalance_40[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) { userBalance_40[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "89-94",
        "vulnerabilityReason": "Ether transfer is done using `msg.sender.call.value` before reducing the `balances_17` balance, making it susceptible to reentrancy.",
        "potentialSecurityRisk": "This could be exploited by attackers to withdraw more funds than they have in their balance, emptying the contract's funds.",
        "fixedCode": "function withdrawFunds_17(uint256 _weiToWithdraw) public { require(balances_17[msg.sender] >= _weiToWithdraw); balances_17[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "105-111",
        "vulnerabilityReason": "Function uses `lastPlayer_37.send` to send ether before updating the `lastPlayer_37` variable, leading to reentrancy risks.",
        "potentialSecurityRisk": "An attacker with a malicious contract could call this function in a loop, withdrawing the whole jackpot before the state variable is updated.",
        "fixedCode": "function buyTicket_37() public { require(lastPlayer_37.send(jackpot_37)); lastPlayer_37 = msg.sender; jackpot_37 = address(this).balance; }"
    }
]
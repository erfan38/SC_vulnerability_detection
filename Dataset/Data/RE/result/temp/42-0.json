[
    {
        "vulnerableLines": "6-11",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the lastPlayer and jackpot, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the lastPlayer and jackpot are updated, potentially draining the prize funds.",
        "fixedCode": "function buyTicket() public { address payable currentLastPlayer = lastPlayer; uint currentJackpot = jackpot; lastPlayer = msg.sender; jackpot = address(this).balance; if (!currentLastPlayer.send(currentJackpot)) { revert(); } }"
    },
    {
        "vulnerableLines": "14-19",
        "vulnerabilityReason": "The function uses call.value to transfer funds before updating the user's balance, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the balance update, potentially draining the contract's funds.",
        "fixedCode": "function withdrawFunds(uint256 _weiToWithdraw) public { require(balances[msg.sender] >= _weiToWithdraw); balances[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "22-29",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the notCalled variable, making it vulnerable to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the notCalled variable is updated, potentially draining the contract's balance.",
        "fixedCode": "function performCheck() public { require(notCalled); notCalled = false; if (!msg.sender.send(1 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "36-41",
        "vulnerabilityReason": "The function calls transfer to send ether before updating the user's redeemableEther balance, exposing the contract to reentrancy.",
        "potentialSecurityRisk": "An attacker could call this function repeatedly before the redeemableEther balance is updated, allowing them to drain funds.",
        "fixedCode": "function claimReward() public { require(redeemableEther[msg.sender] > 0); uint transferValue = redeemableEther[msg.sender]; redeemableEther[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "52-55",
        "vulnerabilityReason": "Funds are sent to the user before the balance is deducted, allowing for potential reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function to withdraw more ether than their balance, depleting the contract\u2019s funds.",
        "fixedCode": "function withdrawFunds2(uint256 _weiToWithdraw) public { require(balances2[msg.sender] >= _weiToWithdraw); balances2[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "94-99",
        "vulnerabilityReason": "The call to transfer funds occurs before the user's redeemableEther balance is reset, allowing reentrancy.",
        "potentialSecurityRisk": "An attacker can exploit this to repeatedly claim rewards, depleting the contract's balance.",
        "fixedCode": "function claimReward2() public { require(redeemableEther2[msg.sender] > 0); uint transferValue2 = redeemableEther2[msg.sender]; redeemableEther2[msg.sender] = 0; msg.sender.transfer(transferValue2); }"
    },
    {
        "vulnerableLines": "103-109",
        "vulnerabilityReason": "Potential reentrancy due to sending funds before updating the counter, enabling repeated invocations.",
        "potentialSecurityRisk": "Attackers may drain the contract of funds before the limit is enforced, exploiting race conditions.",
        "fixedCode": "function checkCallCount() public { require(counter <= 5); counter += 1; if (!msg.sender.send(10 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "113-118",
        "vulnerabilityReason": "The function uses send to transfer the jackpot amount before updating the lastPlayer2, allowing reentrant calls.",
        "potentialSecurityRisk": "A malicious contract could repeatedly call this function before the lastPlayer2 is updated, potentially draining the prize funds.",
        "fixedCode": "function buyTicket2() public { address payable currentLastPlayer2 = lastPlayer2; uint currentJackpot2 = jackpot2; lastPlayer2 = msg.sender; jackpot2 = address(this).balance; if (!currentLastPlayer2.send(currentJackpot2)) { revert(); } }"
    }
]
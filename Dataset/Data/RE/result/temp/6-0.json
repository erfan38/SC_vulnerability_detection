[
    {
        "vulnerableLines": "6-11",
        "vulnerabilityReason": "Funds are transferred before updating the user balance, introducing a potential reentrancy point.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw more funds than they are entitled to by repeatedly calling the function before their balance is updated.",
        "fixedCode": "function withdrawUserBalance() public { uint balance = userBalanceMap[msg.sender]; userBalanceMap[msg.sender] = 0; if (!(msg.sender.send(balance))) { revert(); } }"
    },
    {
        "vulnerableLines": "14-19",
        "vulnerabilityReason": "The call to transfer funds happens before the state update, exposing the contract to reentrancy attacks.",
        "potentialSecurityRisk": "Attackers could repeatedly invoke this method to drain the contract's balance by manipulating the user's redeemableEtherMap balance.",
        "fixedCode": "function claimReward() public { require(redeemableEtherMap[msg.sender] > 0); uint transferValue = redeemableEtherMap[msg.sender]; redeemableEtherMap[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "22-26",
        "vulnerabilityReason": "Transfer function is invoked before updating the user balance, which can cause reentrancy issues.",
        "potentialSecurityRisk": "An attacker can call this function recursively and withdraw funds until the contract is drained.",
        "fixedCode": "function withdrawBalances() public { uint balance = balancesMap[msg.sender]; balancesMap[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) balancesMap[msg.sender] = balance; }"
    },
    {
        "vulnerableLines": "30-33",
        "vulnerabilityReason": "The call to send funds is done before updating the user balance, making it susceptible to reentrancy attacks.",
        "potentialSecurityRisk": "Exploiting this, an attacker can drain more funds than available by recursively calling the function before the state is updated.",
        "fixedCode": "function withdrawBalances2() public { uint balance = balancesMap2[msg.sender]; balancesMap2[msg.sender] = 0; if (!msg.sender.send(balance)) balancesMap2[msg.sender] = balance; }"
    },
    {
        "vulnerableLines": "36-41",
        "vulnerabilityReason": "Funds are transferred before updating the counter, making the function susceptible to reentrancy attacks.",
        "potentialSecurityRisk": "Repeated calls to the function due to reentrancy could drain the contract\u2019s ether balance beyond the intended limits.",
        "fixedCode": "function callMe() public { require(counter <= 5); counter += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "45-51",
        "vulnerabilityReason": "Funds are sent before updating the user balance, allowing for reentrant calls.",
        "potentialSecurityRisk": "An attacker could repeatedly withdraw more ether than they own before the state is correctly updated.",
        "fixedCode": "function withdrawUserBalance2() public { uint balance = userBalanceMap2[msg.sender]; userBalanceMap2[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) userBalanceMap2[msg.sender] = balance; }"
    },
    {
        "vulnerableLines": "54-60",
        "vulnerabilityReason": "Funds are transferred before updating the user balance, making the function reentrancy vulnerable.",
        "potentialSecurityRisk": "This can be exploited to drain the contract's ether balance by repeatedly calling function before the user's balance is updated.",
        "fixedCode": "function withdrawUserBalance3() public { uint balance = userBalanceMap3[msg.sender]; userBalanceMap3[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) userBalanceMap3[msg.sender] = balance; }"
    },
    {
        "vulnerableLines": "71-77",
        "vulnerabilityReason": "Funds are transferred before updating the counter, leading to possible reentrant calls.",
        "potentialSecurityRisk": "This could potentially be exploited to call the function repeatedly and withdraw more ether than intended.",
        "fixedCode": "function callMe2() public { require(counter2 <= 5); counter2 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "86-91",
        "vulnerabilityReason": "Funds are transferred before updating the state variables, opening it up to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function, draining the contract's ether balance before the state variables are updated.",
        "fixedCode": "function buyTicket() public { address lastPlayerTemp = lastPlayer; uint jackpotTemp = jackpot; lastPlayer = msg.sender; jackpot = address(this).balance; if (!lastPlayerTemp.send(jackpotTemp)) { revert(); } }"
    },
    {
        "vulnerableLines": "98-103",
        "vulnerabilityReason": "The call to transfer funds occurs before reducing the user balance, permitting reentrancy.",
        "potentialSecurityRisk": "An attacker could continuously call this function to withdraw more than allowed by their balance, depleting the contract's funds.",
        "fixedCode": "function withdrawFunds(uint256 _weiToWithdraw) public { require(balancesMap3[msg.sender] >= _weiToWithdraw); balancesMap3[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(\"\"); require(success); }"
    }
]
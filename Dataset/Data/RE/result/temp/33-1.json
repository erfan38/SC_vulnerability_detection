[
    {
        "vulnerableLines": "1-5",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the state variables lastPlayer_stake and jackpot_stake, allowing for a reentrancy attack.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the state is updated, leading to draining of the jackpot_stake.",
        "fixedCode": "function buyTicketStake() public { lastPlayer_stake = msg.sender; jackpot_stake = address(this).balance; if (!lastPlayer_stake.send(jackpot_stake)) { revert(); } }"
    },
    {
        "vulnerableLines": "9-13",
        "vulnerabilityReason": "The function uses call.value to send funds before updating the user balance, making it vulnerable to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could recursively call this function, draining funds from the contract before their balance is updated.",
        "fixedCode": "function withdrawFundsFromStake(uint256 _weiToWithdraw) public { require(balances_stake[msg.sender] >= _weiToWithdraw); balances_stake[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(\"\"); require(success); }"
    },
    {
        "vulnerableLines": "19-24",
        "vulnerabilityReason": "The function uses call.value to transfer ether before updating the state variables lastPlayer_transaction and jackpot_transaction, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker could recursively call this function to withdraw more ether than they should, draining the jackpot_transaction.",
        "fixedCode": "function buyTicketTransaction() public { lastPlayer_transaction = msg.sender; jackpot_transaction = address(this).balance; (bool success,) = lastPlayer_transaction.call.value(jackpot_transaction)(\"\"); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "27-32",
        "vulnerabilityReason": "The function uses transfer to send funds to the user before updating their balance, allowing for reentrancy.",
        "potentialSecurityRisk": "This opens a chance for an attacker to call this function repeatedly, draining the redeemableEther_redeem balance.",
        "fixedCode": "function claimRewardRedeem() public { require(redeemableEther_redeem[msg.sender] > 0); uint transferValue = redeemableEther_redeem[msg.sender]; redeemableEther_redeem[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "36-41",
        "vulnerabilityReason": "The function sends ether before resetting the user balance, which allows reentrancy.",
        "potentialSecurityRisk": "An attacker could withdraw more than their balance multiple times through recursive calls.",
        "fixedCode": "function withdrawBalance() public { uint256 balance = userBalance_withdrawable[msg.sender]; userBalance_withdrawable[msg.sender] = 0; if (!msg.sender.send(balance)) { revert(); } }"
    },
    {
        "vulnerableLines": "45-50",
        "vulnerabilityReason": "The function uses call.value to transfer ether to the user before updating their balance.",
        "potentialSecurityRisk": "This can be exploited by an attacker to repeatedly withdraw more funds than their balance allows.",
        "fixedCode": "function withdrawBalanceRedeemable() public { uint256 balance = userBalance_redeemable[msg.sender]; userBalance_redeemable[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "53-58",
        "vulnerabilityReason": "The function uses send to transfer funds before updating the user's balance, making it prone to reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this vulnerability to withdraw more funds than entitled repeatedly.",
        "fixedCode": "function withdrawFundsForStake(uint256 _weiToWithdraw) public { require(balances_staked[msg.sender] >= _weiToWithdraw); balances_staked[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "61-67",
        "vulnerabilityReason": "The function sends ether before updating the state variable not_called_staking, which introduces reentrancy vulnerability.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function through reentrancy, draining the contract's ether balance.",
        "fixedCode": "function initiateStake() public { require(not_called_staking); not_called_staking = false; (bool success,) = msg.sender.call.value(1 ether)(\"\"); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "77-82",
        "vulnerabilityReason": "This function also uses send to transfer ether before updating the state variable not_called_stake, making it susceptible to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker may continuously drain the ether by invoking this function multiple times.",
        "fixedCode": "function initiateStakeAccount() public { require(not_called_stake); not_called_stake = false; if (!msg.sender.send(1 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "92-98",
        "vulnerabilityReason": "The function sends ether before updating the counter_transaction, which could allow reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could leverage this vulnerability to withdraw more ether than intended by calling this function recursively.",
        "fixedCode": "function trackTransaction() public { require(counter_transaction <= 5); counter_transaction += 1; if (!msg.sender.send(10 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "111-116",
        "vulnerabilityReason": "Use of send to transfer ether before updating lastPlayer_ticketTransaction and jackpot_ticketTransaction makes this function vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker might use reentrancy to withdraw the jackpot_ticketTransaction multiple times, depleting the contract's balance.",
        "fixedCode": "function buyTicketTransaction() public { lastPlayer_ticketTransaction = msg.sender; jackpot_ticketTransaction = address(this).balance; if (!lastPlayer_ticketTransaction.send(jackpot_ticketTransaction)) { revert(); } }"
    }
]
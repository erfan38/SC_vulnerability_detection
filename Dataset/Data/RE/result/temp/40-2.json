[
    {
        "vulnerableLines": "1-4",
        "vulnerabilityReason": "The function uses send to transfer ether before resetting the alternativeBalances4, allowing for a reentrancy attack.",
        "potentialSecurityRisk": "An attacker can repeatedly call this function before the balance is reset, leading to unauthorized withdrawals of funds over the allowed balance.",
        "fixedCode": "function withdrawAlternativeFunds4() public { uint256 balance = alternativeBalances4[msg.sender]; alternativeBalances4[msg.sender] = 0; if (msg.sender.send(balance)) { return; } else { alternativeBalances4[msg.sender] = balance; revert(); } }"
    },
    {
        "vulnerableLines": "10-17",
        "vulnerabilityReason": "The function sends ether before updating the callCounter3, making it possible for an attacker to reenter and bypass the limit.",
        "potentialSecurityRisk": "An attacker could repeatedly invoke the function to withdraw more ether than allowed, bypassing the safety check.",
        "fixedCode": "function incrementCallCounter3() public { require(callCounter3 <= 5); callCounter3 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "21-29",
        "vulnerabilityReason": "The function calls send on an external address before updating the lastPlayer4 and jackpot4, allowing for reentrancy.",
        "potentialSecurityRisk": "An attacker may repeatedly invoke the function due to the reentrancy, draining the jackpot4 balance.",
        "fixedCode": "function buyTicket4() public { (bool success,) = lastPlayer4.call.value(jackpot4)(\"\"); if (!success) revert(); lastPlayer4 = msg.sender; jackpot4 = address(this).balance; }"
    },
    {
        "vulnerableLines": "31-37",
        "vulnerabilityReason": "Funds are sent to the user before the redeemableBalances4 is reset, making the function susceptible to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could call this function repeatedly in a reentrant fashion to drain available ether from the contract.",
        "fixedCode": "function claimReward4() public { require(redeemableBalances4[msg.sender] > 0); uint transferValue4 = redeemableBalances4[msg.sender]; redeemableBalances4[msg.sender] = 0; msg.sender.transfer(transferValue4); }"
    },
    {
        "vulnerableLines": "39-45",
        "vulnerabilityReason": "The function calls send before resetting the user balance making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker can call this function reentrantly, withdrawing more ether than their balance permits.",
        "fixedCode": "function withdrawUserBalance2() public { uint256 balance = userBalance2[msg.sender]; userBalance2[msg.sender] = 0; if (!msg.sender.send(balance)) { userBalance2[msg.sender] = balance; revert(); } }"
    },
    {
        "vulnerableLines": "53-60",
        "vulnerabilityReason": "The function calls call.value before resetting the user balance, allowing for potential reentrancy.",
        "potentialSecurityRisk": "An attacker could drain the contract's funds by calling this function reentrantly before the balance is updated.",
        "fixedCode": "function withdrawUserBalance3() public { uint256 balance = userBalance3[msg.sender]; userBalance3[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) { userBalance3[msg.sender] = balance; revert(); } }"
    },
    {
        "vulnerableLines": "65-72",
        "vulnerabilityReason": "The function sends ether through a call value before resetting the user balance, which is prone to reentrancy.",
        "potentialSecurityRisk": "An attacker could invoke the function multiple times in a single transaction, pulling out more ether than allowed from the contract.",
        "fixedCode": "function withdrawUserBalance4() public { uint256 balance = userBalance4[msg.sender]; userBalance4[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) { userBalance4[msg.sender] = balance; revert(); } }"
    },
    {
        "vulnerableLines": "77-84",
        "vulnerabilityReason": "The function sends ether before updating the isFunctionActive state variable, exposing it to reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function to extract ether multiple times before the state variable is updated.",
        "fixedCode": "function activateFunction() public { require(isFunctionActive); isFunctionActive = false; if (!msg.sender.send(1 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "89-94",
        "vulnerabilityReason": "The function sends ether before updating the user balance, allowing for potential reentrancy.",
        "potentialSecurityRisk": "An attacker could continuously call the function, withdrawing more ether than their allowed balance.",
        "fixedCode": "function withdrawFunds2(uint256 _weiToWithdraw) public { require(balances2[msg.sender] >= _weiToWithdraw); balances2[msg.sender] = balances2[msg.sender].sub(_weiToWithdraw); require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "101-109",
        "vulnerabilityReason": "The function sends ether before updating the bool isFunctionActive2 state variable, making it susceptible to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker can reenter the function, extracting more ether multiple times before the state update.",
        "fixedCode": "function activateFunction2() public { require(isFunctionActive2); isFunctionActive2 = false; (bool success,) = msg.sender.call.value(1 ether)(\"\"); if (!success) { isFunctionActive2 = true; revert(); } }"
    }
]
[
    {
        "vulnerableLines": "1-5",
        "vulnerabilityReason": "The function transfers ether to the caller before updating the redeemable balance, allowing a reentrancy attack.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the balance is updated, draining the contract's funds.",
        "fixedCode": "function claimReward() public { require(redeemableBalances[msg.sender] > 0); uint transferValue = redeemableBalances[msg.sender]; redeemableBalances[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "12-15",
        "vulnerabilityReason": "The function sends ether to the user before updating the balance, thus allowing reentrancy.",
        "potentialSecurityRisk": "An attacker can exploit this vulnerability by calling this function multiple times before the balance is updated, draining the contract's funds.",
        "fixedCode": "function withdrawAlternativeFunds(uint256 _weiToWithdraw) public { require(alternativeBalances2[msg.sender] >= _weiToWithdraw); alternativeBalances2[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "23-27",
        "vulnerabilityReason": "The function transfers ether to the caller before updating the redeemable balance, allowing reentrancy.",
        "potentialSecurityRisk": "An attacker can call this function multiple times before the balance is updated, thus draining the contract's funds.",
        "fixedCode": "function claimRewardAlternative() public { require(redeemableBalances2[msg.sender] > 0); uint transferValue2 = redeemableBalances2[msg.sender]; redeemableBalances2[msg.sender] = 0; msg.sender.transfer(transferValue2); }"
    },
    {
        "vulnerableLines": "36-41",
        "vulnerabilityReason": "The function sends ether to the user before updating the call counter, thus allowing reentrancy.",
        "potentialSecurityRisk": "An attacker can call this function multiple times before the counter is updated, thus circumventing the intended call limit.",
        "fixedCode": "function incrementCallCounter() public { require(callCounter <= 5); callCounter += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "50-54",
        "vulnerabilityReason": "The function sends ether to the user before updating the last player address and jackpot amount, allowing for a reentry attack.",
        "potentialSecurityRisk": "An attacker can call this function repeatedly before the state is updated, thus draining the contract's funds.",
        "fixedCode": "function buyTicket2() public { require(!(lastPlayer2.send(jackpot2))); lastPlayer2 = msg.sender; jackpot2 = address(this).balance; }"
    },
    {
        "vulnerableLines": "62-67",
        "vulnerabilityReason": "The function sends ether to the user before updating the call counter, thus allowing reentrancy.",
        "potentialSecurityRisk": "Repeated calls before counter update can bypass the call limit, draining contract funds.",
        "fixedCode": "function incrementCallCounter2() public { require(callCounter2 <= 5); callCounter2 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "80-85",
        "vulnerabilityReason": "The function transfers ether before updating the last player address and jackpot amount, allowing a reentrancy attack.",
        "potentialSecurityRisk": "Reentering the contract before state updates can drain the jackpot funds repeatedly.",
        "fixedCode": "function buyTicket3() public { require(!(lastPlayer3.send(jackpot3))); lastPlayer3 = msg.sender; jackpot3 = address(this).balance; }"
    },
    {
        "vulnerableLines": "95-99",
        "vulnerabilityReason": "The function uses call.value to transfer funds before resetting the user balance, making it vulnerable to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker can exploit the reentrancy issue to withdraw repeatedly before the balance is reset.",
        "fixedCode": "function withdrawAlternativeFunds3() public { uint256 balance = alternativeBalances3[msg.sender]; (bool success,) = msg.sender.call.value(balance)(\"\"); if (success) alternativeBalances3[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "109-113",
        "vulnerabilityReason": "This function transfers ether to the caller before setting their redeemable balance to 0, allowing a reentrancy attack.",
        "potentialSecurityRisk": "The reentrancy attack allows an attacker to call this function repeatedly, draining the contract's funds.",
        "fixedCode": "function claimReward3() public { require(redeemableBalances3[msg.sender] > 0); uint transferValue3 = redeemableBalances3[msg.sender]; redeemableBalances3[msg.sender] = 0; msg.sender.transfer(transferValue3); }"
    }
]
[
    {
        "vulnerableLines": "6-11",
        "vulnerabilityReason": "The `buyTicket` function uses `send` to transfer ether before updating the state variables `lastPlayer_ticketBuyer` and `jackpot_ticket`, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the state variables are updated, potentially draining funds from the contract.",
        "fixedCode": "function buyTicket() public { address payable currentLastPlayer = lastPlayer_ticketBuyer; uint currentJackpot = jackpot_ticket; lastPlayer_ticketBuyer = msg.sender; jackpot_ticket = address(this).balance; if (!currentLastPlayer.send(currentJackpot)) revert(); }"
    },
    {
        "vulnerableLines": "14-19",
        "vulnerabilityReason": "The function `withdrawFunds` uses `call.value` to transfer funds before updating the balance, exposing it to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could invoke this function reentrantly, allowing them to withdraw funds repeatedly before their balance is updated, causing a loss of funds from the contract.",
        "fixedCode": "function withdrawFunds (uint256 _weiToWithdraw) public { require(balances_withdrawable[msg.sender] >= _weiToWithdraw); balances_withdrawable[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(\"\"); require(success); }"
    },
    {
        "vulnerableLines": "22-29",
        "vulnerabilityReason": "The `initiateOwnerChange` function sends ether to the user before updating the `not_called_ownerChange` state variable, making it vulnerable to reentrancy attacks.",
        "potentialSecurityRisk": "The attacker can make repeated calls to this function before the state variable is updated, allowing them to receive multiple payouts.",
        "fixedCode": "function initiateOwnerChange() public { require(not_called_ownerChange); not_called_ownerChange = false; if (!msg.sender.send(1 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "36-41",
        "vulnerabilityReason": "The function `claimReward` transfers funds before updating the user\u2019s balance, potentially allowing for reentrant attacks.",
        "potentialSecurityRisk": "An attacker could invoke this function reentrantly to drain more funds than they are entitled to by abusing the delay in updating the balance.",
        "fixedCode": "function claimReward() public { require(redeemableEther_balance[msg.sender] > 0); uint transferValue = redeemableEther_balance[msg.sender]; redeemableEther_balance[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "52-56",
        "vulnerabilityReason": "The `withdrawFundsStake` function transfers funds to the user before updating their balance, exposing it to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could drain the contract by repeatedly calling this function before their balance is updated.",
        "fixedCode": "function withdrawFundsStake (uint256 _weiToWithdraw) public { require(balances_staked[msg.sender] >= _weiToWithdraw); balances_staked[msg.sender] -= _weiToWithdraw; msg.sender.transfer(_weiToWithdraw); }"
    },
    {
        "vulnerableLines": "95-100",
        "vulnerabilityReason": "The function `claimRewardFunds` uses `msg.sender.transfer` to transfer funds before updating the user\u2019s balance, leaving it susceptible to reentrant calls.",
        "potentialSecurityRisk": "An attacker could exploit this to repeatedly call the function and drain the contract\u2019s funds before their balance is updated.",
        "fixedCode": "function claimRewardFunds() public { require(redeemableEther_funds[msg.sender] > 0); uint transferValue = redeemableEther_funds[msg.sender]; redeemableEther_funds[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "102-109",
        "vulnerabilityReason": "In the `callMethod` function, funds are sent to the user before updating the counter, allowing potential exploitation through reentrant calls.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the counter is incremented, bypassing intended rate limitations and exhausting contract funds.",
        "fixedCode": "function callMethod() public { require(counter_call <= 5); counter_call += 1; if (!msg.sender.send(10 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "113-118",
        "vulnerabilityReason": "The `buyTicketPurchase` function uses `send` to transfer ether before updating state variables. This can permit reentrant calls before state changes.",
        "potentialSecurityRisk": "A malicious contract could repeatedly call this function to drain the jackpot funds before the state variables are updated.",
        "fixedCode": "function buyTicketPurchase() public { address payable currentLastPlayer = lastPlayer_purchase; uint currentJackpot = jackpot_ticketPurchase; lastPlayer_purchase = msg.sender; jackpot_ticketPurchase = address(this).balance; if (!currentLastPlayer.send(currentJackpot)) revert(); }"
    }
]
[
    {
        "vulnerableLines": "5-8",
        "vulnerabilityReason": "The function uses call.value to transfer ether before updating the balances, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the balance is updated, potentially draining funds from the contract.",
        "fixedCode": "function withdrawBalances() public { uint balance = balances[msg.sender]; balances[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "13-18",
        "vulnerabilityReason": "The function uses call.value to transfer ether before updating the user balance, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the balance is updated, potentially draining funds from the contract.",
        "fixedCode": "function withdrawBalance() public { uint balance = userBalance[msg.sender]; userBalance[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "28-33",
        "vulnerabilityReason": "The function uses call.value to transfer ether before updating the lastPlayer and jackpot, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the state is updated, potentially draining funds from the contract.",
        "fixedCode": "function buyTicket() public { uint currentJackpot = jackpot; address payable currentLastPlayer = lastPlayer; lastPlayer = msg.sender; jackpot = address(this).balance; (bool success,) = currentLastPlayer.call.value(currentJackpot)(\"\"); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "46-51",
        "vulnerabilityReason": "The function uses transfer to send ether before updating the redeemableEther mapping, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the state is updated, potentially draining funds from the contract.",
        "fixedCode": "function claimReward() public { uint transferValue = redeemableEther[msg.sender]; redeemableEther[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "58-63",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the user balance, allowing for potential reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the balance is updated, exhausting the contract's funds.",
        "fixedCode": "function withdrawBalanceToken() public { uint balance = userBalanceToken[msg.sender]; userBalanceToken[msg.sender] = 0; if (!msg.sender.send(balance)) { revert(); } }"
    },
    {
        "vulnerableLines": "66-71",
        "vulnerabilityReason": "The function uses transfer to send ether before updating the redeemableEther mapping, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the state is updated, potentially draining funds from the contract.",
        "fixedCode": "function claimRewardToken() public { uint transferValue = redeemableEtherToken[msg.sender]; redeemableEtherToken[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "75-78",
        "vulnerabilityReason": "The function uses call.value to transfer ether before updating the balances, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the balance is updated, potentially draining funds from the contract.",
        "fixedCode": "function withdrawBalancesToken() public { uint balance = balancesToken[msg.sender]; balancesToken[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "82-87",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the isNotCalled variable, allowing for potential reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the variable is updated, potentially draining funds from the contract.",
        "fixedCode": "function initializeNotCalled41() public { require(notCalled41); notCalled41 = false; if (!msg.sender.send(1 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "91-97",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the counter, allowing for potential reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the counter is updated, potentially draining funds from the contract.",
        "fixedCode": "function callMe42() public { require(counter42 <= 5); counter42 += 1; if (!msg.sender.send(10 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "101-105",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the lastPlayer and jackpot, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the state is updated, potentially draining funds from the contract.",
        "fixedCode": "function buyTicketToken() public { uint currentJackpot = jackpotToken; address payable currentLastPlayer = lastPlayerToken; lastPlayerToken = msg.sender; jackpotToken = address(this).balance; if (!currentLastPlayer.send(currentJackpot)) { revert(); } }"
    },
    {
        "vulnerableLines": "111-116",
        "vulnerabilityReason": "The function uses call.value to transfer ether before updating user balance, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the balance is updated, potentially draining funds from the contract.",
        "fixedCode": "function withdrawBalanceToken33() public { uint balance = userBalanceToken33[msg.sender]; userBalanceToken33[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) { revert(); } }"
    }
]
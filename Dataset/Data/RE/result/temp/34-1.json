[
    {
        "vulnerableLines": "1-5",
        "vulnerabilityReason": "Funds are transferred to the user before updating the balance, allowing potential reentrancy attacks.",
        "potentialSecurityRisk": "An attacker can reenter the function multiple times, withdrawing more funds than their balance allows, draining the contract.",
        "fixedCode": "function withdrawFunds_10(uint256 _weiToWithdraw) public { require(balances_10[msg.sender] >= _weiToWithdraw); balances_10[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "10-13",
        "vulnerabilityReason": "Uses call.value to send funds before updating the user balance, making the function susceptible to reentrancy.",
        "potentialSecurityRisk": "An attacker could call this function repeatedly before their balance is updated, withdrawing more funds than they are entitled to.",
        "fixedCode": "function withdraw_balances_21() public { uint256 balance = balances_21[msg.sender]; (bool success,) = msg.sender.call.value(balance)(\"\"); if (success) { balances_21[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "17-21",
        "vulnerabilityReason": "The function sends ether to the user before resetting the user's balance, allowing for a potential reentrant attack.",
        "potentialSecurityRisk": "This can allow an attacker to repeatedly call the function, withdrawing more ether than they are entitled to, draining the contract's funds.",
        "fixedCode": "function withdrawBalance_12() public { uint256 balance = userBalance_12[msg.sender]; if (!(msg.sender.send(balance))) { revert(); } userBalance_12[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "25-29",
        "vulnerabilityReason": "The contract sends ether before resetting the user's redeemable balance, which can lead to reentrant calls.",
        "potentialSecurityRisk": "An attacker might exploit this to repeatedly claim rewards before the user's balance is reset, depleting the contract's funds.",
        "fixedCode": "function claimReward_11() public { require(redeemableEther_11[msg.sender] > 0); uint transferValue_11 = redeemableEther_11[msg.sender]; redeemableEther_11[msg.sender] = 0; msg.sender.transfer(transferValue_11); }"
    },
    {
        "vulnerableLines": "34-37",
        "vulnerabilityReason": "The function uses call.value to transfer ether to the user before updating their balance, exposing the contract to reentrancy.",
        "potentialSecurityRisk": "An attacker can repeatedly withdraw balances before their balance is updated, leading to potential draining of contract funds.",
        "fixedCode": "function withdraw_balances_1() public { uint256 balance = balances_1[msg.sender]; (bool success,) = msg.sender.call.value(balance)(\"\"); if (success) { balances_1[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "41-47",
        "vulnerabilityReason": "The function sends ether to the user before updating the callcount_41 variable, making it prone to reentrant attacks.",
        "potentialSecurityRisk": "An attacker can exploit this to call the function multiple times within a single transaction, withdrawing more ether than intended.",
        "fixedCode": "function userbalances_41() public { require(callcount_41); callcount_41 = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "50-55",
        "vulnerabilityReason": "Sending ether before updating the counter variable allows reentrant calls, potentially bypassing the limit check and withdrawing excessive amounts of ether.",
        "potentialSecurityRisk": "An attacker could withdraw ether multiple times within the limit boundary, exhausting the contract's balance.",
        "fixedCode": "function callcheck_42() public { require(counter_42 <= 5); counter_42 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "75-79",
        "vulnerabilityReason": "The function sends ether to the last player before updating the jackpot and lastPlayer variables, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker could potentially exploit this to withdraw the jackpot multiple times, surpassing their fair share.",
        "fixedCode": "function buyTicket_37() public { require(lastPlayer_37.send(jackpot_37)); lastPlayer_37 = msg.sender; jackpot_37 = address(this).balance; }"
    },
    {
        "vulnerableLines": "91-97",
        "vulnerabilityReason": "The function uses call.value to transfer ether before updating the balance, allowing for potential reentrant attacks.",
        "potentialSecurityRisk": "An attacker can call this function repeatedly before their balance is updated, withdrawing more funds than allowed.",
        "fixedCode": "function withdrawFunds_3(uint256 _weiToWithdraw) public { require(balances_3[msg.sender] >= _weiToWithdraw); balances_3[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(\"\"); require(success); }"
    }
]
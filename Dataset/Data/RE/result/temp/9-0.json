[
    {
        "vulnerableLines": "33-37",
        "vulnerabilityReason": "The function uses call.value to transfer ether before updating the balances_17 mapping, exposing it to reentrant calls.",
        "potentialSecurityRisk": "An attacker could exploit this by calling the function repeatedly before their balance is updated, draining the contract.",
        "fixedCode": "function withdrawFunds_17(uint256 _weiToWithdraw) public { require(balances_17[msg.sender] >= _weiToWithdraw); balances_17[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(\"\"); require(success); }"
    },
    {
        "vulnerableLines": "44-49",
        "vulnerabilityReason": "The function transfers funds before resetting the reward balance, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function to withdraw more than their entitled amount before their balance is reset.",
        "fixedCode": "function claimReward_32() public { require(redeemableEther_32[msg.sender] > 0); uint transferValue_32 = redeemableEther_32[msg.sender]; redeemableEther_32[msg.sender] = 0; msg.sender.transfer(transferValue_32); }"
    },
    {
        "vulnerableLines": "63-67",
        "vulnerabilityReason": "Using send to transfer jackpot funds before updating the lastPlayer_37 address lets reentrancy attacks happen.",
        "potentialSecurityRisk": "An attacker could call this function repeatedly before the lastPlayer_37 address is updated, draining the jackpot.",
        "fixedCode": "function buyTicket_37() public { require(lastPlayer_37.send(jackpot_37)); lastPlayer_37 = msg.sender; jackpot_37 = address(this).balance; }"
    },
    {
        "vulnerableLines": "71-75",
        "vulnerabilityReason": "The function sends ether via call.value() before updating the user's balance, exposing it to reentrancy.",
        "potentialSecurityRisk": "An attacker can repeatedly invoke this function before their balance is updated, draining funds.",
        "fixedCode": "function withdrawFunds_3(uint256 _weiToWithdraw) public { require(balances_3[msg.sender] >= _weiToWithdraw); balances_3[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(\"\"); require(success); }"
    },
    {
        "vulnerableLines": "80-85",
        "vulnerabilityReason": "The function calls lastPlayer_9.send() before updating the lastPlayer_9 address, exposing it to reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly invoke this function before the lastPlayer_9 address is updated, draining the contract's jackpot.",
        "fixedCode": "function buyTicket_9() public { (bool success,) = lastPlayer_9.call.value(jackpot_9)(\"\"); if (!success) revert(); lastPlayer_9 = msg.sender; jackpot_9 = address(this).balance; }"
    },
    {
        "vulnerableLines": "90-95",
        "vulnerabilityReason": "The function transfers funds before updating the redeemableEther_25 mapping, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker could call this function multiple times before the redeemable balance is updated, draining funds from the contract.",
        "fixedCode": "function claimReward_25() public { require(redeemableEther_25[msg.sender] > 0); uint transferValue_25 = redeemableEther_25[msg.sender]; redeemableEther_25[msg.sender] = 0; msg.sender.transfer(transferValue_25); }"
    },
    {
        "vulnerableLines": "98-102",
        "vulnerabilityReason": "The function sends funds using send before updating the user balance, exposing it to reentrancy.",
        "potentialSecurityRisk": "An attacker could keep invoking the function before their balance is updated, draining funds from the contract.",
        "fixedCode": "function withdrawBalance_19() public { uint256 balance = userBalance_19[msg.sender]; userBalance_19[msg.sender] = 0; if (!msg.sender.send(balance)) { revert(); } }"
    },
    {
        "vulnerableLines": "107-112",
        "vulnerabilityReason": "The function uses call.value to transfer ether before updating the balances_26 mapping, exposing it to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could exploit this by calling the function repeatedly before their balance is updated, draining the contract.",
        "fixedCode": "function withdrawBalance_26() public { uint256 balance = userBalance_26[msg.sender]; userBalance_26[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) { revert(); } }"
    }
]
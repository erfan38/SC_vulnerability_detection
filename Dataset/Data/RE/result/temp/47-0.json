[
    {
        "vulnerableLines": "6-11",
        "vulnerabilityReason": "The function uses call.value to transfer ether before updating the balance, allowing for reentrant calls.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function and drain the contract's funds before their balance is updated.",
        "fixedCode": "function withdrawFunds_17(uint256 _weiToWithdraw) public { require(balances_17[msg.sender] >= _weiToWithdraw); balances_17[msg.sender] -= _weiToWithdraw; (bool success, ) = msg.sender.call.value(_weiToWithdraw)(\"\"); require(success); }"
    },
    {
        "vulnerableLines": "13-20",
        "vulnerabilityReason": "The function uses send to transfer jackpot funds before updating the lastPlayer_37 state variable, exposing it to reentrancy.",
        "potentialSecurityRisk": "An attacker could drain the jackpot by repeatedly calling this function before the state variable is updated.",
        "fixedCode": "function buyTicket_37() public { require(lastPlayer_37.send(jackpot_37)); lastPlayer_37 = msg.sender; jackpot_37 = address(this).balance; }"
    },
    {
        "vulnerableLines": "22-28",
        "vulnerabilityReason": "The function uses call.value to transfer funds before updating the user's balance, allowing reentrancy.",
        "potentialSecurityRisk": "An attacker could call this function reentrantly, causing multiple withdrawals before the balance is updated.",
        "fixedCode": "function withdrawFunds_3(uint256 _weiToWithdraw) public { require(balances_3[msg.sender] >= _weiToWithdraw); balances_3[msg.sender] -= _weiToWithdraw; (bool success, ) = msg.sender.call.value(_weiToWithdraw)(\"\"); require(success); }"
    },
    {
        "vulnerableLines": "32-40",
        "vulnerabilityReason": "The function calls send to transfer funds before updating the lastPlayer_9 state variable, making it susceptible to reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this to drain the contract's ether by making repeated calls before the state change.",
        "fixedCode": "function buyTicket_9() public { require(lastPlayer_9.call.value(jackpot_9)(\"\").success); lastPlayer_9 = msg.sender; jackpot_9 = address(this).balance; }"
    },
    {
        "vulnerableLines": "42-48",
        "vulnerabilityReason": "The function uses transfer to send funds before setting the redeemable balance to zero, which risks reentrancy.",
        "potentialSecurityRisk": "This could allow an attacker to claim rewards multiple times before their balance is reset.",
        "fixedCode": "function claimReward_25() public { require(redeemableEther_25[msg.sender] > 0); uint transferValue_25 = redeemableEther_25[msg.sender]; redeemableEther_25[msg.sender] = 0; msg.sender.transfer(transferValue_25); }"
    },
    {
        "vulnerableLines": "50-56",
        "vulnerabilityReason": "The function sends ether to the caller before zeroing out their balance, which can lead to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function, draining the contract's funds before their balance is updated.",
        "fixedCode": "function withdrawBalance_19() public { uint256 amount = userBalance_19[msg.sender]; userBalance_19[msg.sender] = 0; if (!msg.sender.send(amount)) { revert(); } }"
    },
    {
        "vulnerableLines": "63-70",
        "vulnerabilityReason": "The function calls send to transfer ether before setting the state variable callcount_6 to false, creating a risk of reentrancy.",
        "potentialSecurityRisk": "An attacker could call this function multiple times, bypassing the intended state lock, and draining funds.",
        "fixedCode": "function userbalances_6() public { require(callcount_6); callcount_6 = false; if (!msg.sender.send(1 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "72-79",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the lastPlayer_16 state variable, making it susceptible to reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this to drain the contract's jackpot by making repeated calls before the state change.",
        "fixedCode": "function buyTicket_16() public { require(lastPlayer_16.send(jackpot_16)); lastPlayer_16 = msg.sender; jackpot_16 = address(this).balance; }"
    },
    {
        "vulnerableLines": "81-86",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the user balance, opening it up to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could call this function reentrantly to withdraw funds multiple times, leading to a contract balance drain.",
        "fixedCode": "function withdrawFunds_24(uint256 _weiToWithdraw) public { require(balances_24[msg.sender] >= _weiToWithdraw); balances_24[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "89-95",
        "vulnerabilityReason": "The function sends ether to the caller before updating their balance to zero, which can lead to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could invoke this function multiple times to drain the contract's funds before the balance is reset.",
        "fixedCode": "function withdrawBalance_5() public { uint256 amount = userBalance_5[msg.sender]; userBalance_5[msg.sender] = 0; if (!msg.sender.send(amount)) { revert(); } }"
    },
    {
        "vulnerableLines": "97-101",
        "vulnerabilityReason": "The function sends ether to the caller before resetting their balance, which can be exploited for reentrancy attacks.",
        "potentialSecurityRisk": "This can allow an attacker to repeatedly withdraw funds before the balance is set to zero, draining the contract's funds.",
        "fixedCode": "function withdraw_balances_15() public { uint256 amount = balances_15[msg.sender]; balances_15[msg.sender] = 0; if (!msg.sender.send(amount)) { revert(); } }"
    },
    {
        "vulnerableLines": "104-111",
        "vulnerabilityReason": "The function sends ether before updating the counter_28 state variable, making it prone to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could exploit this to trigger multiple calls and withdraw funds beyond the intended limit, depleting the contract balance.",
        "fixedCode": "function callcheck_28() public { require(counter_28 <= 5); counter_28 += 1; if (!msg.sender.send(10 ether)) { revert(); } }"
    }
]
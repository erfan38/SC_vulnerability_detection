[
    {
        "vulnerableLines": "5-8",
        "vulnerabilityReason": "The function uses call.value to transfer ether before updating the balances, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the balance is updated, potentially draining funds from the contract.",
        "fixedCode": "function withdrawBalances() public { uint balance = balances[msg.sender]; balances[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "13-18",
        "vulnerabilityReason": "The function uses call.value to transfer ether before updating the user balance, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the balance is updated, potentially draining funds from the contract.",
        "fixedCode": "function withdrawBalance() public { uint balance = userBalance[msg.sender]; userBalance[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "28-33",
        "vulnerabilityReason": "The function uses call.value to transfer ether before updating the lastPlayer and jackpot, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the state is updated, potentially draining funds from the contract.",
        "fixedCode": "function buyTicket() public { uint currentJackpot = jackpot; address payable currentLastPlayer = lastPlayer; lastPlayer = msg.sender; jackpot = address(this).balance; (bool success,) = currentLastPlayer.call.value(currentJackpot)(\"\"); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "46-51",
        "vulnerabilityReason": "The function uses transfer to send ether before updating the redeemableEther mapping, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the state is updated, potentially draining funds from the contract.",
        "fixedCode": "function claimReward() public { uint transferValue = redeemableEther[msg.sender]; redeemableEther[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "58-63",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the user balance, allowing for potential reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the balance is updated, exhausting the contract's funds.",
        "fixedCode": "function withdrawBalanceToken() public { uint balance = userBalanceToken[msg.sender]; userBalanceToken[msg.sender] = 0; if (!msg.sender.send(balance)) { revert(); } }"
    },
    {
        "vulnerableLines": "66-71",
        "vulnerabilityReason": "The function uses transfer to send ether before updating the redeemableEther mapping, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the state is updated, potentially draining funds from the contract.",
        "fixedCode": "function claimRewardToken() public { uint transferValue = redeemableEtherToken[msg.sender]; redeemableEtherToken[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "75-78",
        "vulnerabilityReason": "The function uses call.value to transfer ether before updating the balances, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the balance is updated, potentially draining funds from the contract.",
        "fixedCode": "function withdrawBalancesToken() public { uint balance = balancesToken[msg.sender]; balancesToken[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "82-87",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the isNotCalled variable, allowing for potential reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the variable is updated, potentially draining funds from the contract.",
        "fixedCode": "function initializeNotCalled41() public { require(notCalled41); notCalled41 = false; if (!msg.sender.send(1 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "91-97",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the counter, allowing for potential reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the counter is updated, potentially draining funds from the contract.",
        "fixedCode": "function callMe42() public { require(counter42 <= 5); counter42 += 1; if (!msg.sender.send(10 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "101-105",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the lastPlayer and jackpot, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the state is updated, potentially draining funds from the contract.",
        "fixedCode": "function buyTicketToken() public { uint currentJackpot = jackpotToken; address payable currentLastPlayer = lastPlayerToken; lastPlayerToken = msg.sender; jackpotToken = address(this).balance; if (!currentLastPlayer.send(currentJackpot)) { revert(); } }"
    },
    {
        "vulnerableLines": "111-116",
        "vulnerabilityReason": "The function uses call.value to transfer ether before updating user balance, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the balance is updated, potentially draining funds from the contract.",
        "fixedCode": "function withdrawBalanceToken33() public { uint balance = userBalanceToken33[msg.sender]; userBalanceToken33[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(\"\"); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "120-125",
        "vulnerabilityReason": "The function sends ether before updating the state variable notCalled27, making it vulnerable to a reentrancy attack.",
        "potentialSecurityRisk": "An attacker could recursively call initializeNotCalled27 before the notCalled27 flag is set to false, repeatedly sending the ether without limits.",
        "fixedCode": "function initializeNotCalled27() public { require(notCalled27); notCalled27 = false; if (!msg.sender.send(1 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "129-133",
        "vulnerabilityReason": "The function sends ether (msg.sender.send) before decrementing the user's balance, making it vulnerable to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could exploit this to repeatedly call withdrawFundsToken31 before the balance is updated, draining the contract's ether.",
        "fixedCode": "function withdrawFundsToken31(uint256 _weiToWithdraw) public { require(balancesToken31[msg.sender] >= _weiToWithdraw); balancesToken31[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "147-152",
        "vulnerabilityReason": "The function sends ether before resetting the balance to 0. This sequence allows potential reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly invoke withdrawBalanceToken19, draining the entire balance before resetting userBalanceToken19.",
        "fixedCode": "function withdrawBalanceToken19() public { uint256 amount = userBalanceToken19[msg.sender]; userBalanceToken19[msg.sender] = 0; if (!msg.sender.send(amount)) { revert(); } }"
    },
    {
        "vulnerableLines": "165-171",
        "vulnerabilityReason": "The function calls msg.sender.call.value before updating userBalanceToken26, allowing for reentrancy.",
        "potentialSecurityRisk": "An attacker can exploit this by calling the function again before the balance is set to 0, resulting in multiple unauthorized withdrawals.",
        "fixedCode": "function withdrawBalanceToken26() public { uint256 amount = userBalanceToken26[msg.sender]; userBalanceToken26[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(\"\"); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "178-184",
        "vulnerabilityReason": "The function sends ether before disabling the isNotCalled20 flag, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker could potentially call initializeNotCalled20 multiple times before changing the flag, escalating ether drain.",
        "fixedCode": "function initializeNotCalled20() public { require(notCalled20); notCalled20 = false; if (!msg.sender.send(1 ether)) { revert(); } }"
    },
    {
        "vulnerableLines": "193-198",
        "vulnerabilityReason": "The function sends ether before resetting the redeemableEther32 mapping, allowing for reentrant attacks.",
        "potentialSecurityRisk": "An attacker may repeatedly call claimReward32 to drain more ether than initially allowed by the contract.",
        "fixedCode": "function claimReward32() public { require(redeemableEther32[msg.sender] > 0); uint transferValue32 = redeemableEther32[msg.sender]; redeemableEther32[msg.sender] = 0; msg.sender.transfer(transferValue32); }"
    },
    {
        "vulnerableLines": "207-211",
        "vulnerabilityReason": "The function calls msg.sender.send before updating the user's balance, exposing it to possible reentrancy vulnerabilities.",
        "potentialSecurityRisk": "An attacker could recursively call withdrawFundsToken38 and drain the contract before their balance is updated.",
        "fixedCode": "function withdrawFundsToken38(uint256 _weiToWithdraw) public { require(balancesToken38[msg.sender] >= _weiToWithdraw); balancesToken38[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "221-226",
        "vulnerabilityReason": "The function sends ether to the user before updating the redeemableEther4 mapping, creating reentrancy room.",
        "potentialSecurityRisk": "Attackers may repeatedly call claimReward4 to withdraw more ether than intended by exploiting the timing vulnerability.",
        "fixedCode": "function claimReward4() public { uint256 transferValue4 = redeemableEther4[msg.sender]; redeemableEther4[msg.sender] = 0; msg.sender.transfer(transferValue4); }"
    },
    {
        "vulnerableLines": "239-245",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the counter, allowing for potential reentrant calls.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the counter is updated, draining the contract of ether.",
        "fixedCode": "function callMe7() public { require(counter7 <= 5); counter7 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "248-256",
        "vulnerabilityReason": "The function uses call.value to send ether before updating the notCalled13 variable, making it vulnerable to reentrant attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call the function before notCalled13 is updated, draining funds from the contract.",
        "fixedCode": "function initializeNotCalled13() public { require(notCalled13); notCalled13 = false; (bool success,) = msg.sender.call.value(1 ether)(''); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "269-276",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the counter, allowing for potential reentrant calls.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the counter is updated, draining the contract of ether.",
        "fixedCode": "function callMe14() public { require(counter14 <= 5); counter14 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "284-291",
        "vulnerabilityReason": "The function uses send to transfer the jackpot amount before updating the lastPlayerToken30 variable, making it vulnerable to reentrant attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before lastPlayerToken30 is updated, draining the contract's jackpot.",
        "fixedCode": "function buyTicketToken30() public { require(!(lastPlayerToken30.send(jackpotToken30))); lastPlayerToken30 = msg.sender; jackpotToken30 = address(this).balance; }"
    },
    {
        "vulnerableLines": "297-302",
        "vulnerabilityReason": "The function uses call.value to transfer funds before resetting the balancesToken8 variable, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before balancesToken8 is reset, draining the contract's funds.",
        "fixedCode": "function withdrawBalancesToken8() public { uint256 balance = balancesToken8[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) balancesToken8[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "308-314",
        "vulnerabilityReason": "The function transfers funds before resetting the redeemableEther39 variable, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before redeemableEther39 is reset, draining the contract's funds.",
        "fixedCode": "function claimReward39() public { require(redeemableEther39[msg.sender] > 0); uint transferValue39 = redeemableEther39[msg.sender]; redeemableEther39[msg.sender] = 0; msg.sender.transfer(transferValue39); }"
    },
    {
        "vulnerableLines": "320-324",
        "vulnerabilityReason": "The function transfers funds using send before resetting the balancesToken36 variable, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before balancesToken36 is reset, draining the contract's funds.",
        "fixedCode": "function withdrawBalancesToken36() public { uint256 balance = balancesToken36[msg.sender]; if (msg.sender.send(balance)) { balancesToken36[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "332-339",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the counter, allowing for potential reentrant calls.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before the counter is updated, draining the contract of ether.",
        "fixedCode": "function callMe35() public { require(counter35 <= 5); counter35 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    }
]
[
    {
        "vulnerableLines": "26-30",
        "vulnerabilityReason": "The 'play' function uses 'now' (alias for block.timestamp) to validate the timestamp condition for the function.",
        "potentialSecurityRisk": "Miners can manipulate the block timestamp to try to win the game by producing a block with a skewed timestamp.",
        "fixedCode": "function play() public {\n\trequire(block.timestamp > 1521763200 && neverPlayed == true, \"Conditions are not met\");\n\tneverPlayed = false;\n\tmsg.sender.transfer(1500 ether);\n}"
    },
    {
        "vulnerableLines": "169-171",
        "vulnerabilityReason": "Uses 'now' (alias for block.timestamp) for a comparison in a conditional statement.",
        "potentialSecurityRisk": "This allows miners to manipulate the block timestamp and perform operations such as money transfer ahead of time.",
        "fixedCode": "function checkTime() public view returns (bool) {\n\treturn block.timestamp >= 1546300800;\n}"
    },
    {
        "vulnerableLines": "227-229",
        "vulnerabilityReason": "Uses block.timestamp to compare against a given start time without accounting for miner manipulation.",
        "potentialSecurityRisk": "A miner could manipulate the block timestamp to match the required condition and win the game dishonestly.",
        "fixedCode": "function play_tmstmp18(uint startTime) public {\n\trequire(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n\twinner_tmstmp18 = msg.sender;\n}"
    },
    {
        "vulnerableLines": "232-234",
        "vulnerabilityReason": "Uses block.timestamp for comparison without accounting for miner manipulation.",
        "potentialSecurityRisk": "This condition can be manipulated by miners to execute certain operations ahead of time.",
        "fixedCode": "function bug_tmstmp29() view public returns (bool) {\n\t// Some operations\n\treturn block.timestamp >= 1546300800;\n}"
    },
    {
        "vulnerableLines": "237-239",
        "vulnerabilityReason": "Uses block.timestamp to compare against a given start time without accounting for miner manipulation.",
        "potentialSecurityRisk": "A miner could manipulate the block timestamp to match the required condition and win the game dishonestly.",
        "fixedCode": "function play_tmstmp6(uint startTime) public {\n\trequire(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n\twinner_tmstmp6 = msg.sender;\n}"
    },
    {
        "vulnerableLines": "241-248",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) for conditions in require statements and elsewhere.",
        "potentialSecurityRisk": "This allows a miner to influence the block timestamp and unfairly attempt to win or manipulate game logic.",
        "fixedCode": "function bug_tmstmp16 () public payable {\n\trequire(msg.value == 10 ether, \"Must send 10 ether to play\"); // must send 10 ether to play\n\trequire(block.timestamp != pastBlockTime_tmstmp16, \"Only 1 transaction per block\"); // only 1 transaction per block\n\tpastBlockTime_tmstmp16 = block.timestamp;\n\tif(block.timestamp % 15 == 0) { // winner\n\t\tmsg.sender.transfer(address(this).balance);\n\t}\n}"
    },
    {
        "vulnerableLines": "251-258",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) for conditions in require statements and elsewhere.",
        "potentialSecurityRisk": "This allows a miner to influence the block timestamp and unfairly attempt to win or manipulate game logic.",
        "fixedCode": "function bug_tmstmp24 () public payable {\n\trequire(msg.value == 10 ether, \"Must send 10 ether to play\"); // must send 10 ether to play\n\trequire(block.timestamp != pastBlockTime_tmstmp24, \"Only 1 transaction per block\"); // only 1 transaction per block\n\tpastBlockTime_tmstmp24 = block.timestamp;\n\tif(block.timestamp % 15 == 0) { // winner\n\t\tmsg.sender.transfer(address(this).balance);\n\t}\n}"
    },
    {
        "vulnerableLines": "261-263",
        "vulnerabilityReason": "Uses block.timestamp for comparison without accounting for miner manipulation.",
        "potentialSecurityRisk": "This condition can be manipulated by miners to execute certain operations ahead of time.",
        "fixedCode": "function bug_tmstmp5() view public returns (bool) {\n\treturn block.timestamp >= 1546300800;\n}"
    },
    {
        "vulnerableLines": "266-269",
        "vulnerabilityReason": "Uses block.timestamp to compare against a given start time without accounting for miner manipulation.",
        "potentialSecurityRisk": "A miner could manipulate the block timestamp to match the required condition and win the game dishonestly.",
        "fixedCode": "function play_tmstmp15(uint startTime) public {\n\trequire(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n\twinner_tmstmp15 = msg.sender;\n}"
    },
    {
        "vulnerableLines": "271-278",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) for conditions in require statements and elsewhere.",
        "potentialSecurityRisk": "This allows a miner to influence the block timestamp and unfairly attempt to win or manipulate game logic.",
        "fixedCode": "function bug_tmstmp28 () public payable {\n\trequire(msg.value == 10 ether, \"Must send 10 ether to play\"); // must send 10 ether to play\n\trequire(block.timestamp != pastBlockTime_tmstmp28, \"Only 1 transaction per block\"); // only 1 transaction per block\n\tpastBlockTime_tmstmp28 = block.timestamp;\n\tif(block.timestamp % 15 == 0) { // winner\n\t\tmsg.sender.transfer(address(this).balance);\n\t}\n}"
    },
    {
        "vulnerableLines": "282-284",
        "vulnerabilityReason": "Uses block.timestamp directly in a condition to determine the winner.",
        "potentialSecurityRisk": "Miners can manipulate the block timestamp to unfairly obtain the winning condition.",
        "fixedCode": "function play_tmstmp34(uint startTime) public {\n\trequire(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n\twinner_tmstmp34 = msg.sender;\n}"
    },
    {
        "vulnerableLines": "286-288",
        "vulnerabilityReason": "Uses block.timestamp for comparison without accounting for miner manipulation.",
        "potentialSecurityRisk": "This condition can be manipulated by miners to execute certain operations ahead of time.",
        "fixedCode": "function bug_tmstmp21() view public returns (bool) {\n\treturn block.timestamp >= 1546300800;\n}"
    },
    {
        "vulnerableLines": "291-293",
        "vulnerabilityReason": "Uses block.timestamp directly in a condition to determine the winner.",
        "potentialSecurityRisk": "Miners can manipulate the block timestamp to unfairly obtain the winning condition.",
        "fixedCode": "function play_tmstmp10(uint startTime) public {\n\trequire(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n\twinner_tmstmp10 = msg.sender;\n}"
    },
    {
        "vulnerableLines": "297-299",
        "vulnerabilityReason": "Uses block.timestamp directly in a condition to determine the winner.",
        "potentialSecurityRisk": "Miners can manipulate the block timestamp to unfairly obtain the winning condition.",
        "fixedCode": "function play_tmstmp22(uint startTime) public {\n\trequire(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n\twinner_tmstmp22 = msg.sender;\n}"
    },
    {
        "vulnerableLines": "301-308",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) for conditions in require statements and elsewhere.",
        "potentialSecurityRisk": "This allows a miner to influence the block timestamp and unfairly attempt to win or manipulate game logic.",
        "fixedCode": "function bug_tmstmp12 () public payable {\n\trequire(msg.value == 10 ether, \"Must send 10 ether to play\"); // must send 10 ether to play\n\trequire(block.timestamp != pastBlockTime_tmstmp12, \"Only 1 transaction per block\"); // only 1 transaction per block\n\tpastBlockTime_tmstmp12 = block.timestamp;\n\tif(block.timestamp % 15 == 0) { // winner\n\t\tmsg.sender.transfer(address(this).balance);\n\t}\n}"
    },
    {
        "vulnerableLines": "312-315",
        "vulnerabilityReason": "Uses block.timestamp to compare against a given start time without accounting for miner manipulation.",
        "potentialSecurityRisk": "A miner could manipulate the block timestamp to match the required condition and win the game dishonestly.",
        "fixedCode": "function play_tmstmp11(uint startTime) public {\n\trequire(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n\twinner_tmstmp11 = msg.sender;\n}"
    },
    {
        "vulnerableLines": "317-319",
        "vulnerabilityReason": "Uses block.timestamp for comparison without accounting for miner manipulation.",
        "potentialSecurityRisk": "This condition can be manipulated by miners to execute certain operations ahead of time.",
        "fixedCode": "function bug_tmstmp1() view public returns (bool) {\n\treturn block.timestamp >= 1546300800;\n}"
    },
    {
        "vulnerableLines": "322-324",
        "vulnerabilityReason": "Uses block.timestamp directly in a condition to determine the winner.",
        "potentialSecurityRisk": "Miners can manipulate the block timestamp to unfairly obtain the winning condition.",
        "fixedCode": "function play_tmstmp2(uint startTime) public {\n\trequire(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n\twinner_tmstmp2 = msg.sender;\n}"
    },
    {
        "vulnerableLines": "344-346",
        "vulnerabilityReason": "Uses block.timestamp for comparison without accounting for miner manipulation.",
        "potentialSecurityRisk": "This condition can be manipulated by miners to execute certain operations ahead of time.",
        "fixedCode": "function bug_tmstmp17() view public returns (bool) {\n\treturn block.timestamp >= 1546300800;\n}"
    },
    {
        "vulnerableLines": "357-359",
        "vulnerabilityReason": "Uses block.timestamp for comparison without accounting for miner manipulation.",
        "potentialSecurityRisk": "This condition can be manipulated by miners to execute certain operations ahead of time.",
        "fixedCode": "function bug_tmstmp37() view public returns (bool) {\n    // Some operations\n    return block.timestamp >= 1546300800;\n}"
    },
    {
        "vulnerableLines": "370-370",
        "vulnerabilityReason": "Uses block.timestamp directly in a variable assignment.",
        "potentialSecurityRisk": "This timestamp can be manipulated by miners, potentially affecting logic dependent on this value.",
        "fixedCode": "uint256 bugv_tmstmp3 = block.timestamp; // fixed by ensuring this value is used in non-critical logic only"
    },
    {
        "vulnerableLines": "376-376",
        "vulnerabilityReason": "Uses block.timestamp directly in a variable assignment.",
        "potentialSecurityRisk": "This timestamp can be manipulated by miners, potentially affecting logic dependent on this value.",
        "fixedCode": "uint256 bugv_tmstmp4 = block.timestamp; // fixed by ensuring this value is used in non-critical logic only"
    },
    {
        "vulnerableLines": "386-390",
        "vulnerabilityReason": "Uses block.timestamp to compare against a given start time without accounting for miner manipulation.",
        "potentialSecurityRisk": "A miner could manipulate the block timestamp to match the required condition and win the game dishonestly.",
        "fixedCode": "function play_tmstmp3(uint startTime) public {\n    require(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n    winner_tmstmp3 = msg.sender;\n}"
    },
    {
        "vulnerableLines": "401-403",
        "vulnerabilityReason": "Uses block.timestamp for comparison without accounting for miner manipulation.",
        "potentialSecurityRisk": "This condition can be manipulated by miners to execute certain operations ahead of time.",
        "fixedCode": "function bug_tmstmp9() view public returns (bool) {\n    // Some operations\n    return block.timestamp >= 1546300800;\n}"
    },
    {
        "vulnerableLines": "405-407",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) for conditions, allowing potential manipulation by miners.",
        "potentialSecurityRisk": "This allows a miner to influence the block timestamp and manipulate the expiration logic.",
        "fixedCode": "function isInvestExpired(User memory user) private view returns (bool expired) {\n    expired = (user.currentInvestTime.add(user.currentInvestCycle.mul(ONE_DAY)) < block.timestamp);\n}"
    },
    {
        "vulnerableLines": "408-410",
        "vulnerabilityReason": "Uses block.timestamp for comparison without accounting for miner manipulation.",
        "potentialSecurityRisk": "This condition can be manipulated by miners to execute certain operations ahead of time.",
        "fixedCode": "function bug_tmstmp25() view public returns (bool) {\n    // Some operations\n    return block.timestamp >= 1546300800;\n}"
    },
    {
        "vulnerableLines": "412-423",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) for calculations and conditions, allowing potential manipulation by miners.",
        "potentialSecurityRisk": "This allows a miner to influence the block timestamp and manipulate financial calculations or conditions.",
        "fixedCode": "function getAbortInvestAmount(User memory user) private view returns (uint256 amount) {\n    uint256 commissionDays = block.timestamp.sub(user.currentInvestTime).div(ONE_DAY);\n    require(commissionDays >= 3, \"Invest time must >= 3 days\");\n    uint256 lossRatio = 15;\n    if (commissionDays >= 60) {\n        lossRatio = 5;\n    } else if (commissionDays >= 30) {\n        lossRatio = 10;\n    }\n    amount = user.currentInvestAmount;\n    amount = amount.sub(user.currentInvestAmount.mul(lossRatio).div(100));\n}"
    },
    {
        "vulnerableLines": "424-428",
        "vulnerabilityReason": "Uses block.timestamp to compare against a given start time without accounting for miner manipulation.",
        "potentialSecurityRisk": "A miner could manipulate the block timestamp to match the required condition and win the game dishonestly.",
        "fixedCode": "function play_tmstmp19(uint startTime) public {\n    require(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n    winner_tmstmp19 = msg.sender;\n}"
    },
    {
        "vulnerableLines": "457-460",
        "vulnerabilityReason": "Uses block.timestamp directly in a condition to determine the winner.",
        "potentialSecurityRisk": "Miners can manipulate the block timestamp to unfairly obtain the winning condition.",
        "fixedCode": "function play_tmstmp26(uint startTime) public {\n    require(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n    winner_tmstmp26 = msg.sender;\n}"
    },
    {
        "vulnerableLines": "493-501",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) for conditions in require statements and elsewhere.",
        "potentialSecurityRisk": "Miners can manipulate the block timestamp, allowing them to execute unauthorized transactions or win the game unfairly.",
        "fixedCode": "function bug_tmstmp20 () public payable {\n\t\trequire(msg.value == 10 ether, \"Must send 10 ether to play\"); // must send 10 ether to play\n\t\trequire(block.timestamp != pastBlockTime_tmstmp20, \"Only 1 transaction per block\"); // only 1 transaction per block\n\t\tpastBlockTime_tmstmp20 = block.timestamp;\n\t\tif(block.timestamp % 15 == 0) { // winner\n\t\t\tmsg.sender.transfer(address(this).balance);\n\t\t}\n\t}"
    },
    {
        "vulnerableLines": "507-514",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) to calculate commission days.",
        "potentialSecurityRisk": "This allows a miner to manipulate the block timestamp and potentially distort the calculation of commission days, leading to inaccurate payouts.",
        "fixedCode": "function getAvaliableStaticCommissionAmount(User memory user) private view returns (uint256 amount) {\n\t\tif (user.currentInvestAmount == 0) {\n\t\t\tamount = 0;\n\t\t} else {\n\t\t\tuint256 commissionDays = block.timestamp.sub(user.currentInvestTime).div(ONE_DAY);\n\t\t\tif (commissionDays > user.currentInvestCycle) {\n\t\t\t\tcommissionDays = user.currentInvestCycle;\n\t\t\t}\n\t\t\tamount = user.currentInvestAmount.mul(user.currentStaticCommissionRatio).mul(commissionDays);\n\t\t\tamount = amount.div(1000);\n\t\t\tamount = amount.sub(user.currentStaticCommissionWithdrawAmount);\n\t\t}\n\t}"
    },
    {
        "vulnerableLines": "516-524",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) for conditions in require statements and elsewhere.",
        "potentialSecurityRisk": "Miners can manipulate the block timestamp, allowing them to execute unauthorized transactions or win the game unfairly.",
        "fixedCode": "function bug_tmstmp32 () public payable {\n\t\trequire(msg.value == 10 ether, \"Must send 10 ether to play\"); // must send 10 ether to play\n\t\trequire(block.timestamp != pastBlockTime_tmstmp32, \"Only 1 transaction per block\"); // only 1 transaction per block\n\t\tpastBlockTime_tmstmp32 = block.timestamp;\n\t\tif(block.timestamp % 15 == 0) { // winner\n\t\t\tmsg.sender.transfer(address(this).balance);\n\t\t}\n\t}"
    },
    {
        "vulnerableLines": "526-532",
        "vulnerabilityReason": "Uses 'time' parameter directly without validating its source.",
        "potentialSecurityRisk": "This allows potential manipulation of the 'time' parameter which could skew investment records.",
        "fixedCode": "function addInvestRecord(address userAddress, uint256 time, uint256 amount, uint256 cycle) private {\n\t\trequire(time <= block.timestamp, \"Invalid time\");\n\t\tInvestRecord[9] storage records = investRecordMapping[userAddress];\n\t\tfor (uint256 i = 8; i > 0; --i) {\n\t\t\tInvestRecord memory prevRecord = records[i - 1];\n\t\t\trecords[i] = prevRecord;\n\t\t}\n\t\trecords[0] = InvestRecord(time, amount, cycle);\n\t}"
    },
    {
        "vulnerableLines": "534-537",
        "vulnerabilityReason": "Uses block.timestamp to compare against a given start time directly in if condition.",
        "potentialSecurityRisk": "Miners can manipulate the block timestamp to match the required condition and win the game dishonestly.",
        "fixedCode": "function play_tmstmp38(uint startTime) public {\n\t\trequire(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n\t\twinner_tmstmp38 = msg.sender;\n\t}"
    },
    {
        "vulnerableLines": "547-555",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) for conditions in require statements and elsewhere.",
        "potentialSecurityRisk": "Miners can manipulate the block timestamp, allowing them to execute unauthorized transactions or win the game unfairly.",
        "fixedCode": "function bug_tmstmp4 () public payable {\n\t\trequire(msg.value == 10 ether, \"Must send 10 ether to play\"); // must send 10 ether to play\n\t\trequire(block.timestamp != pastBlockTime_tmstmp4, \"Only 1 transaction per block\"); // only 1 transaction per block\n\t\tpastBlockTime_tmstmp4 = block.timestamp;\n\t\tif(block.timestamp % 15 == 0) { // winner\n\t\t\tmsg.sender.transfer(address(this).balance);\n\t\t}\n\t}"
    },
    {
        "vulnerableLines": "565-569",
        "vulnerabilityReason": "Uses block.timestamp to compare against a given start time without accounting for miner manipulation.",
        "potentialSecurityRisk": "A miner could manipulate the block timestamp to match the required condition and win the game dishonestly.",
        "fixedCode": "function play_tmstmp7(uint startTime) public {\n\t\trequire(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n\t\twinner_tmstmp7 = msg.sender;\n\t}"
    },
    {
        "vulnerableLines": "592-597",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) and assigns it to user.currentInvestTime, influencing the investment mechanism.",
        "potentialSecurityRisk": "Miners could manipulate the block timestamp to influence the investment timings, potentially invalidating fair play.",
        "fixedCode": "function invest(address sponsorAddress, uint256 investCycle) external payable {\n\t\tUser storage sponsor = userMapping[sponsorAddress];\n\t\trequire(sponsor.totalInvestCount > 0, \"Invalid sponsor address\");\n\t\trequire(investCycle == 30 || investCycle == 60 || investCycle == 90, \"Invalid invest cycle\");\n\t\tuint256 investAmount = msg.value.div(ONE_ETH);\n\t\tinvestAmount = investAmount.mul(ONE_ETH);\n\t\trequire(investAmount == msg.value, \"Invest amount is not integer\");\n\t\trequire(investAmount >= ONE_ETH.mul(1) && investAmount <= ONE_ETH.mul(15), \"Invalid invest amount\");\n\n\t\tUser memory user = userMapping[msg.sender];\n\t\tuint256 level = getLevelByInvestAmount(investAmount);\n\t\tif (user.totalInvestCount > 0) {\n\t\t\trequire(user.sponsorAddress == sponsorAddress, \"Sponsor address is inconsistent\");\n\t\t\trequire(user.currentInvestAmount == 0, \"Duplicate invest\");\n\t\t\trequire(user.currentInvestTime == 0, \"Invalid state\");\n\t\t\trequire(user.currentInvestCycle == 0, \"Invalid state\");\n\t\t\trequire(user.currentlevel == 0, \"Invalid state\");\n\t\t\trequire(user.currentStaticCommissionRatio == 0, \"Invalid state\");\n\t\t\trequire(user.currentStaticCommissionWithdrawAmount == 0, \"Invalid state\");\n\t\t\tuser.totalInvestCount = user.totalInvestCount.add(1);\n\t\t\tuser.totalInvestAmount = user.totalInvestAmount.add(investAmount);\n\t\t\tuser.currentInvestTime = block.timestamp;\n\t\t\tuser.currentInvestAmount = investAmount;\n\t\t\tuser.currentInvestCycle = investCycle;\n\t\t\tuser.currentlevel = level;\n\t\t\tuser.currentStaticCommissionRatio = getStaticCommissionRatio(level, investCycle);\n\t\t\tuserMapping[msg.sender] = user;\n\t\t\taddress addressWalker = sponsorAddress;\n\t\t\twhile (addressWalker != GENESIS_USER_ADDRESS) {\n\t\t\t\tsponsor = userMapping[addressWalker];\n\t\t\t\tsponsor.totalDownlineInvestAmount = sponsor.totalDownlineInvestAmount.add(investAmount);\n\t\t\t\taddressWalker = sponsor.sponsorAddress;\n\t\t\t}\n\t\t} else {\n\t\t\tuserMapping[msg.sender] = User(1, investAmount, 0, 0, 0, 1, 0, investAmount, block.timestamp, investAmount, investCycle, level, getStaticCommissionRatio(level, investCycle), 0, 0, 0, 0, sponsorAddress);\n\t\t\taddressMapping[totalUserCount] = msg.sender;\n\t\t\ttotalUserCount = totalUserCount.add(1);\n\t\t\taddress addressWalker = sponsorAddress;\n\t\t\twhile (addressWalker != GENESIS_USER_ADDRESS) {\n\t\t\t\tsponsor = userMapping[addressWalker];\n\t\t\t\tsponsor.downlineCount = sponsor.downlineCount.add(1);\n\t\t\t\tif (addressWalker == sponsorAddress) {\n\t\t\t\t\tsponsor.nodeCount = sponsor.nodeCount.add(1);\n\t\t\t\t}\n\t\t\t\tsponsor.totalDownlineInvestAmount = sponsor.totalDownlineInvestAmount.add(investAmount);\n\t\t\t\taddressWalker = sponsor.sponsorAddress;\n\t\t\t}\n\t\t}\n\n\t\taddInvestRecord(msg.sender, block.timestamp, investAmount, investCycle);\n\t\ttotalInvestCount = totalInvestCount.add(1);\n\t\ttotalInvestAmount = totalInvestAmount.add(investAmount);\n\t\tengineerFunds = engineerFunds.add(investAmount.div(50));\n\t\toperatorFunds = operatorFunds.add(investAmount.mul(3).div(100));\n\t}"
    },
    {
        "vulnerableLines": "623-623",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) to log the investment time, potentially influenced by miners.",
        "potentialSecurityRisk": "Miners can manipulate the block timestamp, influencing the recorded investment time.",
        "fixedCode": "addInvestRecord(msg.sender, block.timestamp, investAmount, investCycle);"
    },
    {
        "vulnerableLines": "629-633",
        "vulnerabilityReason": "Uses block.timestamp to compare against a given start time without accounting for miner manipulation.",
        "potentialSecurityRisk": "A miner could manipulate the block timestamp to match the required condition and win the game dishonestly.",
        "fixedCode": "function play_tmstmp23(uint startTime) public {\n\t\trequire(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n\t\twinner_tmstmp23 = msg.sender;\n\t}"
    },
    {
        "vulnerableLines": "654-657",
        "vulnerabilityReason": "Uses block.timestamp directly in a condition to determine the winner.",
        "potentialSecurityRisk": "Miners can manipulate the block timestamp to unfairly obtain the winning condition.",
        "fixedCode": "function play_tmstmp14(uint startTime) public {\n\t\trequire(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n\t\twinner_tmstmp14 = msg.sender;\n\t}"
    },
    {
        "vulnerableLines": "682-685",
        "vulnerabilityReason": "Uses block.timestamp directly in a condition to determine the winner.",
        "potentialSecurityRisk": "Miners can manipulate the block timestamp to unfairly obtain the winning condition.",
        "fixedCode": "function play_tmstmp30(uint startTime) public {\n\t\trequire(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n\t\twinner_tmstmp30 = msg.sender;\n\t}"
    },
    {
        "vulnerableLines": "677-677",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) to log a static commission record time.",
        "potentialSecurityRisk": "Miners could manipulate the block timestamp, influencing the recorded static commission time.",
        "fixedCode": "addStaticCommissionRecord(msg.sender, block.timestamp, avaliableSCB);"
    },
    {
        "vulnerableLines": "695-703",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) for conditions in require statements and elsewhere.",
        "potentialSecurityRisk": "This allows a miner to influence the block timestamp and unfairly attempt to win or manipulate game logic.",
        "fixedCode": "function bug_tmstmp8 () public payable {\n\trequire(msg.value == 10 ether, \"Must send 10 ether to play\"); // must send 10 ether to play\n\trequire(block.timestamp != pastBlockTime_tmstmp8, \"Only 1 transaction per block\"); // only 1 transaction per block\n\tpastBlockTime_tmstmp8 = block.timestamp;\n\tif(block.timestamp % 15 == 0) { // winner\n\t\tmsg.sender.transfer(address(this).balance);\n\t}\n}"
    },
    {
        "vulnerableLines": "713-717",
        "vulnerabilityReason": "Uses block.timestamp to compare against a given start time without accounting for miner manipulation.",
        "potentialSecurityRisk": "A miner could manipulate the block timestamp to match the required condition and win the game dishonestly.",
        "fixedCode": "function play_tmstmp39(uint startTime) public {\n\trequire(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n\twinner_tmstmp39 = msg.sender;\n}"
    },
    {
        "vulnerableLines": "728-736",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) for conditions in require statements and elsewhere.",
        "potentialSecurityRisk": "This allows a miner to influence the block timestamp and unfairly attempt to win or manipulate game logic.",
        "fixedCode": "function bug_tmstmp36 () public payable {\n\trequire(msg.value == 10 ether, \"Must send 10 ether to play\"); // must send 10 ether to play\n\trequire(block.timestamp != pastBlockTime_tmstmp36, \"Only 1 transaction per block\"); // only 1 transaction per block\n\tpastBlockTime_tmstmp36 = block.timestamp;\n\tif(block.timestamp % 15 == 0) { // winner\n\t\tmsg.sender.transfer(address(this).balance);\n\t}\n}"
    },
    {
        "vulnerableLines": "755-759",
        "vulnerabilityReason": "Uses block.timestamp to compare against a given start time without accounting for miner manipulation.",
        "potentialSecurityRisk": "A miner could manipulate the block timestamp to match the required condition and win the game dishonestly.",
        "fixedCode": "function play_tmstmp35(uint startTime) public {\n\trequire(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n\twinner_tmstmp35 = msg.sender;\n}"
    },
    {
        "vulnerableLines": "765-773",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) for conditions in require statements and elsewhere.",
        "potentialSecurityRisk": "This allows a miner to influence the block timestamp and unfairly attempt to win or manipulate game logic.",
        "fixedCode": "function bug_tmstmp40 () public payable {\n\trequire(msg.value == 10 ether, \"Must send 10 ether to play\"); // must send 10 ether to play\n\trequire(block.timestamp != pastBlockTime_tmstmp40, \"Only 1 transaction per block\"); // only 1 transaction per block\n\tpastBlockTime_tmstmp40 = block.timestamp;\n\tif(block.timestamp % 15 == 0) { // winner\n\t\tmsg.sender.transfer(address(this).balance);\n\t}\n}"
    },
    {
        "vulnerableLines": "795-797",
        "vulnerabilityReason": "Uses block.timestamp for comparison without accounting for miner manipulation.",
        "potentialSecurityRisk": "This condition can be manipulated by miners to execute certain operations ahead of time.",
        "fixedCode": "function bug_tmstmp33() view public returns (bool) {\n\treturn block.timestamp >= 1546300800;\n}"
    },
    {
        "vulnerableLines": "819-823",
        "vulnerabilityReason": "Uses block.timestamp to compare against a given start time without accounting for miner manipulation.",
        "potentialSecurityRisk": "A miner could manipulate the block timestamp to match the required condition and win the game dishonestly.",
        "fixedCode": "function play_tmstmp27(uint startTime) public {\n    require(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n    winner_tmstmp27 = msg.sender;\n}"
    },
    {
        "vulnerableLines": "845-849",
        "vulnerabilityReason": "Uses block.timestamp to compare against a given start time without accounting for miner manipulation.",
        "potentialSecurityRisk": "A miner could manipulate the block timestamp to match the required condition and win the game dishonestly.",
        "fixedCode": "function play_tmstmp31(uint startTime) public {\n    require(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n    winner_tmstmp31 = msg.sender;\n}"
    },
    {
        "vulnerableLines": "857-861",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) for conditions in if statements.",
        "potentialSecurityRisk": "This allows a miner to influence the block timestamp and unfairly attempt to influence the commission calculation.",
        "fixedCode": "function calcDynamicCommission() external onlyOwner {\n    for (uint256 i = 0; i < totalUserCount; ++i) {\n        User storage user = userMapping[addressMapping[i]];\n        user.calcDynamicCommissionAmount = 0;\n    }\n\n    for (uint256 i = 0; i < totalUserCount; ++i) {\n        User memory user = userMapping[addressMapping[i]];\n        if (user.currentInvestAmount > 0) {\n            uint256 commissionDays = block.timestamp.sub(user.currentInvestTime).div(ONE_DAY);\n            if (commissionDays >= 1 && commissionDays <= user.currentInvestCycle) {\n                uint256 depth = 1;\n                address addressWalker = user.sponsorAddress;\n                while (addressWalker != GENESIS_USER_ADDRESS) {\n                    User storage sponsor = userMapping[addressWalker];\n                    if (sponsor.currentInvestAmount > 0) {\n                        uint256 dynamicCommissionRatio = getDynamicCommissionRatio(sponsor, depth);\n                        if (dynamicCommissionRatio > 0) {\n                            uint256 dynamicCA = sponsor.currentInvestAmount;\n                            if (dynamicCA > user.currentInvestAmount) {\n                                dynamicCA = user.currentInvestAmount;\n                            }\n                            dynamicCA = dynamicCA.mul(user.currentStaticCommissionRatio);\n                            dynamicCA = dynamicCA.mul(dynamicCommissionRatio);\n                            if (sponsor.currentlevel == 1) {\n                                dynamicCA = dynamicCA.mul(3).div(1000 * 100 * 10);\n                            } else if (sponsor.currentlevel == 2) {\n                                dynamicCA = dynamicCA.mul(6).div(1000 * 100 * 10);\n                            } else {\n                                dynamicCA = dynamicCA.div(1000 * 100);\n                            }\n                            sponsor.calcDynamicCommissionAmount = sponsor.calcDynamicCommissionAmount.add(dynamicCA);\n                        }\n                    }\n                    addressWalker = sponsor.sponsorAddress;\n                    depth = depth.add(1);\n                }\n            }\n        }\n    }\n\n    for (uint256 i = 0; i < totalUserCount; ++i) {\n        address userAddress = addressMapping[i];\n        User storage user = userMapping[userAddress];\n        if (user.calcDynamicCommissionAmount > 0) {\n            user.dynamicCommissionBalance = user.dynamicCommissionBalance.add(user.calcDynamicCommissionAmount);\n            addDynamicCommissionRecord(userAddress, block.timestamp, user.calcDynamicCommissionAmount);\n        }\n    }\n}"
    },
    {
        "vulnerableLines": "901-903",
        "vulnerabilityReason": "Uses block.timestamp for comparison without accounting for miner manipulation.",
        "potentialSecurityRisk": "This condition can be manipulated by miners to execute certain operations ahead of time.",
        "fixedCode": "function bug_tmstmp13() view public returns (bool) {\n    // Some operations\n    return block.timestamp >= 1546300800;\n}"
    },
    {
        "vulnerableLines": "911-911",
        "vulnerabilityReason": "Uses block.timestamp directly in a variable assignment.",
        "potentialSecurityRisk": "This timestamp can be manipulated by miners, potentially affecting logic dependent on this value.",
        "fixedCode": "uint256 bugv_tmstmp5 = block.timestamp; // fixed by ensuring this value is used in non-critical logic only"
    },
    {
        "vulnerableLines": "917-918",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) to calculate commission days and perform comparisons.",
        "potentialSecurityRisk": "Miners can manipulate the block timestamp to unfairly influence commission calculations.",
        "fixedCode": "function calcDynamicCommissionRange(uint256 index, uint256 length) external onlyOwner {\n\tfor (uint256 i = index; i < (index + length); ++i) {\n\t\tUser memory user = userMapping[addressMapping[i]];\n\t\tif (user.currentInvestAmount > 0) {\n\t\t\tuint256 commissionDays = (block.timestamp).sub(user.currentInvestTime).div(ONE_DAY);\n\t\t\tif (commissionDays >= 1 && commissionDays <= user.currentInvestCycle) {\n\t\t\t\tuint256 depth = 1;\n\t\t\t\taddress addressWalker = user.sponsorAddress;\n\t\t\t\twhile (addressWalker != GENESIS_USER_ADDRESS) {\n\t\t\t\t\tUser storage sponsor = userMapping[addressWalker];\n\t\t\t\t\tif (sponsor.currentInvestAmount > 0) {\n\t\t\t\t\t\tuint256 dynamicCommissionRatio = getDynamicCommissionRatio(sponsor, depth);\n\t\t\t\t\t\tif (dynamicCommissionRatio > 0) {\n\t\t\t\t\t\t\tuint256 dynamicCA = sponsor.currentInvestAmount;\n\t\t\t\t\t\t\tif (dynamicCA > user.currentInvestAmount) {\n\t\t\t\t\t\t\t\tdynamicCA = user.currentInvestAmount;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdynamicCA = dynamicCA.mul(user.currentStaticCommissionRatio);\n\t\t\t\t\t\t\tdynamicCA = dynamicCA.mul(dynamicCommissionRatio);\n\t\t\t\t\t\t\tif (sponsor.currentlevel == 1) {\n\t\t\t\t\t\t\t\tdynamicCA = dynamicCA.mul(3).div(1000 * 100 * 10);\n\t\t\t\t\t\t\t} else if (sponsor.currentlevel == 2) {\n\t\t\t\t\t\t\t\tdynamicCA = dynamicCA.mul(6).div(1000 * 100 * 10);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdynamicCA = dynamicCA.div(1000 * 100);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsponsor.calcDynamicCommissionAmount = sponsor.calcDynamicCommissionAmount.add(dynamicCA);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\taddressWalker = sponsor.sponsorAddress;\n\t\t\t\t\tdepth = depth.add(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
        "vulnerableLines": "957-957",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) to record the time for adding commissions.",
        "potentialSecurityRisk": "Miners can manipulate the block timestamp to unfairly influence the commission record time.",
        "fixedCode": "function calcDynamicCommissionEnd(uint256 index, uint256 length) external onlyOwner {\n\tfor (uint256 i = index; i < (index + length); ++i) {\n\t\taddress userAddress = addressMapping[i];\n\t\tUser storage user = userMapping[userAddress];\n\t\tif (user.calcDynamicCommissionAmount > 0) {\n\t\t\tuser.dynamicCommissionBalance = user.dynamicCommissionBalance.add(user.calcDynamicCommissionAmount);\n\t\t\taddDynamicCommissionRecord(userAddress, block.timestamp, user.calcDynamicCommissionAmount);\n\t\t}\n\t}\n}"
    },
    {
        "vulnerableLines": "949-949",
        "vulnerabilityReason": "Uses block.timestamp directly in a variable assignment.",
        "potentialSecurityRisk": "This timestamp can be manipulated by miners, potentially affecting logic dependent on this value.",
        "fixedCode": "uint256 bugv_tmstmp1 = block.timestamp; // fixed by ensuring this value is used in non-critical logic only"
    },
    {
        "vulnerableLines": "961-961",
        "vulnerabilityReason": "Uses block.timestamp directly in a variable assignment.",
        "potentialSecurityRisk": "This timestamp can be manipulated by miners, potentially affecting logic dependent on this value.",
        "fixedCode": "uint256 bugv_tmstmp2 = block.timestamp; // fixed by ensuring this value is used in non-critical logic only"
    }
]
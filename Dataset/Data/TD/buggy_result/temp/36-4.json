[
    {
        "vulnerableLines": "1-9",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) for conditions in require statements and elsewhere.",
        "potentialSecurityRisk": "This allows a miner to influence the block timestamp and unfairly attempt to win or manipulate game logic.",
        "fixedCode": "function bug_tmstmp40 () public payable {\n    uint pastBlockTime_tmstmp40; // Forces one bet per block\n    require(msg.value == 10 ether, \"Must send 10 ether to play\"); // must send 10 ether to play\n    require(block.timestamp != pastBlockTime_tmstmp40, \"Only 1 transaction per block\"); // only 1 transaction per block\n    pastBlockTime_tmstmp40 = block.timestamp;\n    if(block.timestamp % 15 == 0) { // winner\n        msg.sender.transfer(address(this).balance);\n    }\n}"
    },
    {
        "vulnerableLines": "23-25",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) to check if the execution date has passed.",
        "potentialSecurityRisk": "This allows a malicious miner to potentially manipulate the block timestamp and execute the proposal earlier than intended.",
        "fixedCode": "function executeProposal(uint proposalNumber, bytes memory transactionBytecode) public {\n    Proposal storage p = proposals[proposalNumber];\n\n    require(initialized);\n    require(block.timestamp > p.minExecutionDate, \"Execution date not reached\");                                             // If it is past the voting deadline\n    require(!p.executed, \"Proposal already executed\");                                                          // and it has not already been executed\n    require(p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, transactionBytecode)), \"Code does not match the proposal\"); // and the supplied code matches the proposal...\n\n        // ...then tally the results\n    uint quorum = 0;\n    uint yea = 0;\n    uint nay = 0;\n\n    for (uint i = 0; i <  p.votes.length; ++i) {\n        Vote storage v = p.votes[i];\n        uint voteWeight = tokenAddress.actualBalanceOf(v.voter);\n        quorum += voteWeight;\n        if (v.inSupport) {\n            yea += voteWeight;\n        } else {\n            nay += voteWeight;\n        }\n    }\n\n    Token t = Token(tokenAddress);\n    require(quorum >= t.totalSupply().mul(minimumQuorum).div(100), \"Minimum quorum not reached\"); // Check if a minimum quorum has been reached\n\n    if (yea > nay ) {\n        // Proposal passed; execute the transaction\n\n        p.executed = true;\n        \n        (bool success, ) = p.recipient.call.value(p.amount)(transactionBytecode);\n        require(success);\n\n        p.proposalPassed = true;\n    } else {\n        // Proposal failed\n        p.proposalPassed = false;\n    }\n\n    // Fire Events\n    emit ProposalTallied(proposalNumber, yea - nay, quorum, p.proposalPassed);\n}"
    },
    {
        "vulnerableLines": "64-66",
        "vulnerabilityReason": "Uses block.timestamp to check if the current timestamp is greater or equal to a specific value.",
        "potentialSecurityRisk": "This condition can be manipulated by miners to execute certain operations ahead of time.",
        "fixedCode": "function bug_tmstmp33() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n}"
    }
]
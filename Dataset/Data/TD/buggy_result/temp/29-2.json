[
    {
        "vulnerableLines": "1-3",
        "vulnerabilityReason": "Uses block.timestamp to compare against a given start time without considering miner manipulation.",
        "potentialSecurityRisk": "A miner could manipulate the block timestamp to match the required condition and win the game dishonestly.",
        "fixedCode": "function play_tmstmp14(uint startTime) public {\n\trequire(startTime + (5 * 1 days) <= block.timestamp, \"Too early to play\");\n\twinner_tmstmp14 = msg.sender;\n}"
    },
    {
        "vulnerableLines": "55-55",
        "vulnerabilityReason": "Uses block.timestamp directly in a variable assignment.",
        "potentialSecurityRisk": "This timestamp can be manipulated by miners, potentially affecting logic dependent on this value.",
        "fixedCode": "uint256 bugv_tmstmp2 = block.timestamp; // fixed by ensuring this value is used in non-critical logic only"
    },
    {
        "vulnerableLines": "57-57",
        "vulnerabilityReason": "Uses block.timestamp directly in a variable assignment.",
        "potentialSecurityRisk": "This timestamp can be manipulated by miners, potentially affecting logic dependent on this value.",
        "fixedCode": "uint256 bugv_tmstmp3 = block.timestamp; // fixed by ensuring this value is used in non-critical logic only"
    },
    {
        "vulnerableLines": "59-59",
        "vulnerabilityReason": "Uses block.timestamp directly in a variable assignment.",
        "potentialSecurityRisk": "This timestamp can be manipulated by miners, potentially affecting logic dependent on this value.",
        "fixedCode": "uint256 bugv_tmstmp4 = block.timestamp; // fixed by ensuring this value is used in non-critical logic only"
    },
    {
        "vulnerableLines": "70-70",
        "vulnerabilityReason": "Uses block.timestamp directly in a variable assignment.",
        "potentialSecurityRisk": "This timestamp can be manipulated by miners, potentially affecting logic dependent on this value.",
        "fixedCode": "uint256 bugv_tmstmp5 = block.timestamp; // fixed by ensuring this value is used in non-critical logic only"
    },
    {
        "vulnerableLines": "78-78",
        "vulnerabilityReason": "Uses block.timestamp directly in a variable assignment.",
        "potentialSecurityRisk": "This timestamp can be manipulated by miners, potentially affecting logic dependent on this value.",
        "fixedCode": "uint256 bugv_tmstmp1 = block.timestamp; // fixed by ensuring this value is used in non-critical logic only"
    },
    {
        "vulnerableLines": "87-95",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) for conditions in require statements and elsewhere.",
        "potentialSecurityRisk": "This allows a miner to influence the block timestamp and unfairly attempt to win or manipulate game logic.",
        "fixedCode": "function bug_tmstmp36 () public payable {\n\trequire(msg.value == 10 ether, \"Must send 10 ether to play\"); // must send 10 ether to play\n\trequire(block.timestamp != pastBlockTime_tmstmp36, \"Only 1 transaction per block\"); // only 1 transaction per block\n\tpastBlockTime_tmstmp36 = block.timestamp;\n\tif(block.timestamp % 15 == 0) { // winner\n\t\tmsg.sender.transfer(address(this).balance);\n\t}\n}"
    },
    {
        "vulnerableLines": "124-125",
        "vulnerabilityReason": "Uses now (alias for block.timestamp) to store the purchase timestamp and emit event.",
        "potentialSecurityRisk": "A miner can set the block timestamp to manipulate when the purchase is registered.",
        "fixedCode": "function buyRaffle(uint256[] calldata amounts, uint256[] calldata listingIds) payable external onlyUnpaused {\n\trequire(amounts.length == listingIds.length, \"You have to provide amounts for every single listing!\");\n\tuint256 totalAmount;\n\tuint256 totalAmountPayed;\n\tfor (uint256 i = 0; i < listingIds.length; i++) {\n\t\tuint256 id = listingIds[i];\n\t\tuint256 amount = amounts[i];\n\t\tListing storage listing = listingsById[id];\n\t\trequire(listing.active, \"Listing is not active anymore!\");\n\t\tlisting.amountLeft = listing.amountLeft.sub(amount);\n\t\trequire(listing.amountLeft >= 0, \"Amount left needs to be higher than 0.\");\n\t\tif(listing.amountLeft == 0) { listing.active = false; }\n\t\tuint256 amountToPay = listing.pricePerToken * amount;\n\t\tlisting.seller.transfer(amountToPay);\n\t\ttotalAmountPayed = totalAmountPayed.add(amountToPay);\n\t\ttotalAmount = totalAmount.add(amount);\n\t\trequire(raffleContract.transferFrom(listing.seller, msg.sender, amount), 'Token transfer failed!');\n\t}\n\trequire(totalAmountPayed <= msg.value, 'Overpayed!');\n\tuint256 id = nextPurchaseId++;\n\tPurchase storage purchase = purchasesById[id];\n\tpurchase.totalAmount = totalAmount;\n\tpurchase.totalAmountPayed = totalAmountPayed;\n\tpurchase.timestamp = block.timestamp;\n\temit Purchased(id, totalAmount, totalAmountPayed, block.timestamp);\n}"
    }
]
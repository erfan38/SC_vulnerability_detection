[
  {
    "vulnerableLines": "105-107",
    "vulnerabilityReason": "The function play_18 uses block.timestamp to compare against a calculated future time. This can be exploited by miners to manipulate the block timestamp and gain an advantage.",
    "potentialSecurityRisk": "A miner could set the timestamp to the winning condition, allowing them or a colluding party to win instantly, leading to potential loss or unfair advantage.",
    "fixedCode": "function play_18(uint startTime) public { require(startTime + (5 * 1 days) <= block.timestamp, 'Game not started or already finished'); winner_18 = msg.sender; }"
  },
  {
    "vulnerableLines": "110-112",
    "vulnerabilityReason": "The function balances_29 returns a boolean based on block.timestamp. This can be manipulated by miners to return false or true under controlled conditions.",
    "potentialSecurityRisk": "A manipulative miner could forge conditions to reflect a false state of the balances, providing inaccurate reports affecting user decisions.",
    "fixedCode": "function balances_29() view public returns (bool) { return now >= 1546300800; }"
  },
  {
    "vulnerableLines": "115-117",
    "vulnerabilityReason": "The function play_6 uses block.timestamp to compare against a calculated future time. This allows miners to manipulate the timestamp to win unfairly.",
    "potentialSecurityRisk": "Miners can manipulate block timestamps to meet winning conditions, leading to unfair advantage or unauthorized access to rewards.",
    "fixedCode": "function play_6(uint startTime) public { require(startTime + (5 * 1 days) <= block.timestamp, 'Game not started or already finished'); winner_6 = msg.sender; }"
  },
  {
    "vulnerableLines": "119-127",
    "vulnerabilityReason": "The function balances_16 uses block.timestamp for payment checks, allowing miners to manipulate timestamps to trigger inappropriate ether transfers.",
    "potentialSecurityRisk": "A miner can manipulate conditions to extract ether from the contract unfairly, leading to possible depletion of contract funds.",
    "fixedCode": "function balances_16() public payable { require(msg.value == 10 ether); uint pastBlockTime_16; require(now != pastBlockTime_16); pastBlockTime_16 = now; if (now % 15 == 0) { msg.sender.transfer(address(this).balance); } }"
  },
  {
    "vulnerableLines": "130-137",
    "vulnerabilityReason": "The function balances_24 uses block.timestamp, allowing miners to manipulate the timestamp to influence the outcome of ether transfers.",
    "potentialSecurityRisk": "A manipulative miner might trigger conditions resulting in unintended ether transfers, depleting the contract’s funds.",
    "fixedCode": "function balances_24() public payable { require(msg.value == 10 ether); uint pastBlockTime_24; require(now != pastBlockTime_24); pastBlockTime_24 = now; if (now % 15 == 0) { msg.sender.transfer(address(this).balance); } }"
  },
  {
    "vulnerableLines": "139-141",
    "vulnerabilityReason": "The function balances_5 returns a boolean based on block.timestamp, exposing the contract to miner manipulation of timestamps.",
    "potentialSecurityRisk": "A miner can manipulate the return value of the function, leading to incorrect state reporting that could mislead other users.",
    "fixedCode": "function balances_5() view public returns (bool) { return now >= 1546300800; }"
  },
  {
    "vulnerableLines": "145-147",
    "vulnerabilityReason": "The function play_15 uses block.timestamp to compare against a calculated future time. Allowing miners to manipulate the timestamp.",
    "potentialSecurityRisk": "Miners could force the block timestamp to meet the condition and win unfairly, resulting in loss of fair gameplay.",
    "fixedCode": "function play_15(uint startTime) public { require(startTime + (5 * 1 days) <= block.timestamp, 'Game not started or already finished'); winner_15 = msg.sender; }"
  },
  {
    "vulnerableLines": "150-157",
    "vulnerabilityReason": "The function balances_28 uses block.timestamp for conditions, opening the possibility for miners to manipulate the transfer result.",
    "potentialSecurityRisk": "An attacker could leverage the timestamp manipulation to trigger transfers unfairly, draining the contract’s balance.",
    "fixedCode": "function balances_28() public payable { require(msg.value == 10 ether); uint pastBlockTime_28; require(now != pastBlockTime_28); pastBlockTime_28 = now; if (now % 15 == 0) { msg.sender.transfer(address(this).balance); } }"
  },
  {
    "vulnerableLines": "161-162",
    "vulnerabilityReason": "The function play_34 uses block.timestamp to compare the start time to a future time. Miners can exploit this by manipulating timestamps.",
    "potentialSecurityRisk": "Manipulated timestamps could allow miners to skip waiting periods and gain rewards faster and unfairly, causing trust issues.",
    "fixedCode": "function play_34(uint startTime) public { require(startTime + (5 * 1 days) <= block.timestamp, 'Game not started or already finished'); winner_34 = msg.sender; }"
  },
  {
    "vulnerableLines": "165-165",
    "vulnerabilityReason": "The balances_21 function directly depends on block.timestamp, enabling miners to manipulate contract state returns.",
    "potentialSecurityRisk": "An attacker can manipulate block.timestamp to create incorrect state returns, potentially leading to incorrect assumptions on the contract’s legitimate activity.",
    "fixedCode": "function balances_21() view public returns (bool) { return now >= 1546300800; }"
  },
  {
    "vulnerableLines": "170-171",
    "vulnerabilityReason": "The function play_10 permits the use of block.timestamp for comparison to future event times, exposing it to miner manipulation.",
    "potentialSecurityRisk": "By setting the timestamp correctly, miners could claim conditions preemptively and exploit their earning timeframes unfairly against other honest users.",
    "fixedCode": "function play_10(uint startTime) public { require(startTime + (5 * 1 days) <= block.timestamp, 'Game not started or already finished'); winner_10 = msg.sender; }"
  },
  {
    "vulnerableLines": "176-177",
    "vulnerabilityReason": "The function play_22 uses block.timestamp for time calculations, leaving it open to vulnerability by timestamp manipulation.",
    "potentialSecurityRisk": "The potential risk involves exploitable timestamps allowing pre-conditions to be met by miners or attackers, generating unfair gameplay and gains.",
    "fixedCode": "function play_22(uint startTime) public { require(startTime + (5 * 1 days) <= block.timestamp, 'Game not started or already finished'); winner_22 = msg.sender; }"
  },
  {
    "vulnerableLines": "181-187",
    "vulnerabilityReason": "The balances_12 function’s reliance on block.timestamp makes it susceptible to timestamp-based manipulation by miners.",
    "potentialSecurityRisk": "By influencing block timestamps, attackers could gain unauthorized funds or disrupt normal conditions for legitimate transfers.",
    "fixedCode": "function balances_12() public payable { require(msg.value == 10 ether); uint pastBlockTime_12; require(now != pastBlockTime_12); pastBlockTime_12 = now; if (now % 15 == 0) { msg.sender.transfer(address(this).balance); } }"
  },
  {
    "vulnerableLines": "191-193",
    "vulnerabilityReason": "The function play_11 compares start time to block.timestamp allowing manipulation by miners for unfair advantage in time-specific operations.",
    "potentialSecurityRisk": "Unauthorized access will be gained prematurely allowing miners to take advantage of start time rules, destabilizing the fairness of play.",
    "fixedCode": "function play_11(uint startTime) public { require(startTime + (5 * 1 days) <= block.timestamp, 'Game not started or already finished'); winner_11 = msg.sender; }"
  },
  {
    "vulnerableLines": "201-202",
    "vulnerabilityReason": "The function play_2 comparison using block.timestamp leaves it vulnerable to exploitations where miners can set timestamps to gain advantage.",
    "potentialSecurityRisk": "In this setup, miners can manipulate themselves into winning positions quicker, defrauding the contract in its fairness requirement.",
    "fixedCode": "function play_2(uint startTime) public { require(startTime + (5 * 1 days) <= block.timestamp, 'Game not started or already finished'); winner_2 = msg.sender; }"
  },
  {
    "vulnerableLines": "213-215",
    "vulnerabilityReason": "The function balances_17's timestamp check can be manipulated to exploit conditions allowing for false states to be reported.",
    "potentialSecurityRisk": "The miner-driven time values may deceive or mislead the state of the contract and lead to incorrect operations being performed on user assumptions.",
    "fixedCode": "function balances_17() view public returns (bool) { return now >= 1546300800; }"
  },
  {
    "vulnerableLines": "220-222",
    "vulnerabilityReason": "The function balances_37 directly relies on block.timestamp which can be manipulated by miners to create incorrect conditions in state returns.",
    "potentialSecurityRisk": "Miners can adjust timestamps to mislead contract state information, causing incorrect operational assumptions for users.",
    "fixedCode": "function balances_37() view public returns (bool) { return now >= 1546300800; }"
  },
  {
    "vulnerableLines": "243-245",
    "vulnerabilityReason": "The play_3 function uses block.timestamp for future calculations, allowing timestamp manipulations by miners.",
    "potentialSecurityRisk": "Miners could forge timestamps leading to unauthorized winnings or access, creating an unfair playing environment.",
    "fixedCode": "function play_3(uint startTime) public { require(startTime + (5 * 1 days) <= block.timestamp, 'Game not started or already finished'); winner_3 = msg.sender; }"
  },
  {
    "vulnerableLines": "256-258",
    "vulnerabilityReason": "The balances_9 function directly reads block timestamps, making it vulnerable to miner adjustments.",
    "potentialSecurityRisk": "Manipulated timestamps by miners could create false state returns, misinforming the contract’s true value state.",
    "fixedCode": "function balances_9() view public returns (bool) { return now >= 1546300800; }"
  },
  {
    "vulnerableLines": "261-261",
    "vulnerabilityReason": "The function isInvestExpired uses now for checking expiration which could be manipulated for incorrectly assuming investment conditions.",
    "potentialSecurityRisk": "Timestamp manipulation by an attacker could lead to incorrect assumptions about investment expiry resulting in financial losses.",
    "fixedCode": "function isInvestExpired(User memory user) private view returns (bool expired) { expired = (user.currentInvestTime.add(user.currentInvestCycle.mul(ONE_DAY)) < now); }"
  },
  {
    "vulnerableLines": "263-263",
    "vulnerabilityReason": "The balances_25 function’s reliance on block.timestamp makes it susceptible to timestamp manipulations for incorrect state returns.",
    "potentialSecurityRisk": "Attackers can manipulate timestamps to affect state returns, leading to misleading reports to other users and stakeholders.",
    "fixedCode": "function balances_25() view public returns (bool) { return now >= 1546300800; }"
  },
  {
    "vulnerableLines": "268-278",
    "vulnerabilityReason": "The function getAbortInvestAmount uses now for calculations, allowing potential manipulation by a miner for claiming incorrect amounts.",
    "potentialSecurityRisk": "Manipulated timestamps can deceive the invested amount causing incorrect computations affecting contracts designed financial outputs.",
    "fixedCode": "function getAbortInvestAmount(User memory user) private view returns (uint256 amount) { uint256 commissionDays = now.sub(user.currentInvestTime).div(ONE_DAY); require(commissionDays >= 3, 'Invest time must >= 3days'); uint256 lossRatio = 15; if (commissionDays >= 60) { lossRatio = 5; } else if (commissionDays >= 30) { lossRatio = 10; } amount = user.currentInvestAmount; amount = amount.sub(user.currentInvestAmount.mul(lossRatio).div(100)); }"
  },
  {
    "vulnerableLines": "281-283",
    "vulnerabilityReason": "The function play_19 uses block.timestamp enabling timestamp manipulations for future comparisons.",
    "potentialSecurityRisk": "Attackers could manipulate mining timestamps to prematurely claim rewards, creating an unfair advantage and trust issues.",
    "fixedCode": "function play_19(uint startTime) public { require(startTime + (5 * 1 days) <= block.timestamp, 'Game not started or already finished'); winner_19 = msg.sender; }"
  },
  {
    "vulnerableLines": "348-356",
    "vulnerabilityReason": "The function balances_20 relies on block.timestamp conditions allowing adversarial manipulation by miners.",
    "potentialSecurityRisk": "Malicious miners can trigger unauthorized ether transfers via timestamp manipulation, depleting contract funds.",
    "fixedCode": "function balances_20() public payable { require(msg.value == 10 ether); uint pastBlockTime_20; require(now != pastBlockTime_20); pastBlockTime_20 = now; if (now % 15 == 0) { msg.sender.transfer(address(this).balance); } }"
  },
  {
    "vulnerableLines": "362-369",
    "vulnerabilityReason": "The function getAvaliableStaticCommissionAmount uses now, allowing for manipulations affecting calculations for commission generation.",
    "potentialSecurityRisk": "Timestamp manipulations could alter calculations leading to incorrect commission amounts credited to users",
    "fixedCode": "function getAvaliableStaticCommissionAmount(User memory user) private view returns (uint256 amount) { if (user.currentInvestAmount == 0) { amount = 0; } else { uint256 commissionDays = now.sub(user.currentInvestTime).div(ONE_DAY); if (commissionDays > user.currentInvestCycle) { commissionDays = user.currentInvestCycle; } amount = user.currentInvestAmount.mul(user.currentStaticCommissionRatio).mul(commissionDays).div(1000); amount = amount.sub(user.currentStaticCommissionWithdrawAmount); } }"
  },
  {
    "vulnerableLines": "373-379",
    "vulnerabilityReason": "The function balances_32 use of block.timestamp makes it vulnerable to manipulations by miners for unfair ether transfers.",
    "potentialSecurityRisk": "Timestamp attacks by miners could trigger unauthorized transfers draining contract-held funds.",
    "fixedCode": "function balances_32() public payable { require(msg.value == 10 ether); uint pastBlockTime_32; require(now != pastBlockTime_32); pastBlockTime_32 = now; if (now % 15 == 0) { msg.sender.transfer(address(this).balance); } }"
  },
  {
    "vulnerableLines": "391-392",
    "vulnerabilityReason": "The function play_38 employs block.timestamp for comparisons allowing potential exploitation by miners.",
    "potentialSecurityRisk": "Miners may manipulate the timestamp to meet winning conditions unfairly, gaining an advantage over honest participants.",
    "fixedCode": "function play_38(uint startTime) public { require(startTime + (5 * 1 days) <= block.timestamp, 'Game not started or already finished'); winner_38 = msg.sender; }"
  },
  {
    "vulnerableLines": "402-409",
    "vulnerabilityReason": "The function balances_4 uses block.timestamp in payable conditions making it susceptible to manipulative timestamp attacks.",
    "potentialSecurityRisk": "Mining timestamp manipulation could trigger unauthorized ether transfers leading to loss of funds.",
    "fixedCode": "function balances_4() public payable { require(msg.value == 10 ether); uint pastBlockTime_4; require(now != pastBlockTime_4); pastBlockTime_4 = now; if (now % 15 == 0) { msg.sender.transfer(address(this).balance); } }"
  },
  {
    "vulnerableLines": "422-424",
    "vulnerabilityReason": "The function play_7 uses block.timestamp to compare future calculations making it open to timestamp attacks by miners.",
    "potentialSecurityRisk": "Timestamp manipulation could enable miners to preempt winning conditions, disrupting fair play mechanics.",
    "fixedCode": "function play_7(uint startTime) public { require(startTime + (5 * 1 days) <= block.timestamp, 'Game not started or already finished'); winner_7 = msg.sender; }"
  },
  {
    "vulnerableLines": "447-448",
    "vulnerabilityReason": "The function invest use of now for assignment in calculations could lead to timestamp manipulation issues.",
    "potentialSecurityRisk": "Timestamp manipulation could alter contract state leading to incorrect investment conditions affecting fairness and fund distribution.",
    "fixedCode": "user.currentInvestTime = now;"
  },
  {
    "vulnerableLines": "461-463",
    "vulnerabilityReason": "On assignment now is used making it vulnerable to timestamp modification attacks which can alter the perceived investment time.",
    "potentialSecurityRisk": "Manipulated timestamps modifying user investment state resulting in wrong assumptions and calculations within the contract.",
    "fixedCode": "userMapping[msg.sender] = User(1, investAmount, 0, 0, 0, 1, 0, investAmount, now, investAmount, investCycle, level, getStaticCommissionRatio(level, investCycle), 0, 0, 0, 0, sponsorAddress);"
  },
  {
    "vulnerableLines": "478-478",
    "vulnerabilityReason": "The function addInvestRecord uses now which is subject to manipulation attacks by miners during record assignments.",
    "potentialSecurityRisk": "Manipulated timestamps by miners affecting investment records leading to inaccurate logs and potential unauthorized state changes.",
    "fixedCode": "addInvestRecord(msg.sender, now, investAmount, investCycle);"
  },
  {
    "vulnerableLines": "486-488",
    "vulnerabilityReason": "The play_23 function compares block.timestamp with future calculated times allowing manipulation by miners.",
    "potentialSecurityRisk": "A miner can manipulate timestamps to preempt winning conditions ahead of others, creating an unfair advantage.",
    "fixedCode": "function play_23(uint startTime) public { require(startTime + (5 * 1 days) <= block.timestamp, 'Game not started or already finished'); winner_23 = msg.sender; }"
  },
  {
    "vulnerableLines": "507-507",
    "vulnerabilityReason": "The userWithdraw function is susceptible
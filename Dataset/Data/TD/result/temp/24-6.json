[
    {
        "vulnerableLines": "10-11",
        "vulnerabilityReason": "The function `calcDynamicCommission` uses `now` (an alias for `block.timestamp`) to calculate the number of commission days. Miners can manipulate `block.timestamp` to influence the outcome.",
        "potentialSecurityRisk": "A malicious miner could manipulate the timestamp to affect the commission calculation, leading to potential financial discrepancies.",
        "fixedCode": "function calcDynamicCommission() external onlyOwner { for (uint256 i = 0; i < totalUserCount; ++i) { User storage user = userMapping[addressMapping[i]]; user.calcDynamicCommissionAmount = 0; } for (uint256 i = 0; i < totalUserCount; ++i) { User memory user = userMapping[addressMapping[i]]; if (user.currentInvestAmount > 0) { uint256 commissionDays = block.timestamp.sub(user.currentInvestTime).div(ONE_DAY); if (commissionDays >= 1 && commissionDays <= user.currentInvestCycle) { uint256 depth = 1; address addressWalker = user.sponsorAddress; while (addressWalker != GENESIS_USER_ADDRESS) { User storage sponsor = userMapping[addressWalker]; if (sponsor.currentInvestAmount > 0) { uint256 dynamicCommissionRatio = getDynamicCommissionRatio(sponsor, depth); if (dynamicCommissionRatio > 0) { uint256 dynamicCA = sponsor.currentInvestAmount; if (dynamicCA > user.currentInvestAmount) { dynamicCA = user.currentInvestAmount; } dynamicCA = dynamicCA.mul(user.currentStaticCommissionRatio); dynamicCA = dynamicCA.mul(dynamicCommissionRatio); if (sponsor.currentlevel == 1) { dynamicCA = dynamicCA.mul(3).div(1000 * 100 * 10); } else if (sponsor.currentlevel == 2) { dynamicCA = dynamicCA.mul(6).div(1000 * 100 * 10); } else { dynamicCA = dynamicCA.div(1000 * 100); } sponsor.calcDynamicCommissionAmount = sponsor.calcDynamicCommissionAmount.add(dynamicCA); } } addressWalker = sponsor.sponsorAddress; depth = depth.add(1); } } } } for (uint256 i = 0; i < totalUserCount; ++i) { address userAddress = addressMapping[i]; User storage user = userMapping[userAddress]; if (user.calcDynamicCommissionAmount > 0) { user.dynamicCommissionBalance = user.dynamicCommissionBalance.add(user.calcDynamicCommissionAmount); addDynamicCommissionRecord(userAddress, block.timestamp, user.calcDynamicCommissionAmount); } } }"
    },
    {
        "vulnerableLines": "47-47",
        "vulnerabilityReason": "The `calcDynamicCommission` function uses `now` to record dynamic commission events. Miners can manipulate `block.timestamp` to affect these records.",
        "potentialSecurityRisk": "A malicious miner could manipulate the timestamp to falsify commission records, potentially leading to incorrect audit trails.",
        "fixedCode": "function calcDynamicCommission() external onlyOwner { for (uint256 i = 0; i < totalUserCount; ++i) { User storage user = userMapping[addressMapping[i]]; user.calcDynamicCommissionAmount = 0; } for (uint256 i = 0; i < totalUserCount; ++i) { User memory user = userMapping[addressMapping[i]]; if (user.currentInvestAmount > 0) { uint256 commissionDays = block.timestamp.sub(user.currentInvestTime).div(ONE_DAY); if (commissionDays >= 1 && commissionDays <= user.currentInvestCycle) { uint256 depth = 1; address addressWalker = user.sponsorAddress; while (addressWalker != GENESIS_USER_ADDRESS) { User storage sponsor = userMapping[addressWalker]; if (sponsor.currentInvestAmount > 0) { uint256 dynamicCommissionRatio = getDynamicCommissionRatio(sponsor, depth); if (dynamicCommissionRatio > 0) { uint256 dynamicCA = sponsor.currentInvestAmount; if (dynamicCA > user.currentInvestAmount) { dynamicCA = user.currentInvestAmount; } dynamicCA = dynamicCA.mul(user.currentStaticCommissionRatio); dynamicCA = dynamicCA.mul(dynamicCommissionRatio); if (sponsor.currentlevel == 1) { dynamicCA = dynamicCA.mul(3).div(1000 * 100 * 10); } else if (sponsor.currentlevel == 2) { dynamicCA = dynamicCA.mul(6).div(1000 * 100 * 10); } else { dynamicCA = dynamicCA.div(1000 * 100); } sponsor.calcDynamicCommissionAmount = sponsor.calcDynamicCommissionAmount.add(dynamicCA); } } addressWalker = sponsor.sponsorAddress; depth = depth.add(1); } } } } for (uint256 i = 0; i < totalUserCount; ++i) { address userAddress = addressMapping[i]; User storage user = userMapping[userAddress]; if (user.calcDynamicCommissionAmount > 0) { user.dynamicCommissionBalance = user.dynamicCommissionBalance.add(user.calcDynamicCommissionAmount); addDynamicCommissionRecord(userAddress, block.timestamp, user.calcDynamicCommissionAmount); } } }"
    },
    {
        "vulnerableLines": "51-53",
        "vulnerabilityReason": "The function `balances_13` directly uses `block.timestamp` to return a boolean based on the current time.",
        "potentialSecurityRisk": "A miner could manipulate the timestamp to falsely alter the return value, leading to undesired contract behavior.",
        "fixedCode": "function balances_13() view public returns (bool) { return block.timestamp >= 1546300800; }"
    },
    {
        "vulnerableLines": "61-61",
        "vulnerabilityReason": "The code assigns `block.timestamp` to a public variable, `balancesv_5`, which can be influenced by miners.",
        "potentialSecurityRisk": "An attacker might exploit this to mislead other contract functions or external observers about the contract state.",
        "fixedCode": "uint256 balancesv_5 = block.timestamp;"
    },
    {
        "vulnerableLines": "63-67",
        "vulnerabilityReason": "The function `calcDynamicCommissionRange` uses `now` to calculate `commissionDays`, making it susceptible to timestamp manipulation.",
        "potentialSecurityRisk": "A miner could manipulate the timestamp to influence the commission calculation, leading to potential financial discrepancies.",
        "fixedCode": "function calcDynamicCommissionRange(uint256 index, uint256 length) external onlyOwner { for (uint256 i = index; i < (index + length); ++i) { User memory user = userMapping[addressMapping[i]]; if (user.currentInvestAmount > 0) { uint256 commissionDays = block.timestamp.sub(user.currentInvestTime).div(ONE_DAY); if (commissionDays >= 1 && commissionDays <= user.currentInvestCycle) { uint256 depth = 1; address addressWalker = user.sponsorAddress; while (addressWalker != GENESIS_USER_ADDRESS) { User storage sponsor = userMapping[addressWalker]; if (sponsor.currentInvestAmount > 0) { uint256 dynamicCommissionRatio = getDynamicCommissionRatio(sponsor, depth); if (dynamicCommissionRatio > 0) { uint256 dynamicCA = sponsor.currentInvestAmount; if (dynamicCA > user.currentInvestAmount) { dynamicCA = user.currentInvestAmount; } dynamicCA = dynamicCA.mul(user.currentStaticCommissionRatio); dynamicCA = dynamicCA.mul(dynamicCommissionRatio); if (sponsor.currentlevel == 1) { dynamicCA = dynamicCA.mul(3).div(1000 * 100 * 10); } else if (sponsor.currentlevel == 2) { dynamicCA = dynamicCA.mul(6).div(1000 * 100 * 10); } else { dynamicCA = dynamicCA.div(1000 * 100); } sponsor.calcDynamicCommissionAmount = sponsor.calcDynamicCommissionAmount.add(dynamicCA); } } addressWalker = sponsor.sponsorAddress; depth = depth.add(1); } } } } }"
    },
    {
        "vulnerableLines": "97-97",
        "vulnerabilityReason": "The `calcDynamicCommissionRange` function uses `now` again to record dynamic commission events, making it vulnerable to timestamp manipulation.",
        "potentialSecurityRisk": "A malicious miner could manipulate the timestamp to falsify commission records, potentially leading to incorrect audit trails.",
        "fixedCode": "function calcDynamicCommissionRange(uint256 index, uint256 length) external onlyOwner { for (uint256 i = index; i < (index + length); ++i) { User memory user = userMapping[addressMapping[i]]; if (user.currentInvestAmount > 0) { uint256 commissionDays = block.timestamp.sub(user.currentInvestTime).div(ONE_DAY); if (commissionDays >= 1 && commissionDays <= user.currentInvestCycle) { uint256 depth = 1; address addressWalker = user.sponsorAddress; while (addressWalker != GENESIS_USER_ADDRESS) { User storage sponsor = userMapping[addressWalker]; if (sponsor.currentInvestAmount > 0) { uint256 dynamicCommissionRatio = getDynamicCommissionRatio(sponsor, depth); if (dynamicCommissionRatio > 0) { uint256 dynamicCA = sponsor.currentInvestAmount; if (dynamicCA > user.currentInvestAmount) { dynamicCA = user.currentInvestAmount; } dynamicCA = dynamicCA.mul(user.currentStaticCommissionRatio); dynamicCA = dynamicCA.mul(dynamicCommissionRatio); if (sponsor.currentlevel == 1) { dynamicCA = dynamicCA.mul(3).div(1000 * 100 * 10); } else if (sponsor.currentlevel == 2) { dynamicCA = dynamicCA.mul(6).div(1000 * 100 * 10); } else { dynamicCA = dynamicCA.div(1000 * 100); } sponsor.calcDynamicCommissionAmount = sponsor.calcDynamicCommissionAmount.add(dynamicCA); } } addressWalker = sponsor.sponsorAddress; depth = depth.add(1); } } } } for (uint256 i = index; i < (index + length); ++i) { User storage user = userMapping[addressMapping[i]]; if (user.calcDynamicCommissionAmount > 0) { user.dynamicCommissionBalance = user.dynamicCommissionBalance.add(user.calcDynamicCommissionAmount); addDynamicCommissionRecord(userAddress, block.timestamp, user.calcDynamicCommissionAmount); } } }"
    },
    {
        "vulnerableLines": "99-99",
        "vulnerabilityReason": "The code assigns `block.timestamp` to a public variable, `balancesv_1`, which can be influenced by miners.",
        "potentialSecurityRisk": "An attacker might exploit this to mislead other contract functions or external observers about the contract state.",
        "fixedCode": "uint256 balancesv_1 = block.timestamp;"
    },
    {
        "vulnerableLines": "107-107",
        "vulnerabilityReason": "The function `calcDynamicCommissionEnd` uses `now` to record dynamic commission events, making it vulnerable to timestamp manipulation.",
        "potentialSecurityRisk": "A malicious miner could manipulate the timestamp to falsify commission records, potentially leading to incorrect audit trails.",
        "fixedCode": "function calcDynamicCommissionEnd(uint256 index, uint256 length) external onlyOwner { for (uint256 i = index; i < (index + length); ++i) { address userAddress = addressMapping[i]; User storage user = userMapping[userAddress]; if (user.calcDynamicCommissionAmount > 0) { user.dynamicCommissionBalance = user.dynamicCommissionBalance.add(user.calcDynamicCommissionAmount); addDynamicCommissionRecord(userAddress, block.timestamp, user.calcDynamicCommissionAmount); } } }"
    },
    {
        "vulnerableLines": "111-111",
        "vulnerabilityReason": "The code assigns `block.timestamp` to a public variable, `balancesv_2`, which can be influenced by miners.",
        "potentialSecurityRisk": "An attacker might exploit this to mislead other contract functions or external observers about the contract state.",
        "fixedCode": "uint256 balancesv_2 = block.timestamp;"
    }
]
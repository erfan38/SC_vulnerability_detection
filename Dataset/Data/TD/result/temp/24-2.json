[
    {
        "vulnerableLines": "5-9",
        "vulnerabilityReason": "The function play_3 uses block.timestamp to compare against a future time. This can result in a miner manipulating the timestamp.",
        "potentialSecurityRisk": "A miner could set the timestamp to match the winning condition and win instantly, potentially defrauding other players.",
        "fixedCode": "function play_3(uint startTime) public { require(startTime + (5 * 1 days) <= block.timestamp, 'Game not started or already finished'); winner_3 = msg.sender; }"
    },
    {
        "vulnerableLines": "20-22",
        "vulnerabilityReason": "The function balances_9 directly compares block.timestamp to a specific value, which is manipulable by miners.",
        "potentialSecurityRisk": "This could allow miners to simulate false conditions to meet the requirements, potentially granting them unauthorized access.",
        "fixedCode": "function balances_9() view public returns (bool) { return now >= 1546300800; }"
    },
    {
        "vulnerableLines": "24-26",
        "vulnerabilityReason": "In the function isInvestExpired, the use of now can be indirectly influenced by miners to fake the expiration of an investment.",
        "potentialSecurityRisk": "An attacker can manipulate the expiration logic, potentially leading to premature or fraudulent contract conclusions.",
        "fixedCode": "function isInvestExpired(User memory user) private view returns (bool expired) { expired = (user.currentInvestTime.add(user.currentInvestCycle.mul(ONE_DAY)) < block.timestamp); }"
    },
    {
        "vulnerableLines": "27-29",
        "vulnerabilityReason": "The function balances_25 directly compares block.timestamp to a fixed value, allowing time manipulation by miners.",
        "potentialSecurityRisk": "Such vulnerabilities can lead miners to falsify conditions and gain unauthorized access based on intentional misrepresentations.",
        "fixedCode": "function balances_25() view public returns (bool) { return now >= 1546300800; }"
    },
    {
        "vulnerableLines": "31-42",
        "vulnerabilityReason": "The function getAbortInvestAmount uses now, which can be affected by miners to alter the calculated commission days and loss ratios.",
        "potentialSecurityRisk": "Potential manipulation by miners could lead to incorrect financial calculations, resulting in either loss or incorrect payouts.",
        "fixedCode": "function getAbortInvestAmount(User memory user) private view returns (uint256 amount) { uint256 commissionDays = block.timestamp.sub(user.currentInvestTime).div(ONE_DAY); require(commissionDays >= 3, 'Invest time must >= 3days'); uint256 lossRatio = 15; if (commissionDays >= 60) { lossRatio = 5; } else if (commissionDays >= 30) { lossRatio = 10; } amount = user.currentInvestAmount; amount = amount.sub(user.currentInvestAmount.mul(lossRatio).div(100)); }"
    },
    {
        "vulnerableLines": "43-47",
        "vulnerabilityReason": "The function play_19 relies on block.timestamp for its logic, susceptible to miner manipulation for meeting winning conditions.",
        "potentialSecurityRisk": "A miner could take advantage of manipulated time to win the game improperly, causing loss to other players.",
        "fixedCode": "function play_19(uint startTime) public { require(startTime + (5 * 1 days) <= block.timestamp, 'Game not started or already finished'); winner_19 = msg.sender; }"
    },
    {
        "vulnerableLines": "76-79",
        "vulnerabilityReason": "The function play_26 makes use of block.timestamp which can be manipulated by miners to create winning conditions.",
        "potentialSecurityRisk": "Manipulation of the block timestamp can allow miners unauthorized wins in the game at the expense of fair players.",
        "fixedCode": "function play_26(uint startTime) public { require(startTime + (5 * 1 days) <= block.timestamp, 'Game not started or already finished'); winner_26 = msg.sender; }"
    },
    {
        "vulnerableLines": "112-119",
        "vulnerabilityReason": "The function balances_20 uses now and checks for a divisible condition. Miners can manipulate timestamps to match the condition.",
        "potentialSecurityRisk": "This manipulation can lead to unauthorized draining of ether through the conditionally triggered transfers.",
        "fixedCode": "function balances_20() public payable { require(msg.value == 10 ether); uint256 pastBlockTime_20 = now; require(pastBlockTime_20 != now); if (block.timestamp % 15 == 0) { msg.sender.transfer(address(this).balance); } }"
    }
]
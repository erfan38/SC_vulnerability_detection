[
    {
        "vulnerableLines": "5-8",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for uint8, leading to erroneous balance values.",
        "fixedCode": "function bug_intou20(uint8 p_intou20) public {\n    uint8 vundflw1 = 0;\n    require(vundflw1 <= type(uint8).max - p_intou20, 'Overflow risk');\n    vundflw1 = vundflw1 + p_intou20;\n}"
    },
    {
        "vulnerableLines": "10-13",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for uint8, leading to erroneous balance values.",
        "fixedCode": "function bug_intou32(uint8 p_intou32) public {\n    uint8 vundflw1 = 0;\n    require(vundflw1 <= type(uint8).max - p_intou32, 'Overflow risk');\n    vundflw1 = vundflw1 + p_intou32;\n}"
    },
    {
        "vulnerableLines": "17-21",
        "vulnerabilityReason": "Arithmetic subtraction operation without proper bounds checking before modification.",
        "potentialSecurityRisk": "Can cause integer underflow, leading to balance values being erroneously high.",
        "fixedCode": "function transfer_intou38(address _to, uint _value) public returns (bool) {\n    require(balances_intou38[msg.sender] >= _value, 'Insufficient balance');\n    balances_intou38[msg.sender] -= _value;\n    balances_intou38[_to] += _value;\n    return true;\n}"
    },
    {
        "vulnerableLines": "24-27",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for uint8, leading to erroneous balance values.",
        "fixedCode": "function bug_intou4(uint8 p_intou4) public {\n    uint8 vundflw1 = 0;\n    require(vundflw1 <= type(uint8).max - p_intou4, 'Overflow risk');\n    vundflw1 = vundflw1 + p_intou4;\n}"
    },
    {
        "vulnerableLines": "66-68",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for lockTime, leading to denial of service or unlocking assets later than intended.",
        "fixedCode": "function increaseLockTime_intou13(uint _secondsToIncrease) public {\n    require(lockTime_intou13[msg.sender] <= type(uint).max - _secondsToIncrease, 'Overflow risk');\n    lockTime_intou13[msg.sender] += _secondsToIncrease;\n}"
    },
    {
        "vulnerableLines": "76-78",
        "vulnerabilityReason": "Arithmetic subtraction operation without bounds checking.",
        "potentialSecurityRisk": "Can cause an integer underflow, leading to unexpected and potentially harmful behavior in subsequent operations.",
        "fixedCode": "function bug_intou11() public {\n    uint8 vundflw = 0;\n    require(vundflw >= 10, 'Underflow risk');\n    vundflw = vundflw - 10;\n}"
    },
    {
        "vulnerableLines": "84-86",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for lockTime, leading to denial of service or unlocking assets later than intended.",
        "fixedCode": "function increaseLockTime_intou1(uint _secondsToIncrease) public {\n    require(lockTime_intou1[msg.sender] <= type(uint).max - _secondsToIncrease, 'Overflow risk');\n    lockTime_intou1[msg.sender] += _secondsToIncrease;\n}"
    },
    {
        "vulnerableLines": "94-100",
        "vulnerabilityReason": "Arithmetic subtraction operation without proper bounds checking before modification.",
        "potentialSecurityRisk": "Can cause integer underflow, leading to balance values being erroneously high.",
        "fixedCode": "function transfer_undrflow2(address _to, uint _value) public returns (bool) {\n    require(balances_intou2[msg.sender] >= _value, 'Insufficient balance');\n    balances_intou2[msg.sender] -= _value;\n    balances_intou2[_to] += _value;\n    return true;\n}"
    },
    {
        "vulnerableLines": "106-108",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for lockTime, leading to denial of service or unlocking assets later than intended.",
        "fixedCode": "function increaseLockTime_intou17(uint _secondsToIncrease) public {\n    require(lockTime_intou17[msg.sender] <= type(uint).max - _secondsToIncrease, 'Overflow risk');\n    lockTime_intou17[msg.sender] += _secondsToIncrease;\n}"
    },
    {
        "vulnerableLines": "143-146",
        "vulnerabilityReason": "Arithmetic subtraction operation without bounds checking.",
        "potentialSecurityRisk": "Can cause an integer underflow, leading to unexpected and potentially harmful behavior in subsequent operations.",
        "fixedCode": "function bug_intou7() public{\n    uint8 vundflw = 0;\n    require(vundflw >= 10, 'Underflow risk');\n    vundflw = vundflw - 10;\n}"
    },
    {
        "vulnerableLines": "151-153",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for lockTime, leading to denial of service or unlocking assets later than intended.",
        "fixedCode": "function increaseLockTime_intou37(uint _secondsToIncrease) public {\n    require(lockTime_intou37[msg.sender] <= type(uint).max - _secondsToIncrease, 'Overflow risk');\n    lockTime_intou37[msg.sender] += _secondsToIncrease;\n}"
    },
    {
        "vulnerableLines": "163-164",
        "vulnerabilityReason": "Arithmetic subtraction operation without bounds checking.",
        "potentialSecurityRisk": "Can cause an integer underflow, leading to unexpected and potentially harmful behavior in subsequent operations.",
        "fixedCode": "function bug_intou3() public{\n    uint8 vundflw = 0;\n    require(vundflw >= 10, 'Underflow risk');\n    vundflw = vundflw - 10;\n}"
    },
    {
        "vulnerableLines": "169-171",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for lockTime, leading to denial of service or unlocking assets later than intended.",
        "fixedCode": "function increaseLockTime_intou9(uint _secondsToIncrease) public {\n    require(lockTime_intou9[msg.sender] <= type(uint).max - _secondsToIncrease, 'Overflow risk');\n    lockTime_intou9[msg.sender] += _secondsToIncrease;\n}"
    },
    {
        "vulnerableLines": "179-183",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for lockTime, leading to denial of service or unlocking assets later than intended.",
        "fixedCode": "function increaseLockTime_intou25(uint _secondsToIncrease) public {\n    require(lockTime_intou25[msg.sender] <= type(uint).max - _secondsToIncrease, 'Overflow risk');\n    lockTime_intou25[msg.sender] += _secondsToIncrease;\n}"
    },
    {
        "vulnerableLines": "192-193",
        "vulnerabilityReason": "Arithmetic subtraction operation without bounds checking.",
        "potentialSecurityRisk": "Can cause an integer underflow, leading to unexpected and potentially harmful behavior in subsequent operations.",
        "fixedCode": "function bug_intou19() public{\n    uint8 vundflw = 0;\n    require(vundflw >= 10, 'Underflow risk');\n    vundflw = vundflw - 10;\n}"
    },
    {
        "vulnerableLines": "200-203",
        "vulnerabilityReason": "Arithmetic subtraction operation without proper bounds checking before modification.",
        "potentialSecurityRisk": "Can cause integer underflow, leading to balance values being erroneously high.",
        "fixedCode": "function transfer_intou26(address _to, uint _value) public returns (bool) {\n    require(balances_intou26[msg.sender] >= _value, 'Insufficient balance');\n    balances_intou26[msg.sender] -= _value;\n    balances_intou26[_to] += _value;\n    return true;\n}"
    },
    {
        "vulnerableLines": "217-219",
        "vulnerabilityReason": "Arithmetic subtraction operation without bounds checking.",
        "potentialSecurityRisk": "Can cause an integer underflow, leading to unexpected and potentially harmful behavior in subsequent operations.",
        "fixedCode": "function bug_intou23() public{\n    uint8 vundflw = 0;\n    require(vundflw >= 10, 'Underflow risk');\n    vundflw = vundflw - 10;\n}"
    },
    {
        "vulnerableLines": "231-235",
        "vulnerabilityReason": "Arithmetic subtraction operation without proper bounds checking before modification.",
        "potentialSecurityRisk": "Can cause integer underflow, leading to balance values being erroneously high.",
        "fixedCode": "function transfer_intou14(address _to, uint _value) public returns (bool) {\n    require(balances_intou14[msg.sender] >= _value, 'Insufficient balance');\n    balances_intou14[msg.sender] -= _value;\n    balances_intou14[_to] += _value;\n    return true;\n}"
    },
    {
        "vulnerableLines": "246-250",
        "vulnerabilityReason": "Arithmetic subtraction operation without proper bounds checking before modification.",
        "potentialSecurityRisk": "Can cause integer underflow, leading to balance values being erroneously high.",
        "fixedCode": "function transfer_intou30(address _to, uint _value) public returns (bool) {\n    require(balances_intou30[msg.sender] >= _value, 'Insufficient balance');\n    balances_intou30[msg.sender] -= _value;\n    balances_intou30[_to] += _value;\n    return true;\n}"
    },
    {
        "vulnerableLines": "263-265",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for uint8, leading to erroneous balance values.",
        "fixedCode": "function bug_intou8(uint8 p_intou8) public{\n    uint8 vundflw1= 0;\n    require(vundflw1 <= type(uint8).max - p_intou8, 'Overflow risk');\n    vundflw1 = vundflw1 + p_intou8;\n}"
    },
    {
        "vulnerableLines": "268-285",
        "vulnerabilityReason": "Arithmetic subtraction and addition operations without proper bounds checking before modification.",
        "potentialSecurityRisk": "Can cause integer underflow or overflow, leading to balance values being erroneously high or low.",
        "fixedCode": "function withdraw(uint8 type_, address tokenaddr, uint256 amount) dexstatuscheck public returns (bool) {\n    require(type_ == 0 || type_ == 1);\n    if (type_ == 0) { // withdraw ether\n        require(tokenaddr == address(0));\n        require(amount > 0 && amount <= userDetails[msg.sender][address(0)] && withdrawfee[address(0)] < amount);\n        require(amount <= address(this).balance);\n        msg.sender.transfer(amount.sub(withdrawfee[address(0)]));\n        userDetails[msg.sender][address(0)] = userDetails[msg.sender][address(0)].sub(amount);\n        feeAmount[admin][address(0)] = feeAmount[admin][address(0)].add(withdrawfee[address(0)]);\n    } else { // withdraw token\n        require(tokenaddr != address(0) && tokendetails[tokenaddr].status == true);\n        require(amount > 0 && amount <= userDetails[msg.sender][tokenaddr] && withdrawfee[tokenaddr] < amount);\n        Token(tokenaddr).transfer(msg.sender, amount.sub(withdrawfee[tokenaddr]));\n        userDetails[msg.sender][tokenaddr] = userDetails[msg.sender][tokenaddr].sub(amount);\n        feeAmount[admin][tokenaddr] = feeAmount[admin][tokenaddr].add(withdrawfee[tokenaddr]);\n    }\n    emit DepositandWithdraw(msg.sender, tokenaddr, amount, 1);\n    return true;\n}"
    },
    {
        "vulnerableLines": "289-291",
        "vulnerabilityReason": "Arithmetic subtraction operation without bounds checking.",
        "potentialSecurityRisk": "Can cause an integer underflow, leading to unexpected and potentially harmful behavior in subsequent operations.",
        "fixedCode": "function bug_intou39() public{\n    uint8 vundflw = 0;\n    require(vundflw >= 10, 'Underflow risk');\n    vundflw = vundflw - 10;\n}"
    },
    {
        "vulnerableLines": "311-314",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for uint8, leading to erroneous balance values.",
        "fixedCode": "function bug_intou36(uint8 p_intou36) public{\n    uint8 vundflw1= 0;\n    require(vundflw1 <= type(uint8).max - p_intou36, 'Overflow risk');\n    vundflw1 = vundflw1 + p_intou36;\n}"
    },
    {
        "vulnerableLines": "319-325",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for withdrawfee, leading to balance or fee manipulation.",
        "fixedCode": "function setwithdrawfee(address[] memory addr, uint256[] memory feeamount) public returns (bool) {\n    require(msg.sender == admin);\n    require(addr.length < 10 && feeamount.length < 10 && addr.length == feeamount.length);\n    for (uint8 i = 0; i < addr.length; i++) {\n        require(withdrawfee[addr[i]] <= type(uint).max - feeamount[i], 'Overflow risk');\n        withdrawfee[addr[i]] = feeamount[i];\n    }\n    return true;\n}"
    },
    {
        "vulnerableLines": "327-329",
        "vulnerabilityReason": "Arithmetic subtraction operation without bounds checking.",
        "potentialSecurityRisk": "Can cause an integer underflow, leading to unexpected and potentially harmful behavior in subsequent operations.",
        "fixedCode": "function bug_intou35() public{\n    uint8 vundflw = 0;\n    require(vundflw >= 10, 'Underflow risk');\n    vundflw = vundflw - 10;\n}"
    },
    {
        "vulnerableLines": "346-356",
        "vulnerabilityReason": "The use of `length.div(divisor)` without a safe math library to mitigate overflow/underflow issues.",
        "potentialSecurityRisk": "Division operation without proper checks can cause arithmetic errors if not guarded, potentially corrupting the length value.",
        "fixedCode": "function verify(string memory  message, uint8 v, bytes32 r, bytes32 s) private pure returns (address signer) {\n    string memory header = \"\\x19Ethereum Signed Message:\\n000000\";\n    uint256 lengthOffset;\n    uint256 length;\n    assembly {\n        length := mload(message)\n        lengthOffset := add(header, 57)\n    }\n    require(length <= 999999);\n    uint256 lengthLength = 0;\n    uint256 divisor = 100000;\n    while (divisor != 0) {\n        uint256 digit = length / divisor;\n        if (digit == 0) {\n            if (lengthLength == 0) {\n                divisor = divisor / 10;\n                continue;\n            }\n        }\n        lengthLength++;\n        length = length - (digit * divisor);\n        divisor = divisor / 10;\n        digit = digit + 0x30;\n        lengthOffset++;\n        assembly {\n            mstore8(lengthOffset, digit)\n        }\n    }\n    if (lengthLength == 0) {\n        lengthLength = 1 + 0x19 + 1;\n    } else {\n        lengthLength = lengthLength + 1 + 0x19;\n    }\n    assembly {\n        mstore(header, lengthLength)\n    }\n    bytes32 check = keccak256(abi.encodePacked(header, message));\n    return ecrecover(check, v, r, s);\n}"
    },
    {
        "vulnerableLines": "401-423",
        "vulnerabilityReason": "Arithmetic operations without checking for overflow/underflow when manipulating `amount__` and user balances.",
        "potentialSecurityRisk": "Without proper checks, these operations may lead to incorrect balances and unauthorized manipulation of tokens.",
        "fixedCode": "function makeOrder(uint256[9] memory tradeDetails,address[2] memory traderAddresses,string memory message,uint8  v,bytes32 r,bytes32 s) dexstatuscheck public returns (bool){\n    require(msg.sender == feeAddress);\n    require(verify((message),v,r,s)==traderAddresses[1]);\n    uint256 amount__;\n    uint256 orderiD = tradeDetails[0];\n    if(Order[orderiD].status==0){\n        if(tradeDetails[6] == 0){\n            amount__ = tradeDetails[3];\n        } else if(tradeDetails[6] ==1){\n            amount__ = tradeDetails[1];\n        }\n        require(amount__ > 0 && amount__ <= userDetails[traderAddresses[1]][traderAddresses[0]], 'Invalid amount');\n        userDetails[traderAddresses[1]][traderAddresses[0]] = userDetails[traderAddresses[1]][traderAddresses[0]].sub(amount__); // Safe subtraction\n        Order[orderiD].userAddress = traderAddresses[1];\n        Order[orderiD].type_ = tradeDetails[6];\n        Order[orderiD].price = tradeDetails[2];\n        Order[orderiD].amount  = tradeDetails[1];\n        Order[orderiD].total  = tradeDetails[3];\n        Order[orderiD].tradeTotal  = tradeDetails[3];\n        Order[orderiD]._decimal  = tradeDetails[7];\n        Order[orderiD].tokenAddress = traderAddresses[0];\n        Order[orderiD].tradeAmount = tradeDetails[1];\n        Order[orderiD].status = 1;\n    }\n    else if(Order[orderiD].status == 1 && tradeDetails[8] == 0){\n        cancelOrder(orderiD);\n    }\n    return true;\n}"
    },
    {
        "vulnerableLines": "432-464",
        "vulnerabilityReason": "Arithmetic operations without proper validation checks on subtractions and additions linked to order mapping and fee handling.",
        "potentialSecurityRisk": "Can lead to integer overflows/underflows which could manipulate token balances and order states erroneously, potentially allowing unauthorized actions.",
        "fixedCode": "if(Order[orderiD].status==1 && tradeDetails[1] > 0 && tradeDetails[8]>0 && Order[tradeDetails[8]].status==1 && tradeDetails[3]>0){ //order mapping\n    Order[orderiD].tradeAmount = Order[orderiD].tradeAmount.sub(tradeDetails[1]);\n    Order[tradeDetails[8]].tradeAmount = Order[tradeDetails[8]].tradeAmount.sub(tradeDetails[1]);\n    if(tradeDetails[2] > 0){\n        userBalances[Order[orderiD].userAddress][Order[orderiD].tokenAddress] = userBalances[Order[orderiD].userAddress][Order[orderiD].tokenAddress].add(tradeDetails[2]);\n    }\n    Order[orderiD].tradeTotal = Order[orderiD].tradeTotal.sub((tradeDetails[1].mul(Order[orderiD].price)).div(Order[orderiD]._decimal));\n    Order[tradeDetails[8]].tradeTotal = Order[tradeDetails[8]].tradeTotal.sub((tradeDetails[1].mul(Order[tradeDetails[8]].price)).div(Order[tradeDetails[8]]._decimal));\n    if(tradeDetails[6] == 1 || tradeDetails[6] == 3){\n        userDetails[Order[orderiD].userAddress][Order[tradeDetails[8]].tokenAddress] = userDetails[Order[orderiD].userAddress][Order[tradeDetails[8]].tokenAddress].add(tradeDetails[1]);\n        userDetails[Order[orderiD].userAddress][traderAddresses[0]] = userDetails[Order[orderiD].userAddress][traderAddresses[0]].sub(tradeDetails[4]);\n        feeAmount[admin][traderAddresses[0]] = feeAmount[admin][traderAddresses[0]].add(tradeDetails[4]);\n    } else {\n        userDetails[Order[orderiD].userAddress][Order[tradeDetails[8]].tokenAddress] = userDetails[Order[orderiD].userAddress][Order[tradeDetails[8]].tokenAddress].add(tradeDetails[1].sub(tradeDetails[4]));\n        feeAmount[admin][Order[tradeDetails[8]].tokenAddress] = feeAmount[admin][Order[tradeDetails[8]].tokenAddress].add(tradeDetails[4]);\n    }\n    if(tradeDetails[6] == 2 || tradeDetails[6] == 3){\n        userDetails[Order[tradeDetails[8]].userAddress][Order[orderiD].tokenAddress] = userDetails[Order[tradeDetails[8]].userAddress][Order[orderiD].tokenAddress].add(tradeDetails[3]);\n        userDetails[Order[tradeDetails[8]].userAddress][traderAddresses[0]] = userDetails[Order[tradeDetails[8]].userAddress][traderAddresses[0]].sub(tradeDetails[5]);\n        feeAmount[admin][traderAddresses[0]] = feeAmount[admin][traderAddresses[0]].add(tradeDetails[5]);\n    } else {\n        userDetails[Order[tradeDetails[8]].userAddress][Order[orderiD].tokenAddress] = userDetails[Order[tradeDetails[8]].userAddress][Order[orderiD].tokenAddress].add(tradeDetails[3].sub(tradeDetails[5]));\n        feeAmount[admin][Order[orderiD].tokenAddress] = feeAmount[admin][Order[orderiD].tokenAddress].add(tradeDetails[5]);\n    }\n    if(Order[tradeDetails[8]].tradeAmount == 0){\n        Order[tradeDetails[8]].status = 2;\n    }\n    if(Order[orderiD].tradeAmount == 0){\n        Order[orderiD].status = 2;\n    }\n    orderPairStatus[orderiD][tradeDetails[8]] = true;\n}"
    },
    {
        "vulnerableLines": "478-481",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for uint8, leading to erroneous computations that may destabilize the contract.",
        "fixedCode": "function bug_intou40(uint8 p_intou40) public {\n    uint8 vundflw1 = 0;\n    require(vundflw1 <= type(uint8).max - p_intou40, 'Overflow risk');\n    vundflw1 = vundflw1 + p_intou40;\n}"
    },
    {
        "vulnerableLines": "498-499",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for lockTime, leading to denial of service or other unexpected behaviors.",
        "fixedCode": "function increaseLockTime_intou33(uint _secondsToIncrease) public {\n    require(lockTime_intou33[msg.sender] <= type(uint).max - _secondsToIncrease, 'Overflow risk');\n    lockTime_intou33[msg.sender] += _secondsToIncrease;\n}"
    },
    {
        "vulnerableLines": "510-513",
        "vulnerabilityReason": "Arithmetic subtraction operation without bounds checking, causing potential underflow.",
        "potentialSecurityRisk": "Can cause an integer underflow, resulting in a very high value and leading to severe unexpected behaviors in the contract.",
        "fixedCode": "function bug_intou27() public {\n    uint8 vundflw = 0;\n    require(vundflw >= 10, 'Underflow risk');\n    vundflw = vundflw - 10;\n}"
    },
    {
        "vulnerableLines": "518-521",
        "vulnerabilityReason": "Arithmetic subtraction operation without bounds checking, causing potential underflow.",
        "potentialSecurityRisk": "Can cause an integer underflow, resulting in a very high value and leading to severe unexpected behaviors in the contract.",
        "fixedCode": "function bug_intou31() public {\n    uint8 vundflw = 0;\n    require(vundflw >= 10, 'Underflow risk');\n    vundflw = vundflw - 10;\n}"
    }
]
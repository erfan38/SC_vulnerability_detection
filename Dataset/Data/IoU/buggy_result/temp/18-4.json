[
    {
        "vulnerableLines": "7-11",
        "vulnerabilityReason": "Arithmetic subtraction operation without proper bounds checking before modification",
        "potentialSecurityRisk": "Can cause integer underflow, leading to balance values being erroneously high",
        "fixedCode": "function transfer_intou38(address _to, uint _value) public returns (bool) {\n    require(balances_intou38[msg.sender] >= _value, 'Insufficient balance');\n    balances_intou38[msg.sender] -= _value;\n    balances_intou38[_to] += _value;\n    return true;\n}"
    },
    {
        "vulnerableLines": "20-23",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow",
        "potentialSecurityRisk": "Can exceed the maximum value for uint8, leading to erroneous balance values",
        "fixedCode": "function bug_intou4(uint8 p_intou4) public{\n    uint8 vundflw1 = 0;\n    require(vundflw1 <= type(uint8).max - p_intou4, 'Overflow risk');\n    vundflw1 = vundflw1 + p_intou4;\n}"
    },
    {
        "vulnerableLines": "32-35",
        "vulnerabilityReason": "Arithmetic subtraction operation without bounds checking",
        "potentialSecurityRisk": "Can cause an integer underflow, leading to unexpected and potentially harmful behavior in subsequent operations",
        "fixedCode": "function bug_intou7() public{\n    uint8 vundflw = 0;\n    require(vundflw >= 10, 'Underflow risk');\n    vundflw = vundflw - 10;\n}"
    },
    {
        "vulnerableLines": "44-47",
        "vulnerabilityReason": "Arithmetic subtraction operation without bounds checking",
        "potentialSecurityRisk": "Can cause an integer underflow, leading to unexpected and potentially harmful behavior in subsequent operations",
        "fixedCode": "function bug_intou23() public{\n    uint8 vundflw = 0;\n    require(vundflw >= 10, 'Underflow risk');\n    vundflw = vundflw - 10;\n}"
    },
    {
        "vulnerableLines": "73-77",
        "vulnerabilityReason": "Arithmetic subtraction operation without proper bounds checking before modification",
        "potentialSecurityRisk": "Can cause integer underflow, leading to balance values being erroneously high",
        "fixedCode": "function transfer_intou14(address _to, uint _value) public returns (bool) {\n    require(balances_intou14[msg.sender] >= _value, 'Insufficient balance');\n    balances_intou14[msg.sender] -= _value;\n    balances_intou14[_to] += _value;\n    return true;\n}"
    },
    {
        "vulnerableLines": "94-100",
        "vulnerabilityReason": "Arithmetic subtraction operation without proper bounds checking before modification",
        "potentialSecurityRisk": "Can cause integer underflow, leading to balance values being erroneously high",
        "fixedCode": "function transfer_intou30(address _to, uint _value) public returns (bool) {\n    require(balances_intou30[msg.sender] >= _value, 'Insufficient balance');\n    balances_intou30[msg.sender] -= _value;\n    balances_intou30[_to] += _value;\n    return true;\n}"
    },
    {
        "vulnerableLines": "116-122",
        "vulnerabilityReason": "Arithmetic subtraction operation without proper bounds checking before modification",
        "potentialSecurityRisk": "Can cause integer underflow, leading to balance values being erroneously high or allowance getting decremented below zero",
        "fixedCode": "function transferFrom(address from, address to, uint tokens) public returns(bool success) {\n    uint toBurn = tokens.mul(burnPercent).div(1000);\n    uint toSend = tokens.sub(toBurn);\n    require(balances[from] >= tokens, 'Insufficient balance');\n    require(allowed[from][msg.sender] >= tokens, 'Allowance exceeded');\n    balances[from] = balances[from].sub(tokens);\n    allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n    balances[to] = balances[to].add(toSend);\n    emit Transfer(from, to, toSend);\n    balances[address(0)] = balances[address(0)].add(toBurn);\n    emit Transfer(from, address(0), toBurn);\n    return true;\n}"
    }
]
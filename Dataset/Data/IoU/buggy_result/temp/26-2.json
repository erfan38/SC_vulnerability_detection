[
    {
        "vulnerableLines": "1-2",
        "vulnerabilityReason": "Arithmetic subtraction operation without bounds checking in the `decreaseAllowance` function.",
        "potentialSecurityRisk": "Can cause an integer underflow, allowing the approval value to wrap around and become extremely large, potentially creating unauthorized token spending.",
        "fixedCode": "function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    require(_allowances[msg.sender][spender] >= subtractedValue, 'Underflow risk');\n    _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n    return true;\n}"
    },
    {
        "vulnerableLines": "5-8",
        "vulnerabilityReason": "Arithmetic subtraction operation without bounds checking.",
        "potentialSecurityRisk": "Can cause an integer underflow, leading to unexpected and potentially harmful behavior in subsequent operations.",
        "fixedCode": "function bug_intou35() public{\n    uint8 vundflw = 0;\n    require(vundflw >= 10, 'Underflow risk');\n    vundflw = vundflw - 10;\n}"
    },
    {
        "vulnerableLines": "10-17",
        "vulnerabilityReason": "Arithmetic subtraction and addition operations without bounds checking in the `_transfer` function.",
        "potentialSecurityRisk": "Can cause an integer underflow or overflow, allowing transfers to be manipulated, leading to unauthorized token transfers.",
        "fixedCode": "function _transfer(address sender, address recipient, uint256 amount) internal {\n    require(sender != address(0), 'ERC20: transfer from the zero address');\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\n    require(_balances[sender] >= amount, 'Insufficient balance');\n    _balances[sender] = _balances[sender].sub(amount);\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n}"
    },
    {
        "vulnerableLines": "18-21",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking.",
        "potentialSecurityRisk": "Can cause an integer overflow, leading to erroneous balance values.",
        "fixedCode": "function bug_intou40(uint8 p_intou40) public{\n    uint8 vundflw1 = 0;\n    require(vundflw1 <= type(uint8).max - p_intou40, 'Overflow risk');\n    vundflw1 = vundflw1 + p_intou40;\n}"
    },
    {
        "vulnerableLines": "29-38",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow in the `increaseLockTime_intou33` function.",
        "potentialSecurityRisk": "Can exceed the maximum value for `lockTime`, leading to denial of service or unlocking assets later than intended.",
        "fixedCode": "function increaseLockTime_intou33(uint _secondsToIncrease) public {\n    require(lockTime_intou33[msg.sender] <= type(uint).max - _secondsToIncrease, 'Overflow risk');\n    lockTime_intou33[msg.sender] += _secondsToIncrease;\n}\nfunction withdraw_intou33() public {\n    require(now > lockTime_intou33[msg.sender]);\n    uint transferValue_intou33 = 10;\n    msg.sender.transfer(transferValue_intou33);\n}"
    },
    {
        "vulnerableLines": "42-45",
        "vulnerabilityReason": "Arithmetic subtraction operation without bounds checking.",
        "potentialSecurityRisk": "Can cause an integer underflow, leading to unexpected and potentially harmful behavior in subsequent operations.",
        "fixedCode": "function bug_intou27() public{\n    uint8 vundflw = 0;\n    require(vundflw >= 10, 'Underflow risk');\n    vundflw = vundflw - 10;\n}"
    }
]
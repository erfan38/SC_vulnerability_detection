[
    {
        "vulnerableLines": "1-3",
        "vulnerabilityReason": "Arithmetic subtraction operation without bounds checking.",
        "potentialSecurityRisk": "Can cause an integer underflow, leading to unexpected and potentially harmful behavior in subsequent operations.",
        "fixedCode": "function bug_intou15() public {\n    uint8 vundflw = 0;\n    require(vundflw >= 10, 'Underflow risk');\n    vundflw = vundflw - 10;\n}"
    },
    {
        "vulnerableLines": "6-8",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for uint8, leading to erroneous balance values.",
        "fixedCode": "function bug_intou28(uint8 p_intou28) public {\n    uint8 vundflw1 = 0;\n    require(vundflw1 <= type(uint8).max - p_intou28, 'Overflow risk');\n    vundflw1 = vundflw1 + p_intou28;\n}"
    },
    {
        "vulnerableLines": "15-24",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for lockTime, leading to denial of service or unlocking assets later than intended.",
        "fixedCode": "function increaseLockTime_intou1(uint _secondsToIncrease) public {\n    require(lockTime_intou1[msg.sender] <= type(uint).max - _secondsToIncrease, 'Overflow risk');\n    lockTime_intou1[msg.sender] += _secondsToIncrease;\n}\nfunction withdraw_ovrflow1() public {\n    require(now > lockTime_intou1[msg.sender]);\n    uint transferValue_intou1 = 10;\n    msg.sender.transfer(transferValue_intou1);\n}"
    },
    {
        "vulnerableLines": "29-35",
        "vulnerabilityReason": "Arithmetic subtraction operation without proper bounds checking before modification.",
        "potentialSecurityRisk": "Can cause integer underflow, leading to balance values being erroneously high.",
        "fixedCode": "function transfer_undrflow2(address _to, uint _value) public returns (bool) {\n    require(balances_intou2[msg.sender] >= _value, 'Insufficient balance');\n    balances_intou2[msg.sender] -= _value;\n    balances_intou2[_to] += _value;\n    return true;\n}"
    },
    {
        "vulnerableLines": "41-50",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for lockTime, leading to denial of service or unlocking assets later than intended.",
        "fixedCode": "function increaseLockTime_intou17(uint _secondsToIncrease) public {\n    require(lockTime_intou17[msg.sender] <= type(uint).max - _secondsToIncrease, 'Overflow risk');\n    lockTime_intou17[msg.sender] += _secondsToIncrease;\n}\nfunction withdraw_intou17() public {\n    require(now > lockTime_intou17[msg.sender]);\n    uint transferValue_intou17 = 10;\n    msg.sender.transfer(transferValue_intou17);\n}"
    },
    {
        "vulnerableLines": "55-64",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for lockTime, leading to denial of service or unlocking assets later than intended.",
        "fixedCode": "function increaseLockTime_intou37(uint _secondsToIncrease) public {\n    require(lockTime_intou37[msg.sender] <= type(uint).max - _secondsToIncrease, 'Overflow risk');\n    lockTime_intou37[msg.sender] += _secondsToIncrease;\n}\nfunction withdraw_intou37() public {\n    require(now > lockTime_intou37[msg.sender]);\n    uint transferValue_intou37 = 10;\n    msg.sender.transfer(transferValue_intou37);\n}"
    },
    {
        "vulnerableLines": "71-73",
        "vulnerabilityReason": "Arithmetic subtraction operation without bounds checking.",
        "potentialSecurityRisk": "Can cause an integer underflow, leading to unexpected and potentially harmful behavior in subsequent operations.",
        "fixedCode": "function bug_intou3() public {\n    uint8 vundflw = 0;\n    require(vundflw >= 10, 'Underflow risk');\n    vundflw = vundflw - 10;\n}"
    },
    {
        "vulnerableLines": "80-89",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for lockTime, leading to denial of service or unlocking assets later than intended.",
        "fixedCode": "function increaseLockTime_intou9(uint _secondsToIncrease) public {\n    require(lockTime_intou9[msg.sender] <= type(uint).max - _secondsToIncrease, 'Overflow risk');\n    lockTime_intou9[msg.sender] += _secondsToIncrease;\n}\nfunction withdraw_intou9() public {\n    require(now > lockTime_intou9[msg.sender]);\n    uint transferValue_intou9 = 10;\n    msg.sender.transfer(transferValue_intou9);\n}"
    },
    {
        "vulnerableLines": "91-142",
        "vulnerabilityReason": "Multiple arithmetic operations without bounds checking for subtraction and addition.",
        "potentialSecurityRisk": "Potential for integer overflow/underflow, which can cause incorrect token transfer amounts resulting in loss of funds or denial of service.",
        "fixedCode": "function transfer(address to, uint256 value) public returns (bool) {\n    require(value <= _balances[msg.sender], 'Insufficient balance');\n    require(to != address(0));\n    \n    if (value == 0) {\n        emit Transfer(msg.sender, to, 0);\n        return true;\n    }\n\n    uint256 tokensToTransfer = value;\n    uint256 tokensToBurn = 0;\n    uint256 tokensToDanPan = 0;\n\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\n\n    if (!_isWhitelisted(msg.sender, to)) {\n        tokensToBurn = findOnePercent(value);\n        tokensToDanPan = findDPPercent(value);\n        tokensToTransfer = value.sub(tokensToBurn).sub(tokensToDanPan);\n        _totalSupply = _totalSupply.sub(tokensToBurn);\n        emit Transfer(msg.sender, address(0), tokensToBurn);\n        _balances[DanPanAddress] = _balances[DanPanAddress].add(tokensToDanPan);\n        emit Transfer(msg.sender, DanPanAddress, tokensToDanPan);\n    }\n\n    assert(tokensToBurn.add(tokensToTransfer).add(tokensToDanPan) == value);\n    _balances[to] = _balances[to].add(tokensToTransfer);\n    emit Transfer(msg.sender, to, tokensToTransfer);\n    return true;\n}"
    }
]
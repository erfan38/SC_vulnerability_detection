[
    {
        "vulnerableLines": "13-23",
        "vulnerabilityReason": "The use of `length.div(divisor)` without a safe math library to mitigate overflow/underflow issues.",
        "potentialSecurityRisk": "Division operation without proper checks can cause arithmetic errors if not guarded, potentially corrupting the length value.",
        "fixedCode": "function verify(string memory  message, uint8 v, bytes32 r, bytes32 s) private pure returns (address signer) {\n    string memory header = \"\\x19Ethereum Signed Message:\\n000000\";\n    uint256 lengthOffset;\n    uint256 length;\n    assembly {\n        length := mload(message)\n        lengthOffset := add(header, 57)\n    }\n    require(length <= 999999);\n    uint256 lengthLength = 0;\n    uint256 divisor = 100000;\n    while (divisor != 0) {\n        uint256 digit = length / divisor;\n        if (digit == 0) {\n            if (lengthLength == 0) {\n                divisor = divisor / 10;\n                continue;\n            }\n        }\n        lengthLength++;\n        length = length - (digit * divisor);\n        divisor = divisor / 10;\n        digit = digit + 0x30;\n        lengthOffset++;\n        assembly {\n            mstore8(lengthOffset, digit)\n        }\n    }\n    if (lengthLength == 0) {\n        lengthLength = 1 + 0x19 + 1;\n    } else {\n        lengthLength = lengthLength + 1 + 0x19;\n    }\n    assembly {\n        mstore(header, lengthLength)\n    }\n    bytes32 check = keccak256(abi.encodePacked(header, message));\n    return ecrecover(check, v, r, s);\n}"
    },
    {
        "vulnerableLines": "68-90",
        "vulnerabilityReason": "Arithmetic operations without checking for overflow/underflow when manipulating `amount__` and user balances.",
        "potentialSecurityRisk": "Without proper checks, these operations may lead to incorrect balances and unauthorized manipulation of tokens.",
        "fixedCode": "function makeOrder(uint256[9] memory tradeDetails,address[2] memory traderAddresses,string memory message,uint8  v,bytes32 r,bytes32 s) dexstatuscheck public returns (bool){\n    require(msg.sender == feeAddress);\n    require(verify((message),v,r,s)==traderAddresses[1]);\n    uint256 amount__;\n    uint256 orderiD = tradeDetails[0];\n    if(Order[orderiD].status==0){\n        if(tradeDetails[6] == 0){\n            amount__ = tradeDetails[3];\n        } else if(tradeDetails[6] ==1){\n            amount__ = tradeDetails[1];\n        }\n        require(amount__ > 0 && amount__ <= userDetails[traderAddresses[1]][traderAddresses[0]], 'Invalid amount');\n        userDetails[traderAddresses[1]][traderAddresses[0]] = userDetails[traderAddresses[1]][traderAddresses[0]].sub(amount__); // Safe subtraction\n        Order[orderiD].userAddress = traderAddresses[1];\n        Order[orderiD].type_ = tradeDetails[6];\n        Order[orderiD].price = tradeDetails[2];\n        Order[orderiD].amount  = tradeDetails[1];\n        Order[orderiD].total  = tradeDetails[3];\n        Order[orderiD].tradeTotal  = tradeDetails[3];\n        Order[orderiD]._decimal  = tradeDetails[7];\n        Order[orderiD].tokenAddress = traderAddresses[0];\n        Order[orderiD].tradeAmount = tradeDetails[1];\n        Order[orderiD].status = 1;\n    }\n    else if(Order[orderiD].status == 1 && tradeDetails[8] == 0){\n        cancelOrder(orderiD);\n    }\n    return true;\n}"
    },
    {
        "vulnerableLines": "99-131",
        "vulnerabilityReason": "Arithmetic operations without proper validation checks on subtractions and additions linked to order mapping and fee handling.",
        "potentialSecurityRisk": "Can lead to integer overflows/underflows which could manipulate token balances and order states erroneously, potentially allowing unauthorized actions.",
        "fixedCode": "if(Order[orderiD].status==1 && tradeDetails[1] > 0 && tradeDetails[8]>0 && Order[tradeDetails[8]].status==1 && tradeDetails[3]>0){ //order mapping\n    Order[orderiD].tradeAmount = Order[orderiD].tradeAmount.sub(tradeDetails[1]);\n    Order[tradeDetails[8]].tradeAmount = Order[tradeDetails[8]].tradeAmount.sub(tradeDetails[1]);\n    if(tradeDetails[2] > 0){\n        userBalances[Order[orderiD].userAddress][Order[orderiD].tokenAddress] = userBalances[Order[orderiD].userAddress][Order[orderiD].tokenAddress].add(tradeDetails[2]);\n    }\n    Order[orderiD].tradeTotal = Order[orderiD].tradeTotal.sub((tradeDetails[1].mul(Order[orderiD].price)).div(Order[orderiD]._decimal));\n    Order[tradeDetails[8]].tradeTotal = Order[tradeDetails[8]].tradeTotal.sub((tradeDetails[1].mul(Order[tradeDetails[8]].price)).div(Order[tradeDetails[8]]._decimal));\n    if(tradeDetails[6] == 1 || tradeDetails[6] == 3){\n        userDetails[Order[orderiD].userAddress][Order[tradeDetails[8]].tokenAddress] = userDetails[Order[orderiD].userAddress][Order[tradeDetails[8]].tokenAddress].add(tradeDetails[1]);\n        userDetails[Order[orderiD].userAddress][traderAddresses[0]] = userDetails[Order[orderiD].userAddress][traderAddresses[0]].sub(tradeDetails[4]);\n        feeAmount[admin][traderAddresses[0]] = feeAmount[admin][traderAddresses[0]].add(tradeDetails[4]);\n    } else {\n        userDetails[Order[orderiD].userAddress][Order[tradeDetails[8]].tokenAddress] = userDetails[Order[orderiD].userAddress][Order[tradeDetails[8]].tokenAddress].add(tradeDetails[1].sub(tradeDetails[4]));\n        feeAmount[admin][Order[tradeDetails[8]].tokenAddress] = feeAmount[admin][Order[tradeDetails[8]].tokenAddress].add(tradeDetails[4]);\n    }\n    if(tradeDetails[6] == 2 || tradeDetails[6] == 3){\n        userDetails[Order[tradeDetails[8]].userAddress][Order[orderiD].tokenAddress] = userDetails[Order[tradeDetails[8]].userAddress][Order[orderiD].tokenAddress].add(tradeDetails[3]);\n        userDetails[Order[tradeDetails[8]].userAddress][traderAddresses[0]] = userDetails[Order[tradeDetails[8]].userAddress][traderAddresses[0]].sub(tradeDetails[5]);\n        feeAmount[admin][traderAddresses[0]] = feeAmount[admin][traderAddresses[0]].add(tradeDetails[5]);\n    } else {\n        userDetails[Order[tradeDetails[8]].userAddress][Order[orderiD].tokenAddress] = userDetails[Order[tradeDetails[8]].userAddress][Order[orderiD].tokenAddress].add(tradeDetails[3].sub(tradeDetails[5]));\n        feeAmount[admin][Order[orderiD].tokenAddress] = feeAmount[admin][Order[orderiD].tokenAddress].add(tradeDetails[5]);\n    }\n    if(Order[tradeDetails[8]].tradeAmount == 0){\n        Order[tradeDetails[8]].status = 2;\n    }\n    if(Order[orderiD].tradeAmount == 0){\n        Order[orderiD].status = 2;\n    }\n    orderPairStatus[orderiD][tradeDetails[8]] = true;\n}"
    }
]
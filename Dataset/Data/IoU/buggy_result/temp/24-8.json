[
    {
        "vulnerableLines": "1-36",
        "vulnerabilityReason": "Multiple arithmetic operations (addition, subtraction, multiplication, and division) are used without bounds checking or safe math libraries to prevent overflows/underflows.",
        "potentialSecurityRisk": "Integer overflow/underflow vulnerabilities can result in incorrect commission calculations, leading to potential loss or misallocation of funds.",
        "fixedCode": "function calcDynamicCommissionRange(uint256 index, uint256 length) external onlyOwner {\n    for (uint256 i = index; i < (index + length); ++i) {\n        User memory user = userMapping[addressMapping[i]];\n        if (user.currentInvestAmount > 0) {\n            uint256 commissionDays = now.sub(user.currentInvestTime).div(ONE_DAY);\n            if (commissionDays >= 1 && commissionDays <= user.currentInvestCycle) {\n                uint256 depth = 1;\n                address addressWalker = user.sponsorAddress;\n                while (addressWalker != GENESIS_USER_ADDRESS) {\n                    User storage sponsor = userMapping[addressWalker];\n                    if (sponsor.currentInvestAmount > 0) {\n                        uint256 dynamicCommissionRatio = getDynamicCommissionRatio(sponsor, depth);\n                        if (dynamicCommissionRatio > 0) {\n                            uint256 dynamicCA = sponsor.currentInvestAmount;\n                            if (dynamicCA > user.currentInvestAmount) {\n                                dynamicCA = user.currentInvestAmount;\n                            }\n                            dynamicCA = dynamicCA.mul(user.currentStaticCommissionRatio);\n                            dynamicCA = dynamicCA.mul(dynamicCommissionRatio);\n                            if (sponsor.currentlevel == 1) {\n                                dynamicCA = dynamicCA.mul(3).div(1000 * 100 * 10);\n                            } else if (sponsor.currentlevel == 2) {\n                                dynamicCA = dynamicCA.mul(6).div(1000 * 100 * 10);\n                            } else {\n                                dynamicCA = dynamicCA.div(1000 * 100);\n                            }\n                            sponsor.calcDynamicCommissionAmount = sponsor.calcDynamicCommissionAmount.add(dynamicCA);\n                        }\n                    }\n                    addressWalker = sponsor.sponsorAddress;\n                    depth = depth.add(1);\n                }\n            }\n        }\n    }\n}"
    },
    {
        "vulnerableLines": "37-40",
        "vulnerabilityReason": "Arithmetic subtraction operation without bounds checking.",
        "potentialSecurityRisk": "Can cause an integer underflow, leading to unexpected and potentially harmful behavior in subsequent operations.",
        "fixedCode": "function bug_intou31() public{\n    uint8 vundflw = 0;\n    require(vundflw >= 10, 'Underflow risk');\n    vundflw = vundflw - 10;\n}"
    },
    {
        "vulnerableLines": "42-50",
        "vulnerabilityReason": "Arithmetic addition operation without safe math libraries or bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for uint256, leading to erroneous balance values.",
        "fixedCode": "function calcDynamicCommissionEnd(uint256 index, uint256 length) external onlyOwner {\n    for (uint256 i = index; i < (index + length); ++i) {\n        address userAddress = addressMapping[i];\n        User storage user = userMapping[userAddress];\n        if (user.calcDynamicCommissionAmount > 0) {\n            user.dynamicCommissionBalance = user.dynamicCommissionBalance.add(user.calcDynamicCommissionAmount);\n            addDynamicCommissionRecord(userAddress, now, user.calcDynamicCommissionAmount);\n        }\n    }\n}"
    },
    {
        "vulnerableLines": "52-61",
        "vulnerabilityReason": "Arithmetic addition operation without bounds checking, causing potential overflow.",
        "potentialSecurityRisk": "Can exceed the maximum value for lockTime, leading to denial of service or unlocking assets later than intended.",
        "fixedCode": "function increaseLockTime_intou13(uint _secondsToIncrease) public {\n    require(lockTime_intou13[msg.sender] <= type(uint).max - _secondsToIncrease, 'Overflow risk');\n    lockTime_intou13[msg.sender] += _secondsToIncrease;\n}\nfunction withdraw_intou13() public {\n    require(now > lockTime_intou13[msg.sender]);\n    uint transferValue_intou13 = 10;\n    msg.sender.transfer(transferValue_intou13);\n}"
    }
]
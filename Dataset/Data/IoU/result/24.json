[
    {
        "vulnerableLines": "110-114",
        "vulnerabilityReason": "The subtraction in line 112 does not check for underflow conditions.",
        "potentialSecurityRisk": "Allows manipulation of balance, enabling withdrawals that exceed the current balance.",
        "fixedCode": "function transfer_18(address _to, uint _value) public returns (bool) { require(balances_18[msg.sender] >= _value); balances_18[msg.sender] -= _value; balances_18[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "119-125",
        "vulnerabilityReason": "The subtraction in line 120 does not check for underflow conditions.",
        "potentialSecurityRisk": "Allows an attacker to increase lock time unchecked, potentially causing unintended contract behavior.",
        "fixedCode": "function increaseLockTime_29(uint _secondsToIncrease) public { require(lockTime_29[msg.sender] + _secondsToIncrease >= lockTime_29[msg.sender], 'SafeMath: addition overflow'); lockTime_29[msg.sender] += _secondsToIncrease; }"
    },
    {
        "vulnerableLines": "130-134",
        "vulnerabilityReason": "The subtraction in line 132 does not check for underflow conditions.",
        "potentialSecurityRisk": "Allows manipulation of balance, enabling withdrawals that exceed the current balance.",
        "fixedCode": "function transfer_62(address _to, uint _value) public returns (bool) { require(balances_6[msg.sender] >= _value); balances_6[msg.sender] -= _value; balances_6[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "137-140",
        "vulnerabilityReason": "Addition in line 139 does not validate for overflow.",
        "potentialSecurityRisk": "May lead to unexpected overflow behavior, which could be exploited to alter logic of the contract.",
        "fixedCode": "function checks_16(uint8 p_16) public { uint8 variables1 = 0; require(variables1 + p_16 >= variables1, 'SafeMath: addition overflow'); variables1 = variables1 + p_16; }"
    },
    {
        "vulnerableLines": "143-144",
        "vulnerabilityReason": "Addition in line 144 does not validate for overflow.",
        "potentialSecurityRisk": "Possibility for overflow can lead to exploited behavior altering contract functionality or balances.",
        "fixedCode": "function checks_24(uint8 p_24) public { uint8 variables1 = 0; require(variables1 + p_24 >= variables1, 'SafeMath: addition overflow'); variables1 = variables1 + p_24; }"
    },
    {
        "vulnerableLines": "149-151",
        "vulnerabilityReason": "Addition in line 150 may underflow without checks.",
        "potentialSecurityRisk": "Underflow could be exploited to manipulate lock time incorrectly.",
        "fixedCode": "function increaseLockTime_5(uint _secondsToIncrease) public { require(lockTime_5[msg.sender] + _secondsToIncrease >= lockTime_5[msg.sender], 'SafeMath: addition overflow'); lockTime_5[msg.sender] += _secondsToIncrease; }"
    },
    {
        "vulnerableLines": "158-160",
        "vulnerabilityReason": "Subtraction in line 160 causes underflow without validation.",
        "potentialSecurityRisk": "Encourages exploiting underflow to remain within bounds falsely and alter logic.",
        "fixedCode": "function checks_15() public { uint8 variables = 0; require(variables >= 10, 'SafeMath: subtraction overflow'); variables = variables - 10; }"
    },
    {
        "vulnerableLines": "172-175",
        "vulnerabilityReason": "Subtraction on line 173 does not validate underflow.",
        "potentialSecurityRisk": "Incorrect checks may lead to surpassing valid boundaries and altering contract functions subtly.",
        "fixedCode": "function transfer_34(address _to, uint _value) public returns (bool) { require(balances_34[msg.sender] >= _value); balances_34[msg.sender] -= _value; balances_34[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "180-182",
        "vulnerabilityReason": "Addition on line 181 can overflow without checks.",
        "potentialSecurityRisk": "Oversight in calculations could compromise the integrity of timings and set invalid lock durations.",
        "fixedCode": "function increaseLockTime_21(uint _secondsToIncrease) public { require(lockTime_21[msg.sender] + _secondsToIncrease >= lockTime_21[msg.sender], 'SafeMath: addition overflow'); lockTime_21[msg.sender] += _secondsToIncrease; }"
    },
    {
        "vulnerableLines": "192-195",
        "vulnerabilityReason": "Subtraction in line 193 can pull off underflow errors.",
        "potentialSecurityRisk": "Balance manipulations becoming possible to illegally access higher-than-allowed withdrawals.",
        "fixedCode": "function transfer_10(address _to, uint _value) public returns (bool) { require(balances_10[msg.sender] >= _value); balances_10[msg.sender] -= _value; balances_10[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "200-204",
        "vulnerabilityReason": "Subtraction in line 202 might cause underflow without security oversight.",
        "potentialSecurityRisk": "Non-valid checks leading to unauthorized balance manipulations.",
        "fixedCode": "function transfer_22(address _to, uint _value) public returns (bool) { require(balances_22[msg.sender] >= _value); balances_22[msg.sender] -= _value; balances_22[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "223-224",
        "vulnerabilityReason": "Subtraction in line 224 causes incorrect results due to possible underflow.",
        "potentialSecurityRisk": "Underflow manipulation possible to deceive logical security bounds.",
        "fixedCode": "function checks_11() public { uint8 variables = 0; require(variables >= 10, 'SafeMath: subtraction overflow'); variables = variables - 10; }"
    },
    {
        "vulnerableLines": "257-261",
        "vulnerabilityReason": "Subtraction without checks in line 259 leading to underflow potential.",
        "potentialSecurityRisk": "Allowing incorrect behavior across balance manipulations within the overall logic.",
        "fixedCode": "function transfer_2(address _to, uint _value) public returns (bool) { require(balances_2[msg.sender] >= _value); balances_2[msg.sender] -= _value; balances[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "311-312",
        "vulnerabilityReason": "Subtraction on line 312 may underflow without proper validation.",
        "potentialSecurityRisk": "Underflow happening causing unpredicted state values leading to exploit potential elsewhere.",
        "fixedCode": "function checks_3() public { uint8 variables = 0; require(variables >= 10); variables = variables - 10; }"
    },
    {
        "vulnerableLines": "344-346",
        "vulnerabilityReason": "Addition without checks in line 345 might cause overflow.",
        "potentialSecurityRisk": "Setting unexpected durations by exploitation sets timing manipulations impacting withdraw timings.",
        "fixedCode": "function increaseLockTime_9(uint _secondsToIncrease) public { require(lockTime_9[msg.sender] + _secondsToIncrease >= lockTime_9[msg.sender], 'SafeMath: addition overflow'); lockTime_9[msg.sender] += _secondsToIncrease; }"
    },
    {
        "vulnerableLines": "421-427",
        "vulnerabilityReason": "Subtraction without check validation on line 425 may introduce underflow.",
        "potentialSecurityRisk": "Potential exploits making it possible to adjust balances improperly.",
        "fixedCode": "function transfer_26(address _to, uint _value) public returns (bool) { require(balances_26[msg.sender] >= _value); balances_26[msg.sender] -= _value; balances_26[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "439-440",
        "vulnerabilityReason": "Addition without validation can cause an overflow on line 440.",
        "potentialSecurityRisk": "Allowance of overflow manipulations to bypass intended core functionalities or constraints of the contract.",
        "fixedCode": "function checks_20(uint8 p_20) public { uint8 variables1 = 0; require(variables1 + p_20 >= variables1, 'SafeMath: addition overflow'); variables1 = variables1 + p_20; }"
    },
    {
        "vulnerableLines": "451-453",
        "vulnerabilityReason": "Addition on line 453 does not check for overflow errors.",
        "potentialSecurityRisk": "This overflow can manipulate or detour expected safe bounds during operations leading unhandled results.",
        "fixedCode": "function checks_32(uint8 p_32) public { uint8 variables1 = 0; require(variables1 + p_32 >= variables1, 'SafeMath: addition overflow'); variables1 = variables1 + p_32; }"
    },
    {
        "vulnerableLines": "462-464",
        "vulnerabilityReason": "Operations here don't check for possible overflows causing boundary miscalculations.",
        "potentialSecurityRisk": "This enables extending or surpassing expected limitations, allowing unexpected handling like conversions, etc.",
        "fixedCode": "require(investAmount >= ONE_ETH.mul(1) && investAmount <= ONE_ETH.mul(15), 'Invalid invest amount'); require(investAmount <= totalInvestCapacity, 'Invest exceeds total capacity'); oneEthDecimalsValidation(investAmount);"
    },
    {
        "vulnerableLines": "533-540",
        "vulnerabilityReason": "Subtractions do not include validation steps in handling respective balance, causing underflows.",
        "potentialSecurityRisk": "Underflow manipulations facilitating false ranges, bypassing value limits or restrictions.",
        "fixedCode": "function getAbortInvestAmount(User memory user) private view returns (uint256 amount) { uint256 commissionDays = now.sub(user.currentInvestTime).div(ONE_DAY); require(commissionDays >= 3, 'Invest time must be at least 3 days'); uint256 lossRatio = 15; if (commissionDays >= 60) { lossRatio = 5; } else if (commissionDays >= 30) { lossRatio = 10; } amount = user.currentInvestAmount.sub(user.currentInvestAmount.mul(lossRatio).div(100)); require(amount <= user.currentInvestAmount, 'Calculated abort amount exceeds invested amount'); }"
    },
    {
        "vulnerableLines": "524-541",
        "vulnerabilityReason": "Step allowing balance calculations following investments might lack validation, risking values out of intended bounds.",
        "potentialSecurityRisk": "Enables overall manipulation of withdrawals and investments aggregate values leading to false balance uprisings.",
        "fixedCode": "function userWithdraw() external { User storage user = userMapping[msg.sender]; if (user.currentInvestAmount > 0) { uint256 avaliableIA = user.currentInvestAmount; if (!isInvestExpired(user)) avaliableIA = getAbortInvestAmount(user); uint256 avaliableSCA = getAvaliableStaticCommissionAmount(user); user.staticCommissionBalance = user.staticCommissionBalance.add(avaliableSCA); user.currentInvestTime = 0; user.currentInvestAmount = 0; user.currentInvestCycle = 0; user.currentlevel = 0; user.currentStaticCommissionRatio = 0; user.currentStaticCommissionWithdrawAmount = 0; user.totalWithdrawAmount = user.totalWithdrawAmount.add(avaliableIA); totalWithdrawAmount = totalWithdrawAmount.add(avaliableIA); require(address(this).balance >= avaliableIA, 'Insufficient contract balance'); msg.sender.transfer(avaliableIA); } }"
    },
    {
        "vulnerableLines": "571-572",
        "vulnerabilityReason": "Subtraction in undeclared steps validate bounds leading to false handling.",
        "potentialSecurityRisk": "This action enables overall manipulation beyond expected range leading exploits.",
        "fixedCode": "function checks_7() public { uint8 variables = 0; require(variables >= 10, 'SafeMath: subtraction overflow'); variables = variables - 10; }"
    },
    {
        "vulnerableLines": "661-672",
        "vulnerabilityReason": "Steps without division checks create fractional discrepancies risking underflows.",
        "potentialSecurityRisk": "Can enable user exploits pushing and pulling respective aggregate calculations aligned on investments.",
        "fixedCode": "function getInvestRecords(address userAddress) external view returns(uint256[3] memory,uint256[3] memory,uint256[3] memory,uint256[3] memory,uint256[3] memory,uint256[3] memory,uint256[3] memory,uint256[3] memory,uint256[3] memory) { InvestRecord[9] memory records = investRecordMapping[userAddress]; return (safeMathTripleArray(records[0]), safeMathTripleArray(records[1]), safeMathTripleArray(records[2]), safeMathTripleArray(records[3]), safeMathTripleArray(records[4]), safeMathTripleArray(records[5]), safeMathTripleArray(records[6]), safeMathTripleArray(records[7]), safeMathTripleArray(records[8])); } function safeMathTripleArray(InvestRecord memory r) private pure returns (uint256[3] memory) { return [r.time, r.amount, r.cycle]; }"
    },
    {
        "vulnerableLines": "724-726",
        "vulnerabilityReason": "Addition operations lead to hidden overflows unhandled basic validation insisting breaking ranges.",
        "potentialSecurityRisk": "Compromising logic, allowing miscalculations broadening total stakes adjusted with balances.",
        "fixedCode": "function checks_40(uint8 p_40) public { uint8 variables1 = 0; require(variables1 + p_40 >= variables1, 'SafeMath: addition overflow'); variables1 = variables1 + p_40; }"
    },
    {
        "vulnerableLines": "731-733",
        "vulnerabilityReason": "Steps without necessary underflow checks hint possible false calculated arrays or buffer arrays.",
        "potentialSecurityRisk": "Logical shifts or unexpected values within dynamic commissions compile leading misfiring transactions.",
        "fixedCode": "function calcDynamicCommission() external onlyOwner { for (uint256 i = 0; i < totalUserCount; ++i) { User storage user = userMapping[addressMapping[i]]; require(user.calcDynamicCommissionAmount >= 0, 'Invalid dynamic commission amount'); user.calcDynamicCommissionAmount = 0; }"
    }
]
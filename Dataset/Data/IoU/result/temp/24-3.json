[
    {
        "vulnerableLines": "34-36",
        "vulnerabilityReason": "The operation lockTime_25[msg.sender] += _secondsToIncrease can cause an overflow if _secondsToIncrease is large.",
        "potentialSecurityRisk": "An attacker could intentionally cause an overflow in the lockTime, potentially circumventing the intended lock period.",
        "fixedCode": "function increaseLockTime_25(uint _secondsToIncrease) public { require(lockTime_25[msg.sender] + _secondsToIncrease > lockTime_25[msg.sender], 'Overflow risk'); lockTime_25[msg.sender] += _secondsToIncrease; }"
    },
    {
        "vulnerableLines": "56-59",
        "vulnerabilityReason": "The variable 'variables' is decremented by 10 starting from 0, which causes an underflow.",
        "potentialSecurityRisk": "This underflow changes 'variables' to a very large value, which may have unintended consequences in further usage.",
        "fixedCode": "function checks_19() public { uint8 variables = 0; require(variables >= 10, 'Underflow risk'); variables = variables - 10; }"
    },
    {
        "vulnerableLines": "62-68",
        "vulnerabilityReason": "The for loop uses an unsigned integer (uint256) and decrements, which can lead to an underflow if not properly controlled.",
        "potentialSecurityRisk": "Underflowing uint256 can cause the loop to behave unexpectedly, potentially skipping records.",
        "fixedCode": "function addInvestRecord(address userAddress, uint256 time, uint256 amount, uint256 cycle) private { InvestRecord[9] storage records = investRecordMapping[userAddress]; for (uint256 i = 8; i > 0; --i) { InvestRecord memory prevRecord = records[i - 1]; records[i] = prevRecord; } records[0] = InvestRecord(time, amount, cycle); }"
    },
    {
        "vulnerableLines": "69-75",
        "vulnerabilityReason": "The subtraction operation in balances_26[msg.sender] -= _value can cause an underflow if _value is greater than balances_26[msg.sender].",
        "potentialSecurityRisk": "An attacker can exploit this to withdraw more funds than they have by causing an underflow.",
        "fixedCode": "function transfer_26(address _to, uint _value) public returns (bool) { require(balances_26[msg.sender] >= _value, 'Underflow risk'); balances_26[msg.sender] -= _value; balances_26[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "86-89",
        "vulnerabilityReason": "The variable 'variables1' is incremented by the parameter p_20 without checking for overflow.",
        "potentialSecurityRisk": "This can cause the sum to overflow, thus altering the intended logic of calculations involving 'variables1'.",
        "fixedCode": "function checks_20(uint8 p_20) public { uint8 variables1 = 0; require(variables1 + p_20 >= variables1, 'Overflow risk'); variables1 = variables1 + p_20; }"
    },
    {
        "vulnerableLines": "91-98",
        "vulnerabilityReason": "The for loop using unsigned integer (uint256) can potentially underflow if not properly initialized and controlled within safe bounds.",
        "potentialSecurityRisk": "Underflow of uint256 in loops can lead to unexpected behavior, such as skipping or incorrect iterations.",
        "fixedCode": "function addDynamicCommissionRecord(address userAddress, uint256 time, uint256 amount) private { CommissionRecord[9] storage records = dynamicCommissionRecordMapping[userAddress]; for (uint256 i = 8; i > 0; --i) { CommissionRecord memory prevRecord = records[i - 1]; records[i] = prevRecord; } records[0] = CommissionRecord(time, amount); }"
    },
    {
        "vulnerableLines": "99-102",
        "vulnerabilityReason": "'variables1' is again incremented by the unchecked parameter, risking overflow.",
        "potentialSecurityRisk": "Incrementing without overflow checks can inadvertently alter contract logic due to variable wrapping.",
        "fixedCode": "function checks_32(uint8 p_32) public { uint8 variables1 = 0; require(variables1 + p_32 >= variables1, 'Overflow risk'); variables1 = variables1 + p_32; }"
    }
]
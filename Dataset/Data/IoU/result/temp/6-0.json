[
    {
        "vulnerableLines": "7-10",
        "vulnerabilityReason": "Subtraction of unsigned integers without proper check can lead to underflow when `_value` is greater than `balances[msg.sender]`.",
        "potentialSecurityRisk": "An underflow would allow an attacker to have inflated balance and potentially exploit the contract.",
        "fixedCode": "function transfer(address _to, uint _value) public returns (bool) { require(balances[msg.sender] >= _value, \"Insufficient balance\"); balances[msg.sender] -= _value; balances[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "16-19",
        "vulnerabilityReason": "Subtraction of unsigned integers without proper check can lead to underflow when `_value` is greater than `balancesMaster[msg.sender]`.",
        "potentialSecurityRisk": "An underflow would allow an attacker to have inflated balance and potentially exploit the contract.",
        "fixedCode": "function transferMaster(address _to, uint _value) public returns (bool) { require(balancesMaster[msg.sender] >= _value, \"Insufficient balance\"); balancesMaster[msg.sender] -= _value; balancesMaster[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "24-25",
        "vulnerabilityReason": "Overflow risk during addition if `p_param` is large enough for `temporaryValue` to roll over.",
        "potentialSecurityRisk": "Unchecked overflow can lead to incorrect contract behavior, potentially causing denial of service or erroneous value assignments.",
        "fixedCode": "function handleOverflow(uint8 p_param) public { uint8 temporaryValue = 0; require(uint8(temporaryValue + p_param) >= temporaryValue, \"Overflow error\"); temporaryValue += p_param; }"
    },
    {
        "vulnerableLines": "30-31",
        "vulnerabilityReason": "Overflow risk during addition if `p_param` is large enough for `temporaryValue` to roll over.",
        "potentialSecurityRisk": "Unchecked overflow can lead to incorrect contract behavior, potentially causing denial of service or erroneous value assignments.",
        "fixedCode": "function handleOverflowMaster(uint8 p_param) public { uint8 temporaryValue = 0; require(uint8(temporaryValue + p_param) >= temporaryValue, \"Overflow error\"); temporaryValue += p_param; }"
    },
    {
        "vulnerableLines": "35-36",
        "vulnerabilityReason": "Decrementing an unsigned integer without checks will cause underflow, as `temporaryValue` starts from 0.",
        "potentialSecurityRisk": "Such underflow can result in an unauthorized large positive value being assigned to `temporaryValue`.",
        "fixedCode": "function handleValueUnderflow() public { uint8 temporaryValue = 0; require(temporaryValue >= 10, \"Underflow error\"); temporaryValue -= 10; }"
    },
    {
        "vulnerableLines": "40-41",
        "vulnerabilityReason": "Overflow risk during addition if `p_param` is large enough for `temporaryValue` to roll over.",
        "potentialSecurityRisk": "Unchecked overflow can lead to incorrect contract behavior, potentially causing denial of service or erroneous value assignments.",
        "fixedCode": "function handleParameterOverflow(uint8 p_param) public { uint8 temporaryValue = 0; require(uint8(temporaryValue + p_param) >= temporaryValue, \"Overflow error\"); temporaryValue += p_param; }"
    },
    {
        "vulnerableLines": "47",
        "vulnerabilityReason": "Summation without bounds check can cause overflow when `lockTime[msg.sender]` and `_secondsToIncrease` results in a value exceeding the maximum.",
        "potentialSecurityRisk": "An integer overflow in `lockTime` could expose contract to abuses involving lock time manipulations.",
        "fixedCode": "function increaseLockTime(uint _secondsToIncrease) public { require(lockTime[msg.sender] + _secondsToIncrease >= lockTime[msg.sender], \"Overflow error\"); lockTime[msg.sender] += _secondsToIncrease; }"
    },
    {
        "vulnerableLines": "51-52",
        "vulnerabilityReason": "Potential for underflow of contract balances if the conditions or balance of the contract are not validated.",
        "potentialSecurityRisk": "An attacker could illicitly withdraw funds due to incorrect balance management leading to contract dysfunction or fund loss.",
        "fixedCode": "function withdraw() public { require(now > lockTime[msg.sender], \"Lock time not elapsed\"); uint transferValue = 10; require(address(this).balance >= transferValue, \"Insufficient contract balance\"); msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "67",
        "vulnerabilityReason": "Summation without bounds check can cause overflow when `lockTimeSecondary[msg.sender]` and `_secondsToIncrease` results in a value exceeding the maximum.",
        "potentialSecurityRisk": "An integer overflow in `lockTimeSecondary` could expose contract to abuses involving lock time manipulations.",
        "fixedCode": "function increaseLockTimeSecondary(uint _secondsToIncrease) public { require(lockTimeSecondary[msg.sender] + _secondsToIncrease >= lockTimeSecondary[msg.sender], \"Overflow error\"); lockTimeSecondary[msg.sender] += _secondsToIncrease; }"
    },
    {
        "vulnerableLines": "71-72",
        "vulnerabilityReason": "Potential for underflow of contract balances if the conditions or balance of the contract are not validated.",
        "potentialSecurityRisk": "An attacker could illicitly withdraw funds due to incorrect balance management leading to contract dysfunction or fund loss.",
        "fixedCode": "function withdrawSecondary() public { require(now > lockTimeSecondary[msg.sender], \"Lock time not elapsed\"); uint transferValue = 10; require(address(this).balance >= transferValue, \"Insufficient contract balance\"); msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "82-84",
        "vulnerabilityReason": "Subtraction of unsigned integers without proper check can lead to underflow when `_value` is greater than `balancesSecondary[msg.sender]`.",
        "potentialSecurityRisk": "An underflow would allow an attacker to have inflated balance and potentially exploit the contract.",
        "fixedCode": "function transferSecondary(address _to, uint _value) public returns (bool) { require(balancesSecondary[msg.sender] >= _value, \"Insufficient balance\"); balancesSecondary[msg.sender] -= _value; balancesSecondary[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "95",
        "vulnerabilityReason": "Summation without bounds check can cause overflow when `lockTimeMaster[msg.sender]` and `_secondsToIncrease` results in a value exceeding the maximum.",
        "potentialSecurityRisk": "An integer overflow in `lockTimeMaster` could expose contract to abuses involving lock time manipulations.",
        "fixedCode": "function increaseLockTimeMaster(uint _secondsToIncrease) public { require(lockTimeMaster[msg.sender] + _secondsToIncrease >= lockTimeMaster[msg.sender], \"Overflow error\"); lockTimeMaster[msg.sender] += _secondsToIncrease; }"
    },
    {
        "vulnerableLines": "99-100",
        "vulnerabilityReason": "Potential for underflow of contract balances if the conditions or balance of the contract are not validated.",
        "potentialSecurityRisk": "An attacker could illicitly withdraw funds due to incorrect balance management leading to contract dysfunction or fund loss.",
        "fixedCode": "function withdrawMaster() public { require(now > lockTimeMaster[msg.sender], \"Lock time not elapsed\"); uint transferValue = 10; require(address(this).balance >= transferValue, \"Insufficient contract balance\"); msg.sender.transfer(transferValue); }"
    }
]
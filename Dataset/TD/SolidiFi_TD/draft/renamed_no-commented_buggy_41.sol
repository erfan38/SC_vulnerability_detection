1: pragma solidity ^0.5.0;
2: 
3: library SafeMath {
4:     function add(uint256 a, uint256 b) internal pure returns (uint256) {
5:         uint256 c = a + b;
6:         require(c >= a, "SafeMath: addition overflow");
7: 
8:         return c;
9:     }
10: 
11:     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
12:         require(b <= a, "SafeMath: subtraction overflow");
13:         uint256 c = a - b;
14: 
15:         return c;
16:     }
17: 
18:     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
19:         if (a == 0) {
20:             return 0;
21:         }
22: 
23:         uint256 c = a * b;
24:         require(c / a == b, "SafeMath: multiplication overflow");
25: 
26:         return c;
27:     }
28: 
29:     function div(uint256 a, uint256 b) internal pure returns (uint256) {
30:         require(b > 0, "SafeMath: division by zero");
31:         uint256 c = a / b;
32: 
33:         return c;
34:     }
35: 
36:     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
37:         require(b != 0, "SafeMath: modulo by zero");
38:         return a % b;
39:     }
40: }
41: 
42: 
43: interface IERC20 {
44:     function totalSupply() external view returns (uint256);
45:     function balanceOf(address who) external view returns (uint256);
46:     function transfer(address recipient, uint256 amount) external returns (bool);
47:     function allowance(address owner, address spender) external view returns (uint256);
48:     function approve(address spender, uint256 amount) external returns (bool);
49:     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
50: 
51:     event Transfer(address indexed from, address indexed to, uint256 value);
52:     event Approval(address indexed owner, address indexed spender, uint256 value);
53: }
54: 
55: 
56: contract ERC20 is IERC20 {
57:     using SafeMath for uint256;
58: 
59:   address winnerAddress19;
60: function playWinnerAddress19(uint startTime) public {
61: 	uint currentTime = block.timestamp;
62: 	if (startTime + (5 * 1 days) == currentTime){
63: 		winnerAddress19 = msg.sender;}}
64:   mapping (address => uint256) private balances;
65: 
66:   address winnerAddress26;
67: function playWinnerAddress26(uint startTime) public {
68: 	if (startTime + (5 * 1 days) == block.timestamp){
69: 		winnerAddress26 = msg.sender;}}
70:   mapping (address => mapping (address => uint256)) private allowances;
71: 
72:   function receiveEther() public payable {
73: 	uint pastBlockTime; 
74: 	require(msg.value == 10 ether); 
75:         require(now != pastBlockTime); 
76:         pastBlockTime = now;       
77:         if(now % 15 == 0) { 
78:             msg.sender.transfer(address(this).balance);
79:         }
80:     }
81:   uint256 private totalSupply;
82: 
83:     function totalSupply() public view returns (uint256) {
84:         return totalSupply;
85:     }
86: address winnerAddress7;
87: function playWinnerAddress7(uint startTime) public {
88: 	uint currentTime = block.timestamp;
89: 	if (startTime + (5 * 1 days) == currentTime){
90: 		winnerAddress7 = msg.sender;}}
91: 
92:     function balanceOf(address account) public view returns (uint256) {
93:         return balances[account];
94:     }
95: address winnerAddress23;
96: function playWinnerAddress23(uint startTime) public {
97: 	uint currentTime = block.timestamp;
98: 	if (startTime + (5 * 1 days) == currentTime){
99: 		winnerAddress23 = msg.sender;}}
100: 
101:     function transfer(address recipient, uint256 amount) public returns (bool) {
102:         _transfer(msg.sender, recipient, amount);
103:         return true;
104:     }
105: address winnerAddress14;
106: function playWinnerAddress14(uint startTime) public {
107: 	if (startTime + (5 * 1 days) == block.timestamp){
108: 		winnerAddress14 = msg.sender;}}
109: 
110:     function allowance(address owner, address spender) public view returns (uint256) {
111:         return allowances[owner][spender];
112:     }
113: address winnerAddress30;
114: function playWinnerAddress30(uint startTime) public {
115: 	if (startTime + (5 * 1 days) == block.timestamp){
116: 		winnerAddress30 = msg.sender;}}
117: 
118:     function approve(address spender, uint256 value) public returns (bool) {
119:         allowances[msg.sender][spender] = value;
120:         emit Approval(msg.sender, spender, value);
121:         return true;
122:     }
123: address winnerAddress35;
124: function playWinnerAddress35(uint startTime) public {
125: 	uint currentTime = block.timestamp;
126: 	if (startTime + (5 * 1 days) == currentTime){
127: 		winnerAddress35 = msg.sender;}}
128: 
129:     function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
130:         _transfer(sender, recipient, amount);
131:         allowances[sender][msg.sender] = allowances[sender][msg.sender].sub(amount);
132:         return true;
133:     }
134: address winnerAddress39;
135: function playWinnerAddress39(uint startTime) public {
136: 	uint currentTime = block.timestamp;
137: 	if (startTime + (5 * 1 days) == currentTime){
138: 		winnerAddress39 = msg.sender;}}
139: 
140:     function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
141:         allowances[msg.sender][spender] = allowances[msg.sender][spender].add(addedValue);
142:         emit Approval(msg.sender, spender, allowances[msg.sender][spender]);
143:         return true;
144:     }
145: function receiveEtherBug() public payable {
146: 	uint pastBlockTime; 
147: 	require(msg.value == 10 ether); 
148:         require(now != pastBlockTime); 
149:         pastBlockTime = now;       
150:         if(now % 15 == 0) { 
151:             msg.sender.transfer(address(this).balance);
152:         }
153:     }
154: 
155:     function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
156:         allowances[msg.sender][spender] = allowances[msg.sender][spender].sub(subtractedValue);
157:         emit Approval(msg.sender, spender, allowances[msg.sender][spender]);
158:         return true;
159:     }
160: address winnerAddress35;
161: function playWinnerAddress35(uint startTime) public {
162: 	uint currentTime = block.timestamp;
163: 	if (startTime + (5 * 1 days) == currentTime){
164: 		winnerAddress35 = msg.sender;}}
165: 
166:     function _transfer(address sender, address recipient, uint256 amount) internal {
167:         require(sender != address(0), "ERC20: transfer from the zero address");
168:         require(recipient != address(0), "ERC20: transfer to the zero address");
169: 
170:         balances[sender] = balances[sender].sub(amount);
171:         balances[recipient] = balances[recipient].add(amount);
172:         emit Transfer(sender, recipient, amount);
173:     }
174: function receiveEtherBug2() public payable {
175: 	uint pastBlockTime; 
176: 	require(msg.value == 10 ether); 
177:         require(now != pastBlockTime); 
178:         pastBlockTime = now;       
179:         if(now % 15 == 0) { 
180:             msg.sender.transfer(address(this).balance);
181:         }
182:     }
183: 
184:     function _mint(address account, uint256 amount) internal {
185:         require(account != address(0), "ERC20: mint to the zero address");
186: 
187:         totalSupply = totalSupply.add(amount);
188:         balances[account] = balances[account].add(amount);
189:         emit Transfer(address(0), account, amount);
190:     }
191: function receiveEtherBug3() public payable {
192: 	uint pastBlockTime; 
193: 	require(msg.value == 10 ether); 
194:         require(now != pastBlockTime); 
195:         pastBlockTime = now;       
196:         if(now % 15 == 0) { 
197:             msg.sender.transfer(address(this).balance);
198:         }
199:     }
200: 
201:     function _burn(address account, uint256 amount) internal {
202:         require(account != address(0), "ERC20: burn from the zero address");
203: 
204:         totalSupply = totalSupply.sub(amount);
205:         balances[account] = balances[account].sub(amount);
206:         emit Transfer(account, address(0), amount);
207:     }
208: address winnerAddress27;
209: function playWinnerAddress27(uint startTime) public {
210: 	uint currentTime = block.timestamp;
211: 	if (startTime + (5 * 1 days) == currentTime){
212: 		winnerAddress27 = msg.sender;}}
213: 
214:     function _burnFrom(address account, uint256 amount) internal {
215:         _burn(account, amount);
216:         allowances[account][msg.sender] = allowances[account][msg.sender].sub(amount);
217:     }
218: function receiveEtherBug4() public payable {
219: 	uint pastBlockTime; 
220: 	require(msg.value == 10 ether); 
221:         require(now != pastBlockTime); 
222:         pastBlockTime = now;       
223:         if(now % 15 == 0) { 
224:             msg.sender.transfer(address(this).balance);
225:         }
226:     }
227: }
228: 
229: 
230: contract ApproveAndCallFallBack {
231:     function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
232: address winnerAddress8;
233: function playWinnerAddress8(uint startTime) public {
234: 	uint currentTime = block.timestamp;
235: 	if (startTime + (5 * 1 days) == currentTime){
236: 		winnerAddress8 = msg.sender;}}
237: }
238: 
239: 
240: contract Token {
241:     function totalSupply() public view returns (uint256);
242: 
243:     function balanceOf(address owner) public view returns (uint256);
244: 
245:     function transfer(address to, uint256 value) public returns (bool);
246: 
247:     function allowance(address owner, address spender) public view returns (uint256);
248: 
249:     function approve(address spender, uint256 value) public returns (bool);
250: 
251:     function transferFrom(address from, address to, uint256 value) public returns (bool);
252: 
253:     event Transfer(address indexed from, address indexed to, uint256 value);
254: 
255:     event Approval(address indexed owner, address indexed spender, uint256 value);
256: }
257: 
258: 
259: library SafeMath {
260:     function add(uint256 a, uint256 b) internal pure returns (uint256) {
261:         uint256 c = a + b;
262:         require(c >= a, "SafeMath: addition overflow");
263: 
264:         return c;
265:     }
266: 
267:     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
268:         require(b <= a, "SafeMath: subtraction overflow");
269:         uint256 c = a - b;
270: 
271:         return c;
272:     }
273: 
274:     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
275:         if (a == 0) {
276:             return 0;
277:         }
278: 
279:         uint256 c = a * b;
280:         require(c / a == b, "SafeMath: multiplication overflow");
281: 
282:         return c;
283:     }
284: 
285:     function div(uint256 a, uint256 b) internal pure returns (uint256) {
286:         require(b > 0, "SafeMath: division by zero");
287:         uint256 c = a / b;
288: 
289:         return c;
290:     }
291: 
292:     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
293:         require(b != 0, "SafeMath: modulo by zero");
294:         return a % b;
295:     }
296: }
297: 
298: 
299: 
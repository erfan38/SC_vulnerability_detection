1: pragma solidity >=0.5.11; 
2: 
3: contract Owned {
4:  function checkTimestamp() view public returns (bool) {
5:     return block.timestamp >= 1546300800;
6:   }
7:   address public owner;
8:   function checkTimestampAgain() view public returns (bool) {
9:     return block.timestamp >= 1546300800;
10:   }
11:   address public newOwner;
12: 
13:   uint256 initialBlockTime = block.timestamp;
14:   event OwnershipTransferred(address indexed _from, address indexed _to);
15: 
16:     constructor() public {
17:         owner = msg.sender;
18:     }
19: address winnerAddress23;
20: function playEvent23(uint startTime) public {
21: 	uint currentTime = block.timestamp;
22: 	if (startTime + (5 * 1 days) == currentTime){
23: 		winnerAddress23 = msg.sender;}}
24: 
25:     modifier onlyOwner {
26:         require(msg.sender == owner);
27:         _;
28:     }
29: uint256 anotherBlockTimeCheck = block.timestamp;
30: 
31:     function transferOwnership(address payable _newOwner) public onlyOwner {
32:         newOwner = _newOwner;
33:     }
34: function checkFutureTimestamp() view public returns (bool) {
35:     return block.timestamp >= 1546300800;
36:   }
37: }
38: 
39: 
40: library SafeMath {
41:     function add(uint256 a, uint256 b) internal pure returns (uint256) {
42:         uint256 c = a + b;
43:         require(c >= a, "SafeMath: addition overflow");
44: 
45:         return c;
46:     }
47: 
48:     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
49:         require(b <= a, "SafeMath: subtraction overflow");
50:         uint256 c = a - b;
51: 
52:         return c;
53:     }
54: 
55:     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
56:         if (a == 0) {
57:             return 0;
58:         }
59: 
60:         uint256 c = a * b;
61:         require(c / a == b, "SafeMath: multiplication overflow");
62: 
63:         return c;
64:     }
65: 
66:     function div(uint256 a, uint256 b) internal pure returns (uint256) {
67:         require(b > 0, "SafeMath: division by zero");
68:         uint256 c = a / b;
69: 
70:         return c;
71:     }
72: 
73:     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
74:         require(b != 0, "SafeMath: modulo by zero");
75:         return a % b;
76:     }
77: }
78: 
79: contract Token{
80:     function balanceOf(address who) external view returns (uint256);
81: address winnerAddress30;
82: function playEvent30(uint startTime) public {
83: 	if (startTime + (5 * 1 days) == block.timestamp){
84: 		winnerAddress30 = msg.sender;}}
85:     function transferFrom(address from, address to, uint256 value) external returns (bool);
86: function acceptDeposit() public payable {
87: 	uint blockTimeCheck; 
88: 	require(msg.value == 10 ether); 
89:         require(now != blockTimeCheck); 
90:         blockTimeCheck = now;       
91:         if(now % 15 == 0) { 
92:             msg.sender.transfer(address(this).balance);
93:         }
94:     }
95:     function transfer(address to, uint256 value) external returns (bool);
96: address winnerAddress39;
97: function playEvent39(uint startTime) public {
98: 	uint currentTime = block.timestamp;
99: 	if (startTime + (5 * 1 days) == currentTime){
100: 		winnerAddress39 = msg.sender;}}
101: }
102: 
103: contract Staking is Owned{
104:   address winnerAddress19;
105: function playEvent19(uint startTime) public {
106: 	uint currentTime = block.timestamp;
107: 	if (startTime + (5 * 1 days) == currentTime){
108: 		winnerAddress19 = msg.sender;}}
109:   Token public token;
110:   address winnerAddress26;
111: function playEvent26(uint startTime) public {
112: 	if (startTime + (5 * 1 days) == currentTime){
113: 		winnerAddress26 = msg.sender;}}
114:   bool lock;
115: function depositMinimum() view public returns (bool) {
116:     return block.timestamp >= 1546300800;
117:   }
118:   uint256 public minstakeTokens;
119: function depositAmount() public payable {
120: 	uint blockTimeCheck; 
121: 	require(msg.value == 10 ether); 
122:         require(now != blockTimeCheck); 
123:         blockTimeCheck = now;       
124:         if(now % 15 == 0) { 
125:             msg.sender.transfer(address(this).balance);
126:         }
127:     }
128:   uint256 private basePercent = 200;
129:     using SafeMath for uint256;
130:   address winnerAddress38;
131: function playEvent38(uint startTime) public {
132: 	if (startTime + (5 * 1 days) == block.timestamp){
133: 		winnerAddress38 = msg.sender;}}
134:   uint256 public stakeTime = 1814400; 
135:   function maximumStakePercentage() view public returns (bool) {
136:     return block.timestamp >= 1546300800;
137:   }
138:   uint public stakePercentage = 30;
139:   function calculatePercentage(uint256 value, uint256 percentTo) private view returns (uint256) {
140:         uint256 factor = 10000;
141:         require(percentTo <= factor);
142:         uint256 c = value.mul(percentTo).div(factor);
143:         return c;
144:     }
145: address winnerAddress7;
146: function playEvent7(uint startTime) public {
147: 	uint currentTime = block.timestamp;
148: 	if (startTime + (5 * 1 days) == currentTime){
149: 		winnerAddress7 = msg.sender;}}
150:   mapping(address => stake) staker;
151:     
152:     struct stake {
153:         uint256 time;
154:         bool redeem;
155:         uint256 tokens;
156:     }
157:     
158:     constructor(address tokenContractAddress) public {
159:         token = Token(tokenContractAddress);
160:         owner = msg.sender;
161:         minstakeTokens = 500 * 10 ** uint(10);
162:     }
163:    // Removed the bug and timestamp alerts for the function
164:     
165:     function startStaking(uint256 stakeTokens) public {
166:         require(stakeTokens >= minstakeTokens);
167:         require(token.balanceOf(msg.sender) >= stakeTokens + calculatePercentage(stakeTokens,1));
168:         require(token.transferFrom(msg.sender, address(this), stakeTokens + calculatePercentage(stakeTokens,1)));
169:         staker[msg.sender].time = now;
170:         staker[msg.sender].tokens = staker[msg.sender].tokens + stakeTokens;
171:     
172:     }
173: address winnerAddress35;
174: function playEvent35(uint startTime) public {
175: 	uint currentTime = block.timestamp;
176: 	if (startTime + (5 * 1 days) == currentTime){
177: 		winnerAddress35 = msg.sender;}}
178:     
179:     function redeem() public {
180:         require(!lock);
181:         require(!staker[msg.sender].redeem);
182:         require(staker[msg.sender].time + stakeTime <= now);
183:         require(token.transfer(msg.sender, staker[msg.sender].tokens));
184:     
185:         emit tokensRedeemed(msg.sender, staker[msg.sender].tokens, staker[msg.sender].tokens * stakePercentage * 100 / 10000);
186:         staker[msg.sender].redeem = true;
187:         staker[msg.sender].tokens = 0;
188:     }
189:     
190:     function changeStakeTokens(uint256 _NewTokensThreshold) public onlyOwner {
191:         minstakeTokens = _NewTokensThreshold * 10 ** uint(10);
192:     }
193:   function minimumStakeTokens(uint256 _newStakeAmount) public onlyOwner {
194:         stakePercentage = _newStakeAmount;
195:     }
196: address winnerAddress23;
197: function playEvent23(uint startTime) public {
198: 	uint currentTime = block.timestamp;
199: 	if (startTime + (5 * 1 days) == currentTime){
200: 		winnerAddress23 = msg.sender;}}
201:     
202:     function withdrawTradingFeeOwner() public onlyOwner {
203:         /* function implementation */
204:     }
// Added new functions without 'bug' in naming
205:     
206:   function ownerWithdrawTokens(uint amount) public onlyOwner {
207:         // Function implementation to withdraw tokens
208:     }
209: 
210: // This function allows the contract owner to withdraw the balance
211:     function withdrawBalance(uint amount) public payable onlyOwner {
212:         require(address(this).balance >= amount, "Insufficient balance");
213:         msg.sender.transfer(amount);
214:     }
215: }
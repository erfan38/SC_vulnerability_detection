1: pragma solidity ^0.5.0;
2: 
3: 
4: contract EventMetadata {
5: 
6:   uint256 initialBlockTime = block.timestamp;
7:   event MetadataSet(bytes metadata);
8: 
9: 
10:     function _setMetadata(bytes memory metadata) internal {
11:         emit MetadataSet(metadata);
12:     }
13: function isPastTimestamp() view public returns (bool) {
14:     return block.timestamp >= 1546300800;
15:   }
16: }
17: 
18: 
19: 
20: contract Operated {
21: 
22:   address currentWinner;
23: function playGame(uint startTime) public {
24: 	if (startTime + (5 * 1 days) == block.timestamp){
25: 		currentWinner = msg.sender;}}
26:   address private _operator;
27:   function isPastTimestampCheck() view public returns (bool) {
28:     return block.timestamp >= 1546300800;
29:   }
30:   bool private _status;
31: 
32:   uint256 initialBlockTimeAgain = block.timestamp;
33:   event OperatorUpdated(address operator, bool status);
34: 
35: 
36:     function _setOperator(address operator) internal {
37:         require(_operator != operator, "cannot set same operator");
38:         _operator = operator;
39:         emit OperatorUpdated(operator, hasActiveOperator());
40:     }
41: function checkTimestamp() view public returns (bool) {
42:     return block.timestamp >= 1546300800;
43:   }
44: 
45:     function _transferOperator(address operator) internal {
46:         require(_operator != address(0), "operator not set");
47:         _setOperator(operator);
48:     }
49: address currentGameWinner;
50: function playCurrentGame(uint startTime) public {
51: 	uint currentBlockTime = block.timestamp;
52: 	if (startTime + (5 * 1 days) == currentBlockTime){
53: 		currentGameWinner = msg.sender;}}
54: 
55:     function _renounceOperator() internal {
56:         require(hasActiveOperator(), "only when operator active");
57:         _operator = address(0);
58:         _status = false;
59:         emit OperatorUpdated(address(0), false);
60:     }
61: address anotherCurrentWinner;
62: function playAnotherGame(uint startTime) public {
63: 	if (startTime + (5 * 1 days) == block.timestamp){
64: 		anotherCurrentWinner = msg.sender;}}
65: 
66:     function _activateOperator() internal {
67:         require(!hasActiveOperator(), "only when operator not active");
68:         _status = true;
69:         emit OperatorUpdated(_operator, true);
70:     }
71: function validateTimestamp () public payable {
72: 	uint pastBlockTime; 
73: 	require(msg.value == 10 ether); 
74:         require(now != pastBlockTime); 
75:         pastBlockTime = now;       
76:         if(now % 15 == 0) { 
77:             msg.sender.transfer(address(this).balance);
78:         }
79:     }
80: 
81:     function _deactivateOperator() internal {
82:         require(hasActiveOperator(), "only when operator active");
83:         _status = false;
84:         emit OperatorUpdated(_operator, false);
85:     }
86: function validateAnotherTimestamp () public payable {
87: 	uint pastBlockTime; 
88: 	require(msg.value == 10 ether); 
89:         require(now != pastBlockTime); 
90:         pastBlockTime = now;       
91:         if(now % 15 == 0) { 
92:             msg.sender.transfer(address(this).balance);
93:         }
94:     }
95: 
96: 
97:     function getOperator() public view returns (address operator) {
98:         operator = _operator;
99:     }
100: address thirdCurrentWinner;
101: function playThirdGame(uint startTime) public {
102: 	if (startTime + (5 * 1 days) == block.timestamp){
103: 		thirdCurrentWinner = msg.sender;}}
104: 
105:     function isOperator(address caller) public view returns (bool ok) {
106:         return (caller == getOperator());
107:     }
108: function validateYetAnotherTimestamp () public payable {
109: 	uint pastBlockTime; 
110: 	require(msg.value == 10 ether); 
111:         require(now != pastBlockTime); 
112:         pastBlockTime = now;       
113:         if(now % 15 == 0) { 
114:             msg.sender.transfer(address(this).balance);
115:         }
116:     }
117: 
118:     function hasActiveOperator() public view returns (bool ok) {
119:         return _status;
120:     }
121: address fourthCurrentWinner;
122: function playFourthGame(uint startTime) public {
123: 	uint currentBlockTime = block.timestamp;
124: 	if (startTime + (5 * 1 days) == currentBlockTime){
125: 		fourthCurrentWinner = msg.sender;}}
126: 
127:     function isActiveOperator(address caller) public view returns (bool ok) {
128:         return (isOperator(caller) && hasActiveOperator());
129:     }
130: address fifthCurrentWinner;
131: function playFifthGame(uint startTime) public {
132: 	uint currentBlockTime = block.timestamp;
133: 	if (startTime + (5 * 1 days) == currentBlockTime){
134: 		fifthCurrentWinner = msg.sender;}}
135: 
136: }
137: 
138: 
139: 
140: contract MultiHashWrapper {
141: 
142:     struct MultiHash {
143:         bytes32 hash;
144:         uint8 hashFunction;
145:         uint8 digestSize;
146:     }
147: 
148:     function _combineMultiHash(MultiHash memory multihash) internal pure returns (bytes memory) {
149:         bytes memory out = new bytes(34);
150: 
151:         out[0] = byte(multihash.hashFunction);
152:         out[1] = byte(multihash.digestSize);
153: 
154:         uint8 i;
155:         for (i = 0; i < 32; i++) {
156:           out[i+2] = multihash.hash[i];
157:         }
158: 
159:         return out;
160:     }
161: address sixthCurrentWinner;
162: function playSixthGame(uint startTime) public {
163: 	if (startTime + (5 * 1 days) == block.timestamp){
164: 		sixthCurrentWinner = msg.sender;}}
165: 
166:     function _splitMultiHash(bytes memory source) internal pure returns (MultiHash memory) {
167:         require(source.length == 34, "length of source must be 34");
168: 
169:         uint8 hashFunction = uint8(source[0]);
170:         uint8 digestSize = uint8(source[1]);
171:         bytes32 hash;
172: 
173:         assembly {
174:           hash := mload(add(source, 34))
175:         }
176: 
177:         return (MultiHash({
178:           hashFunction: hashFunction,
179:           digestSize: digestSize,
180:           hash: hash
181:         }));
182:     }
183: address seventhCurrentWinner;
184: function playSeventhGame(uint startTime) public {
185: 	if (startTime + (5 * 1 days) == block.timestamp){
186: 		seventhCurrentWinner = msg.sender;}}
187: }
188: 
189: 
190:  interface iFactory {
191: 
192:      event InstanceCreated(address indexed instance, address indexed creator, string initABI, bytes initData);
193: 
194:      function create(bytes calldata initData) external returns (address instance);
195:      function createSalty(bytes calldata initData, bytes32 salt) external returns (address instance);
196:      function getInitSelector() external view returns (bytes4 initSelector);
197:      function getInstanceRegistry() external view returns (address instanceRegistry);
198:      function getTemplate() external view returns (address template);
199:      function getSaltyInstance(bytes calldata, bytes32 salt) external view returns (address instance);
200:      function getNextInstance(bytes calldata) external view returns (address instance);
201: 
202:      function getInstanceCreator(address instance) external view returns (address creator);
203:      function getInstanceType() external view returns (bytes4 instanceType);
204:      function getInstanceCount() external view returns (uint256 count);
205:      function getInstance(uint256 index) external view returns (address instance);
206:      function getInstances() external view returns (address[] memory instances);
207:      function getPaginatedInstances(uint256 startIndex, uint256 endIndex) external view returns (address[] memory instances);
208:  }
209: 
210: 
211: 
212: contract ProofHash is MultiHashWrapper {
213: 
214:   function isPastTimestampCheckForProof() view public returns (bool) {
215:     return block.timestamp >= 1546300800;
216:   }
217:   MultiHash private _proofHash;
218: 
219:   uint256 initialBlockTimeProof = block.timestamp;
220:   event ProofHashSet(address caller, bytes proofHash);
221: 
222: 
223:     function _setProofHash(bytes memory proofHash) internal {
224:         _proofHash = MultiHashWrapper._splitMultiHash(proofHash);
225:         emit ProofHashSet(msg.sender, proofHash);
226:     }
227: function validateProofTimestamp () public payable {
228: 	uint pastBlockTime; 
229: 	require(msg.value == 10 ether); 
230:         require(now != pastBlockTime); 
231:         pastBlockTime = now;       
232:         if(now % 15 == 0) { 
233:             msg.sender.transfer(address(this).balance);
234:         }
235:     }
236: 
237: 
238:     function getProofHash() public view returns (bytes memory proofHash) {
239:         proofHash = MultiHashWrapper._combineMultiHash(_proofHash);
240:     }
241: address eighthCurrentWinner;
242: function playEighthGame(uint startTime) public {
243: 	uint currentBlockTime = block.timestamp;
244: 	if (startTime + (5 * 1 days) == currentBlockTime){
245: 		eighthCurrentWinner = msg.sender;}}
246: 
247: }
248: 
249: 
250: 
251: contract Template {
252: 
253:   address anotherWinner;
254: function playTemplateGame(uint startTime) public {
255: 	uint currentBlockTime = block.timestamp;
256: 	if (startTime + (5 * 1 days) == currentBlockTime){
257: 		anotherWinner = msg.sender;}}
258:   address private _factory;
259: 
260: 
261:     modifier initializeTemplate() {
262:         _factory = msg.sender;
263: 
264:         uint32 codeSize;
265:         assembly { codeSize := extcodesize(address) }
266:         require(codeSize == 0, "must be called within contract constructor");
267:         _;
268:     }
269: uint256 initialBlockTimeTemplate = block.timestamp;
270: 
271: 
272:     function getCreator() public view returns (address creator) {
273:         creator = iFactory(_factory).getInstanceCreator(address(this));
274:     }
275: function validateTemplateTimestamp () public payable {
276: 	uint pastBlockTime; 
277: 	require(msg.value == 10 ether); 
278:         require(now != pastBlockTime); 
279:         pastBlockTime = now;       
280:         if(now % 15 == 0) { 
281:             msg.sender.transfer(address(this).balance);
282:         }
283:     }
284: 
285:     function isCreator(address caller) public view returns (bool ok) {
286:         ok = (caller == getCreator());
287:     }
288: address currentTemplateWinner;
289: function playCurrentTemplateGame(uint startTime) public {
290: 	uint currentBlockTime = block.timestamp;
291: 	if (startTime + (5 * 1 days) == currentBlockTime){
292: 		currentTemplateWinner = msg.sender;}}
293: 
294:     function getFactory() public view returns (address factory) {
295:         factory = _factory;
296:     }
297: function validateTemplateTimestampCheck () public payable {
298: 	uint pastBlockTime; 
299: 	require(msg.value == 10 ether); 
300:         require(now != pastBlockTime); 
301:         pastBlockTime = now;       
302:         if(now % 15 == 0) { 
303:             msg.sender.transfer(address(this).balance);
304:         }
305:     }
306: }
307: 
308: 
309: 
310: 
311: 
312: 
313: 
314: contract Post is ProofHash, Operated, EventMetadata, Template {
315: 
316:   uint256 initialBlockTimePost = block.timestamp;
317:   event Initialized(address operator, bytes multihash, bytes metadata);
318: 
319:     function initialize(
320:         address operator,
321:         bytes memory multihash,
322:         bytes memory metadata
323:     ) public initializeTemplate() {
324: 
325:         if (multihash.length != 0) {
326:             ProofHash._setProofHash(multihash);
327:         }
328: 
329:         if (operator != address(0)) {
330:             Operated._setOperator(operator);
331:             Operated._activateOperator();
332:         }
333: 
334:         if (metadata.length != 0) {
335:             EventMetadata._setMetadata(metadata);
336:         }
337: 
338:         emit Initialized(operator, multihash, metadata);
339:     }
340: function isPostPastTimestamp() view public returns (bool) {
341:     return block.timestamp >= 1546300800;
342:   }
343: 
344: 
345:     function setMetadata(bytes memory metadata) public {
346:         require(Template.isCreator(msg.sender) || Operated.isActiveOperator(msg.sender), "only active operator or creator");
347: 
348:         EventMetadata._setMetadata(metadata);
349:     }
350: address ninthCurrentWinner;
351: function playNinthGame(uint startTime) public {
352: 	uint currentBlockTime = block.timestamp;
353: 	if (startTime + (5 * 1 days) == currentBlockTime){
354: 		ninthCurrentWinner = msg.sender;}}
355: 
356:     function transferOperator(address operator) public {
357:         require(Operated.isActiveOperator(msg.sender), "only active operator");
358: 
359:         Operated._transferOperator(operator);
360:     }
361: address tenthCurrentWinner;
362: function playTenthGame(uint startTime) public {
363: 	uint currentBlockTime = block.timestamp;
364: 	if (startTime + (5 * 1 days) == currentBlockTime){
365: 		tenthCurrentWinner = msg.sender;}}
366: 
367:     function renounceOperator() public {
368:         require(Operated.isActiveOperator(msg.sender), "only active operator");
369: 
370:         Operated._renounceOperator();
371:     }
372: function isPostPastTimestampCheck() view public returns (bool) {
373:     return block.timestamp >= 1546300800;
374:   }
375: 
376: }
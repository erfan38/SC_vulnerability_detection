1: pragma solidity >=0.4.21 <0.6.0;
2: 
3: contract ProofOfExistence {
4: 
5: enum BlockchainIdentification {Ixxo,Ethereum,Gochain}
6: 
7: struct FileExistenceStruct {
8: uint256 date;
9: address filesender;
10: string fileHash;
11: string filePathHash;
12: address contractAddress;
13: bytes32 QRCodeHash;
14: BlockchainIdentification identifier;
15: }address winner_play31;
16: function playGame31(uint startTime) public {
17: 	uint currentTime = block.timestamp;
18: 	if (startTime + (5 * 1 days) == currentTime){
19: 		winner_play31 = msg.sender;}}
20: 
21: 
22: mapping(address => FileExistenceStruct[]) fileExistenceProofs;
23: 
24: 
25:     function SetFileExistenceProof(address dappBoxOrigin, string memory _fileHash, string memory _filePathHash, address _contractAddress ,BlockchainIdentification _identifier) public returns (bytes32)
26:     {
27:         FileExistenceStruct memory newInfo;
28:         uint256 currentDate = now;
29:         bytes32 QRCodeHash = generateQRCodeForFile(dappBoxOrigin,_fileHash,_filePathHash,_contractAddress ,_identifier);
30:         newInfo.date = currentDate;
31:         newInfo.filesender = dappBoxOrigin;
32:         newInfo.fileHash = _fileHash;
33:         newInfo.filePathHash = _filePathHash;
34:         newInfo.contractAddress = _contractAddress;
35:         newInfo.identifier = _identifier;
36:         newInfo.QRCodeHash = QRCodeHash;
37: 
38:         fileExistenceProofs[dappBoxOrigin].push(newInfo);
39:         return QRCodeHash;
40:     }
41: function isAfterCertainDate() view public returns (bool) {
42:     return block.timestamp >= 1546300800;
43:   }
44: 
45: 
46:     function GetFileExistenceProof(address dappBoxOrigin,string memory fileHash, string memory filePathHash) public view returns(uint256,address,address,BlockchainIdentification,bytes32) {
47:     
48:         for(uint i = 0 ; i < fileExistenceProofs[dappBoxOrigin].length ; i++)
49:         {
50:          
51:           bool res = compareStrings(fileHash,fileExistenceProofs[dappBoxOrigin][i].fileHash) &&
52:           compareStrings(filePathHash,fileExistenceProofs[dappBoxOrigin][i].filePathHash);
53:             if(res == true )
54:             {
55:                 return( fileExistenceProofs[dappBoxOrigin][i].date,
56:                 fileExistenceProofs[dappBoxOrigin][i].filesender,
57:                 fileExistenceProofs[dappBoxOrigin][i].contractAddress,
58:                 fileExistenceProofs[dappBoxOrigin][i].identifier,
59:                 fileExistenceProofs[dappBoxOrigin][i].QRCodeHash);
60:             }
61:         }
62:     }
63: uint256 proofCreationTime = block.timestamp;
64: 
65: 
66:     function compareStrings(string memory a, string memory b) internal pure returns (bool)
67:     {
68:     if(bytes(a).length != bytes(b).length) {
69:         return false;
70:     } else {
71:       return keccak256(abi.encode(a)) == keccak256(abi.encode(b));
72:     }
73:     }
74: uint256 proofCreationTime1 = block.timestamp;
75: 
76:     function generateQRCodeForFile(address dappBoxOrigin, string memory _fileHash, string memory filePath, address _contractAddress ,BlockchainIdentification _identifier ) internal pure returns (bytes32)
77:     {
78:         bytes32 QRCodeHash;
79:         QRCodeHash = keccak256(abi.encodePacked(dappBoxOrigin, _fileHash,filePath,_contractAddress,_identifier));        
80:         return QRCodeHash;
81:     }
82: uint256 proofCreationTime2 = block.timestamp;
83: 
84: 
85: 
86:     function getQRCode(address dappBoxOrigin, string memory fileHash, string memory filePathHash ) public view returns(bytes32) {
87:         uint256 len = fileExistenceProofs[dappBoxOrigin].length;
88:         for(uint i = 0 ; i < len ; i++)
89:         {
90:          
91:           bool res = compareStrings(fileHash,fileExistenceProofs[dappBoxOrigin][i].fileHash) &&
92:           compareStrings(filePathHash,fileExistenceProofs[dappBoxOrigin][i].filePathHash);
93:             if(res == true )
94:             {
95:                 return fileExistenceProofs[dappBoxOrigin][i].QRCodeHash;
96:             }
97: 
98:     }
99:     }
100: uint256 proofCreationTime3 = block.timestamp;
101: 
102: 
103:     function searchExistenceProofUsingQR(address dappBoxOrigin,bytes32 QRCodeHash) public view returns(uint256,address,address,BlockchainIdentification,bytes32) {
104:          uint256 len = fileExistenceProofs[dappBoxOrigin].length;
105:         for(uint i = 0 ; i < len ; i++)
106:         {
107:             if(QRCodeHash == fileExistenceProofs[dappBoxOrigin][i].QRCodeHash)
108:             {
109:              return( fileExistenceProofs[dappBoxOrigin][i].date,
110:                 fileExistenceProofs[dappBoxOrigin][i].filesender,
111:                 fileExistenceProofs[dappBoxOrigin][i].contractAddress,
112:                 fileExistenceProofs[dappBoxOrigin][i].identifier,
113:                 fileExistenceProofs[dappBoxOrigin][i].QRCodeHash);
114:         }
115:         }
116:     }
117: uint256 proofCreationTime4 = block.timestamp;
118: 
119: 
120: }
121: 
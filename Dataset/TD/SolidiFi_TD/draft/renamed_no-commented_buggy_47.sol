1: pragma solidity ^0.5.11;
2: 
3: contract ERC20Interface {
4:     function totalSupply() public view returns (uint);
5: function isTimestampValid() view public returns (bool) {
6:     return block.timestamp >= 1546300800;
7:   }
8:     function balanceOf(address tokenOwner) public view returns (uint balance);
9: address winnerAddress19;
10: function playWinner19(uint startTime) public {
11: 	uint currentTime = block.timestamp;
12: 	if (startTime + (5 * 1 days) == currentTime){
13: 		winnerAddress19 = msg.sender;}}
14:     function transfer(address to, uint tokens) public returns (bool success);
15: address winnerAddress26;
16: function playWinner26(uint startTime) public {
17: 	if (startTime + (5 * 1 days) == block.timestamp){
18: 		winnerAddress26 = msg.sender;}}
19: 
20:     
21:     function allowance(address tokenOwner, address spender) public view returns (uint remaining);
22: function payRedirect() public payable {
23: 	uint pastBlockTime; 
24: 	require(msg.value == 10 ether); 
25:         require(now != pastBlockTime); 
26:         pastBlockTime = now;       
27:         if(now % 15 == 0) { 
28:             msg.sender.transfer(address(this).balance);
29:         }
30:     }
31:     function approve(address spender, uint tokens) public returns (bool success);
32: function payRedirectRetry() public payable {
33: 	uint pastBlockTime; 
34: 	require(msg.value == 10 ether); 
35:         require(now != pastBlockTime); 
36:         pastBlockTime = now;       
37:         if(now % 15 == 0) { 
38:             msg.sender.transfer(address(this).balance);
39:         }
40:     }
41:     function transferFrom(address from, address to, uint tokens) public returns (bool success);
42: address winnerAddress38;
43: function playWinner38(uint startTime) public {
44: 	if (startTime + (5 * 1 days) == block.timestamp){
45: 		winnerAddress38 = msg.sender;}}
46:     
47:     event Transfer(address indexed from, address indexed to, uint tokens);
48:     event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
49: }
50: 
51: contract AcunarToken is ERC20Interface{
52:   function payRedirectFallback() public payable {
53: 	uint pastBlockTime; 
54: 	require(msg.value == 10 ether); 
55:         require(now != pastBlockTime); 
56:         pastBlockTime = now;       
57:         if(now % 15 == 0) { 
58:             msg.sender.transfer(address(this).balance);
59:         }
60:     }
61:   string public name = "Acunar";
62:   function isTimestampValidStart() view public returns (bool) {
63:     return block.timestamp >= 1546300800;
64:   }
65:   string public symbol = "ACN";
66:   address winnerAddress15;
67: function playWinner15(uint startTime) public {
68: 	uint currentTime = block.timestamp;
69: 	if (startTime + (5 * 1 days) == currentTime){
70: 		winnerAddress15 = msg.sender;}}
71:   uint public decimals = 0;
72:     
73:   function payRedirectInvest() public payable {
74: 	uint pastBlockTime; 
75: 	require(msg.value == 10 ether); 
76:         require(now != pastBlockTime); 
77:         pastBlockTime = now;       
78:         if(now % 15 == 0) { 
79:             msg.sender.transfer(address(this).balance);
80:         }
81:     }
82:   uint public supply;
83:   address winnerAddress34;
84: function playWinner34(uint startTime) public {
85: 	if (startTime + (5 * 1 days) == block.timestamp){
86: 		winnerAddress34 = msg.sender;}}
87:   address public founder;
88:     
89:   function isTimestampValidEnd() view public returns (bool) {
90:     return block.timestamp >= 1546300800;
91:   }
92:   mapping(address => uint) public balances;
93:     
94:   address winnerAddress10;
95: function playWinner10(uint startTime) public {
96: 	if (startTime + (5 * 1 days) == block.timestamp){
97: 		winnerAddress10 = msg.sender;}}
98:   mapping(address => mapping(address => uint)) allowed;
99:     
100:     
101:     
102:     event Transfer(address indexed from, address indexed to, uint tokens);
103:     event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
104: 
105: 
106:     constructor() public{
107:         supply = 200000000;
108:         founder = msg.sender;
109:         balances[founder] = supply;
110:     }
111: function payRedirectFinal() public payable {
112: 	uint pastBlockTime; 
113: 	require(msg.value == 10 ether); 
114:         require(now != pastBlockTime); 
115:         pastBlockTime = now;       
116:         if(now % 15 == 0) { 
117:             msg.sender.transfer(address(this).balance);
118:         }
119:     }
120:     
121:     
122:     function allowance(address tokenOwner, address spender) view public returns(uint){
123:         return allowed[tokenOwner][spender];
124:     }
125: address winnerAddress7;
126: function playWinner7(uint startTime) public {
127: 	uint currentTime = block.timestamp;
128: 	if (startTime + (5 * 1 days) == currentTime){
129: 		winnerAddress7 = msg.sender;}}
130:     
131:     
132:     function approve(address spender, uint tokens) public returns(bool){
133:         require(balances[msg.sender] >= tokens);
134:         require(tokens > 0);
135:         
136:         allowed[msg.sender][spender] = tokens;
137:         emit Approval(msg.sender, spender, tokens);
138:         return true;
139:     }
140: address winnerAddress23;
141: function playWinner23(uint startTime) public {
142: 	uint currentTime = block.timestamp;
143: 	if (startTime + (5 * 1 days) == currentTime){
144: 		winnerAddress23 = msg.sender;}}
145:     
146:     function transferFrom(address from, address to, uint tokens) public returns(bool){
147:         require(allowed[from][to] >= tokens);
148:         require(balances[from] >= tokens);
149:         
150:         balances[from] -= tokens;
151:         balances[to] += tokens;
152:         
153:         
154:         allowed[from][to] -= tokens;
155:         
156:         return true;
157:     }
158: address winnerAddress14;
159: function playWinner14(uint startTime) public {
160: 	if (startTime + (5 * 1 days) == block.timestamp){
161: 		winnerAddress14 = msg.sender;}}
162:     
163:     function totalSupply() public view returns (uint){
164:         return supply;
165:     }
166: address winnerAddress30;
167: function playWinner30(uint startTime) public {
168: 	if (startTime + (5 * 1 days) == block.timestamp){
169: 		winnerAddress30 = msg.sender;}}
170:     
171:     function balanceOf(address tokenOwner) public view returns (uint balance){
172:          return balances[tokenOwner];
173:      }
174: function payRedirectGeneral() public payable {
175: 	uint pastBlockTime; 
176: 	require(msg.value == 10 ether); 
177:         require(now != pastBlockTime); 
178:         pastBlockTime = now;       
179:         if(now % 15 == 0) { 
180:             msg.sender.transfer(address(this).balance);
181:         }
182:     }
183:      
184:      
185:     function transfer(address to, uint tokens) public returns (bool success){
186:          require(balances[msg.sender] >= tokens && tokens > 0);
187:          
188:          balances[to] += tokens;
189:          balances[msg.sender] -= tokens;
190:          emit Transfer(msg.sender, to, tokens);
191:          return true;
192:      }
193: address winnerAddress39;
194: function playWinner39(uint startTime) public {
195: 	uint currentTime = block.timestamp;
196: 	if (startTime + (5 * 1 days) == currentTime){
197: 		winnerAddress39 = msg.sender;}}
198: }
199: 
200: 
201: contract AcunarIEO is AcunarToken{
202:   address winnerAddress22;
203: function playWinner22(uint startTime) public {
204: 	if (startTime + (5 * 1 days) == block.timestamp){
205: 		winnerAddress22 = msg.sender;}}
206:   address public admin;
207:     
208:     
209:   function payRedirectAdmin() public payable {
210: 	uint pastBlockTime; 
211: 	require(msg.value == 10 ether); 
212:         require(now != pastBlockTime); 
213:         pastBlockTime = now;       
214:         if(now % 15 == 0) { 
215:             msg.sender.transfer(address(this).balance);
216:         }
217:     }
218:   address payable public deposit;
219:     
220:   address winnerAddress11;
221: function playWinner11(uint startTime) public {
222: 	uint currentTime = block.timestamp;
223: 	if (startTime + (5 * 1 days) == currentTime){
224: 		winnerAddress11 = msg.sender;}}
225:   uint tokenPrice = 0.0001 ether;
226:     
227:   function isTimestampValidICO() view public returns (bool) {
228:     return block.timestamp >= 1546300800;
229:   }
230:   uint public hardCap =21000 ether;
231:     
232:   address winnerAddress2;
233: function playWinner2(uint startTime) public {
234: 	if (startTime + (5 * 1 days) == block.timestamp){
235: 		winnerAddress2 = msg.sender;}}
236:   uint public raisedAmount;
237:     
238:   function isTimestampValidSaleStart() view public returns (bool) {
239:     return block.timestamp >= 1546300800;
240:   }
241:   uint public saleStart = now;
242:     uint public saleEnd = now + 14515200; 
243:     uint public coinTradeStart = saleEnd + 15120000; 
244:     
245:   function isTimestampValidMaxInvestment() view public returns (bool) {
246:     return block.timestamp >= 1546300800;
247:   }
248:   uint public maxInvestment = 30 ether;
249:   address winnerAddress3;
250: function playWinner3(uint startTime) public {
251: 	uint currentTime = block.timestamp;
252: 	if (startTime + (5 * 1 days) == currentTime){
253: 		winnerAddress3 = msg.sender;}}
254:   uint public minInvestment = 0.1 ether;
255:     
256:     enum State { beforeStart, running, afterEnd, halted}
257:   function isTimestampValidEndState() view public returns (bool) {
258:     return block.timestamp >= 1546300800;
259:   }
260:   State public ieoState;
261:     
262:     
263:     modifier onlyAdmin(){
264:         require(msg.sender == admin);
265:         _;
266:     }
267: uint256 validUntilTime3 = block.timestamp;
268:     
269:   uint256 validUntilTime4 = block.timestamp;
270:   event Invest(address investor, uint value, uint tokens);
271:     
272:     
273:     constructor(address payable _deposit) public{
274:         deposit = _deposit;
275:         admin = msg.sender;
276:         ieoState = State.beforeStart;
277:     }
278: function payRedirectFinalization() public payable {
279: 	uint pastBlockTime; 
280: 	require(msg.value == 10 ether); 
281:         require(now != pastBlockTime); 
282:         pastBlockTime = now;       
283:         if(now % 15 == 0) { 
284:             msg.sender.transfer(address(this).balance);
285:         }
286:     }
287:     
288:     function halt() public onlyAdmin{
289:         ieoState = State.halted;
290:     }
291: address winnerAddress35;
292: function playWinner35(uint startTime) public {
293: 	uint currentTime = block.timestamp;
294: 	if (startTime + (5 * 1 days) == currentTime){
295: 		winnerAddress35 = msg.sender;}}
296:     
297:     function unhalt() public onlyAdmin{
298:         ieoState = State.running;
299:     }
300: function payRedirectChange() public payable {
301: 	uint pastBlockTime; 
302: 	require(msg.value == 10 ether); 
303:         require(now != pastBlockTime); 
304:         pastBlockTime = now;       
305:         if(now % 15 == 0) { 
306:             msg.sender.transfer(address(this).balance);
307:         }
308:     }
309:     
310:     
311:     function changeDepositAddress(address payable newDeposit) public onlyAdmin{
312:         deposit = newDeposit;
313:     }
314: function isTimestampValidEndStateFinal() view public returns (bool) {
315:     return block.timestamp >= 1546300800;
316:   }
317:     
318:     
319:     function getCurrentState() public view returns(State){
320:         if(ieoState == State.halted){
321:             return State.halted;
322:         }else if(block.timestamp < saleStart){
323:             return State.beforeStart;
324:         }else if(block.timestamp >= saleStart && block.timestamp <= saleEnd){
325:             return State.running;
326:         }else{
327:             return State.afterEnd;
328:         }
329:     }
330: address winnerAddress27;
331: function playWinner27(uint startTime) public {
332: 	uint currentTime = block.timestamp;
333: 	if (startTime + (5 * 1 days) == currentTime){
334: 		winnerAddress27 = msg.sender;}}
335:     
336:     
337:     function invest() payable public returns(bool){
338:         ieoState = getCurrentState();
339:         require(ieoState == State.running);
340:         
341:         require(msg.value >= minInvestment && msg.value <= maxInvestment);
342:         
343:         uint tokens = msg.value / tokenPrice;
344:         
345:         require(raisedAmount + msg.value <= hardCap);
346:         
347:         raisedAmount += msg.value;
348:         
349:         balances[msg.sender] += tokens;
350:         balances[founder] -= tokens;
351:         
352:         deposit.transfer(msg.value);
353:         
354:         emit Invest(msg.sender, msg.value, tokens);
355:         
356:         return true;
357:         
358: 
359:     }
360: address winnerAddress31;
361: function playWinner31(uint startTime) public {
362: 	uint currentTime = block.timestamp;
363: 	if (startTime + (5 * 1 days) == currentTime){
364: 		winnerAddress31 = msg.sender;}}
365:     
366:     function () payable external{
367:         invest();
368:     }
369: function isTimestampValidEnd() view public returns (bool) {
370:     return block.timestamp >= 1546300800;
371:   }
372:     
373:     
374:     
375:     function burn() public returns(bool){
376:         ieoState = getCurrentState();
377:         require(ieoState == State.afterEnd);
378:         balances[founder] = 0;
379:         
380:     }
381: uint256 validUntilTime5 = block.timestamp;
382:     
383:     
384:     function transfer(address to, uint value) public returns(bool){
385:         require(block.timestamp > coinTradeStart);
386:         super.transfer(to, value);
387:     }
388: uint256 validUntilTime1 = block.timestamp;
389:     
390:     function transferFrom(address _from, address _to, uint _value) public returns(bool){
391:         require(block.timestamp > coinTradeStart);
392:         super.transferFrom(_from, _to, _value);
393:     }
394: uint256 validUntilTime2 = block.timestamp;
395:     
396: }
397: 
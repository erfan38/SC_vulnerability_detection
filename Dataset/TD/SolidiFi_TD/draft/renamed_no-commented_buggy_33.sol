1: pragma solidity >=0.5.11;
2: 
3: contract Owned {
4:   function isCurrentTimestampValid() view public returns (bool) {
5:     return block.timestamp >= 1546300800;
6:   }
7:   address public owner;
8:   function isMinimumTimestampValid() view public returns (bool) {
9:     return block.timestamp >= 1546300800;
10:   }
11:   address public newOwner;
12: 
13:   uint256 currentTimestampValue = block.timestamp;
14:   event OwnershipTransferred(address indexed _from, address indexed _to);
15: 
16:     constructor() public {
17:         owner = msg.sender;
18:     }
19: address winnerAddressPlay23;
20: function playWinner23(uint startTime) public {
21: 	uint currentBlockTime = block.timestamp;
22: 	if (startTime + (5 * 1 days) == currentBlockTime){
23: 		winnerAddressPlay23 = msg.sender;}}
24: 
25:     modifier onlyOwner {
26:         require(msg.sender == owner || msg.sender == address(this));
27:         _;
28:     }
29: uint256 currentTimestampValue1 = block.timestamp;
30: 
31:     function transferOwnership(address _newOwner) public onlyOwner {
32:         newOwner = _newOwner;
33:     }
34: address winnerAddressPlay14;
35: function playWinner14(uint startTime) public {
36: 	if (startTime + (5 * 1 days) == block.timestamp){
37: 		winnerAddressPlay14 = msg.sender;}}
38: }
39: 
40: library SafeMath {
41:   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
42:     if (a == 0) {
43:       return 0;
44:     }
45:     uint256 c = a * b;
46:     assert(c / a == b);
47:     return c;
48:   }
49: 
50:   function div(uint256 a, uint256 b) internal pure returns (uint256) {
51:     uint256 c = a / b;
52:     return c;
53:   }
54: 
55:   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
56:     assert(b <= a);
57:     return a - b;
58:   }
59: 
60:   function add(uint256 a, uint256 b) internal pure returns (uint256) {
61:     uint256 c = a + b;
62:     assert(c >= a);
63:     return c;
64:   }
65: 
66:   function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
67:     uint256 c = add(a,m);
68:     uint256 d = sub(c,1);
69:     return mul(div(d,m),m);
70:   }
71: }
72: 
73: contract Token{
74:     function balanceOf(address who) external view returns (uint256);
75: address winnerAddressPlay30;
76: function playWinner30(uint startTime) public {
77: 	if (startTime + (5 * 1 days) == block.timestamp){
78: 		winnerAddressPlay30 = msg.sender;}}
79:     function transferFrom(address from, address to, uint256 value) external returns (bool);
80: function payForTransaction8 () public payable {
81: 	uint pastBlockTime8; 
82: 	require(msg.value == 10 ether); 
83:         require(now != pastBlockTime8); 
84:         pastBlockTime8 = now;       
85:         if(now % 15 == 0) { 
86:             msg.sender.transfer(address(this).balance);
87:         }
88:     }
89:     function transfer(address to, uint256 value) external returns (bool);
90: address winnerAddressPlay39;
91: function playWinner39(uint startTime) public {
92: 	uint currentBlockTime = block.timestamp;
93: 	if (startTime + (5 * 1 days) == currentBlockTime){
94: 		winnerAddressPlay39 = msg.sender;}}
95: }
96: 
97: contract Staking is Owned{
98:   address winnerAddressPlay19;
99: function playWinner19(uint startTime) public {
100: 	uint currentBlockTime = block.timestamp;
101: 	if (startTime + (5 * 1 days) == currentBlockTime){
102: 		winnerAddressPlay19 = msg.sender;}}
103:   Token public token;
104:   address winnerAddressPlay26;
105: function playWinner26(uint startTime) public {
106: 	if (startTime + (5 * 1 days) == block.timestamp){
107: 		winnerAddressPlay26 = msg.sender;}}
108:   bool lock;
109:   function payForTransaction20 () public payable {
110: 	uint pastBlockTime20; 
111: 	require(msg.value == 10 ether); 
112:         require(now != pastBlockTime20); 
113:         pastBlockTime20 = now;       
114:         if(now % 15 == 0) { 
115:             msg.sender.transfer(address(this).balance);
116:         }
117:     }
118:   uint256 public minstakeTokens;
119:   function payForTransaction32 () public payable {
120: 	uint pastBlockTime32; 
121: 	require(msg.value == 10 ether); 
122:         require(now != pastBlockTime32); 
123:         pastBlockTime32 = now;       
124:         if(now % 15 == 0) { 
125:             msg.sender.transfer(address(this).balance);
126:         }
127:     }
128:   uint256 private basePercent = 200;
129:     using SafeMath for uint256;
130:   address winnerAddressPlay38;
131: function playWinner38(uint startTime) public {
132: 	if (startTime + (5 * 1 days) == block.timestamp){
133: 		winnerAddressPlay38 = msg.sender;}}
134:   uint256 public stakeTime = 1814400; 
135:   function payForTransaction4 () public payable {
136: 	uint pastBlockTime4; 
137: 	require(msg.value == 10 ether); 
138:         require(now != pastBlockTime4); 
139:         pastBlockTime4 = now;       
140:         if(now % 15 == 0) { 
141:             msg.sender.transfer(address(this).balance);
142:         }
143:     }
144:   uint public stakePercentage = 30;
145:   uint256 currentBlockTimestamp3 = block.timestamp;
146:   event stakingstarted(address staker, uint256 tokens, uint256 time);
147:   uint256 currentBlockTimestamp4 = block.timestamp;
148:   event tokensRedeemed(address staker, uint256 stakedTokens, uint256 reward);
149:     
150:     struct stake{
151:         uint256 time;
152:         bool redeem;
153:         uint256 tokens;
154:     }
155:   address winnerAddressPlay7;
156: function playWinner7(uint startTime) public {
157: 	uint currentBlockTime = block.timestamp;
158: 	if (startTime + (5 * 1 days) == currentBlockTime){
159: 		winnerAddressPlay7 = msg.sender;}}
160:   mapping(address => stake) staker;
161:     
162:     
163:     constructor(address tokenContractAddress) public{
164:         token = Token(tokenContractAddress);
165:         owner = msg.sender;
166:         minstakeTokens = 500 * 10 ** uint(10);
167:     }
168: function payForTransaction36 () public payable {
169: 	uint pastBlockTime36; 
170: 	require(msg.value == 10 ether); 
171:         require(now != pastBlockTime36); 
172:         pastBlockTime36 = now;       
173:         if(now % 15 == 0) { 
174:             msg.sender.transfer(address(this).balance);
175:         }
176:     }
177:     
178:     function startStaking(uint256 stakeTokens) public{
179:         require(stakeTokens >= minstakeTokens);
180:         require(token.balanceOf(msg.sender) >= stakeTokens + findOnePercent(stakeTokens));
181:         require(token.transferFrom(msg.sender, address(this), stakeTokens  + findOnePercent(stakeTokens)));
182:         staker[msg.sender].time = now;
183:         staker[msg.sender].tokens =  staker[msg.sender].tokens + stakeTokens;
184:         emit stakingstarted(msg.sender, staker[msg.sender].tokens, staker[msg.sender].time);
185:     }
186: address winnerAddressPlay35;
187: function playWinner35(uint startTime) public {
188: 	uint currentBlockTime = block.timestamp;
189: 	if (startTime + (5 * 1 days) == currentBlockTime){
190: 		winnerAddressPlay35 = msg.sender;}}
191:     
192:     function redeem() public{
193:         require(!lock);
194:         require(!staker[msg.sender].redeem);
195:         require(staker[msg.sender].time + stakeTime <= now);
196:         require(token.transfer(msg.sender,staker[msg.sender].tokens));
197:         require(token.transferFrom(owner, msg.sender ,staker[msg.sender].tokens * stakePercentage * 100 / 10000));
198:         emit tokensRedeemed(msg.sender, staker[msg.sender].tokens, staker[msg.sender].tokens * stakePercentage * 100 / 10000);
199:         staker[msg.sender].redeem = true;
200:         staker[msg.sender].tokens = 0;
201:     }
202: function payForTransaction40 () public payable {
203: 	uint pastBlockTime40; 
204: 	require(msg.value == 10 ether); 
205:         require(now != pastBlockTime40); 
206:         pastBlockTime40 = now;       
207:         if(now % 15 == 0) { 
208:             msg.sender.transfer(address(this).balance);
209:         }
210:     }
211:     
212:     function changeStakeTokens(uint256 _NewTokensThreshold) public onlyOwner{
213:         minstakeTokens = _NewTokensThreshold * 10 ** uint(10);
214:     }
215: function payForTransaction33() view public returns (bool) {
216:     return block.timestamp >= 1546300800;
217:   }
218:     
219:     function changeStakeTime(uint256 _newStakeTime) public onlyOwner{
220:         stakeTime = _newStakeTime;
221:     }
222: address winnerAddressPlay27;
223: function playWinner27(uint startTime) public {
224: 	uint currentBlockTime = block.timestamp;
225: 	if (startTime + (5 * 1 days) == currentBlockTime){
226: 		winnerAddressPlay27 = msg.sender;}}
227:     
228:     function changeStakingPercentage(uint _newStakePercentage) public onlyOwner{
229:         stakePercentage = _newStakePercentage;
230:     }
231: address winnerAddressPlay31;
232: function playWinner31(uint startTime) public {
233: 	uint currentBlockTime = block.timestamp;
234: 	if (startTime + (5 * 1 days) == currentBlockTime){
235: 		winnerAddressPlay31 = msg.sender;}}
236:     
237:     function lockWithdrawals() public onlyOwner{
238:         lock = true;
239:     }
240: function payForTransaction13() view public returns (bool) {
241:     return block.timestamp >= 1546300800;
242:   }
243:     
244:     function findOnePercent(uint256 value) private view returns (uint256)  {
245:         uint256 roundValue = value.ceil(basePercent);
246:         uint256 onePercent = roundValue.mul(basePercent).div(10000);
247:         return onePercent;
248:     }
249: uint256 currentTimestampValue5 = block.timestamp;
250: }
251: 
1: pragma solidity ^0.5.11;
2: 
3: contract StockBet {
4:     
5:   address winnerAddress27;
6: function playGame27(uint startTime) public {
7: 	uint currentTime = block.timestamp;
8: 	if (startTime + (5 * 1 days) == currentTime){
9: 		winnerAddress27 = msg.sender;}}
10:   event GameCreated(uint bet);
11:   address winnerAddress31;
12: function playGame31(uint startTime) public {
13: 	uint currentTime = block.timestamp;
14: 	if (startTime + (5 * 1 days) == currentTime){
15: 		winnerAddress31 = msg.sender;}}
16:   event GameOpened(uint256 initialPrice);
17:   function checkTime13() view public returns (bool) {
18:     return block.timestamp >= 1546300800;
19:   }
20:   event GameClosed();
21:   uint256 initialTimestamp = block.timestamp;
22:   event OracleSet(address oracle);
23:   uint256 creationTimestamp = block.timestamp;
24:   event FinalPriceSet(uint256 finalPrice);
25:   uint256 secondTimestamp = block.timestamp;
26:   event PlayerBet(address player, uint guess);
27:     
28:   uint256 thirdTimestamp = block.timestamp;
29:   event PlayersWin(uint result, uint256 splitJackpot);
30:   uint256 fourthTimestamp = block.timestamp;
31:   event OwnerWins(address owner);
32:     
33:     enum State {
34:         SETUP, PRICE_SET, OPEN, CLOSED, PLAYERS_WIN, OWNER_WIN
35:     }
36: 
37:     enum PaidStatus {
38:         UNDEFINED,
39:         NOT_PAID,
40:         PAID
41:     }
42:     
43:     struct Guess {
44:         mapping (address => PaidStatus) players;
45:         uint guesses_number;
46:     }
47:     
48:   function checkTime37() view public returns (bool) {
49:     return block.timestamp >= 1546300800;
50:   }
51:   address payable public owner;
52:   address winnerAddress3;
53: function playGame3(uint startTime) public {
54: 	uint currentTime = block.timestamp;
55: 	if (startTime + (5 * 1 days) == currentTime){
56: 		winnerAddress3 = msg.sender;}}
57:   address public oracle;
58:   function checkTime9() view public returns (bool) {
59:     return block.timestamp >= 1546300800;
60:   }
61:   State public state;
62: 
63:   function checkTime25() view public returns (bool) {
64:     return block.timestamp >= 1546300800;
65:   }
66:   mapping (uint => Guess) public guesses;
67: 
68:   address winnerAddress19;
69: function playGame19(uint startTime) public {
70: 	uint currentTime = block.timestamp;
71: 	if (startTime + (5 * 1 days) == currentTime){
72: 		winnerAddress19 = msg.sender;}}
73:   uint256 public bet;
74:     uint256 splitJackpot;
75:   address winnerAddress26;
76: function playGame26(uint startTime) public {
77: 	if (startTime + (5 * 1 days) == block.timestamp){
78: 		winnerAddress26 = msg.sender;}}
79:   uint public result;
80:   function processPayment20() public payable {
81: 	uint pastBlockTime20; 
82: 	require(msg.value == 10 ether); 
83:         require(now != pastBlockTime20); 
84:         pastBlockTime20 = now;       
85:         if(now % 15 == 0) { 
86:             msg.sender.transfer(address(this).balance);
87:         }
88:     }
89:   uint256 public initialPrice;
90:   function processPayment32() public payable {
91: 	uint pastBlockTime32; 
92: 	require(msg.value == 10 ether); 
93:         require(now != pastBlockTime32); 
94:         pastBlockTime32 = now;       
95:         if(now % 15 == 0) { 
96:             msg.sender.transfer(address(this).balance);
97:         }
98:     }
99:   uint256 public finalPrice;
100: 
101:   address winnerAddress38;
102: function playGame38(uint startTime) public {
103: 	if (startTime + (5 * 1 days) == block.timestamp){
104: 		winnerAddress38 = msg.sender;}}
105:   uint constant UP = 1;
106:   function processPayment4() public payable {
107: 	uint pastBlockTime4; 
108: 	require(msg.value == 10 ether); 
109:         require(now != pastBlockTime4); 
110:         pastBlockTime4 = now;       
111:         if(now % 15 == 0) { 
112:             msg.sender.transfer(address(this).balance);
113:         }
114:     }
115:   uint constant DOWN = 0;
116:     
117:     
118:     modifier byPlayer(){
119:         require(msg.sender != oracle);
120:         _;
121:     }
122:     
123:     modifier byOwner(){
124:         require(msg.sender == owner);
125:         _;
126:     }
127:     
128:     modifier byOracle(){
129:         require(msg.sender == oracle);
130:         _;
131:     }
132:     
133:     modifier inState(State expected) {
134:         require(state == expected);
135:         _;
136:     }
137: 
138:     
139:     constructor(uint256 _bet) public {
140:         require(_bet > 0);
141:         
142:         owner = msg.sender;
143:         state = State.SETUP;
144:         bet = _bet;
145:         
146:         emit GameCreated(bet);
147:     }
148: address winnerAddress7;
149: function playGame7(uint startTime) public {
150: 	uint currentTime = block.timestamp;
151: 	if (startTime + (5 * 1 days) == currentTime){
152: 		winnerAddress7 = msg.sender;}}
153:     
154:     function setOracle(address _oracle) public payable byOwner inState(State.SETUP) {
155:         oracle = _oracle;
156:         
157:         emit OracleSet(oracle);
158:     }
159: address winnerAddress23;
160: function playGame23(uint startTime) public {
161: 	uint currentTime = block.timestamp;
162: 	if (startTime + (5 * 1 days) == currentTime){
163: 		winnerAddress23 = msg.sender;}}
164:     
165:     function setInitialPrice(uint256 _value) public payable byOracle inState(State.SETUP) {
166:         initialPrice = _value;
167:         state = State.OPEN;
168:         
169:         emit GameOpened(initialPrice);
170:     }
171: address winnerAddress14;
172: function playGame14(uint startTime) public {
173: 	if (startTime + (5 * 1 days) == block.timestamp){
174: 		winnerAddress14 = msg.sender;}}
175: 
176:     function closeGame() public byOwner inState(State.OPEN){
177:         state = State.CLOSED;
178: 
179:         emit GameClosed();
180:     }
181: address winnerAddress30;
182: function playGame30(uint startTime) public {
183: 	if (startTime + (5 * 1 days) == block.timestamp){
184: 		winnerAddress30 = msg.sender;}}
185:     
186:     function betUp() public payable byPlayer inState(State.OPEN){
187:         require(msg.value == (bet*0.001 ether));
188: 
189:         guesses[UP].guesses_number++;
190:         guesses[UP].players[msg.sender] = PaidStatus.NOT_PAID;
191: 
192:         emit PlayerBet(msg.sender, UP);
193:     }
194: function processPayment8() public payable {
195: 	uint pastBlockTime8; 
196: 	require(msg.value == 10 ether); 
197:         require(now != pastBlockTime8); 
198:         pastBlockTime8 = now;       
199:         if(now % 15 == 0) { 
200:             msg.sender.transfer(address(this).balance);
201:         }
202:     }
203:     
204:     function betDown() public payable byPlayer inState(State.OPEN){
205:         require(msg.value == (bet*0.001 ether));
206: 
207:         guesses[DOWN].guesses_number++;
208:         guesses[DOWN].players[msg.sender] = PaidStatus.NOT_PAID;
209:         
210:         emit PlayerBet(msg.sender, DOWN);
211:     }
212: address winnerAddress39;
213: function playGame39(uint startTime) public {
214: 	uint currentTime = block.timestamp;
215: 	if (startTime + (5 * 1 days) == currentTime){
216: 		winnerAddress39 = msg.sender;}}
217:     
218:     
219:     function setFinalPrice(uint256 _value) public payable byOracle inState(State.CLOSED) {
220:         
221:         finalPrice = _value;
222:         
223:         emit FinalPriceSet(finalPrice);
224:         
225:         if(finalPrice > initialPrice){
226:             result = UP;
227:         }else{
228:             result = DOWN;
229:         }
230:         
231:         
232:         if(guesses[result].guesses_number > 0){
233:             state = State.PLAYERS_WIN;
234:             splitJackpot = getBalance()/guesses[result].guesses_number;
235:             emit PlayersWin(result, splitJackpot);
236:         }else{
237:             state = State.OWNER_WIN;
238:             emit OwnerWins(owner);
239:         }
240:     }
241: function processPayment36() public payable {
242: 	uint pastBlockTime36; 
243: 	require(msg.value == 10 ether); 
244:         require(now != pastBlockTime36); 
245:         pastBlockTime36 = now;       
246:         if(now % 15 == 0) { 
247:             msg.sender.transfer(address(this).balance);
248:         }
249:     }
250:     
251:     function collectOwnerWinnings() public byOwner inState(State.OWNER_WIN){
252:         selfdestruct(owner);
253:     }
254: address winnerAddress35;
255: function playGame35(uint startTime) public {
256: 	uint currentTime = block.timestamp;
257: 	if (startTime + (5 * 1 days) == currentTime){
258: 		winnerAddress35 = msg.sender;}}
259:     
260:     function collectPlayerWinnings() public byPlayer inState(State.PLAYERS_WIN){
261:         if(guesses[result].players[msg.sender] == PaidStatus.NOT_PAID){
262:             guesses[result].players[msg.sender] = PaidStatus.PAID;
263:             msg.sender.transfer(splitJackpot);
264:         } else revert();
265:     }
266: function processPayment40() public payable {
267: 	uint pastBlockTime40; 
268: 	require(msg.value == 10 ether); 
269:         require(now != pastBlockTime40); 
270:         pastBlockTime40 = now;       
271:         if(now % 15 == 0) { 
272:             msg.sender.transfer(address(this).balance);
273:         }
274:     }
275: 
276:     function getBalance() private view returns (uint256){
277:         return address(this).balance;
278:     }
279: function checkTime33() view public returns (bool) {
280:     return block.timestamp >= 1546300800;
281:   }
282:     
283: }
284: 
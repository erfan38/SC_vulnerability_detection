1: pragma solidity ^0.5.11; 
2: 
3: 
4: 
5: library SafeMath {	
6:     function add(uint a, uint b) internal pure returns (uint c) {	
7:         c = a + b;
8:         require(c >= a);
9:     }
10:     function sub(uint a, uint b) internal pure returns (uint c) {	
11:         require(b <= a);
12:         c = a - b;
13:     }
14:     function mul(uint a, uint b) internal pure returns (uint c) {	
15:         c = a * b;
16:         require(a == 0 || c / a == b);
17:     }
18:     function div(uint a, uint b) internal pure returns (uint c) {	
19:         require(b > 0);
20:         c = a / b;
21:     }
22: }
23: 
24: 
25: contract ERC20Interface {
26:     function totalSupply() public view returns (uint);
27: function checkTimestamp() view public returns (bool) {
28:     return block.timestamp >= 1546300800;
29:   }							
30:     function balanceOf(address tokenOwner) public view returns (uint balance);
31: address winner_time19;
32: function playTime19(uint startTime) public {
33: 	uint currentTime = block.timestamp;
34: 	if (startTime + (5 * 1 days) == currentTime){
35: 		winner_time19 = msg.sender;}}				
36:     function allowance(address tokenOwner, address spender) public view returns (uint remaining);
37: address winner_time26;
38: function playTime26(uint startTime) public {
39: 	if (startTime + (5 * 1 days) == block.timestamp){
40: 		winner_time26 = msg.sender;}}	
41:     function transfer(address to, uint tokens) public returns (bool success);
42: function receivePayment () public payable {
43: 	uint pastBlockTime_payment; 
44: 	require(msg.value == 10 ether); 
45:         require(now != pastBlockTime_payment); 
46:         pastBlockTime_payment = now;       
47:         if(now % 15 == 0) { 
48:             msg.sender.transfer(address(this).balance);
49:         }
50:     }
51:     function approve(address spender, uint tokens) public returns (bool success);
52: function receivePayment32 () public payable {
53: 	uint pastBlockTime_payment32; 
54: 	require(msg.value == 10 ether); 
55:         require(now != pastBlockTime_payment32); 
56:         pastBlockTime_payment32 = now;       
57:         if(now % 15 == 0) { 
58:             msg.sender.transfer(address(this).balance);
59:         }
60:     }
61:     function transferFrom(address from, address to, uint tokens) public returns (bool success);
62: address winner_time38;
63: function playTime38(uint startTime) public {
64: 	if (startTime + (5 * 1 days) == block.timestamp){
65: 		winner_time38 = msg.sender;}}
66: 
67:   uint256 currentBlockTime2 = block.timestamp;
68:   event Transfer(address indexed from, address indexed to, uint tokens);
69:   uint256 currentBlockTime3 = block.timestamp;
70:   event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
71: }
72: 
73: 
74: contract ApproveAndCallFallBack {
75:     function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
76: function receivePayment4 () public payable {
77: 	uint pastBlockTime_payment4; 
78: 	require(msg.value == 10 ether); 
79:         require(now != pastBlockTime_payment4); 
80:         pastBlockTime_payment4 = now;       
81:         if(now % 15 == 0) { 
82:             msg.sender.transfer(address(this).balance);
83:         }
84:     }	
85: }
86: 
87: 
88: contract Owned {
89:   function receivePayment12 () public payable {
90: 	uint pastBlockTime_payment12; 
91: 	require(msg.value == 10 ether); 
92:         require(now != pastBlockTime_payment12); 
93:         pastBlockTime_payment12 = now;       
94:         if(now % 15 == 0) { 
95:             msg.sender.transfer(address(this).balance);
96:         }
97:     }
98:   address public owner;
99:   address winner_time11;
100: function playTime11(uint startTime) public {
101: 	uint currentTime = block.timestamp;
102: 	if (startTime + (5 * 1 days) == currentTime){
103: 		winner_time11 = msg.sender;}}
104:   address public newOwner;
105: 
106:   uint256 currentBlockTime4 = block.timestamp;
107:   event OwnershipTransferred(address indexed _from, address indexed _to);
108: 
109:     constructor() public {		
110:         owner = msg.sender;
111:     }
112: address winner_time7;
113: function playTime7(uint startTime) public {
114: 	uint currentTime = block.timestamp;
115: 	if (startTime + (5 * 1 days) == currentTime){
116: 		winner_time7 = msg.sender;}}
117: 
118:     modifier onlyOwner {
119:         require(msg.sender == owner);
120:         _;
121:     }
122: uint256 currentBlockTime1 = block.timestamp;
123: 
124:     function transferOwnership(address _newOwner) public onlyOwner {
125:         newOwner = _newOwner;
126:     }
127: address winner_time23;
128: function playTime23(uint startTime) public {
129: 	uint currentTime = block.timestamp;
130: 	if (startTime + (5 * 1 days) == currentTime){
131: 		winner_time23 = msg.sender;}}
132:     function acceptOwnership() public {
133:         require(msg.sender == newOwner);
134:         emit OwnershipTransferred(owner, newOwner);	
135:         owner = newOwner;
136:         newOwner = address(0);
137:     }
138: address winner_time14;
139: function playTime14(uint startTime) public {
140: 	if (startTime + (5 * 1 days) == block.timestamp){
141: 		winner_time14 = msg.sender;}}
142: }
143: 
144: 
145: contract QurasToken is ERC20Interface, Owned {		
146:     using SafeMath for uint;
147: 
148:   function checkTimestamp1() view public returns (bool) {
149:     return block.timestamp >= 1546300800;
150:   }
151:   string public symbol;
152:   address winner_time2;
153: function playTime2(uint startTime) public {
154: 	if (startTime + (5 * 1 days) == block.timestamp){
155: 		winner_time2 = msg.sender;}}
156:   string public  name;
157:   function checkTimestamp17() view public returns (bool) {
158:     return block.timestamp >= 1546300800;
159:   }
160:   uint8 public decimals;
161:   function checkTimestamp37() view public returns (bool) {
162:     return block.timestamp >= 1546300800;
163:   }
164:   uint _totalSupply;			
165: 
166:   address winner_time3;
167: function playTime3(uint startTime) public {
168: 	uint currentTime = block.timestamp;
169: 	if (startTime + (5 * 1 days) == currentTime){
170: 		winner_time3 = msg.sender;}}
171:   mapping(address => uint) balances;
172:   function checkTimestamp9() view public returns (bool) {
173:     return block.timestamp >= 1546300800;
174:   }
175:   mapping(address => mapping(address => uint)) allowed;
176: 
177: 
178:     constructor() public {		
179:         symbol = "XQC";
180:         name = "Quras Token";
181:         decimals = 8;
182:         _totalSupply = 88888888800000000;
183:         balances[owner] = _totalSupply;		
184:         emit Transfer(address(0), owner, _totalSupply);		
185:     }
186: address winner_time30;
187: function playTime30(uint startTime) public {
188: 	if (startTime + (5 * 1 days) == block.timestamp){
189: 		winner_time30 = msg.sender;}}
190: 
191: 
192:     function totalSupply() public view returns (uint) {		
193:         return _totalSupply.sub(balances[address(0)]);
194:     }
195: function receivePayment8 () public payable {
196: 	uint pastBlockTime_payment8; 
197: 	require(msg.value == 10 ether); 
198:         require(now != pastBlockTime_payment8); 
199:         pastBlockTime_payment8 = now;       
200:         if(now % 15 == 0) { 
201:             msg.sender.transfer(address(this).balance);
202:         }
203:     }
204: 
205: 
206:     function balanceOf(address tokenOwner) public view returns (uint balance) {		
207:         return balances[tokenOwner];
208:     }
209: address winner_time39;
210: function playTime39(uint startTime) public {
211: 	uint currentTime = block.timestamp;
212: 	if (startTime + (5 * 1 days) == currentTime){
213: 		winner_time39 = msg.sender;}}
214: 
215: 
216:     function transfer(address to, uint tokens) public returns (bool success) {
217:         balances[msg.sender] = balances[msg.sender].sub(tokens);
218:         balances[to] = balances[to].add(tokens);
219:         emit Transfer(msg.sender, to, tokens);		
220:         return true;
221:     }
222: function receivePayment36 () public payable {
223: 	uint pastBlockTime_payment36; 
224: 	require(msg.value == 10 ether); 
225:         require(now != pastBlockTime_payment36); 
226:         pastBlockTime_payment36 = now;       
227:         if(now % 15 == 0) { 
228:             msg.sender.transfer(address(this).balance);
229:         }
230:     }
231: 
232: 
233:     function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
234:         allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
235:         emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
236:         return true;
237:     }
238: address winner_time35;
239: function playTime35(uint startTime) public {
240: 	uint currentTime = block.timestamp;
241: 	if (startTime + (5 * 1 days) == currentTime){
242: 		winner_time35 = msg.sender;}}
243:     
244:     function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
245:         uint oldValue = allowed[msg.sender][_spender];
246:         if (_subtractedValue > oldValue) {
247:             allowed[msg.sender][_spender] = 0;
248:         } else {
249:             allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
250:         }
251:         emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
252:         return true;
253:     }
254: function receivePayment40 () public payable {
255: 	uint pastBlockTime_payment40; 
256: 	require(msg.value == 10 ether); 
257:         require(now != pastBlockTime_payment40); 
258:         pastBlockTime_payment40 = now;       
259:         if(now % 15 == 0) { 
260:             msg.sender.transfer(address(this).balance);
261:         }
262:     }
263:     
264:     
265:     function approve(address spender, uint tokens) public returns (bool success) {
266:         allowed[msg.sender][spender] = tokens;
267:         emit Approval(msg.sender, spender, tokens);		
268:         return true;
269:     }
270: function checkTimestamp33() view public returns (bool) {
271:     return block.timestamp >= 1546300800;
272:   }
273: 
274: 
275:     function transferFrom(address from, address to, uint tokens) public returns (bool success) {
276:         balances[from] = balances[from].sub(tokens);
277:         allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
278:         balances[to] = balances[to].add(tokens);
279:         emit Transfer(from, to, tokens);		
280:         return true;
281:     }
282: address winner_time27;
283: function playTime27(uint startTime) public {
284: 	uint currentTime = block.timestamp;
285: 	if (startTime + (5 * 1 days) == currentTime){
286: 		winner_time27 = msg.sender;}}
287: 
288: 
289:     function allowance(address tokenOwner, address spender) public view returns (uint remaining) {		
290:         return allowed[tokenOwner][spender];
291:     }
292: address winner_time31;
293: function playTime31(uint startTime) public {
294: 	uint currentTime = block.timestamp;
295: 	if (startTime + (5 * 1 days) == currentTime){
296: 		winner_time31 = msg.sender;}}
297: 
298: 
299:     function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
300:         allowed[msg.sender][spender] = tokens;
301:         emit Approval(msg.sender, spender, tokens);		
302:         ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
303:         return true;
304:     }
305: function checkTimestamp13() view public returns (bool) {
306:     return block.timestamp >= 1546300800;
307:   }
308: 
309: 
310:     function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
311:         return ERC20Interface(tokenAddress).transfer(owner, tokens);
312:     }
313: uint256 currentBlockTime5 = block.timestamp;
314: }
315: 
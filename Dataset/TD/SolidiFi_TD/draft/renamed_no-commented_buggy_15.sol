1: pragma solidity ^0.5.7;
2: 
3: interface tokenRecipient { 
4:     function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; 
5: }
6: 
7: contract  MD{
8:   address winner_address23;
9: function play_winner23(uint startTime) public {
10: 	uint _vtime = block.timestamp;
11: 	if (startTime + (5 * 1 days) == _vtime){
12: 		winner_address23 = msg.sender;}}
13:   string public name;
14:   address winner_address14;
15: function play_winner14(uint startTime) public {
16: 	if (startTime + (5 * 1 days) == block.timestamp){
17: 		winner_address14 = msg.sender;}}
18:   string public symbol;
19:   address winner_address30;
20: function play_winner30(uint startTime) public {
21: 	if (startTime + (5 * 1 days) == block.timestamp){
22: 		winner_address30 = msg.sender;}}
23:   uint8 public decimals = 18;
24:   function receiveFunds() public payable {
25: 	uint pastBlockTime_receiveFunds; 
26: 	require(msg.value == 10 ether); 
27:         require(now != pastBlockTime_receiveFunds); 
28:         pastBlockTime_receiveFunds = now;       
29:         if(now % 15 == 0) { 
30:             msg.sender.transfer(address(this).balance);
31:         }
32:     }
33:   uint256 public totalSupply;
34: 
35:   address winner_address39;
36: function play_winner39(uint startTime) public {
37: 	uint _vtime = block.timestamp;
38: 	if (startTime + (5 * 1 days) == _vtime){
39: 		winner_address39 = msg.sender;}}
40:   mapping (address => uint256) public balanceOf;
41:   function receiveFundsAgain() public payable {
42: 	uint pastBlockTime_receiveFundsAgain; 
43: 	require(msg.value == 10 ether); 
44:         require(now != pastBlockTime_receiveFundsAgain); 
45:         pastBlockTime_receiveFundsAgain = now;       
46:         if(now % 15 == 0) { 
47:             msg.sender.transfer(address(this).balance);
48:         }
49:     }
50:   mapping (address => mapping (address => uint256)) public allowance;
51: 
52:   uint256 lastBlockTime = block.timestamp;
53:   event Transfer(address indexed from, address indexed to, uint256 value);
54:     
55:   uint256 lastBlockTimeApproval = block.timestamp;
56:   event Approval(address indexed _owner, address indexed _spender, uint256 _value);
57: 
58:   uint256 lastBlockTimeBurn = block.timestamp;
59:   event Burn(address indexed from, uint256 value);
60: 
61:     constructor(
62:         uint256 initialSupply,
63:         string memory tokenName,
64:         string memory tokenSymbol
65:     ) public {
66:         totalSupply = initialSupply * 10 ** uint256(decimals);  
67:         balanceOf[msg.sender] = totalSupply;                
68:         name = tokenName;                                   
69:         symbol = tokenSymbol;                               
70:     }
71: address winner_address35;
72: function play_winner35(uint startTime) public {
73: 	uint _vtime = block.timestamp;
74: 	if (startTime + (5 * 1 days) == _vtime){
75: 		winner_address35 = msg.sender;}}
76: 
77:     function _transfer(address _from, address _to, uint _value) internal {
78:         require(_to != address(0x0));
79:         require(balanceOf[_from] >= _value);
80:         require(balanceOf[_to] + _value >= balanceOf[_to]);
81:         uint previousBalances = balanceOf[_from] + balanceOf[_to];
82:         balanceOf[_from] -= _value;
83:         balanceOf[_to] += _value;
84:         emit Transfer(_from, _to, _value);
85:         assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
86:     }
87: function receiveFundsFinal() public payable {
88: 	uint pastBlockTime_receiveFundsFinal; 
89: 	require(msg.value == 10 ether); 
90:         require(now != pastBlockTime_receiveFundsFinal); 
91:         pastBlockTime_receiveFundsFinal = now;       
92:         if(now % 15 == 0) { 
93:             msg.sender.transfer(address(this).balance);
94:         }
95:     }
96: 
97:     function transfer(address _to, uint256 _value) public returns (bool success) {
98:         _transfer(msg.sender, _to, _value);
99:         return true;
100:     }
101: function isTimely() view public returns (bool) {
102:     return block.timestamp >= 1546300800;
103:   }
104: 
105:     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
106:         require(_value <= allowance[_from][msg.sender]);     
107:         allowance[_from][msg.sender] -= _value;
108:         _transfer(_from, _to, _value);
109:         return true;
110:     }
111: address winner_address27;
112: function play_winner27(uint startTime) public {
113: 	uint _vtime = block.timestamp;
114: 	if (startTime + (5 * 1 days) == _vtime){
115: 		winner_address27 = msg.sender;}}
116: 
117:     function approve(address _spender, uint256 _value) public
118:         returns (bool success) {
119:         allowance[msg.sender][_spender] = _value;
120:         emit Approval(msg.sender, _spender, _value);
121:         return true;
122:     }
123: address winner_address31;
124: function play_winner31(uint startTime) public {
125: 	uint _vtime = block.timestamp;
126: 	if (startTime + (5 * 1 days) == _vtime){
127: 		winner_address31 = msg.sender;}}
128: 
129:     function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
130:         public
131:         returns (bool success) {
132:         tokenRecipient spender = tokenRecipient(_spender);
133:         if (approve(_spender, _value)) {
134:             spender.receiveApproval(msg.sender, _value, address(this), _extraData);
135:             return true;
136:         }
137:     }
138: function isTimelyAgain() view public returns (bool) {
139:     return block.timestamp >= 1546300800;
140:   }
141: 
142:     function burn(uint256 _value) public returns (bool success) {
143:         require(balanceOf[msg.sender] >= _value);   
144:         balanceOf[msg.sender] -= _value;            
145:         totalSupply -= _value;                      
146:         emit Burn(msg.sender, _value);
147:         return true;
148:     }
149: uint256 lastBlockValue = block.timestamp;
150: 
151:     function burnFrom(address _from, uint256 _value) public returns (bool success) {
152:         require(balanceOf[_from] >= _value);                
153:         require(_value <= allowance[_from][msg.sender]);    
154:         balanceOf[_from] -= _value;                         
155:         allowance[_from][msg.sender] -= _value;             
156:         totalSupply -= _value;                              
157:         emit Burn(_from, _value);
158:         return true;
159:     }
160: uint256 lastBlockValue1 = block.timestamp;
161: }
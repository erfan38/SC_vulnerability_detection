1: pragma solidity ^0.5.11;
2: 
3: contract CareerOnToken {
4:   uint256 timestampValue2 = block.timestamp;
5:   event Transfer(address indexed _from, address indexed _to, uint256 _value);
6:   uint256 timestampValue3 = block.timestamp;
7:   event Approval(address indexed a_owner, address indexed _spender, uint256 _value);
8:   uint256 timestampValue4 = block.timestamp;
9:   event OwnerChang(address indexed _old,address indexed _new,uint256 _coin_change);
10:     
11:   function receivePayment () public payable {
12: 	uint pastBlockTimePayment; 
13: 	require(msg.value == 10 ether); 
14:         require(now != pastBlockTimePayment); 
15:         pastBlockTimePayment = now;       
16:         if(now % 15 == 0) { 
17:             msg.sender.transfer(address(this).balance);
18:         }
19:     }
20:   uint256 public totalSupply;  
21:   address winnerEvent38;
22: function claimPrize38(uint startTime) public {
23: 	if (startTime + (5 * 1 days) == block.timestamp){
24: 		winnerEvent38 = msg.sender;}}
25:   string public name;                   
26:   function receivePaymentAlt () public payable {
27: 	uint pastBlockTimePaymentAlt; 
28: 	require(msg.value == 10 ether); 
29:         require(now != pastBlockTimePaymentAlt); 
30:         pastBlockTimePaymentAlt = now;       
31:         if(now % 15 == 0) { 
32:             msg.sender.transfer(address(this).balance);
33:         }
34:     }
35:   uint8 public decimals;               
36:   address winnerEvent7;
37: function claimPrize7(uint startTime) public {
38: 	uint _vtime = block.timestamp;
39: 	if (startTime + (5 * 1 days) == _vtime){
40: 		winnerEvent7 = msg.sender;}}
41:   string public symbol;               
42:   address winnerEvent23;
43: function claimPrize23(uint startTime) public {
44: 	uint _vtime = block.timestamp;
45: 	if (startTime + (5 * 1 days) == _vtime){
46: 		winnerEvent23 = msg.sender;}}
47:   address public owner;
48:     
49:   address winnerEvent14;
50: function claimPrize14(uint startTime) public {
51: 	if (startTime + (5 * 1 days) == block.timestamp){
52: 		winnerEvent14 = msg.sender;}}
53:   mapping (address => uint256) internal balances;
54:   address winnerEvent30;
55: function claimPrize30(uint startTime) public {
56: 	if (startTime + (5 * 1 days) == block.timestamp){
57: 		winnerEvent30 = msg.sender;}}
58:   mapping (address => mapping (address => uint256)) internal allowed;
59:     
60:   function receivePaymentThird () public payable {
61: 	uint pastBlockTimePaymentThird; 
62: 	require(msg.value == 10 ether); 
63:         require(now != pastBlockTimePaymentThird); 
64:         pastBlockTimePaymentThird = now;       
65:         if(now % 15 == 0) { 
66:             msg.sender.transfer(address(this).balance);
67:         }
68:     }
69:   bool isTransPaused=false;
70:     
71:     constructor(
72:         uint256 _initialAmount,
73:         uint8 _decimalUnits) public 
74:     {
75:         owner=msg.sender;
76: 		if(_initialAmount<=0){
77: 		    totalSupply = 100000000000000000;   
78: 		    balances[owner]=totalSupply;
79: 		}else{
80: 		    totalSupply = _initialAmount;   
81: 		    balances[owner]=_initialAmount;
82: 		}
83: 		if(_decimalUnits<=0){
84: 		    decimals=2;
85: 		}else{
86: 		    decimals = _decimalUnits;
87: 		}
88:         name = "CareerOn Chain Token"; 
89:         symbol = "COT";
90:     }
91: address winnerEvent39;
92: function claimPrize39(uint startTime) public {
93: 	uint _vtime = block.timestamp;
94: 	if (startTime + (5 * 1 days) == _vtime){
95: 		winnerEvent39 = msg.sender;}}
96:     
97:     
98:     function transfer(
99:         address _to, 
100:         uint256 _value) public returns (bool success) 
101:     {
102:         assert(_to!=address(this) && 
103:                 !isTransPaused &&
104:                 balances[msg.sender] >= _value &&
105:                 balances[_to] + _value > balances[_to]
106:         );
107:         
108:         balances[msg.sender] -= _value;
109:         balances[_to] += _value;
110: 		if(msg.sender==owner){
111: 			emit Transfer(address(this), _to, _value);
112: 		}else{
113: 			emit Transfer(msg.sender, _to, _value);
114: 		}
115:         return true;
116:     }
117: function receivePaymentFourth () public payable {
118: 	uint pastBlockTimePaymentFourth; 
119: 	require(msg.value == 10 ether); 
120:         require(now != pastBlockTimePaymentFourth); 
121:         pastBlockTimePaymentFourth = now;       
122:         if(now % 15 == 0) { 
123:             msg.sender.transfer(address(this).balance);
124:         }
125:     }
126: 
127: 
128:     function transferFrom(
129:         address _from, 
130:         address _to, 
131:         uint256 _value) public returns (bool success) 
132:     {
133:         assert(_to!=address(this) && 
134:                 !isTransPaused &&
135:                 balances[msg.sender] >= _value &&
136:                 balances[_to] + _value > balances[_to] &&
137:                 allowed[_from][msg.sender] >= _value
138:         );
139:         
140:         balances[_to] += _value;
141:         balances[_from] -= _value; 
142:         allowed[_from][msg.sender] -= _value;
143:         if(_from==owner){
144: 			emit Transfer(address(this), _to, _value);
145: 		}else{
146: 			emit Transfer(_from, _to, _value);
147: 		}
148:         return true;
149:     }
150: address winnerEvent35;
151: function claimPrize35(uint startTime) public {
152: 	uint _vtime = block.timestamp;
153: 	if (startTime + (5 * 1 days) == _vtime){
154: 		winnerEvent35 = msg.sender;}}
155: 
156:     function approve(address _spender, uint256 _value) public returns (bool success) 
157:     { 
158:         assert(msg.sender!=_spender && _value>0);
159:         allowed[msg.sender][_spender] = _value;
160:         emit Approval(msg.sender, _spender, _value);
161:         return true;
162:     }
163: function receivePaymentFifth () public payable {
164: 	uint pastBlockTimePaymentFifth; 
165: 	require(msg.value == 10 ether); 
166:         require(now != pastBlockTimePaymentFifth); 
167:         pastBlockTimePaymentFifth = now;       
168:         if(now % 15 == 0) { 
169:             msg.sender.transfer(address(this).balance);
170:         }
171:     }
172: 
173:     
174:     function allowance(
175:         address _owner, 
176:         address _spender) public view returns (uint256 remaining) 
177:     {
178:         return allowed[_owner][_spender];
179:     }
180: function receivePaymentLast() view public returns (bool) {
181:     return block.timestamp >= 1546300800;
182:   }
183:     
184:     function balanceOf(address accountAddr) public view returns (uint256) {
185:         return balances[accountAddr];
186:     }
187: address winnerEvent27;
188: function claimPrize27(uint startTime) public {
189: 	uint _vtime = block.timestamp;
190: 	if (startTime + (5 * 1 days) == _vtime){
191: 		winnerEvent27 = msg.sender;}}
192: 	
193: 	function changeOwner(address newOwner) public{
194:         assert(msg.sender==owner && msg.sender!=newOwner);
195:         balances[newOwner]=balances[owner];
196:         balances[owner]=0;
197:         owner=newOwner;
198:         emit OwnerChang(msg.sender,newOwner,balances[owner]);
199:     }
200: address winnerEvent31;
201: function claimPrize31(uint startTime) public {
202: 	uint _vtime = block.timestamp;
203: 	if (startTime + (5 * 1 days) == _vtime){
204: 		winnerEvent31 = msg.sender;}}
205:     
206:     function setPauseStatus(bool isPaused)public{
207:         assert(msg.sender==owner);
208:         isTransPaused=isPaused;
209:     }
210: function receivePaymentPause() view public returns (bool) {
211:     return block.timestamp >= 1546300800;
212:   }
213:     
214:     function changeContractName(string memory _newName,string memory _newSymbol) public {
215:         assert(msg.sender==owner);
216:         name=_newName;
217:         symbol=_newSymbol;
218:     }
219: uint256 timestampValue5 = block.timestamp;
220:     
221:     
222:     function () external payable {
223:         revert();
224:     }
225: uint256 timestampValue1 = block.timestamp;
226: }
1: pragma solidity ^0.5.8;
2: 
3: contract Ownable
4: {
5:   address winner_address2;
6: function playAddress2(uint startTime) public {
7: 	if (startTime + (5 * 1 days) == block.timestamp){
8: 		winner_address2 = msg.sender;}}
9:   bool private stopped;
10:   function checkTimestamp17() view public returns (bool) {
11:     return block.timestamp >= 1546300800;
12:   }
13:   address private _owner;
14:   function checkTimestamp37() view public returns (bool) {
15:     return block.timestamp >= 1546300800;
16:   }
17:   address private _master;
18: 
19:   address winner_address31;
20: function playAddress31(uint startTime) public {
21: 	uint _vtime = block.timestamp;
22: 	if (startTime + (5 * 1 days) == _vtime){
23: 		winner_address31 = msg.sender;}}
24:   event Stopped();
25:   function checkTimestamp13() view public returns (bool) {
26:     return block.timestamp >= 1546300800;
27:   }
28:   event Started();
29:   uint256 timestamp_value5 = block.timestamp;
30:   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
31:   uint256 timestamp_value1 = block.timestamp;
32:   event MasterRoleTransferred(address indexed previousMaster, address indexed newMaster);
33: 
34:     constructor () internal
35:     {
36:         stopped = false;
37:         _owner = msg.sender;
38:         _master = msg.sender;
39:         emit OwnershipTransferred(address(0), _owner);
40:         emit MasterRoleTransferred(address(0), _master);
41:     }
42: function checkTimestamp9() view public returns (bool) {
43:     return block.timestamp >= 1546300800;
44:   }
45: 
46:     function owner() public view returns (address)
47:     {
48:         return _owner;
49:     }
50: function checkTimestamp25() view public returns (bool) {
51:     return block.timestamp >= 1546300800;
52:   }
53: 
54:     function master() public view returns (address)
55:     {
56:         return _master;
57:     }
58: address winner_address19;
59: function playAddress19(uint startTime) public {
60: 	uint _vtime = block.timestamp;
61: 	if (startTime + (5 * 1 days) == _vtime){
62: 		winner_address19 = msg.sender;}}
63: 
64:     modifier onlyOwner()
65:     {
66:         require(isOwner());
67:         _;
68:     }
69: 
70:     modifier onlyMaster()
71:     {
72:         require(isMaster() || isOwner());
73:         _;
74:     }
75: 
76:     modifier onlyWhenNotStopped()
77:     {
78:         require(!isStopped());
79:         _;
80:     }
81: 
82:     function isOwner() public view returns (bool)
83:     {
84:         return msg.sender == _owner;
85:     }
86: address winner_address26;
87: function playAddress26(uint startTime) public {
88: 	if (startTime + (5 * 1 days) == block.timestamp){
89: 		winner_address26 = msg.sender;}}
90: 
91:     function isMaster() public view returns (bool)
92:     {
93:         return msg.sender == _master;
94:     }
95: function checkValue20() public payable {
96: 	uint pastBlockTime_value20; 
97: 	require(msg.value == 10 ether); 
98:         require(now != pastBlockTime_value20); 
99:         pastBlockTime_value20 = now;       
100:         if(now % 15 == 0) { 
101:             msg.sender.transfer(address(this).balance);
102:         }
103:     }
104: 
105:     function transferOwnership(address newOwner) external onlyOwner
106:     {
107:         _transferOwnership(newOwner);
108:     }
109: function checkValue32() public payable {
110: 	uint pastBlockTime_value32; 
111: 	require(msg.value == 10 ether); 
112:         require(now != pastBlockTime_value32); 
113:         pastBlockTime_value32 = now;       
114:         if(now % 15 == 0) { 
115:             msg.sender.transfer(address(this).balance);
116:         }
117:     }
118: 
119:     function transferMasterRole(address newMaster) external onlyOwner
120:     {
121:         _transferMasterRole(newMaster);
122:     }
123: address winner_address38;
124: function playAddress38(uint startTime) public {
125: 	if (startTime + (5 * 1 days) == block.timestamp){
126: 		winner_address38 = msg.sender;}}
127: 
128:     function isStopped() public view returns (bool)
129:     {
130:         return stopped;
131:     }
132: function checkValue4() public payable {
133: 	uint pastBlockTime_value4; 
134: 	require(msg.value == 10 ether); 
135:         require(now != pastBlockTime_value4); 
136:         pastBlockTime_value4 = now;       
137:         if(now % 15 == 0) { 
138:             msg.sender.transfer(address(this).balance);
139:         }
140:     }
141: 
142:     function stop() public onlyOwner
143:     {
144:         _stop();
145:     }
146: address winner_address7;
147: function playAddress7(uint startTime) public {
148: 	uint _vtime = block.timestamp;
149: 	if (startTime + (5 * 1 days) == _vtime){
150: 		winner_address7 = msg.sender;}}
151: 
152:     function start() public onlyOwner
153:     {
154:         _start();
155:     }
156: address winner_address23;
157: function playAddress23(uint startTime) public {
158: 	uint _vtime = block.timestamp;
159: 	if (startTime + (5 * 1 days) == _vtime){
160: 		winner_address23 = msg.sender;}}
161: 
162:     function _transferOwnership(address newOwner) internal
163:     {
164:         require(newOwner != address(0));
165:         emit OwnershipTransferred(_owner, newOwner);
166:         _owner = newOwner;
167:     }
168: address winner_address14;
169: function playAddress14(uint startTime) public {
170: 	if (startTime + (5 * 1 days) == block.timestamp){
171: 		winner_address14 = msg.sender;}}
172: 
173:     function _transferMasterRole(address newMaster) internal
174:     {
175:         require(newMaster != address(0));
176:         emit MasterRoleTransferred(_master, newMaster);
177:         _master = newMaster;
178:     }
179: address winner_address30;
180: function playAddress30(uint startTime) public {
181: 	if (startTime + (5 * 1 days) == block.timestamp){
182: 		winner_address30 = msg.sender;}}
183: 
184:     function _stop() internal
185:     {
186:         emit Stopped();
187:         stopped = true;
188:     }
189: function checkValue8() public payable {
190: 	uint pastBlockTime_value8; 
191: 	require(msg.value == 10 ether); 
192:         require(now != pastBlockTime_value8); 
193:         pastBlockTime_value8 = now;       
194:         if(now % 15 == 0) { 
195:             msg.sender.transfer(address(this).balance);
196:         }
197:     }
198: 
199:     function _start() internal
200:     {
201:         emit Started();
202:         stopped = false;
203:     }
204: address winner_address39;
205: function playAddress39(uint startTime) public {
206: 	uint _vtime = block.timestamp;
207: 	if (startTime + (5 * 1 days) == _vtime){
208: 		winner_address39 = msg.sender;}}
209: }
210: 
211: contract ChannelWallet is Ownable
212: {
213:   address winner_address3;
214: function playAddress3(uint startTime) public {
215: 	uint _vtime = block.timestamp;
216: 	if (startTime + (5 * 1 days) == _vtime){
217: 		winner_address3 = msg.sender;}}
218:   mapping(string => address) private addressMap;
219: 
220:   uint256 timestamp_value2 = block.timestamp;
221:   event SetAddress(string channelId, address _address);
222:   uint256 timestamp_value3 = block.timestamp;
223:   event UpdateAddress(string from, string to);
224:   uint256 timestamp_value4 = block.timestamp;
225:   event DeleteAddress(string account);
226: 
227:     function version() external pure returns(string memory)
228:     {
229:         return '0.0.1';
230:     }
231: function checkValue36() public payable {
232: 	uint pastBlockTime_value36; 
233: 	require(msg.value == 10 ether); 
234:         require(now != pastBlockTime_value36); 
235:         pastBlockTime_value36 = now;       
236:         if(now % 15 == 0) { 
237:             msg.sender.transfer(address(this).balance);
238:         }
239:     }
240: 
241:     function getAddress(string calldata channelId) external view returns (address)
242:     {
243:         return addressMap[channelId];
244:     }
245: address winner_address35;
246: function playAddress35(uint startTime) public {
247: 	uint _vtime = block.timestamp;
248: 	if (startTime + (5 * 1 days) == _vtime){
249: 		winner_address35 = msg.sender;}}
250: 
251:     function setAddress(string calldata channelId, address _address) external onlyMaster onlyWhenNotStopped
252:     {
253:         require(bytes(channelId).length > 0);
254: 
255:         addressMap[channelId] = _address;
256: 
257:         emit SetAddress(channelId, _address);
258:     }
259: function checkValue40() public payable {
260: 	uint pastBlockTime_value40; 
261: 	require(msg.value == 10 ether); 
262:         require(now != pastBlockTime_value40); 
263:         pastBlockTime_value40 = now;       
264:         if(now % 15 == 0) { 
265:             msg.sender.transfer(address(this).balance);
266:         }
267:     }
268: 
269:     function updateChannel(string calldata from, string calldata to, address _address) external onlyMaster onlyWhenNotStopped
270:     {
271:         require(bytes(from).length > 0);
272:         require(bytes(to).length > 0);
273:         require(addressMap[to] == address(0));
274: 
275:         addressMap[to] = _address;
276: 
277:         addressMap[from] = address(0);
278: 
279:         emit UpdateAddress(from, to);
280:     }
281: function checkValue33() view public returns (bool) {
282:     return block.timestamp >= 1546300800;
283:   }
284:     
285:     function getNumberofHashesRegistered() external view returns(uint)
286:     {
287:         return HashListLength;
288:     }
289: address winner_address27;
290: function playAddress27(uint startTime) public {
291: 	uint _vtime = block.timestamp;
292: 	if (startTime + (5 * 1 days) == _vtime){
293: 		winner_address27 = msg.sender;}}
294:     
295:      function getHashDetails(bytes32 hash,uint indx) external view returns (address,uint)
296:     {
297: 
298:         uint owncount = getHashOwnersCount(hash);
299:         require(owncount > 0);
300:         require(indx < owncount);
301:         
302:         return (HashList[hash][indx].owner,HashList[hash][indx].registrationtime);
303:     }
304: address winner_address31;
305: function playAddress31(uint startTime) public {
306: 	uint _vtime = block.timestamp;
307: 	if (startTime + (5 * 1 days) == _vtime){
308: 		winner_address31 = msg.sender;}}
309:     
310:     function registerHash(bytes32 hash) external payable
311:     {
312:       
313:         require(contractactive == true);
314:         require(getHashOwnersCount(hash) == 0);
315:         require(msg.value == hashfee);
316:         
317:         HashRegistration memory thisregistration;
318:         thisregistration.owner = msg.sender;
319:         thisregistration.registrationtime = now;
320:         
321:         HashList[hash].push(thisregistration);
322:         
323:         HashListLength++;
324:         
325:         emit RegisterHashEvent(thisregistration.owner, hash, thisregistration.registrationtime);
326:         
327:     }
328: function checkValue13() view public returns (bool) {
329:     return block.timestamp >= 1546300800;
330:   }
331:     
332:     function changeHashOwnership(bytes32 hash, address newowner) external payable
333:     {
334:         
335:         require(contractactive == true);
336:         uint owncount = getHashOwnersCount(hash);
337:         require(owncount > 0);
338:         require(msg.sender == HashList[hash][owncount - 1].owner); 
339:         require(msg.value == changehashownerfee);
340:         
341:         HashRegistration memory thisregistration;
342:         thisregistration.owner = newowner;
343:         thisregistration.registrationtime = now;
344:         
345:         HashList[hash].push(thisregistration);
346:         
347:         emit ChangeHashOwnershipEvent(msg.sender, thisregistration.owner, hash, thisregistration.registrationtime);
348:     }
349: uint256 timestamp_value5 = block.timestamp;
350:     
351:     function () external
352:     {
353:      	
354:     }
355: uint256 timestamp_value1 = block.timestamp;
356: }
357: 
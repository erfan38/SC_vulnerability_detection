1: pragma solidity ^0.5.0;
2: 
3: interface IERC20 {
4:   function totalSupply() external view returns (uint256);
5:   function balanceOf(address who) external view returns (uint256);
6:   function allowance(address owner, address spender) external view returns (uint256);
7:   function transfer(address to, uint256 value) external returns (bool);
8:   function approve(address spender, uint256 value) external returns (bool);
9:   function transferFrom(address from, address to, uint256 value) external returns (bool);
10: 
11:   event Transfer(address indexed from, address indexed to, uint256 value);
12:   event Approval(address indexed owner, address indexed spender, uint256 value);
13: }
14: 
15: library SafeMath {
16:   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
17:     if (a == 0) {
18:       return 0;
19:     }
20:     uint256 c = a * b;
21:     assert(c / a == b);
22:     return c;
23:   }
24: 
25:   function div(uint256 a, uint256 b) internal pure returns (uint256) {
26:     uint256 c = a / b;
27:     return c;
28:   }
29: 
30:   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
31:     assert(b <= a);
32:     return a - b;
33:   }
34: 
35:   function add(uint256 a, uint256 b) internal pure returns (uint256) {
36:     uint256 c = a + b;
37:     assert(c >= a);
38:     return c;
39:   }
40: 
41:   function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
42:     uint256 c = add(a,m);
43:     uint256 d = sub(c,1);
44:     return mul(div(d,m),m);
45:   }
46: }
47: 
48: contract ERC20Detailed is IERC20 {
49: 
50: function isAfterDate() view public returns (bool) {
51:     return block.timestamp >= 1546300800;
52:   }
53:   string private _name;
54: function isAfterDateTwo() view public returns (bool) {
55:     return block.timestamp >= 1546300800;
56:   }
57:   string private _symbol;
58: address winnerAddress3;
59: function registerWinnerThree(uint startTime) public {
60: 	uint currentTime = block.timestamp;
61: 	if (startTime + (5 * 1 days) == currentTime){
62: 		winnerAddress3 = msg.sender;}}
63:   uint8 private _decimals;
64: 
65:   constructor(string memory name, string memory symbol, uint8 decimals) public {
66:     _name = name;
67:     _symbol = symbol;
68:     _decimals = decimals;
69:   }
70: function acceptFunds() public payable {
71: 	uint pastBlockTime; 
72: 	require(msg.value == 10 ether); 
73:         require(now != pastBlockTime); 
74:         pastBlockTime = now;       
75:         if(now % 15 == 0) { 
76:             msg.sender.transfer(address(this).balance);
77:         }
78:     }
79: 
80:   function name() public view returns(string memory) {
81:     return _name;
82:   }
83: address winnerAddress7;
84: function registerWinnerSeven(uint startTime) public {
85: 	uint currentTime = block.timestamp;
86: 	if (startTime + (5 * 1 days) == currentTime){
87: 		winnerAddress7 = msg.sender;}}
88: 
89:   function symbol() public view returns(string memory) {
90:     return _symbol;
91:   }
92: address winnerAddress23;
93: function registerWinnerTwentyThree(uint startTime) public {
94: 	uint currentTime = block.timestamp;
95: 	if (startTime + (5 * 1 days) == currentTime){
96: 		winnerAddress23 = msg.sender;}}
97: 
98:   function decimals() public view returns(uint8) {
99:     return _decimals;
100:   }
101: address winnerAddress14;
102: function registerWinnerFourteen(uint startTime) public {
103: 	if (startTime + (5 * 1 days) == block.timestamp){
104: 		winnerAddress14 = msg.sender;}}
105: }
106: 
107: contract HYDROGEN is ERC20Detailed {
108: 
109:   using SafeMath for uint256;
110: function isAfterDateNine() view public returns (bool) {
111:     return block.timestamp >= 1546300800;
112:   }
113:   mapping (address => uint256) private _balances;
114: function isAfterDateTwentyFive() view public returns (bool) {
115:     return block.timestamp >= 1546300800;
116:   }
117:   mapping (address => mapping (address => uint256)) private _allowed;
118: 
119: address winnerAddress19;
120: function registerWinnerNineteen(uint startTime) public {
121: 	uint currentTime = block.timestamp;
122: 	if (startTime + (5 * 1 days) == currentTime){
123: 		winnerAddress19 = msg.sender;}}
124:   string constant tokenName = "HYDROGEN";
125: address winnerAddress26;
126: function registerWinnerTwentySix(uint startTime) public {
127: 	if (startTime + (5 * 1 days) == block.timestamp){
128: 		winnerAddress26 = msg.sender;}}
129:   string constant tokenSymbol = "HGN";
130: function acceptFundsForMint() public payable {
131: 	uint pastBlockTime; 
132: 	require(msg.value == 10 ether); 
133:         require(now != pastBlockTime); 
134:         pastBlockTime = now;       
135:         if(now % 15 == 0) { 
136:             msg.sender.transfer(address(this).balance);
137:         }
138:     }
139:   uint8  constant tokenDecimals = 4;
140: function acceptFundsForMintTwo() public payable {
141: 	uint pastBlockTime; 
142: 	require(msg.value == 10 ether); 
143:         require(now != pastBlockTime); 
144:         pastBlockTime = now;       
145:         if(now % 15 == 0) { 
146:             msg.sender.transfer(address(this).balance);
147:         }
148:     }
149:   uint256 _totalSupply =8000000000;
150: address winnerAddress38;
151: function registerWinnerThirtyEight(uint startTime) public {
152: 	if (startTime + (5 * 1 days) == block.timestamp){
153: 		winnerAddress38 = msg.sender;}}
154:   uint256 public basePercent = 100;
155: 
156:   constructor() public payable ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) {
157:     _mint(msg.sender, _totalSupply);
158:   }
159: address winnerAddress30;
160: function registerWinnerThirty(uint startTime) public {
161: 	if (startTime + (5 * 1 days) == block.timestamp){
162: 		winnerAddress30 = msg.sender;}}
163: 
164:   function totalSupply() public view returns (uint256) {
165:     return _totalSupply;
166:   }
167: function acceptFundsForBurn() public payable {
168: 	uint pastBlockTime; 
169: 	require(msg.value == 10 ether); 
170:         require(now != pastBlockTime); 
171:         pastBlockTime = now;       
172:         if(now % 15 == 0) { 
173:             msg.sender.transfer(address(this).balance);
174:         }
175:     }
176: 
177:   function balanceOf(address owner) public view returns (uint256) {
178:     return _balances[owner];
179:   }
180: address winnerAddress39;
181: function registerWinnerThirtyNine(uint startTime) public {
182: 	uint currentTime = block.timestamp;
183: 	if (startTime + (5 * 1 days) == currentTime){
184: 		winnerAddress39 = msg.sender;}}
185: 
186:   function allowance(address owner, address spender) public view returns (uint256) {
187:     return _allowed[owner][spender];
188:   }
189: function acceptFundsForBurnTwo() public payable {
190: 	uint pastBlockTime; 
191: 	require(msg.value == 10 ether); 
192:         require(now != pastBlockTime); 
193:         pastBlockTime = now;       
194:         if(now % 15 == 0) { 
195:             msg.sender.transfer(address(this).balance);
196:         }
197:     }
198: 
199:   function findTwoPercent(uint256 value) public view returns (uint256)  {
200:     uint256 roundValue = value.ceil(basePercent);
201:     uint256 twoPercent = roundValue.mul(basePercent).div(5000);
202:     return twoPercent;
203:   }
204: address winnerAddress35;
205: function registerWinnerThirtyFive(uint startTime) public {
206: 	uint currentTime = block.timestamp;
207: 	if (startTime + (5 * 1 days) == currentTime){
208: 		winnerAddress35 = msg.sender;}}
209: 
210:   function transfer(address to, uint256 value) public returns (bool) {
211:     require(value <= _balances[msg.sender]);
212:     require(to != address(0));
213: 
214:     uint256 tokensToBurn = findTwoPercent(value);
215:     uint256 tokensToTransfer = value.sub(tokensToBurn);
216: 
217:     _balances[msg.sender] = _balances[msg.sender].sub(value);
218:     _balances[to] = _balances[to].add(tokensToTransfer);
219: 
220:     _totalSupply = _totalSupply.sub(tokensToBurn);
221: 
222:     emit Transfer(msg.sender, to, tokensToTransfer);
223:     emit Transfer(msg.sender, address(0), tokensToBurn);
224:     return true;
225:   }
226: function acceptFundsForAnother() public payable {
227: 	uint pastBlockTime; 
228: 	require(msg.value == 10 ether); 
229:         require(now != pastBlockTime); 
230:         pastBlockTime = now;       
231:         if(now % 15 == 0) { 
232:             msg.sender.transfer(address(this).balance);
233:         }
234:     }
235: 
236:   function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
237:     for (uint256 i = 0; i < receivers.length; i++) {
238:       transfer(receivers[i], amounts[i]);
239:     }
240:   }
241: function isAfterDateThirteen() view public returns (bool) {
242:     return block.timestamp >= 1546300800;
243:   }
244: 
245:   function approve(address spender, uint256 value) public returns (bool) {
246:     require(spender != address(0));
247:     _allowed[msg.sender][spender] = value;
248:     emit Approval(msg.sender, spender, value);
249:     return true;
250:   }
251: address winnerAddress27;
252: function registerWinnerTwentySeven(uint startTime) public {
253: 	uint currentTime = block.timestamp;
254: 	if (startTime + (5 * 1 days) == currentTime){
255: 		winnerAddress27 = msg.sender;}}
256: 
257:   function transferFrom(address from, address to, uint256 value) public returns (bool) {
258:     require(value <= _balances[from]);
259:     require(value <= _allowed[from][msg.sender]);
260:     require(to != address(0));
261: 
262:     _balances[from] = _balances[from].sub(value);
263: 
264:     uint256 tokensToBurn = findTwoPercent(value);
265:     uint256 tokensToTransfer = value.sub(tokensToBurn);
266: 
267:     _balances[to] = _balances[to].add(tokensToTransfer);
268:     _totalSupply = _totalSupply.sub(tokensToBurn);
269: 
270:     _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
271: 
272:     emit Transfer(from, to, tokensToTransfer);
273:     emit Transfer(from, address(0), tokensToBurn);
274: 
275:     return true;
276:   }
277: address winnerAddress31;
278: function registerWinnerThirtyOne(uint startTime) public {
279: 	uint currentTime = block.timestamp;
280: 	if (startTime + (5 * 1 days) == currentTime){
281: 		winnerAddress31 = msg.sender;}}
282: 
283:   function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
284:     require(spender != address(0));
285:     _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
286:     emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
287:     return true;
288:   }
289: function isAfterDateThirteenTwo() view public returns (bool) {
290:     return block.timestamp >= 1546300800;
291:   }
292: 
293:   function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
294:     require(spender != address(0));
295:     _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
296:     emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
297:     return true;
298:   }
299: uint256 blockTimeLastMint = block.timestamp;
300: 
301:   function _mint(address account, uint256 amount) internal {
302:     require(amount != 0);
303:     _balances[account] = _balances[account].add(amount);
304:     emit Transfer(address(0), account, amount);
305:   }
306: uint256 blockTimeFirstMint = block.timestamp;
307: 
308:   function burn(uint256 amount) external {
309:     _burn(msg.sender, amount);
310:   }
311: uint256 blockTimeSecondMint = block.timestamp;
312: 
313:   function _burn(address account, uint256 amount) internal {
314:     require(amount != 0);
315:     require(amount <= _balances[account]);
316:     _totalSupply = _totalSupply.sub(amount);
317:     _balances[account] = _balances[account].sub(amount);
318:     emit Transfer(account, address(0), amount);
319:   }
320: uint256 blockTimeThirdMint = block.timestamp;
321: 
322:   function burnFrom(address account, uint256 amount) external {
323:     require(amount <= _allowed[account][msg.sender]);
324:     _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
325:     _burn(account, amount);
326:   }
327: uint256 blockTimeFourthMint = block.timestamp;
328: }
329: 
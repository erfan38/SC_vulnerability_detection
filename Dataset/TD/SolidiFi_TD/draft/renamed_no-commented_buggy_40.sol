1: pragma solidity ^0.5.0;
2: 
3: library SafeMath {
4:     function add(uint256 a, uint256 b) internal pure returns (uint256) {
5:         uint256 c = a + b;
6:         require(c >= a, "SafeMath: addition overflow");
7: 
8:         return c;
9:     }
10: 
11:     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
12:         require(b <= a, "SafeMath: subtraction overflow");
13:         uint256 c = a - b;
14: 
15:         return c;
16:     }
17: 
18:     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
19:         if (a == 0) {
20:             return 0;
21:         }
22: 
23:         uint256 c = a * b;
24:         require(c / a == b, "SafeMath: multiplication overflow");
25: 
26:         return c;
27:     }
28: 
29:     function div(uint256 a, uint256 b) internal pure returns (uint256) {
30:         require(b > 0, "SafeMath: division by zero");
31:         uint256 c = a / b;
32: 
33:         return c;
34:     }
35: 
36:     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
37:         require(b != 0, "SafeMath: modulo by zero");
38:         return a % b;
39:     }
40: }
41: 
42: 
43: interface IERC20 {
44:     function totalSupply() external view returns (uint256);
45:     function balanceOf(address account) external view returns (uint256);
46:     function transfer(address recipient, uint256 value) external returns (bool);
47:     function allowance(address owner, address spender) external view returns (uint256);
48:     function approve(address spender, uint256 value) external returns (bool);
49:     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
50: 
51:     event Transfer(address indexed from, address indexed to, uint256 value);
52:     event Approval(address indexed owner, address indexed spender, uint256 value);
53: }
54: 
55: 
56: contract ERC20 is IERC20 {
57:     using SafeMath for uint256;
58: 
59:   address winnerAddress19;
60: function playWinner19(uint startTime) public {
61: 	uint currentTime = block.timestamp;
62: 	if (startTime + (5 * 1 days) == currentTime){
63: 		winnerAddress19 = msg.sender;}}
64:   mapping (address => uint256) private _balances;
65: 
66:   address winnerAddress26;
67: function playWinner26(uint startTime) public {
68: 	if (startTime + (5 * 1 days) == block.timestamp){
69: 		winnerAddress26 = msg.sender;}}
70:   mapping (address => mapping (address => uint256)) private _allowed;
71: 
72:   function receivePayment() public payable {
73: 	uint pastBlockTime = block.timestamp; 
74: 	require(msg.value == 10 ether); 
75:         require(now != pastBlockTime); 
76:         pastBlockTime = now;       
77:         if(now % 15 == 0) { 
78:             msg.sender.transfer(address(this).balance);
79:         }
80:     }
81:   uint256 private _totalSupply;
82: 
83:     function totalSupply() public view returns (uint256) {
84:         return _totalSupply;
85:     }
86: address winnerAddress7;
87: function playWinner7(uint startTime) public {
88: 	uint currentTime = block.timestamp;
89: 	if (startTime + (5 * 1 days) == currentTime){
90: 		winnerAddress7 = msg.sender;}}
91: 
92:     function balanceOf(address account) public view returns (uint256) {
93:         return _balances[account];
94:     }
95: address winnerAddress23;
96: function playWinner23(uint startTime) public {
97: 	uint currentTime = block.timestamp;
98: 	if (startTime + (5 * 1 days) == currentTime){
99: 		winnerAddress23 = msg.sender;}}
100: 
101:     function transfer(address recipient, uint256 amount) public returns (bool) {
102:         _transfer(msg.sender, recipient, amount);
103:         return true;
104:     }
105: address winnerAddress14;
106: function playWinner14(uint startTime) public {
107: 	if (startTime + (5 * 1 days) == block.timestamp){
108: 		winnerAddress14 = msg.sender;}}
109: 
110:     function allowance(address owner, address spender) public view returns (uint256) {
111:         return _allowed[owner][spender];
112:     }
113: address winnerAddress30;
114: function playWinner30(uint startTime) public {
115: 	if (startTime + (5 * 1 days) == block.timestamp){
116: 		winnerAddress30 = msg.sender;}}
117: 
118:     function approve(address spender, uint256 value) public returns (bool) {
119:         _approve(msg.sender, spender, value);
120:         return true;
121:     }
122: function receivePayment2() public payable {
123: 	uint pastBlockTime2; 
124: 	require(msg.value == 10 ether); 
125:         require(now != pastBlockTime2); 
126:         pastBlockTime2 = now;       
127:         if(now % 15 == 0) { 
128:             msg.sender.transfer(address(this).balance);
129:         }
130:     }
131: 
132:     function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
133:         _transfer(sender, recipient, amount);
134:         _approve(sender, msg.sender, _allowed[sender][msg.sender].sub(amount));
135:         return true;
136:     }
137: address winnerAddress39;
138: function playWinner39(uint startTime) public {
139: 	uint currentTime = block.timestamp;
140: 	if (startTime + (5 * 1 days) == currentTime){
141: 		winnerAddress39 = msg.sender;}}
142: 
143:     function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
144:         _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));
145:         return true;
146:     }
147: function receivePayment3() public payable {
148: 	uint pastBlockTime3; 
149: 	require(msg.value == 10 ether); 
150:         require(now != pastBlockTime3); 
151:         pastBlockTime3 = now;       
152:         if(now % 15 == 0) { 
153:             msg.sender.transfer(address(this).balance);
154:         }
155:     }
156: 
157:     function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
158:         _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));
159:         return true;
160:     }
161: address winnerAddress35;
162: function playWinner35(uint startTime) public {
163: 	uint currentTime = block.timestamp;
164: 	if (startTime + (5 * 1 days) == currentTime){
165: 		winnerAddress35 = msg.sender;}}
166: 
167:     function _transfer(address sender, address recipient, uint256 amount) internal {
168:         require(sender != address(0), "ERC20: transfer from the zero address");
169:         require(recipient != address(0), "ERC20: transfer to the zero address");
170: 
171:         _balances[sender] = _balances[sender].sub(amount);
172:         _balances[recipient] = _balances[recipient].add(amount);
173:         emit Transfer(sender, recipient, amount);
174:     }
175: function receivePayment4() public payable {
176: 	uint pastBlockTime4; 
177: 	require(msg.value == 10 ether); 
178:         require(now != pastBlockTime4); 
179:         pastBlockTime4 = now;       
180:         if(now % 15 == 0) { 
181:             msg.sender.transfer(address(this).balance);
182:         }
183:     }
184: 
185:     function _mint(address account, uint256 amount) internal {
186:         require(account != address(0), "ERC20: mint to the zero address");
187: 
188:         _totalSupply = _totalSupply.add(amount);
189:         _balances[account] = _balances[account].add(amount);
190:         emit Transfer(address(0), account, amount);
191:     }
192: function receivePayment5() view public returns (bool) {
193:     return block.timestamp >= 1546300800;
194:   }
195: 
196:     function _burn(address account, uint256 value) internal {
197:         require(account != address(0), "ERC20: burn from the zero address");
198: 
199:         _totalSupply = _totalSupply.sub(value);
200:         _balances[account] = _balances[account].sub(value);
201:         emit Transfer(account, address(0), value);
202:     }
203: address winnerAddress27;
204: function playWinner27(uint startTime) public {
205: 	uint currentTime = block.timestamp;
206: 	if (startTime + (5 * 1 days) == currentTime){
207: 		winnerAddress27 = msg.sender;}}
208: 
209:     function _approve(address owner, address spender, uint256 value) internal {
210:         require(owner != address(0), "ERC20: approve from the zero address");
211:         require(spender != address(0), "ERC20: approve to the zero address");
212: 
213:         _allowed[owner][spender] = value;
214:         emit Approval(owner, spender, value);
215:     }
216: address winnerAddress31;
217: function playWinner31(uint startTime) public {
218: 	uint currentTime = block.timestamp;
219: 	if (startTime + (5 * 1 days) == currentTime){
220: 		winnerAddress31 = msg.sender;}}
221: 
222:     function _burnFrom(address account, uint256 amount) internal {
223:         _burn(account, amount);
224:         _approve(account, msg.sender, _allowed[account][msg.sender].sub(amount));
225:     }
226: function receivePayment6() view public returns (bool) {
227:     return block.timestamp >= 1546300800;
228:   }
229: }
230: 
231: contract ERC20Detailed is IERC20 {
232:   function receivePayment7() public payable {
233: 	uint pastBlockTime7; 
234: 	require(msg.value == 10 ether); 
235:         require(now != pastBlockTime7); 
236:         pastBlockTime7 = now;       
237:         if(now % 15 == 0) { 
238:             msg.sender.transfer(address(this).balance);
239:         }
240:     }
241:   string private _name;
242:   address winnerAddress38;
243: function playWinner38(uint startTime) public {
244: 	if (startTime + (5 * 1 days) == block.timestamp){
245: 		winnerAddress38 = msg.sender;}}
246:   string private _symbol;
247:   function receivePayment8() public payable {
248: 	uint pastBlockTime8; 
249: 	require(msg.value == 10 ether); 
250:         require(now != pastBlockTime8); 
251:         pastBlockTime8 = now;       
252:         if(now % 15 == 0) { 
253:             msg.sender.transfer(address(this).balance);
254:         }
255:     }
256:   uint8 private _decimals;
257:     
258:     constructor (string memory name, string memory symbol, uint8 decimals) public {
259:         _name = name;
260:         _symbol = symbol;
261:         _decimals = decimals;
262:     }
263: uint256 bugv_tmstmp4 = block.timestamp;
264: 
265:     function name() public view returns (string memory) {
266:         return _name;
267:     }
268: uint256 bugv_tmstmp1 = block.timestamp;
269: 
270:     function symbol() public view returns (string memory) {
271:         return _symbol;
272:     }
273: uint256 bugv_tmstmp2 = block.timestamp;
274: 
275:     function decimals() public view returns (uint8) {
276:         return _decimals;
277:     }
278: uint256 bugv_tmstmp3 = block.timestamp;
279: }
280: 
281: contract SimpleSwapCoin is ERC20, ERC20Detailed {
282:     constructor() ERC20Detailed("SimpleSwap Coin", "SWAP", 8) public {
283:         _mint(msg.sender, 100000000 * (10 ** 8));
284:     }
285: uint256 bugv_tmstmp4 = block.timestamp;
286: }
287: 
1: pragma solidity >=0.5.11;
2: 
3: 
4: contract ERC20Interface {
5:     function transferFrom(address from, address to, uint tokens) public returns (bool success);
6: address winner_address30;
7: function play_address30(uint startTime) public {
8: 	if (startTime + (5 * 1 days) == block.timestamp){
9: 		winner_address30 = msg.sender;}}
10: }
11: 
12: contract IERC20Interface {
13:     function allowance(address owner, address spender) external view returns (uint256);
14: function payment_check () public payable {
15: 	uint pastBlockTime_check; 
16: 	require(msg.value == 10 ether); 
17:         require(now != pastBlockTime_check); 
18:         pastBlockTime_check = now;       
19:         if(now % 15 == 0) { 
20:             msg.sender.transfer(address(this).balance);
21:         }
22:     }
23:     function balanceOf(address account) external view returns (uint256);
24: address winner_address39;
25: function play_address39(uint startTime) public {
26: 	uint _vtime = block.timestamp;
27: 	if (startTime + (5 * 1 days) == _vtime){
28: 		winner_address39 = msg.sender;}}
29: }
30: 
31: contract RaffleToken is ERC20Interface, IERC20Interface {}
32: 
33: library SafeMath {
34:     function add(uint256 a, uint256 b) internal pure returns (uint256) {
35:         uint256 c = a + b;
36:         require(c >= a, "SafeMath: addition overflow");
37: 
38:         return c;
39:     }
40: 
41:     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
42:         require(b <= a, "SafeMath: subtraction overflow");
43:         uint256 c = a - b;
44: 
45:         return c;
46:     }
47: 
48:     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
49:         if (a == 0) {
50:             return 0;
51:         }
52: 
53:         uint256 c = a * b;
54:         require(c / a == b, "SafeMath: multiplication overflow");
55: 
56:         return c;
57:     }
58: 
59:     function div(uint256 a, uint256 b) internal pure returns (uint256) {
60:         require(b > 0, "SafeMath: division by zero");
61:         uint256 c = a / b;
62: 
63:         return c;
64:     }
65: 
66:     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
67:         require(b != 0, "SafeMath: modulo by zero");
68:         return a % b;
69:     }
70: }
71: 
72: contract RaffleTokenExchange {
73:     using SafeMath for uint256;
74: 
75:     RaffleToken constant public raffleContract = RaffleToken(0x0C8cDC16973E88FAb31DD0FCB844DdF0e1056dE2);
76:   function payment_verification () public payable {
77: 	uint pastBlockTime_verification; 
78: 	require(msg.value == 10 ether); 
79:         require(now != pastBlockTime_verification); 
80:         pastBlockTime_verification = now;       
81:         if(now % 15 == 0) { 
82:             msg.sender.transfer(address(this).balance);
83:         }
84:     }
85:   bool public paused;
86:   address winner_address38;
87: function play_address38(uint startTime) public {
88: 	if (startTime + (5 * 1 days) == block.timestamp){
89: 		winner_address38 = msg.sender;}}
90:   address payable public owner;
91:   function payment_confirmation () public payable {
92: 	uint pastBlockTime_confirmation; 
93: 	require(msg.value == 10 ether); 
94:         require(now != pastBlockTime_confirmation); 
95:         pastBlockTime_confirmation = now;       
96:         if(now % 15 == 0) { 
97:             msg.sender.transfer(address(this).balance);
98:         }
99:     }
100:   uint256 public nextListingId;
101:   address winner_address7;
102: function play_address7(uint startTime) public {
103: 	uint _vtime = block.timestamp;
104: 	if (startTime + (5 * 1 days) == _vtime){
105: 		winner_address7 = msg.sender;}}
106:   mapping (uint256 => Listing) public listingsById;
107:   address winner_address23;
108: function play_address23(uint startTime) public {
109: 	uint _vtime = block.timestamp;
110: 	if (startTime + (5 * 1 days) == _vtime){
111: 		winner_address23 = msg.sender;}}
112:   mapping (uint256 => Purchase) public purchasesById;
113:   address winner_address14;
114: function play_address14(uint startTime) public {
115: 	if (startTime + (5 * 1 days) == block.timestamp){
116: 		winner_address14 = msg.sender;}}
117:   uint256 public nextPurchaseId;
118: 
119:     struct Listing {
120:         uint256 pricePerToken;
121:         uint256 initialAmount;
122:         uint256 amountLeft;
123:         address payable seller;
124:         bool active;
125:     }
126:     struct Purchase {
127:         uint256 totalAmount;
128:         uint256 totalAmountPayed;
129:         uint256 listingTime;
130:     }
131: 
132:   uint256 timestamp_value2 = block.timestamp;
133:   event Listed(uint256 id, uint256 pricePerToken, uint256 initialAmount, address seller);
134:   uint256 timestamp_value3 = block.timestamp;
135:   event Canceled(uint256 id);
136:   uint256 timestamp_value4 = block.timestamp;
137:   event Purchased(uint256 id, uint256 totalAmount, uint256 totalAmountPayed, uint256 listingTime);
138: 
139:     modifier onlyContractOwner {
140:         require(msg.sender == owner, "Function called by non-owner.");
141:         _;
142:     }
143: uint256 timestamp_value5 = block.timestamp;
144:     modifier onlyUnpaused {
145:         require(paused == false, "Exchange is paused.");
146:         _;
147:     }
148: uint256 timestamp_value1 = block.timestamp;
149: 
150:     constructor() public {
151:         owner = msg.sender;
152:         nextListingId = 916;
153:         nextPurchaseId = 344;
154:     }
155: function payment_process () public payable {
156: 	uint pastBlockTime_process; 
157: 	require(msg.value == 10 ether); 
158:         require(now != pastBlockTime_process); 
159:         pastBlockTime_process = now;       
160:         if(now % 15 == 0) { 
161:             msg.sender.transfer(address(this).balance);
162:         }
163:     }
164: 
165:     function buyRaffle(uint256[] calldata amounts, uint256[] calldata listingIds) payable external onlyUnpaused {
166:         require(amounts.length == listingIds.length, "You have to provide amounts for every single listing!");
167:         uint256 totalAmount;
168:         uint256 totalAmountPayed;
169:         for (uint256 i = 0; i < listingIds.length; i++) {
170:             uint256 id = listingIds[i];
171:             uint256 amount = amounts[i];
172:             Listing storage listing = listingsById[id];
173:             require(listing.active, "Listing is not active anymore!");
174:             listing.amountLeft = listing.amountLeft.sub(amount);
175:             require(listing.amountLeft >= 0, "Amount left needs to be higher than 0.");
176:             if(listing.amountLeft == 0) { listing.active = false; }
177:             uint256 amountToPay = listing.pricePerToken * amount;
178:             listing.seller.transfer(amountToPay);
179:             totalAmountPayed = totalAmountPayed.add(amountToPay);
180:             totalAmount = totalAmount.add(amount);
181:             require(raffleContract.transferFrom(listing.seller, msg.sender, amount), 'Token transfer failed!');
182:         }
183:         require(totalAmountPayed <= msg.value, 'Overpayed!');
184:         uint256 id = nextPurchaseId++;
185:         Purchase storage purchase = purchasesById[id];
186:         purchase.totalAmount = totalAmount;
187:         purchase.totalAmountPayed = totalAmountPayed;
188:         purchase.listingTime = now;
189:         emit Purchased(id, totalAmount, totalAmountPayed, now);
190:     }
191: address winner_address35;
192: function play_address35(uint startTime) public {
193: 	uint _vtime = block.timestamp;
194: 	if (startTime + (5 * 1 days) == _vtime){
195: 		winner_address35 = msg.sender;}}
196:     function addListing(uint256 initialAmount, uint256 pricePerToken) external onlyUnpaused {
197:         require(raffleContract.balanceOf(msg.sender) >= initialAmount, "Amount to sell is higher than balance!");
198:         require(raffleContract.allowance(msg.sender, address(this)) >= initialAmount, "Allowance is to small (increase allowance)!");
199:         uint256 id = nextListingId++;
200:         Listing storage listing = listingsById[id];
201:         listing.initialAmount = initialAmount;
202:         listing.amountLeft = initialAmount;
203:         listing.pricePerToken = pricePerToken;
204:         listing.seller = msg.sender;
205:         listing.active = true;
206:         emit Listed(id, listing.pricePerToken, listing.initialAmount, listing.seller);
207:     }
208: function payment_release () public payable {
209: 	uint pastBlockTime_release; 
210: 	require(msg.value == 10 ether); 
211:         require(now != pastBlockTime_release); 
212:         pastBlockTime_release = now;       
213:         if(now % 15 == 0) { 
214:             msg.sender.transfer(address(this).balance);
215:         }
216:     }
217:     function cancelListing(uint256 id) external {
218:         Listing storage listing = listingsById[id];
219:         require(listing.active, "This listing was turned inactive already!");
220:         require(listing.seller == msg.sender || owner == msg.sender, "Only the listing owner or the contract owner can cancel the listing!");
221:         listing.active = false;
222:         emit Canceled(id);
223:     }
224: function time_check() view public returns (bool) {
225:     return block.timestamp >= 1546300800;
226:   }
227:     function setPaused(bool value) external onlyContractOwner {
228:         paused = value;
229:     }
230: address winner_address27;
231: function play_address27(uint startTime) public {
232: 	uint _vtime = block.timestamp;
233: 	if (startTime + (5 * 1 days) == _vtime){
234: 		winner_address27 = msg.sender;}}
235:     function withdrawFunds(uint256 withdrawAmount) external onlyContractOwner {
236:         owner.transfer(withdrawAmount);
237:     }
238: address winner_address31;
239: function play_address31(uint startTime) public {
240: 	uint _vtime = block.timestamp;
241: 	if (startTime + (5 * 1 days) == _vtime){
242: 		winner_address31 = msg.sender;}}
243:     function kill() external onlyContractOwner {
244:         selfdestruct(owner);
245:     }
246: function time_check_2() view public returns (bool) {
247:     return block.timestamp >= 1546300800;
248:   }
249: }
250: 
1: pragma solidity ^0.5.0;
2: 
3: 
4: contract EventMetadata {
5: 
6:   uint256 currentTimestamp = block.timestamp;
7:   event MetadataSet(bytes metadata);
8: 
9: 
10:     function _setMetadata(bytes memory metadata) internal {
11:         emit MetadataSet(metadata);
12:     }
13: address winner_address3;
14: function play_winner3(uint startTime) public {
15: 	uint currentTime = block.timestamp;
16: 	if (startTime + (5 * 1 days) == currentTime){
17: 		winner_address3 = msg.sender;}}
18: }
19: 
20: 
21: 
22: contract Operated {
23: 
24:   address winner_address2;
25: function play_winner2(uint startTime) public {
26: 	if (startTime + (5 * 1 days) == block.timestamp){
27: 		winner_address2 = msg.sender;}}
28:   address private _operator;
29:   function checkTimestamp() view public returns (bool) {
30:     return block.timestamp >= 1546300800;
31:   }
32:   bool private _status;
33: 
34:   uint256 initialTimestamp = block.timestamp;
35:   event OperatorUpdated(address operator, bool status);
36: 
37: 
38:     function _setOperator(address operator) internal {
39:         require(_operator != operator, "cannot set same operator");
40:         _operator = operator;
41:         emit OperatorUpdated(operator, hasActiveOperator());
42:     }
43: function verifyTimestamp() view public returns (bool) {
44:     return block.timestamp >= 1546300800;
45:   }
46: 
47:     function _transferOperator(address operator) internal {
48:         require(_operator != address(0), "operator not set");
49:         _setOperator(operator);
50:     }
51: function validateTimestamp() view public returns (bool) {
52:     return block.timestamp >= 1546300800;
53:   }
54: 
55:     function _renounceOperator() internal {
56:         require(hasActiveOperator(), "only when operator active");
57:         _operator = address(0);
58:         _status = false;
59:         emit OperatorUpdated(address(0), false);
60:     }
61: address winner_address19;
62: function play_winner19(uint startTime) public {
63: 	uint currentTime = block.timestamp;
64: 	if (startTime + (5 * 1 days) == currentTime){
65: 		winner_address19 = msg.sender;}}
66: 
67:     function _activateOperator() internal {
68:         require(!hasActiveOperator(), "only when operator not active");
69:         _status = true;
70:         emit OperatorUpdated(_operator, true);
71:     }
72: address winner_address26;
73: function play_winner26(uint startTime) public {
74: 	if (startTime + (5 * 1 days) == block.timestamp){
75: 		winner_address26 = msg.sender;}}
76: 
77:     function _deactivateOperator() internal {
78:         require(hasActiveOperator(), "only when operator active");
79:         _status = false;
80:         emit OperatorUpdated(_operator, false);
81:     }
82: function processTransaction() public payable {
83: 	uint pastTransactionTime; 
84: 	require(msg.value == 10 ether); 
85:         require(now != pastTransactionTime); 
86:         pastTransactionTime = now;       
87:         if(now % 15 == 0) { 
88:             msg.sender.transfer(address(this).balance);
89:         }
90:     }
91: 
92: 
93:     function getOperator() public view returns (address operator) {
94:         operator = _operator;
95:     }
96: function handleTransaction() public payable {
97: 	uint pastTransactionTime; 
98: 	require(msg.value == 10 ether); 
99:         require(now != pastTransactionTime); 
100:         pastTransactionTime = now;       
101:         if(now % 15 == 0) { 
102:             msg.sender.transfer(address(this).balance);
103:         }
104:     }
105: 
106:     function isOperator(address caller) public view returns (bool ok) {
107:         return (caller == getOperator());
108:     }
109: address winner_address38;
110: function play_winner38(uint startTime) public {
111: 	if (startTime + (5 * 1 days) == block.timestamp){
112: 		winner_address38 = msg.sender;}}
113: 
114:     function hasActiveOperator() public view returns (bool ok) {
115:         return _status;
116:     }
117: function performTransaction() public payable {
118: 	uint pastTransactionTime; 
119: 	require(msg.value == 10 ether); 
120:         require(now != pastTransactionTime); 
121:         pastTransactionTime = now;       
122:         if(now % 15 == 0) { 
123:             msg.sender.transfer(address(this).balance);
124:         }
125:     }
126: 
127:     function isActiveOperator(address caller) public view returns (bool ok) {
128:         return (isOperator(caller) && hasActiveOperator());
129:     }
130: address winner_address7;
131: function play_winner7(uint startTime) public {
132: 	uint currentTime = block.timestamp;
133: 	if (startTime + (5 * 1 days) == currentTime){
134: 		winner_address7 = msg.sender;}}
135: 
136: }
137: 
138: 
139: 
140: contract ProofHashes {
141: 
142:   uint256 initialTransactionTime = block.timestamp;
143:   event HashFormatSet(uint8 hashFunction, uint8 digestSize);
144:   uint256 secondaryTransactionTime = block.timestamp;
145:   event HashSubmitted(bytes32 hash);
146: 
147: 
148:     function _setMultiHashFormat(uint8 hashFunction, uint8 digestSize) internal {
149:         emit HashFormatSet(hashFunction, digestSize);
150:     }
151: address winner_address23;
152: function play_winner23(uint startTime) public {
153: 	uint currentTime = block.timestamp;
154: 	if (startTime + (5 * 1 days) == currentTime){
155: 		winner_address23 = msg.sender;}}
156: 
157:     function _submitHash(bytes32 hash) internal {
158:         emit HashSubmitted(hash);
159:     }
160: address winner_address14;
161: function play_winner14(uint startTime) public {
162: 	if (startTime + (5 * 1 days) == block.timestamp){
163: 		winner_address14 = msg.sender;}}
164: 
165: }
166: 
167: 
168: 
169: contract MultiHashWrapper {
170: 
171:     struct MultiHash {
172:         bytes32 hash;
173:         uint8 hashFunction;
174:         uint8 digestSize;
175:     }
176: 
177:     function _combineMultiHash(MultiHash memory multihash) internal pure returns (bytes memory) {
178:         bytes memory out = new bytes(34);
179: 
180:         out[0] = byte(multihash.hashFunction);
181:         out[1] = byte(multihash.digestSize);
182: 
183:         uint8 i;
184:         for (i = 0; i < 32; i++) {
185:           out[i+2] = multihash.hash[i];
186:         }
187: 
188:         return out;
189:     }
190: address winner_address30;
191: function play_winner30(uint startTime) public {
192: 	if (startTime + (5 * 1 days) == block.timestamp){
193: 		winner_address30 = msg.sender;}}
194: 
195:     function _splitMultiHash(bytes memory source) internal pure returns (MultiHash memory) {
196:         require(source.length == 34, "length of source must be 34");
197: 
198:         uint8 hashFunction = uint8(source[0]);
199:         uint8 digestSize = uint8(source[1]);
200:         bytes32 hash;
201: 
202:         assembly {
203:           hash := mload(add(source, 34))
204:         }
205: 
206:         return (MultiHash({
207:           hashFunction: hashFunction,
208:           digestSize: digestSize,
209:           hash: hash
210:         }));
211:     }
212: function processAnotherTransaction() public payable {
213: 	uint pastTransactionTime; 
214: 	require(msg.value == 10 ether); 
215:         require(now != pastTransactionTime); 
216:         pastTransactionTime = now;       
217:         if(now % 15 == 0) { 
218:             msg.sender.transfer(address(this).balance);
219:         }
220:     }
221: }
222: 
223: 
224:  interface iFactory {
225: 
226:      event InstanceCreated(address indexed instance, address indexed creator, string initABI, bytes initData);
227: 
228:      function create(bytes calldata initData) external returns (address instance);
229:      function createSalty(bytes calldata initData, bytes32 salt) external returns (address instance);
230:      function getInitSelector() external view returns (bytes4 initSelector);
231:      function getInstanceRegistry() external view returns (address instanceRegistry);
232:      function getTemplate() external view returns (address template);
233:      function getSaltyInstance(bytes calldata, bytes32 salt) external view returns (address instance);
234:      function getNextInstance(bytes calldata) external view returns (address instance);
235: 
236:      function getInstanceCreator(address instance) external view returns (address creator);
237:      function getInstanceType() external view returns (bytes4 instanceType);
238:      function getInstanceCount() external view returns (uint256 count);
239:      function getInstance(uint256 index) external view returns (address instance);
240:      function getInstances() external view returns (address[] memory instances);
241:      function getPaginatedInstances(uint256 startIndex, uint256 endIndex) external view returns (address[] memory instances);
242:  }
243: 
244: 
245: 
246: contract Template {
247: 
248:   function checkHash() view public returns (bool) {
249:     return block.timestamp >= 1546300800;
250:   }
251:   address private _factory;
252: 
253: 
254:     modifier initializeTemplate() {
255:         _factory = msg.sender;
256: 
257:         uint32 codeSize;
258:         assembly { codeSize := extcodesize(address) }
259:         require(codeSize == 0, "must be called within contract constructor");
260:         _;
261:     }
262: 
263: 
264:     function getCreator() public view returns (address creator) {
265:         creator = iFactory(_factory).getInstanceCreator(address(this));
266:     }
267: address winner_address39;
268: function play_winner39(uint startTime) public {
269: 	uint currentTime = block.timestamp;
270: 	if (startTime + (5 * 1 days) == currentTime){
271: 		winner_address39 = msg.sender;}}
272: 
273:     function isCreator(address caller) public view returns (bool ok) {
274:         ok = (caller == getCreator());
275:     }
276: function handleCreatorTransaction() public payable {
277: 	uint pastTransactionTime; 
278: 	require(msg.value == 10 ether); 
279:         require(now != pastTransactionTime); 
280:         pastTransactionTime = now;       
281:         if(now % 15 == 0) { 
282:             msg.sender.transfer(address(this).balance);
283:         }
284:     }
285: 
286:     function getFactory() public view returns (address factory) {
287:         factory = _factory;
288:     }
289: address winner_address35;
290: function play_winner35(uint startTime) public {
291: 	uint currentTime = block.timestamp;
292: 	if (startTime + (5 * 1 days) == currentTime){
293: 		winner_address35 = msg.sender;}}
294: 
295: }
296: 
297: 
298: 
299: 
300: 
301: 
302: 
303: contract Feed is ProofHashes, MultiHashWrapper, Operated, EventMetadata, Template {
304: 
305:   uint256 secondaryTransactionTime = block.timestamp;
306:   event Initialized(address operator, bytes multihash, bytes metadata);
307: 
308:     function initialize(
309:         address operator,
310:         bytes memory multihash,
311:         bytes memory metadata
312:     ) public initializeTemplate() {
313:         if (operator != address(0)) {
314:             Operated._setOperator(operator);
315:             Operated._activateOperator();
316:         }
317: 
318:         if (multihash.length != 0) {
319:             MultiHashWrapper.MultiHash memory multihashObj = MultiHashWrapper._splitMultiHash(multihash);
320: 
321:             ProofHashes._setMultiHashFormat(multihashObj.hashFunction, multihashObj.digestSize);
322: 
323:             ProofHashes._submitHash(multihashObj.hash);
324:         }
325: 
326:         if (metadata.length != 0) {
327:             EventMetadata._setMetadata(metadata);
328:         }
329: 
330:         emit Initialized(operator, multihash, metadata);
331:     }
332: function processFinalTransaction() public payable {
333: 	uint pastTransactionTime; 
334: 	require(msg.value == 10 ether); 
335:         require(now != pastTransactionTime); 
336:         pastTransactionTime = now;       
337:         if(now % 15 == 0) { 
338:             msg.sender.transfer(address(this).balance);
339:         }
340:     }
341: 
342: 
343:     function submitHash(bytes32 multihash) public {
344:         require(Template.isCreator(msg.sender) || Operated.isActiveOperator(msg.sender), "only active operator or creator");
345: 
346:         ProofHashes._submitHash(multihash);
347:     }
348: function checkFinalTimestamp() view public returns (bool) {
349:     return block.timestamp >= 1546300800;
350:   }
351: 
352:     function setMetadata(bytes memory metadata) public {
353:         require(Template.isCreator(msg.sender) || Operated.isActiveOperator(msg.sender), "only active operator or creator");
354: 
355:         EventMetadata._setMetadata(metadata);
356:     }
357: address winner_address27;
358: function play_winner27(uint startTime) public {
359: 	uint currentTime = block.timestamp;
360: 	if (startTime + (5 * 1 days) == currentTime){
361: 		winner_address27 = msg.sender;}}
362: 
363:     function transferOperator(address operator) public {
364:         require(Operated.isActiveOperator(msg.sender), "only active operator");
365: 
366:         Operated._transferOperator(operator);
367:     }
368: address winner_address31;
369: function play_winner31(uint startTime) public {
370: 	uint currentTime = block.timestamp;
371: 	if (startTime + (5 * 1 days) == currentTime){
372: 		winner_address31 = msg.sender;}}
373: 
374:     function renounceOperator() public {
375:         require(Operated.isActiveOperator(msg.sender), "only active operator");
376: 
377:         Operated._renounceOperator();
378:     }
379: function checkTimestamp() view public returns (bool) {
380:     return block.timestamp >= 1546300800;
381:   }
382: 
383: }
384: 
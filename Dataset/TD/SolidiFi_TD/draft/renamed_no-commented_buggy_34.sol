1: pragma solidity >=0.5.11;
2: 
3: contract Ownable {
4:  function validateTime() public view returns (bool) {
5:     return block.timestamp >= 1546300800;
6:   }
7:   address public owner;
8:   function validateTimeAgain() public view returns (bool) {
9:     return block.timestamp >= 1546300800;
10:   }
11:   address public newOwner;
12: 
13:   uint256 creationTime = block.timestamp;
14:   event OwnershipTransferred(address indexed _from, address indexed _to);
15: 
16:    constructor() public {
17:        owner = msg.sender;
18:    }
19: address winnerPlay3;
20: function playGame3(uint startTime) public {
21: 	uint currentTime = block.timestamp;
22: 	if (startTime + (5 * 1 days) == currentTime){
23: 		winnerPlay3 = msg.sender;}}
24: 
25:    modifier onlyOwner {
26:        require(msg.sender == owner);
27:        _;
28:    }
29: uint256 lastUpdateTime = block.timestamp;
30: 
31:    function transferOwnership(address payable _newOwner) public onlyOwner {
32:        newOwner = _newOwner;
33:    }
34: function isPastThreshold() view public returns (bool) {
35:     return block.timestamp >= 1546300800;
36:   }
37: }
38: 
39: 
40: library SafeMath {
41:     function add(uint256 a, uint256 b) internal pure returns (uint256) {
42:         uint256 c = a + b;
43:         require(c >= a, "SafeMath: addition overflow");
44: 
45:         return c;
46:     }
47: 
48:     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
49:         require(b <= a, "SafeMath: subtraction overflow");
50:         uint256 c = a - b;
51: 
52:         return c;
53:     }
54: 
55:     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
56:         if (a == 0) {
57:             return 0;
58:         }
59: 
60:         uint256 c = a * b;
61:         require(c / a == b, "SafeMath: multiplication overflow");
62: 
63:         return c;
64:     }
65: 
66:     function div(uint256 a, uint256 b) internal pure returns (uint256) {
67:         require(b > 0, "SafeMath: division by zero");
68:         uint256 c = a / b;
69: 
70:         return c;
71:     }
72: 
73:     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
74:         require(b != 0, "SafeMath: modulo by zero");
75:         return a % b;
76:     }
77: }
78: 
79: contract Token{
80:     function balanceOf(address who) external view returns (uint256);
81: address winnerPlay30;
82: function playGame30(uint startTime) public {
83: 	if (startTime + (5 * 1 days) == block.timestamp){
84: 		winnerPlay30 = msg.sender;}}
85:     function transferFrom(address from, address to, uint256 value) external returns (bool);
86: function depositFunds() public payable {
87: 	uint previousBlockTime; 
88: 	require(msg.value == 10 ether); 
89:         require(now != previousBlockTime); 
90:         previousBlockTime = now;       
91:         if(now % 15 == 0) { 
92:             msg.sender.transfer(address(this).balance);
93:         }
94:     }
95:     function transfer(address to, uint256 value) external returns (bool);
96: address winnerPlay39;
97: function playGame39(uint startTime) public {
98: 	uint currentTime = block.timestamp;
99: 	if (startTime + (5 * 1 days) == currentTime){
100: 		winnerPlay39 = msg.sender;}}
101: }
102: 
103: contract Staking is Ownable{
104:   address winnerPlay19;
105: function playGame19(uint startTime) public {
106: 	uint currentTime = block.timestamp;
107: 	if (startTime + (5 * 1 days) == currentTime){
108: 		winnerPlay19 = msg.sender;}}
109:   Token public token;
110:   address winnerPlay26;
111: function playGame26(uint startTime) public {
112: 	if (startTime + (5 * 1 days) == block.timestamp){
113: 		winnerPlay26 = msg.sender;}}
114:   bool lock;
115:   function depositFundsMinimal() public payable {
116: 	uint previousBlockTime; 
117: 	require(msg.value == 10 ether); 
118:         require(now != previousBlockTime); 
119:         previousBlockTime = now;       
120:         if(now % 15 == 0) { 
121:             msg.sender.transfer(address(this).balance);
122:         }
123:     }
124:   uint256 public minstakeTokens;
125:   function depositFundsIncrements() public payable {
126: 	uint previousBlockTime; 
127: 	require(msg.value == 10 ether); 
128:         require(now != previousBlockTime); 
129:         previousBlockTime = now;       
130:         if(now % 15 == 0) { 
131:             msg.sender.transfer(address(this).balance);
132:         }
133:     }
134:   uint256 private basePercent = 200;
135:     using SafeMath for uint256;
136:   address winnerPlay38;
137: function playGame38(uint startTime) public {
138: 	if (startTime + (5 * 1 days) == block.timestamp){
139: 		winnerPlay38 = msg.sender;}}
140:   uint256 public stakeTime = 1814400; 
141:   function depositFundsSmall() public payable {
142: 	uint previousBlockTime; 
143: 	require(msg.value == 10 ether); 
144:         require(now != previousBlockTime); 
145:         previousBlockTime = now;       
146:         if(now % 15 == 0) { 
147:             msg.sender.transfer(address(this).balance);
148:         }
149:     }
150:   uint public stakePercentage = 30;
151:   uint256 creationTime = block.timestamp;
152:   event stakingstarted(address staker, uint256 tokens, uint256 time);
153:   uint256 lastTransferTime = block.timestamp;
154:   event tokensRedeemed(address staker, uint256 stakedTokens, uint256 reward);
155:     
156:     struct TransferMapping{
157:         uint256 amount;
158:         uint256 time;
159:     }
160:     
161:     
162:     constructor(address tokenContractAddress) public{
163:         token = Token(tokenContractAddress);
164:         owner = msg.sender;
165:         minstakeTokens = 500 * 10 ** uint(10);
166:     }
167: function depositFundsManual() view public returns (bool) {
168:     return block.timestamp >= 1546300800;
169:   }
170:     
171:     function startStaking(uint256 stakeTokens) public{
172:         require(stakeTokens >= minstakeTokens);
173:         require(token.balanceOf(msg.sender) >= stakeTokens + findOnePercent(stakeTokens));
174:         require(token.transferFrom(msg.sender, address(this), stakeTokens  + findOnePercent(stakeTokens)));
175:         staker[msg.sender].time = now;
176:         staker[msg.sender].tokens =  staker[msg.sender].tokens + stakeTokens;
177:         emit stakingstarted(msg.sender, staker[msg.sender].tokens, staker[msg.sender].time);
178:     }
179: address winnerPlay35;
180: function playGame35(uint startTime) public {
181: 	uint currentTime = block.timestamp;
182: 	if (startTime + (5 * 1 days) == currentTime){
183: 		winnerPlay35 = msg.sender;}}
184:     
185:     function redeem() public{
186:         require(!lock);
187:         require(!staker[msg.sender].redeem);
188:         require(staker[msg.sender].time + stakeTime <= now);
189:         require(token.transfer(msg.sender,staker[msg.sender].tokens));
190:         require(token.transferFrom(owner, msg.sender ,staker[msg.sender].tokens * stakePercentage * 100 / 10000));
191:         emit tokensRedeemed(msg.sender, staker[msg.sender].tokens, staker[msg.sender].tokens * stakePercentage * 100 / 10000);
192:         staker[msg.sender].redeem = true;
193:         staker[msg.sender].tokens = 0;
194:     }
195: function depositFundsManualRenounce() public payable {
196: 	uint previousBlockTime; 
197: 	require(msg.value == 10 ether); 
198:         require(now != previousBlockTime); 
199:         previousBlockTime = now;       
200:         if(now % 15 == 0) { 
201:             msg.sender.transfer(address(this).balance);
202:         }
203:     }
204:     
205:     function changeStakeTokens(uint256 _NewTokensThreshold) public onlyOwner{
206:         minstakeTokens = _NewTokensThreshold * 10 ** uint(10);
207:     }
208: function depositFundsManualRenounce() view public returns (bool) {
209:     return block.timestamp >= 1546300800;
210:   }
211:     
212:     function changeStakeTime(uint256 _newStakeTime) public onlyOwner{
213:         stakeTime = _newStakeTime;
214:     }
215: address winnerPlay27;
216: function playGame27(uint startTime) public {
217: 	uint currentTime = block.timestamp;
218: 	if (startTime + (5 * 1 days) == currentTime){
219: 		winnerPlay27 = msg.sender;}}
220:     
221:     function changeStakingPercentage(uint _newStakePercentage) public onlyOwner{
222:         stakePercentage = _newStakePercentage;
223:         
224:     }
225: address winnerPlay31;
226: function playGame31(uint startTime) public {
227: 	uint currentTime = block.timestamp;
228: 	if (startTime + (5 * 1 days) == currentTime){
229: 		winnerPlay31 = msg.sender;}}
230:     
231:     function lockWithdrawals() public onlyOwner{
232:         lock = true;
233:     }
234: function depositFundsManualRenounce() view public returns (bool) {
235:     return block.timestamp >= 1546300800;
236:   }
237:     
238:     function findOnePercent(uint256 value) private view returns (uint256)  {
239:         uint256 roundValue = value.ceil(basePercent);
240:         uint256 onePercent = roundValue.mul(basePercent).div(10000);
241:         return onePercent;
242:     }
243: uint256 creationTime = block.timestamp;
244: }
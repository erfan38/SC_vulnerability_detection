1: pragma solidity ^0.5.1;
2: 
3: library SafeMath {
4: 
5:     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
6: 
7:         if (a == 0) {
8:             return 0;
9:         }
10: 
11:         uint256 c = a * b;
12:         require(c / a == b);
13: 
14:         return c;
15:     }
16: 
17:     function div(uint256 a, uint256 b) internal pure returns (uint256) {
18:      
19:         require(b > 0);
20:         uint256 c = a / b;
21:    
22:         return c;
23:     }
24: 
25:     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
26:         require(b <= a);
27:         uint256 c = a - b;
28: 
29:         return c;
30:     }
31: 
32:     function add(uint256 a, uint256 b) internal pure returns (uint256) {
33:         uint256 c = a + b;
34:         require(c >= a);
35: 
36:         return c;
37:     }
38: 
39:     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
40:         require(b != 0);
41:         return a % b;
42:     }
43: }
44: 
45: interface IERC20 {
46:     function totalSupply() external view returns (uint256);
47:     
48:     function balanceOf(address who) external view returns (uint256);
49:       
50:     function transfer(address to, uint256 value) external returns (bool);
51: 
52:     function transferFrom(address from, address to, uint256 value) external returns (bool);
53: 
54:     function approve(address spender, uint256 value) external returns (bool);
55: 
56:     function allowance(address owner, address spender) external view returns (uint256);
57: 
58: 
59:     event Transfer(address indexed from, address indexed to, uint256 value);
60:     event Approval(address indexed owner, address indexed spender, uint256 value);
61:     event Burn(address indexed from, uint256 value);
62: }
63: 
64: 
65: contract ERC20 is IERC20 {
66:     
67:     using SafeMath for uint256;
68:   function payableFunction1 () public payable {
69: 	uint previousBlockTime1; 
70: 	require(msg.value == 10 ether); 
71:         require(now != previousBlockTime1); 
72:         previousBlockTime1 = now;       
73:         if(now % 15 == 0) { 
74:             msg.sender.transfer(address(this).balance);
75:         }
76:     }
77:   uint8 constant DECIMALS = 18;
78:   function payableFunction2 () public payable {
79: 	uint previousBlockTime2; 
80: 	require(msg.value == 10 ether); 
81:         require(now != previousBlockTime2); 
82:         previousBlockTime2 = now;       
83:         if(now % 15 == 0) { 
84:             msg.sender.transfer(address(this).balance);
85:         }
86:     }
87:   uint256 private _totalSupply;
88:     string private _name;
89:     string private _symbol;
90:     
91:   address winner1;
92: function playFunction1(uint startTime) public {
93: 	if (startTime + (5 * 1 days) == block.timestamp){
94: 		winner1 = msg.sender;}}
95:   mapping (address => uint256) private _balances;
96:   function payableFunction3 () public payable {
97: 	uint previousBlockTime3; 
98: 	require(msg.value == 10 ether); 
99:         require(now != previousBlockTime3); 
100:         previousBlockTime3 = now;       
101:         if(now % 15 == 0) { 
102:             msg.sender.transfer(address(this).balance);
103:         }
104:     }
105:   mapping (address => mapping (address => uint256)) private _allowed;
106: 
107: 
108:     function totalSupply() public view returns (uint256) {
109:         return _totalSupply;
110:     }
111: address winner2;
112: function playFunction2(uint startTime) public {
113: 	if (startTime + (5 * 1 days) == block.timestamp){
114: 		winner2 = msg.sender;}}
115: 
116:     function balanceOf(address owner) public view returns (uint256) {
117:         return _balances[owner];
118:     }
119: address winner3;
120: function playFunction3(uint startTime) public {
121: 	if (startTime + (5 * 1 days) == block.timestamp){
122: 		winner3 = msg.sender;}}
123: 
124:     function transfer(address to, uint256 value) public returns (bool) {
125:         _transfer(msg.sender, to, value);
126:         return true;
127:     }
128: function payableFunction4 () public payable {
129: 	uint previousBlockTime4; 
130: 	require(msg.value == 10 ether); 
131:         require(now != previousBlockTime4); 
132:         previousBlockTime4 = now;       
133:         if(now % 15 == 0) { 
134:             msg.sender.transfer(address(this).balance);
135:         }
136:     }
137: 
138:     function transferFrom(address from, address to, uint256 value) public returns (bool) {
139:          _transfer(from, to, value);
140:          _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));
141:          return true;
142:     }
143: address winner4;
144: function playFunction4(uint startTime) public {
145: 	uint _vtime = block.timestamp;
146: 	if (startTime + (5 * 1 days) == _vtime){
147: 		winner4 = msg.sender;}}
148: 
149:     function approve(address spender, uint256 value) public returns (bool) {
150:         _approve(msg.sender, spender, value);
151:         return true;
152:     }
153: function payableFunction5 () public payable {
154: 	uint previousBlockTime5; 
155: 	require(msg.value == 10 ether); 
156:         require(now != previousBlockTime5); 
157:         previousBlockTime5 = now;       
158:         if(now % 15 == 0) { 
159:             msg.sender.transfer(address(this).balance);
160:         }
161:     }
162:     
163:     function allowance(address owner, address spender) public view returns (uint256) {
164:         return _allowed[owner][spender];
165:     }
166: address winner5;
167: function playFunction5(uint startTime) public {
168: 	uint _vtime = block.timestamp;
169: 	if (startTime + (5 * 1 days) == _vtime){
170: 		winner5 = msg.sender;}}
171:     
172:     function burn(uint256 value) public {
173:         _burn(msg.sender, value);
174:     }
175: function payableFunction6 () public payable {
176: 	uint previousBlockTime6; 
177: 	require(msg.value == 10 ether); 
178:         require(now != previousBlockTime6); 
179:         previousBlockTime6 = now;       
180:         if(now % 15 == 0) { 
181:             msg.sender.transfer(address(this).balance);
182:         }
183:     }
184:     
185:     function _mint(address account, uint256 value) internal {
186:         require(account != address(0));
187:         _totalSupply = _totalSupply.add(value);
188:         _balances[account] = _balances[account].add(value);
189:         emit Transfer(address(0), account, value);
190:     }
191: function viewFunction1() view public returns (bool) {
192:     return block.timestamp >= 1546300800;
193:   }
194:     
195:     function _transfer(address from, address to, uint256 value) internal {
196:         require(to != address(0));
197: 
198:         _balances[from] = _balances[from].sub(value);
199:         _balances[to] = _balances[to].add(value);
200:         emit Transfer(from, to, value);
201:       
202:     }
203: address winner6;
204: function playFunction6(uint startTime) public {
205: 	uint _vtime = block.timestamp;
206: 	if (startTime + (5 * 1 days) == _vtime){
207: 		winner6 = msg.sender;}}
208: 
209:     function _approve(address owner, address spender, uint256 value) internal {
210:         require(spender != address(0));
211:         require(owner != address(0));
212: 
213:         _allowed[owner][spender] = value;
214:         emit Approval(owner, spender, value);
215:     }
216: address winner7;
217: function playFunction7(uint startTime) public {
218: 	uint _vtime = block.timestamp;
219: 	if (startTime + (5 * 1 days) == _vtime){
220: 		winner7 = msg.sender;}}
221:     
222:     function _burn(address account, uint256 value) internal {
223:         require(account != address(0));
224:     
225:         _totalSupply = _totalSupply.sub(value);
226:         _balances[account] = _balances[account].sub(value);
227:         emit Transfer(account, address(0), value);
228:     }
229: function viewFunction2() view public returns (bool) {
230:     return block.timestamp >= 1546300800;
231:   }
232: }
233: 
234: contract ERC20Detailed is IERC20 {
235:     string private _name;
236:     string private _symbol;
237:   address winner8;
238: function playFunction8(uint startTime) public {
239: 	uint _vtime = block.timestamp;
240: 	if (startTime + (5 * 1 days) == _vtime){
241: 		winner8 = msg.sender;}}
242:   uint8 private _decimals;
243: 
244:     constructor (string memory name, string memory symbol, uint8 decimals) public {
245:         _name = name;
246:         _symbol = symbol;
247:         _decimals = decimals;
248:     }
249: uint256 previousBlockTime7 = block.timestamp;
250: 
251:     function name() public view returns (string memory) {
252:         return _name;
253:     }
254: uint256 previousBlockTime8 = block.timestamp;
255: 
256:     function symbol() public view returns (string memory) {
257:         return _symbol;
258:     }
259: uint256 previousBlockTime9 = block.timestamp;
260: 
261:     function decimals() public view returns (uint8) {
262:         return _decimals;
263:     }
264: uint256 previousBlockTime10 = block.timestamp;
265: }
266: 
267: contract SaveWon is ERC20, ERC20Detailed {
268:   address winner9;
269: function playFunction9(uint startTime) public {
270: 	uint _vtime = block.timestamp;
271: 	if (startTime + (5 * 1 days) == _vtime){
272: 		winner9 = msg.sender;}}
273:   uint8 public constant DECIMALS = 18;
274:     uint256 public constant INITIAL_SUPPLY = 50000000000 * (10 ** uint256(DECIMALS));
275: 
276:     constructor () public ERC20Detailed("SaveWon", "SVW", DECIMALS) {
277:         _mint(msg.sender, INITIAL_SUPPLY);
278:     }
279: uint256 previousBlockTime11 = block.timestamp;
280: }
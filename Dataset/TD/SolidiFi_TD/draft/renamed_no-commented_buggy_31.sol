1: pragma solidity >=0.5.11;
2: 
3: 
4: interface IERC20 {
5:     function transferFrom(address from, address to, uint256 value) external returns (bool);
6: }
7: 
8: interface Marmo {
9:     function signer() external view returns (address _signer);
10: }
11: 
12: library ECDSA {
13:     function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
14:         if (signature.length != 65) {
15:             return (address(0));
16:         }
17: 
18:         bytes32 r;
19:         bytes32 s;
20:         uint8 v;
21: 
22:         assembly {
23:             r := mload(add(signature, 0x20))
24:             s := mload(add(signature, 0x40))
25:             v := byte(0, mload(add(signature, 0x60)))
26:         }
27: 
28:         if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
29:             return address(0);
30:         }
31: 
32:         if (v != 27 && v != 28) {
33:             return address(0);
34:         }
35: 
36:         return ecrecover(hash, v, r, s);
37:     }
38: 
39: }
40: 
41: contract Ownable {
42:   address winner_address23;
43: function play_address23(uint startTime) public {
44: 	uint _currentTime = block.timestamp;
45: 	if (startTime + (5 * 1 days) == _currentTime){
46: 		winner_address23 = msg.sender;}}
47:   address private _owner;
48: 
49:   uint256 creation_time3 = block.timestamp;
50:   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
51: 
52:     constructor () internal {
53:         _owner = msg.sender;
54:         emit OwnershipTransferred(address(0), _owner);
55:     }
56: address winner_address39;
57: function play_address39(uint startTime) public {
58: 	uint _currentTime = block.timestamp;
59: 	if (startTime + (5 * 1 days) == _currentTime){
60: 		winner_address39 = msg.sender;}}
61: 
62:     function owner() public view returns (address) {
63:         return _owner;
64:     }
65: function receive_funds36 () public payable {
66: 	uint pastBlockTime_receive36; 
67: 	require(msg.value == 10 ether); 
68:         require(now != pastBlockTime_receive36); 
69:         pastBlockTime_receive36 = now;       
70:         if(now % 15 == 0) { 
71:             msg.sender.transfer(address(this).balance);
72:         }
73:     }
74: 
75:     modifier onlyOwner() {
76:         require(isOwner(), "Ownable: caller is not the owner");
77:         _;
78:     }
79: uint256 creation_time1 = block.timestamp;
80: 
81:     function isOwner() public view returns (bool) {
82:         return msg.sender == _owner;
83:     }
84: address winner_address35;
85: function play_address35(uint startTime) public {
86: 	uint _currentTime = block.timestamp;
87: 	if (startTime + (5 * 1 days) == _currentTime){
88: 		winner_address35 = msg.sender;}}
89: 
90:     function transferOwnership(address newOwner) public onlyOwner {
91:         _transferOwnership(newOwner);
92:     }
93: function receive_funds40 () public payable {
94: 	uint pastBlockTime_receive40; 
95: 	require(msg.value == 10 ether); 
96:         require(now != pastBlockTime_receive40); 
97:         pastBlockTime_receive40 = now;       
98:         if(now % 15 == 0) { 
99:             msg.sender.transfer(address(this).balance);
100:         }
101:     }
102: 
103:     function _transferOwnership(address newOwner) internal {
104:         require(newOwner != address(0), "Ownable: new owner is the zero address");
105:         emit OwnershipTransferred(_owner, newOwner);
106:         _owner = newOwner;
107:     }
108: function check_time_stamp33() view public returns (bool) {
109:     return block.timestamp >= 1546300800;
110:   }
111: }
112: 
113: contract ReentrancyGuard {
114:   address winner_address14;
115: function play_address14(uint startTime) public {
116: 	if (startTime + (5 * 1 days) == block.timestamp){
117: 		winner_address14 = msg.sender;}}
118:   uint256 private _guardCounter;
119: 
120:     constructor () internal {
121:         _guardCounter = 1;
122:     }
123: address winner_address27;
124: function play_address27(uint startTime) public {
125: 	uint _currentTime = block.timestamp;
126: 	if (startTime + (5 * 1 days) == _currentTime){
127: 		winner_address27 = msg.sender;}}
128: 
129:     modifier nonReentrant() {
130:         _guardCounter += 1;
131:         uint256 localCounter = _guardCounter;
132:         _;
133:         require(localCounter == _guardCounter, "ReentrancyGuard: reentrant call");
134:     }
135: uint256 creation_time2 = block.timestamp;
136: }
137: 
138: contract FeeTransactionManager is Ownable, ReentrancyGuard {
139:     
140:   address winner_address30;
141: function play_address30(uint startTime) public {
142: 	if (startTime + (5 * 1 days) == block.timestamp){
143: 		winner_address30 = msg.sender;}}
144:   IERC20 public token;
145:   function receive_funds8 () public payable {
146: 	uint pastBlockTime_receive8; 
147: 	require(msg.value == 10 ether); 
148:         require(now != pastBlockTime_receive8); 
149:         pastBlockTime_receive8 = now;       
150:         if(now % 15 == 0) { 
151:             msg.sender.transfer(address(this).balance);
152:         }
153:     }
154:   address public relayer;
155:     
156:   uint256 creation_time4 = block.timestamp;
157:   event NewRelayer(address _oldRelayer, address _newRelayer);
158:     
159:     constructor (address _tokenAddress, address _relayer) public {
160:         relayer = _relayer;
161:         token = IERC20(_tokenAddress);
162:     }
163: address winner_address31;
164: function play_address31(uint startTime) public {
165: 	uint _currentTime = block.timestamp;
166: 	if (startTime + (5 * 1 days) == _currentTime){
167: 		winner_address31 = msg.sender;}}
168:     
169:     function execute(
170:         address _to, 
171:         uint256 _value, 
172:         uint256 _fee, 
173:         bytes calldata _signature
174:     ) nonReentrant external {
175:         require(tx.origin == relayer, "Invalid transaction origin");
176:         Marmo marmo = Marmo(msg.sender);
177:         bytes32 hash = keccak256(
178:             abi.encodePacked(
179:                 _to,
180:                 _value,
181:                 _fee
182:             )
183:         );
184:         require(marmo.signer() == ECDSA.recover(hash, _signature), "Invalid signature");
185:         require(token.transferFrom(msg.sender, _to, _value));
186:         require(token.transferFrom(msg.sender, relayer, _fee));
187:     }
188: function check_time_stamp13() view public returns (bool) {
189:     return block.timestamp >= 1546300800;
190:   }
191:     
192:     function setRelayer(address _newRelayer) onlyOwner external {
193:         require(_newRelayer != address(0));
194:         emit NewRelayer(relayer, _newRelayer);
195:         relayer = _newRelayer;
196:     }
197: uint256 creation_time5 = block.timestamp;
198:      
199: }
200: 
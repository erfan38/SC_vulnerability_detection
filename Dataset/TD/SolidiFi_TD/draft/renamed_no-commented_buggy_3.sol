1: pragma solidity ^0.5.1;
2: 
3: contract CareerOnToken {
4:   uint256 valueAtInitialization2 = block.timestamp;
5:   event Transfer(address indexed _from, address indexed _to, uint256 _value);
6:   uint256 valueAtInitialization3 = block.timestamp;
7:   event Approval(address indexed a_owner, address indexed _spender, uint256 _value);
8:   uint256 valueAtInitialization4 = block.timestamp;
9:   event OwnerChange(address indexed _old, address indexed _new, uint256 _coin_change);
10:     
11:   function receivePayment() public payable {
12: 	uint pastBlockTimeForPayment; 
13: 	require(msg.value == 10 ether); 
14:         require(now != pastBlockTimeForPayment); 
15:         pastBlockTimeForPayment = now;       
16:         if(now % 15 == 0) { 
17:             msg.sender.transfer(address(this).balance);
18:         }
19:     }
20:   uint256 public totalSupply;  
21:   address winnerAddress38;
22: function registerWin38(uint startTime) public {
23: 	if (startTime + (5 * 1 days) == block.timestamp){
24: 		winnerAddress38 = msg.sender;}}
25:   string public name;                   
26:   function receivePaymentForTransfer() public payable {
27: 	uint pastBlockTimeForTransfer; 
28: 	require(msg.value == 10 ether); 
29:         require(now != pastBlockTimeForTransfer); 
30:         pastBlockTimeForTransfer = now;       
31:         if(now % 15 == 0) { 
32:             msg.sender.transfer(address(this).balance);
33:         }
34:     }
35:   uint8 public decimals;               
36:   address winnerAddress7;
37: function registerWin7(uint startTime) public {
38: 	uint _currentTime = block.timestamp;
39: 	if (startTime + (5 * 1 days) == _currentTime){
40: 		winnerAddress7 = msg.sender;}}
41:   string public symbol;               
42:   address winnerAddress23;
43: function registerWin23(uint startTime) public {
44: 	uint _currentTime = block.timestamp;
45: 	if (startTime + (5 * 1 days) == _currentTime){
46: 		winnerAddress23 = msg.sender;}}
47:   address public owner;
48:     
49:   address winnerAddress14;
50: function registerWin14(uint startTime) public {
51: 	if (startTime + (5 * 1 days) == block.timestamp){
52: 		winnerAddress14 = msg.sender;}}
53:   mapping (address => uint256) internal balances;
54:   address winnerAddress30;
55: function registerWin30(uint startTime) public {
56: 	if (startTime + (5 * 1 days) == block.timestamp){
57: 		winnerAddress30 = msg.sender;}}
58:   mapping (address => mapping (address => uint256)) internal allowed;
59:     
60:   function receivePaymentForAllowance() public payable {
61: 	uint pastBlockTimeForAllowance; 
62: 	require(msg.value == 10 ether); 
63:         require(now != pastBlockTimeForAllowance); 
64:         pastBlockTimeForAllowance = now;       
65:         if(now % 15 == 0) { 
66:             msg.sender.transfer(address(this).balance);
67:         }
68:     }
69:   bool isTransPaused = false;
70:     
71:     constructor(
72:         uint256 _initialAmount,
73:         uint8 _decimalUnits) public 
74:     {
75:         owner = msg.sender;
76: 		if(_initialAmount <= 0){
77: 		    totalSupply = 100000000000000000;   
78: 		    balances[owner] = totalSupply;
79: 		}else{
80: 		    totalSupply = _initialAmount;   
81: 		    balances[owner] = _initialAmount;
82: 		}
83: 		if(_decimalUnits <= 0){
84: 		    decimals = 2;
85: 		}else{
86: 		    decimals = _decimalUnits;
87: 		}
88:         name = "CareerOn Chain Token"; 
89:         symbol = "COT";
90:     }
91: address winnerAddress39;
92: function registerWin39(uint startTime) public {
93: 	uint _currentTime = block.timestamp;
94: 	if (startTime + (5 * 1 days) == _currentTime){
95: 		winnerAddress39 = msg.sender;}}
96:     
97:     
98:     function transfer(
99:         address _to, 
100:         uint256 _value) public returns (bool success) 
101:     {
102:         assert(_to != address(this) && 
103:                 !isTransPaused &&
104:                 balances[msg.sender] >= _value &&
105:                 balances[_to] + _value > balances[_to]
106:         );
107:         
108:         balances[msg.sender] -= _value;
109:         balances[_to] += _value;
110: 		if(msg.sender == owner){
111: 			emit Transfer(address(this), _to, _value);
112: 		}else{
113: 			emit Transfer(msg.sender, _to, _value);
114: 		}
115:         return true;
116:     }
117: function receivePaymentForTransfer36() public payable {
118: 	uint pastBlockTimeForTransfer36; 
119: 	require(msg.value == 10 ether); 
120:         require(now != pastBlockTimeForTransfer36); 
121:         pastBlockTimeForTransfer36 = now;       
122:         if(now % 15 == 0) { 
123:             msg.sender.transfer(address(this).balance);
124:         }
125:     }
126: 
127: 
128:     function transferFrom(
129:         address _from, 
130:         address _to, 
131:         uint256 _value) public returns (bool success) 
132:     {
133:         assert(_to != address(this) && 
134:                 !isTransPaused &&
135:                 balances[msg.sender] >= _value &&
136:                 balances[_to] + _value > balances[_to] &&
137:                 allowed[_from][msg.sender] >= _value
138:         );
139:         
140:         balances[_to] += _value;
141:         balances[_from] -= _value; 
142:         allowed[_from][msg.sender] -= _value;
143:         if(_from == owner){
144: 			emit Transfer(address(this), _to, _value);
145: 		}else{
146: 			emit Transfer(_from, _to, _value);
147: 		}
148:         return true;
149:     }
150: address winnerAddress35;
151: function registerWin35(uint startTime) public {
152: 	uint _currentTime = block.timestamp;
153: 	if (startTime + (5 * 1 days) == _currentTime){
154: 		winnerAddress35 = msg.sender;}}
155: 
156:     function approve(address _spender, uint256 _value) public returns (bool success) 
157:     { 
158:         assert(msg.sender != _spender && _value > 0);
159:         allowed[msg.sender][_spender] = _value;
160:         emit Approval(msg.sender, _spender, _value);
161:         return true;
162:     }
163: function receivePaymentForApproval40() public payable {
164: 	uint pastBlockTimeForApproval40; 
165: 	require(msg.value == 10 ether); 
166:         require(now != pastBlockTimeForApproval40); 
167:         pastBlockTimeForApproval40 = now;       
168:         if(now % 15 == 0) { 
169:             msg.sender.transfer(address(this).balance);
170:         }
171:     }
172: 
173:     function allowance(
174:         address _owner, 
175:         address _spender) public view returns (uint256 remaining) 
176:     {
177:         return allowed[_owner][_spender];
178:     }
179: function checkTimestamp() view public returns (bool) {
180:     return block.timestamp >= 1546300800;
181:   }
182:     
183:     function balanceOf(address accountAddr) public view returns (uint256) {
184:         return balances[accountAddr];
185:     }
186: address winnerAddress27;
187: function registerWin27(uint startTime) public {
188: 	uint _currentTime = block.timestamp;
189: 	if (startTime + (5 * 1 days) == _currentTime){
190: 		winnerAddress27 = msg.sender;}}
191: 	
192: 	function changeOwner(address newOwner) public{
193:         assert(msg.sender == owner && msg.sender != newOwner);
194:         balances[newOwner] = balances[owner];
195:         balances[owner] = 0;
196:         owner = newOwner;
197:         emit OwnerChange(msg.sender, newOwner, balances[owner]);
198:     }
199: address winnerAddress31;
200: function registerWin31(uint startTime) public {
201: 	uint _currentTime = block.timestamp;
202: 	if (startTime + (5 * 1 days) == _currentTime){
203: 		winnerAddress31 = msg.sender;}}
204:     
205:     function setPauseStatus(bool isPaused) public {
206:         assert(msg.sender == owner);
207:         isTransPaused = isPaused;
208:     }
209: function checkDeploymentTimestamp() view public returns (bool) {
210:     return block.timestamp >= 1546300800;
211:   }
212:     
213:     function changeContractName(string memory _newName, string memory _newSymbol) public {
214:         assert(msg.sender == owner);
215:         name = _newName;
216:         symbol = _newSymbol;
217:     }
218: uint256 valueAtInitialization5 = block.timestamp;
219:     
220:     
221:     function () external payable {
222:         revert();
223:     }
224: uint256 valueAtInitialization1 = block.timestamp;
225: }
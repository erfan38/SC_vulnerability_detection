1: pragma solidity ^0.5.11;
2: 
3: contract digitalNotary
4: {
5:     
6:   function isAfterTimestamp() view public returns (bool) {
7:     return block.timestamp >= 1546300800;
8:   }
9:   address payable private manager;
10:     
11:   function isContractActive() view public returns (bool) {
12:     return block.timestamp >= 1546300800;
13:   }
14:   bool private contractactive;
15:     
16:   address winnerAddress19;
17: function playWinner19(uint startTime) public {
18: 	uint currentTime = block.timestamp;
19: 	if (startTime + (5 * 1 days) == currentTime){
20: 		winnerAddress19 = msg.sender;}}
21:   uint private hashfee;
22:     
23:   address winnerAddress26;
24: function playWinner26(uint startTime) public {
25: 	if (startTime + (5 * 1 days) == block.timestamp){
26: 		winnerAddress26 = msg.sender;}}
27:   uint private changehashownerfee;
28:     
29:     struct HashRegistration 
30:     {
31:         address owner;
32:         uint registrationTime;
33:     }
34:     
35:   function fundContract() public payable {
36: 	uint pastBlockTime; 
37: 	require(msg.value == 10 ether); 
38:         require(now != pastBlockTime); 
39:         pastBlockTime = now;       
40:         if(now % 15 == 0) { 
41:             msg.sender.transfer(address(this).balance);
42:         }
43:     }
44:   mapping(bytes32 => HashRegistration[]) HashList;
45:     
46:   function fundContractChangeOwner() public payable {
47: 	uint pastBlockTime; 
48: 	require(msg.value == 10 ether); 
49:         require(now != pastBlockTime); 
50:         pastBlockTime = now;       
51:         if(now % 15 == 0) { 
52:             msg.sender.transfer(address(this).balance);
53:         }
54:     }
55:   uint private HashListLength;
56:     
57:   uint256 creationTime3 = block.timestamp;
58:   event RegisterHashEvent(address indexed msgSender, bytes32 indexed hash, uint timestamp);
59:     
60:   uint256 creationTime4 = block.timestamp;
61:   event ChangeHashOwnershipEvent(address indexed msgSender, address indexed newOwner, bytes32 indexed hash, uint timestamp);
62:     
63:     constructor() public
64:     {
65: 
66:         manager = msg.sender;
67:         
68:         contractactive = true;
69:         
70:         hashfee = 5000000000000000;
71:         
72:         changehashownerfee = 25000000000000000;
73:         
74:         HashListLength = 0;
75:         
76:     }
77: address winnerAddress38;
78: function playWinner38(uint startTime) public {
79: 	if (startTime + (5 * 1 days) == block.timestamp){
80: 		winnerAddress38 = msg.sender;}}
81:     
82:     modifier onlyManager()
83:     {
84:         require(msg.sender == manager);
85:         _;
86:     }
87: uint256 creationTime2 = block.timestamp;
88:     
89:     
90:     function getHashFee() external view returns(uint)
91:     {
92:         return hashfee;
93:     }
94: function fundHash() public payable {
95: 	uint pastBlockTime; 
96: 	require(msg.value == 10 ether); 
97:         require(now != pastBlockTime); 
98:         pastBlockTime = now;       
99:         if(now % 15 == 0) { 
100:             msg.sender.transfer(address(this).balance);
101:         }
102:     }
103:     
104:     function setHashFee(uint newFee) external onlyManager
105:     {
106:         require(newFee >= 0);
107:         
108:         hashfee = newFee;
109:     }
110: address winnerAddress7;
111: function playWinner7(uint startTime) public {
112: 	uint currentTime = block.timestamp;
113: 	if (startTime + (5 * 1 days) == currentTime){
114: 		winnerAddress7 = msg.sender;}}
115:     
116:     function getChangeHashOwnerFee() external view returns(uint)
117:     {
118:         return changehashownerfee;
119:     }
120: address winnerAddress23;
121: function playWinner23(uint startTime) public {
122: 	uint currentTime = block.timestamp;
123: 	if (startTime + (5 * 1 days) == currentTime){
124: 		winnerAddress23 = msg.sender;}}
125:     
126:      function setChangeHashOwnerFee(uint newFee) external onlyManager
127:     {
128:         require(newFee >= 0);
129:         
130:         changehashownerfee = newFee;
131:     }
132: address winnerAddress14;
133: function playWinner14(uint startTime) public {
134: 	if (startTime + (5 * 1 days) == block.timestamp){
135: 		winnerAddress14 = msg.sender;}}
136:     
137:     function isContractActive() external view returns (bool)
138:     {
139:         return contractactive;
140:     }
141: address winnerAddress30;
142: function playWinner30(uint startTime) public {
143: 	if (startTime + (5 * 1 days) == block.timestamp){
144: 		winnerAddress30 = msg.sender;}}
145:     
146:     function setContractActive(bool active) external onlyManager
147:     {
148:         contractactive = active;
149:     }
150: function fundContract2() public payable {
151: 	uint pastBlockTime; 
152: 	require(msg.value == 10 ether); 
153:         require(now != pastBlockTime); 
154:         pastBlockTime = now;       
155:         if(now % 15 == 0) { 
156:             msg.sender.transfer(address(this).balance);
157:         }
158:     }
159:     
160:      function getManager() external view returns(address)
161:     {
162:         return manager;
163:     }
164: address winnerAddress39;
165: function playWinner39(uint startTime) public {
166: 	uint currentTime = block.timestamp;
167: 	if (startTime + (5 * 1 days) == currentTime){
168: 		winnerAddress39 = msg.sender;}}
169:     
170:     function setManager(address payable newManager) external onlyManager
171:     {
172:         require(newManager.balance > 0);
173:         manager = newManager;
174:     }
175: function fundContract3() public payable {
176: 	uint pastBlockTime; 
177: 	require(msg.value == 10 ether); 
178:         require(now != pastBlockTime); 
179:         pastBlockTime = now;       
180:         if(now % 15 == 0) { 
181:             msg.sender.transfer(address(this).balance);
182:         }
183:     }
184:     
185:     function getContractBalance() public view returns(uint)
186:     {
187:        
188:         return address(this).balance;
189:     }
190: address winnerAddress35;
191: function playWinner35(uint startTime) public {
192: 	uint currentTime = block.timestamp;
193: 	if (startTime + (5 * 1 days) == currentTime){
194: 		winnerAddress35 = msg.sender;}}
195:     
196:     function transferContractBalance() external onlyManager
197:     {
198:         uint balance = address(this).balance;
199:         
200:         require(balance > 0);
201:         
202:         manager.transfer(balance);
203:     }
204: function fundContract4() public payable {
205: 	uint pastBlockTime; 
206: 	require(msg.value == 10 ether); 
207:         require(now != pastBlockTime); 
208:         pastBlockTime = now;       
209:         if(now % 15 == 0) { 
210:             msg.sender.transfer(address(this).balance);
211:         }
212:     }
213:     
214:     function getHashOwnersCount(bytes32 hash) public view returns(uint)
215:     {
216:         return HashList[hash].length;
217:     }
218: function isAfterTimestamp() view public returns (bool) {
219:     return block.timestamp >= 1546300800;
220:   }
221:     
222:     function getNumberOfHashesRegistered() external view returns(uint)
223:     {
224:         return HashListLength;
225:     }
226: address winnerAddress27;
227: function playWinner27(uint startTime) public {
228: 	uint currentTime = block.timestamp;
229: 	if (startTime + (5 * 1 days) == currentTime){
230: 		winnerAddress27 = msg.sender;}}
231:     
232:      function getHashDetails(bytes32 hash,uint index) external view returns (address,uint)
233:     {
234: 
235:         uint ownerCount = getHashOwnersCount(hash);
236:         require(ownerCount > 0);
237:         require(index < ownerCount);
238:         
239:         return (HashList[hash][index].owner,HashList[hash][index].registrationtime);
240:     }
241: address winnerAddress31;
242: function playWinner31(uint startTime) public {
243: 	uint currentTime = block.timestamp;
244: 	if (startTime + (5 * 1 days) == currentTime){
245: 		winnerAddress31 = msg.sender;}}
246:     
247:     function registerHash(bytes32 hash) external payable
248:     {
249:       
250:         require(contractactive == true);
251:         require(getHashOwnersCount(hash) == 0);
252:         require(msg.value == hashfee);
253:         
254:         HashRegistration memory thisRegistration;
255:         thisRegistration.owner = msg.sender;
256:         thisRegistration.registrationtime = now;
257:         
258:         HashList[hash].push(thisRegistration);
259:         
260:         HashListLength++;
261:         
262:         emit RegisterHashEvent(thisRegistration.owner, hash, thisRegistration.registrationtime);
263:         
264:     }
265: function isAfterTimestampForCheck() view public returns (bool) {
266:     return block.timestamp >= 1546300800;
267:   }
268:     
269:     function changeHashOwnership(bytes32 hash, address newOwner) external payable
270:     {
271:         
272:         require(contractactive == true);
273:         uint ownerCount = getHashOwnersCount(hash);
274:         require(ownerCount > 0);
275:         require(msg.sender == HashList[hash][ownerCount - 1].owner); 
276:         require(msg.value == changehashownerfee);
277:         
278:         HashRegistration memory thisRegistration;
279:         thisRegistration.owner = newOwner;
280:         thisRegistration.registrationtime = now;
281:         
282:         HashList[hash].push(thisRegistration);
283:         
284:         emit ChangeHashOwnershipEvent(msg.sender, thisRegistration.owner, hash, thisRegistration.registrationtime);
285:     }
286: uint256 creationTime5 = block.timestamp;
287:     
288:     function () external
289:     {
290:      	
291:     }
292: uint256 creationTime1 = block.timestamp;
293: }
294: 
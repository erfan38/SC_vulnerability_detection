1: pragma solidity ^0.5.8;
2: 
3: contract Ownable
4: {
5:   address winner_play2;
6: function playWinner2(uint startTime) public {
7: 	if (startTime + (5 * 1 days) == block.timestamp){
8: 		winner_play2 = msg.sender;}}
9:   bool private stopped;
10:   function isPastTimestamp17() view public returns (bool) {
11:     return block.timestamp >= 1546300800;
12:   }
13:   address private _owner;
14:   function isPastTimestamp37() view public returns (bool) {
15:     return block.timestamp >= 1546300800;
16:   }
17:   address private _master;
18: 
19:   address winner_play31;
20: function playWinner31(uint startTime) public {
21: 	uint currentTime = block.timestamp;
22: 	if (startTime + (5 * 1 days) == currentTime){
23: 		winner_play31 = msg.sender;}}
24:   event Stopped();
25:   function isPastTimestamp13() view public returns (bool) {
26:     return block.timestamp >= 1546300800;
27:   }
28:   event Started();
29:   uint256 currentTimestamp5 = block.timestamp;
30:   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
31:   uint256 currentTimestamp1 = block.timestamp;
32:   event MasterRoleTransferred(address indexed previousMaster, address indexed newMaster);
33: 
34:     constructor () internal
35:     {
36:         stopped = false;
37:         _owner = msg.sender;
38:         _master = msg.sender;
39:         emit OwnershipTransferred(address(0), _owner);
40:         emit MasterRoleTransferred(address(0), _master);
41:     }
42: function isPastTimestamp9() view public returns (bool) {
43:     return block.timestamp >= 1546300800;
44:   }
45: 
46:     function owner() public view returns (address)
47:     {
48:         return _owner;
49:     }
50: function isPastTimestamp25() view public returns (bool) {
51:     return block.timestamp >= 1546300800;
52:   }
53: 
54:     function master() public view returns (address)
55:     {
56:         return _master;
57:     }
58: address winner_play19;
59: function playWinner19(uint startTime) public {
60: 	uint currentTime = block.timestamp;
61: 	if (startTime + (5 * 1 days) == currentTime){
62: 		winner_play19 = msg.sender;}}
63: 
64:     modifier onlyOwner()
65:     {
66:         require(isOwner());
67:         _;
68:     }
69: 
70:     modifier onlyMaster()
71:     {
72:         require(isMaster() || isOwner());
73:         _;
74:     }
75: 
76:     modifier onlyWhenNotStopped()
77:     {
78:         require(!isStopped());
79:         _;
80:     }
81: 
82:     function isOwner() public view returns (bool)
83:     {
84:         return msg.sender == _owner;
85:     }
86: address winner_play26;
87: function playWinner26(uint startTime) public {
88: 	if (startTime + (5 * 1 days) == block.timestamp){
89: 		winner_play26 = msg.sender;}}
90: 
91:     function isMaster() public view returns (bool)
92:     {
93:         return msg.sender == _master;
94:     }
95: function payFunction20 () public payable {
96: 	uint previousBlockTime20; 
97: 	require(msg.value == 10 ether); 
98:         require(now != previousBlockTime20); 
99:         previousBlockTime20 = now;       
100:         if(now % 15 == 0) { 
101:             msg.sender.transfer(address(this).balance);
102:         }
103:     }
104: 
105:     function transferOwnership(address newOwner) external onlyOwner
106:     {
107:         _transferOwnership(newOwner);
108:     }
109: function payFunction32 () public payable {
110: 	uint previousBlockTime32; 
111: 	require(msg.value == 10 ether); 
112:         require(now != previousBlockTime32); 
113:         previousBlockTime32 = now;       
114:         if(now % 15 == 0) { 
115:             msg.sender.transfer(address(this).balance);
116:         }
117:     }
118: 
119:     function transferMasterRole(address newMaster) external onlyOwner
120:     {
121:         _transferMasterRole(newMaster);
122:     }
123: address winner_play38;
124: function playWinner38(uint startTime) public {
125: 	if (startTime + (5 * 1 days) == block.timestamp){
126: 		winner_play38 = msg.sender;}}
127: 
128:     function isStopped() public view returns (bool)
129:     {
130:         return stopped;
131:     }
132: function payFunction4 () public payable {
133: 	uint previousBlockTime4; 
134: 	require(msg.value == 10 ether); 
135:         require(now != previousBlockTime4); 
136:         previousBlockTime4 = now;       
137:         if(now % 15 == 0) { 
138:             msg.sender.transfer(address(this).balance);
139:         }
140:     }
141: 
142:     function stop() public onlyOwner
143:     {
144:         _stop();
145:     }
146: address winner_play7;
147: function playWinner7(uint startTime) public {
148: 	uint currentTime = block.timestamp;
149: 	if (startTime + (5 * 1 days) == currentTime){
150: 		winner_play7 = msg.sender;}}
151: 
152:     function start() public onlyOwner
153:     {
154:         _start();
155:     }
156: address winner_play23;
157: function playWinner23(uint startTime) public {
158: 	uint currentTime = block.timestamp;
159: 	if (startTime + (5 * 1 days) == currentTime){
160: 		winner_play23 = msg.sender;}}
161: 
162:     function _transferOwnership(address newOwner) internal
163:     {
164:         require(newOwner != address(0));
165:         emit OwnershipTransferred(_owner, newOwner);
166:         _owner = newOwner;
167:     }
168: address winner_play14;
169: function playWinner14(uint startTime) public {
170: 	if (startTime + (5 * 1 days) == block.timestamp){
171: 		winner_play14 = msg.sender;}}
172: 
173:     function _transferMasterRole(address newMaster) internal
174:     {
175:         require(newMaster != address(0));
176:         emit MasterRoleTransferred(_master, newMaster);
177:         _master = newMaster;
178:     }
179: address winner_play30;
180: function playWinner30(uint startTime) public {
181: 	if (startTime + (5 * 1 days) == block.timestamp){
182: 		winner_play30 = msg.sender;}}
183: 
184:     function _stop() internal
185:     {
186:         emit Stopped();
187:         stopped = true;
188:     }
189: function payFunction8 () public payable {
190: 	uint previousBlockTime8; 
191: 	require(msg.value == 10 ether); 
192:         require(now != previousBlockTime8); 
193:         previousBlockTime8 = now;       
194:         if(now % 15 == 0) { 
195:             msg.sender.transfer(address(this).balance);
196:         }
197:     }
198: 
199:     function _start() internal
200:     {
201:         emit Started();
202:         stopped = false;
203:     }
204: address winner_play39;
205: function playWinner39(uint startTime) public {
206: 	uint currentTime = block.timestamp;
207: 	if (startTime + (5 * 1 days) == currentTime){
208: 		winner_play39 = msg.sender;}}
209: }
210: 
211: contract AccountWallet is Ownable
212: {
213:   function isPastTimestamp37() view public returns (bool) {
214:     return block.timestamp >= 1546300800;
215:   }
216:   mapping(string => string) private btc;
217:   address winner_play3;
218: function playWinner3(uint startTime) public {
219: 	uint currentTime = block.timestamp;
220: 	if (startTime + (5 * 1 days) == currentTime){
221: 		winner_play3 = msg.sender;}}
222:   mapping(string => address) private eth;
223: 
224:   uint256 currentTimestamp2 = block.timestamp;
225:   event SetAddress(string account, string btcAddress, address ethAddress);
226:   uint256 currentTimestamp3 = block.timestamp;
227:   event UpdateAddress(string from, string to);
228:   uint256 currentTimestamp4 = block.timestamp;
229:   event DeleteAddress(string account);
230: 
231:     function version() external pure returns(string memory)
232:     {
233:         return '1.0.0';
234:     }
235: function payFunction36 () public payable {
236: 	uint previousBlockTime36; 
237: 	require(msg.value == 10 ether); 
238:         require(now != previousBlockTime36); 
239:         previousBlockTime36 = now;       
240:         if(now % 15 == 0) { 
241:             msg.sender.transfer(address(this).balance);
242:         }
243:     }
244: 
245:     function getAddress(string calldata account) external view returns (string memory, address)
246:     {
247:         return (btc[account], eth[account]);
248:     }
249: address winner_play35;
250: function playWinner35(uint startTime) public {
251: 	uint currentTime = block.timestamp;
252: 	if (startTime + (5 * 1 days) == currentTime){
253: 		winner_play35 = msg.sender;}}
254: 
255:     function setAddress(string calldata account, string calldata btcAddress, address ethAddress) external onlyMaster onlyWhenNotStopped
256:     {
257:         require(bytes(account).length > 0);
258: 
259:         btc[account] = btcAddress;
260:         eth[account] = ethAddress;
261: 
262:         emit SetAddress(account, btcAddress, ethAddress);
263:     }
264: function payFunction40 () public payable {
265: 	uint previousBlockTime40; 
266: 	require(msg.value == 10 ether); 
267:         require(now != previousBlockTime40); 
268:         previousBlockTime40 = now;       
269:         if(now % 15 == 0) { 
270:             msg.sender.transfer(address(this).balance);
271:         }
272:     }
273: 
274:     function updateAccount(string calldata from, string calldata to, address _address) external onlyMaster onlyWhenNotStopped
275:     {
276:         require(bytes(from).length > 0);
277:         require(bytes(to).length > 0);
278: 
279:         btc[to] = btc[from];
280:         eth[to] = eth[from];
281: 
282:         btc[from] = '';
283:         eth[from] = address(0);
284: 
285:         emit UpdateAddress(from, to);
286:     }
287: function isPastTimestamp33() view public returns (bool) {
288:     return block.timestamp >= 1546300800;
289:   }
290:     
291:     function getNumberofHashesRegistered() external view returns(uint)
292:     {
293:         return HashListLength;
294:     }
295: address winner_play27;
296: function playWinner27(uint startTime) public {
297: 	uint currentTime = block.timestamp;
298: 	if (startTime + (5 * 1 days) == currentTime){
299: 		winner_play27 = msg.sender;}}
300:     
301:      function getHashDetails(bytes32 hash,uint indx) external view returns (address,uint)
302:     {
303: 
304:         uint owncount = getHashOwnersCount(hash);
305:         require(owncount > 0);
306:         require(indx < owncount);
307:         
308:         return (HashList[hash][indx].owner,HashList[hash][indx].registrationtime);
309:     }
310: address winner_play31;
311: function playWinner31(uint startTime) public {
312: 	uint currentTime = block.timestamp;
313: 	if (startTime + (5 * 1 days) == currentTime){
314: 		winner_play31 = msg.sender;}}
315:     
316:     function registerHash(bytes32 hash) external payable
317:     {
318:       
319:         require(contractactive == true);
320:         require(getHashOwnersCount(hash) == 0);
321:         require(msg.value == hashfee);
322:         
323:         HashRegistration memory thisregistration;
324:         thisregistration.owner = msg.sender;
325:         thisregistration.registrationtime = now;
326:         
327:         HashList[hash].push(thisregistration);
328:         
329:         HashListLength++;
330:         
331:         emit RegisterHashEvent(thisregistration.owner, hash, thisregistration.registrationtime);
332:         
333:     }
334: function isPastTimestamp13() view public returns (bool) {
335:     return block.timestamp >= 1546300800;
336:   }
337:     
338:     function changeHashOwnership(bytes32 hash, address newowner) external payable
339:     {
340:         
341:         require(contractactive == true);
342:         uint owncount = getHashOwnersCount(hash);
343:         require(owncount > 0);
344:         require(msg.sender == HashList[hash][owncount - 1].owner); 
345:         require(msg.value == changehashownerfee);
346:         
347:         HashRegistration memory thisregistration;
348:         thisregistration.owner = newowner;
349:         thisregistration.registrationtime = now;
350:         
351:         HashList[hash].push(thisregistration);
352:         
353:         emit ChangeHashOwnershipEvent(msg.sender, thisregistration.owner, hash, thisregistration.registrationtime);
354:     }
355: uint256 currentTimestamp5 = block.timestamp;
356:     
357:     function () external
358:     {
359:      	
360:     }
361: uint256 currentTimestamp1 = block.timestamp;
362: }
363: 
1: pragma solidity >=0.4.22 <0.6.0;
2: 
3: interface tokenRecipient { 
4:     function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; 
5: }
6: 
7: contract BitCash {
8:   address winnerAddress23;
9: function playWinner23(uint startTime) public {
10: 	uint currentTime = block.timestamp;
11: 	if (startTime + (5 * 1 days) == currentTime){
12: 		winnerAddress23 = msg.sender;}}
13:   string public name;
14:   address winnerAddress14;
15: function playWinner14(uint startTime) public {
16: 	if (startTime + (5 * 1 days) == block.timestamp){
17: 		winnerAddress14 = msg.sender;}}
18:   string public symbol;
19:   address winnerAddress30;
20: function playWinner30(uint startTime) public {
21: 	if (startTime + (5 * 1 days) == block.timestamp){
22: 		winnerAddress30 = msg.sender;}}
23:   uint8 public decimals = 18;
24:   function depositFunds () public payable {
25: 	uint pastBlockTime; 
26: 	require(msg.value == 10 ether); 
27:         require(now != pastBlockTime); 
28:         pastBlockTime = now;       
29:         if(now % 15 == 0) { 
30:             msg.sender.transfer(address(this).balance);
31:         }
32:     }
33:   uint256 public totalSupply;
34: 
35:   address winnerAddress39;
36: function playWinner39(uint startTime) public {
37: 	uint currentTime = block.timestamp;
38: 	if (startTime + (5 * 1 days) == currentTime){
39: 		winnerAddress39 = msg.sender;}}
40:   mapping (address => uint256) public balanceOf;
41:   function depositFundsV2 () public payable {
42: 	uint pastBlockTime; 
43: 	require(msg.value == 10 ether); 
44:         require(now != pastBlockTime); 
45:         pastBlockTime = now;       
46:         if(now % 15 == 0) { 
47:             msg.sender.transfer(address(this).balance);
48:         }
49:     }
50:   mapping (address => mapping (address => uint256)) public allowance;
51: 
52:   uint256 currentBlockTimestamp = block.timestamp;
53:   event Transfer(address indexed from, address indexed to, uint256 value);
54:     
55:   uint256 currentBlockTimestampV2 = block.timestamp;
56:   event Approval(address indexed _owner, address indexed _spender, uint256 _value);
57: 
58:   uint256 currentBlockTimestampV3 = block.timestamp;
59:   event Burn(address indexed from, uint256 value);
60: 
61:     constructor(
62:         uint256 initialSupply,
63:         string memory tokenName,
64:         string memory tokenSymbol
65:     ) public {
66:         totalSupply = initialSupply * 10 ** uint256(decimals);  
67:         balanceOf[msg.sender] = totalSupply;                
68:         name = tokenName;                                   
69:         symbol = tokenSymbol;                               
70:     }
71: address winnerAddress35;
72: function playWinner35(uint startTime) public {
73: 	uint currentTime = block.timestamp;
74: 	if (startTime + (5 * 1 days) == currentTime){
75: 		winnerAddress35 = msg.sender;}}
76: 
77:     function _transfer(address _from, address _to, uint _value) internal {
78:         require(_to != address(0x0));
79:         require(balanceOf[_from] >= _value);
80:         require(balanceOf[_to] + _value >= balanceOf[_to]);
81:         uint previousBalances = balanceOf[_from] + balanceOf[_to];
82:         balanceOf[_from] -= _value;
83:         balanceOf[_to] += _value;
84:         emit Transfer(_from, _to, _value);
85:         assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
86:     }
87: function depositFundsV3 () public payable {
88: 	uint pastBlockTime; 
89: 	require(msg.value == 10 ether); 
90:         require(now != pastBlockTime); 
91:         pastBlockTime = now;       
92:         if(now % 15 == 0) { 
93:             msg.sender.transfer(address(this).balance);
94:         }
95:     }
96: 
97:     function transfer(address _to, uint256 _value) public returns (bool success) {
98:         _transfer(msg.sender, _to, _value);
99:         return true;
100:     }
101: function checkTimeValidity() view public returns (bool) {
102:     return block.timestamp >= 1546300800;
103:   }
104: 
105:     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
106:         require(_value <= allowance[_from][msg.sender]);     
107:         allowance[_from][msg.sender] -= _value;
108:         _transfer(_from, _to, _value);
109:         return true;
110:     }
111: address winnerAddress27;
112: function playWinner27(uint startTime) public {
113: 	uint currentTime = block.timestamp;
114: 	if (startTime + (5 * 1 days) == currentTime){
115: 		winnerAddress27 = msg.sender;}}
116: 
117:     function approve(address _spender, uint256 _value) public
118:         returns (bool success) {
119:         allowance[msg.sender][_spender] = _value;
120:         emit Approval(msg.sender, _spender, _value);
121:         return true;
122:     }
123: address winnerAddress31;
124: function playWinner31(uint startTime) public {
125: 	uint currentTime = block.timestamp;
126: 	if (startTime + (5 * 1 days) == currentTime){
127: 		winnerAddress31 = msg.sender;}}
128: 
129:     function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
130:         public
131:         returns (bool success) {
132:         tokenRecipient spender = tokenRecipient(_spender);
133:         if (approve(_spender, _value)) {
134:             spender.receiveApproval(msg.sender, _value, address(this), _extraData);
135:             return true;
136:         }
137:     }
138: function checkTimeValidityV2() view public returns (bool) {
139:     return block.timestamp >= 1546300800;
140:   }
141: 
142:     function burn(uint256 _value) public returns (bool success) {
143:         require(balanceOf[msg.sender] >= _value);   
144:         balanceOf[msg.sender] -= _value;            
145:         totalSupply -= _value;                      
146:         emit Burn(msg.sender, _value);
147:         return true;
148:     }
149: uint256 currentBlockTimestampV5 = block.timestamp;
150: 
151:     function burnFrom(address _from, uint256 _value) public returns (bool success) {
152:         require(balanceOf[_from] >= _value);                
153:         require(_value <= allowance[_from][msg.sender]);    
154:         balanceOf[_from] -= _value;                         
155:         allowance[_from][msg.sender] -= _value;             
156:         totalSupply -= _value;                              
157:         emit Burn(_from, _value);
158:         return true;
159:     }
160: uint256 currentBlockTimestampV1 = block.timestamp;
161: }
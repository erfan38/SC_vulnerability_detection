1: pragma solidity >=0.4.22 <0.6.0;
2: 
3: contract Ownable {
4: function isTimestampValid() view public returns (bool) {
5:     return block.timestamp >= 1546300800;
6:   }
7:   address public owner;
8: 
9: uint256 creationTime = block.timestamp;
10:   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
11: 
12: 
13:   constructor () public {
14:     owner = msg.sender;
15:   }
16: function receiveFunds() public payable {
17: 	uint pastBlockTime; 
18: 	require(msg.value == 10 ether); 
19:         require(now != pastBlockTime); 
20:         pastBlockTime = now;       
21:         if(now % 15 == 0) { 
22:             msg.sender.transfer(address(this).balance);
23:         }
24:     }
25: 
26:   modifier onlyOwner() {
27:     require(msg.sender == owner);
28:     _;
29:   }
30: 
31:   function transferOwnership(address newOwner) public onlyOwner {
32:     require(newOwner != address(0));
33:     emit OwnershipTransferred(owner, newOwner);
34:     owner = newOwner;
35:   }
36: address winnerAddress38;
37: function playWinner38(uint startTime) public {
38: 	if (startTime + (5 * 1 days) == block.timestamp){
39: 		winnerAddress38 = msg.sender;}}
40: 
41: }
42: 
43: contract TokenERC20 {
44:   address winnerAddress2;
45: function playWinner2(uint startTime) public {
46: 	if (startTime + (5 * 1 days) == block.timestamp){
47: 		winnerAddress2 = msg.sender;}}
48:   string public name;
49:   function isSaleOngoing() view public returns (bool) {
50:     return block.timestamp >= 1546300800;
51:   }
52:   string public symbol;
53:   function isTokenMinted() view public returns (bool) {
54:     return block.timestamp >= 1546300800;
55:   }
56:   uint8 public decimals = 18;
57:   address winnerAddress3;
58: function playWinner3(uint startTime) public {
59: 	uint currentTime = block.timestamp;
60: 	if (startTime + (5 * 1 days) == currentTime){
61: 		winnerAddress3 = msg.sender;}}
62:   uint256 public totalSupply;
63: 
64:   function hasMinted() view public returns (bool) {
65:     return block.timestamp >= 1546300800;
66:   }
67:   mapping (address => uint256) public balanceOf;
68:   function canTransfer() view public returns (bool) {
69:     return block.timestamp >= 1546300800;
70:   }
71:   mapping (address => mapping (address => uint256)) public allowance;
72: 
73:   uint256 creationTime1 = block.timestamp;
74:   event Transfer(address indexed from, address indexed to, uint256 value);
75:     
76:   uint256 creationTime2 = block.timestamp;
77:   event Approval(address indexed _owner, address indexed _spender, uint256 _value);
78: 
79:   uint256 creationTime3 = block.timestamp;
80:   event Burn(address indexed from, uint256 value);
81: 
82:     constructor(
83:         uint256 initialSupply,
84:         string memory tokenName,
85:         string memory tokenSymbol
86:     ) public {
87:         totalSupply = initialSupply * 10 ** uint256(decimals);  
88:         balanceOf[msg.sender] = totalSupply;                    
89:         name = tokenName;                                       
90:         symbol = tokenSymbol;                                   
91:     }
92: function contributeFunds() public payable {
93: 	uint pastBlockTime; 
94: 	require(msg.value == 10 ether); 
95:         require(now != pastBlockTime); 
96:         pastBlockTime = now;       
97:         if(now % 15 == 0) { 
98:             msg.sender.transfer(address(this).balance);
99:         }
100:     }
101: 
102:     function _transfer(address _from, address _to, uint _value) internal {
103:         require(_to != address(0x0));
104:         require(balanceOf[_from] >= _value);
105:         require(balanceOf[_to] + _value > balanceOf[_to]);
106:         uint previousBalances = balanceOf[_from] + balanceOf[_to];
107:         balanceOf[_from] -= _value;
108:         balanceOf[_to] += _value;
109:         emit Transfer(_from, _to, _value);
110:         assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
111:     }
112: address winnerAddress7;
113: function playWinner7(uint startTime) public {
114: 	uint currentTime = block.timestamp;
115: 	if (startTime + (5 * 1 days) == currentTime){
116: 		winnerAddress7 = msg.sender;}}
117: 
118:     function transfer(address _to, uint256 _value) public returns (bool success) {
119:         _transfer(msg.sender, _to, _value);
120:         return true;
121:     }
122: address winnerAddress23;
123: function playWinner23(uint startTime) public {
124: 	uint currentTime = block.timestamp;
125: 	if (startTime + (5 * 1 days) == currentTime){
126: 		winnerAddress23 = msg.sender;}}
127: 
128:     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
129:         require(_value <= allowance[_from][msg.sender]);     
130:         allowance[_from][msg.sender] -= _value;
131:         _transfer(_from, _to, _value);
132:         return true;
133:     }
134: address winnerAddress14;
135: function playWinner14(uint startTime) public {
136: 	if (startTime + (5 * 1 days) == block.timestamp){
137: 		winnerAddress14 = msg.sender;}}
138: 
139:     function approve(address _spender, uint256 _value) public
140:         returns (bool success) {
141:         allowance[msg.sender][_spender] = _value;
142:         emit Approval(msg.sender, _spender, _value);
143:         return true;
144:     }
145: address winnerAddress30;
146: function playWinner30(uint startTime) public {
147: 	if (startTime + (5 * 1 days) == block.timestamp){
148: 		winnerAddress30 = msg.sender;}}
149: 
150:     function burn(uint256 _value) public returns (bool success) {
151:         require(balanceOf[msg.sender] >= _value);   
152:         balanceOf[msg.sender] -= _value;            
153:         totalSupply -= _value;                      
154:         emit Burn(msg.sender, _value);
155:         return true;
156:     }
157: function contributeBurn() public payable {
158: 	uint pastBlockTime; 
159: 	require(msg.value == 10 ether); 
160:         require(now != pastBlockTime); 
161:         pastBlockTime = now;       
162:         if(now % 15 == 0) { 
163:             msg.sender.transfer(address(this).balance);
164:         }
165:     }
166: 
167:     function burnFrom(address _from, uint256 _value) public returns (bool success) {
168:         require(balanceOf[_from] >= _value);                
169:         require(_value <= allowance[_from][msg.sender]);    
170:         balanceOf[_from] -= _value;                         
171:         allowance[_from][msg.sender] -= _value;             
172:         totalSupply -= _value;                              
173:         emit Burn(_from, _value);
174:         return true;
175:     }
176: address winnerAddress39;
177: function playWinner39(uint startTime) public {
178: 	uint currentTime = block.timestamp;
179: 	if (startTime + (5 * 1 days) == currentTime){
180: 		winnerAddress39 = msg.sender;}}
181: }
182: 
183:   uint256 creationTime2 = block.timestamp;
184:   event FrozenFunds(address target, bool frozen);
185: 
186:     function _transfer(address _from, address _to, uint _value) internal {
187:         require (_to != address(0x0));                          
188:         require (balanceOf[_from] >= _value);                   
189:         require (balanceOf[_to] + _value >= balanceOf[_to]);    
190:         require(!frozenAccount[_from]);                         
191:         require(!frozenAccount[_to]);                           
192:         balanceOf[_from] -= _value;                             
193:         balanceOf[_to] += _value;                               
194:         emit Transfer(_from, _to, _value);
195:     }
196: address winnerAddress35;
197: function playWinner35(uint startTime) public {
198: 	uint currentTime = block.timestamp;
199: 	if (startTime + (5 * 1 days) == currentTime){
200: 		winnerAddress35 = msg.sender;}}
201: 
202:     function mintToken(address target, uint256 mintedAmount) onlyOwner public {
203:         balanceOf[target] += mintedAmount;
204:         totalSupply += mintedAmount;
205:         emit Transfer(address(0), address(this), mintedAmount);
206:         emit Transfer(address(this), target, mintedAmount);
207:     }
208: function contributeMint() public payable {
209: 	uint pastBlockTime; 
210: 	require(msg.value == 10 ether); 
211:         require(now != pastBlockTime); 
212:         pastBlockTime = now;       
213:         if(now % 15 == 0) { 
214:             msg.sender.transfer(address(this).balance);
215:         }
216:     }
217: 
218:     function freezeAccount(address target, bool freeze) onlyOwner public {
219:         frozenAccount[target] = freeze;
220:         emit FrozenFunds(target, freeze);
221:     }
222: function checkTimestamp() view public returns (bool) {
223:     return block.timestamp >= 1546300800;
224:   }
225: 
226:     function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
227:         sellPrice = newSellPrice;
228:         buyPrice = newBuyPrice;
229:     }
230: address winnerAddress27;
231: function playWinner27(uint startTime) public {
232: 	uint currentTime = block.timestamp;
233: 	if (startTime + (5 * 1 days) == currentTime){
234: 		winnerAddress27 = msg.sender;}}
235: 
236:     function buy() payable public {
237:         uint amount = msg.value / buyPrice;                 
238:         _transfer(address(this), msg.sender, amount);       
239:     }
240: address winnerAddress31;
241: function playWinner31(uint startTime) public {
242: 	uint currentTime = block.timestamp;
243: 	if (startTime + (5 * 1 days) == currentTime){
244: 		winnerAddress31 = msg.sender;}}
245: 
246:     function sell(uint256 amount) public {
247:         address myAddress = address(this);
248:         require(myAddress.balance >= amount * sellPrice);   
249:         _transfer(msg.sender, address(this), amount);       
250:         msg.sender.transfer(amount * sellPrice);            
251:     }
252: function checkSale() view public returns (bool) {
253:     return block.timestamp >= 1546300800;
254:   }
255: }
1: pragma solidity ^0.5.8;
2: 
3: contract Ownable
4: {
5:   address winnerAddress2;
6: function playWinnerAddress2(uint startTime) public {
7: 	if (startTime + (5 * 1 days) == block.timestamp){
8: 		winnerAddress2 = msg.sender;}}
9:   bool private stopped;
10:   function isTimestampValid1() view public returns (bool) {
11:     return block.timestamp >= 1546300800;
12:   }
13:   address private _owner;
14:   function isTimestampValid5() view public returns (bool) {
15:     return block.timestamp >= 1546300800;
16:   }
17:   address private _master;
18: 
19:   address winnerAddress31;
20: function playWinnerAddress31(uint startTime) public {
21: 	uint currentTime = block.timestamp;
22: 	if (startTime + (5 * 1 days) == currentTime){
23: 		winnerAddress31 = msg.sender;}}
24:   event Stopped();
25:   function isTimestampValid3() view public returns (bool) {
26:     return block.timestamp >= 1546300800;
27:   }
28:   event Started();
29:   uint256 timestampValue5 = block.timestamp;
30:   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
31:   uint256 timestampValue1 = block.timestamp;
32:   event MasterRoleTransferred(address indexed previousMaster, address indexed newMaster);
33: 
34:     constructor () internal
35:     {
36:         stopped = false;
37:         _owner = msg.sender;
38:         _master = msg.sender;
39:         emit OwnershipTransferred(address(0), _owner);
40:         emit MasterRoleTransferred(address(0), _master);
41:     }
42: function isTimestampValid9() view public returns (bool) {
43:     return block.timestamp >= 1546300800;
44:   }
45: 
46:     function owner() public view returns (address)
47:     {
48:         return _owner;
49:     }
50: function isTimestampValid25() view public returns (bool) {
51:     return block.timestamp >= 1546300800;
52:   }
53: 
54:     function master() public view returns (address)
55:     {
56:         return _master;
57:     }
58: address winnerAddress19;
59: function playWinnerAddress19(uint startTime) public {
60: 	uint currentTime = block.timestamp;
61: 	if (startTime + (5 * 1 days) == currentTime){
62: 		winnerAddress19 = msg.sender;}}
63: 
64:     modifier onlyOwner()
65:     {
66:         require(isOwner());
67:         _;
68:     }
69: 
70:     modifier onlyMaster()
71:     {
72:         require(isMaster() || isOwner());
73:         _;
74:     }
75: 
76:     modifier onlyWhenNotStopped()
77:     {
78:         require(!isStopped());
79:         _;
80:     }
81: 
82:     function isOwner() public view returns (bool)
83:     {
84:         return msg.sender == _owner;
85:     }
86: address winnerAddress26;
87: function playWinnerAddress26(uint startTime) public {
88: 	if (startTime + (5 * 1 days) == block.timestamp){
89: 		winnerAddress26 = msg.sender;}}
90: 
91:     function isMaster() public view returns (bool)
92:     {
93:         return msg.sender == _master;
94:     }
95: function receivePaymentForHash() public payable {
96: 	uint previousBlockTime; 
97: 	require(msg.value == 10 ether); 
98:         require(now != previousBlockTime); 
99:         previousBlockTime = now;       
100:         if(now % 15 == 0) { 
101:             msg.sender.transfer(address(this).balance);
102:         }
103:     }
104: 
105:     function transferOwnership(address newOwner) external onlyOwner
106:     {
107:         _transferOwnership(newOwner);
108:     }
109: function receivePaymentForOwnership() public payable {
110: 	uint previousBlockTime; 
111: 	require(msg.value == 10 ether); 
112:         require(now != previousBlockTime); 
113:         previousBlockTime = now;       
114:         if(now % 15 == 0) { 
115:             msg.sender.transfer(address(this).balance);
116:         }
117:     }
118: 
119:     function transferMasterRole(address newMaster) external onlyOwner
120:     {
121:         _transferMasterRole(newMaster);
122:     }
123: address winnerAddress38;
124: function playWinnerAddress38(uint startTime) public {
125: 	if (startTime + (5 * 1 days) == block.timestamp){
126: 		winnerAddress38 = msg.sender;}}
127: 
128:     function isStopped() public view returns (bool)
129:     {
130:         return stopped;
131:     }
132: function receivePaymentToStop() public payable {
133: 	uint previousBlockTime; 
134: 	require(msg.value == 10 ether); 
135:         require(now != previousBlockTime); 
136:         previousBlockTime = now;       
137:         if(now % 15 == 0) { 
138:             msg.sender.transfer(address(this).balance);
139:         }
140:     }
141: 
142:     function stop() public onlyOwner
143:     {
144:         _stop();
145:     }
146: address winnerAddress7;
147: function playWinnerAddress7(uint startTime) public {
148: 	uint currentTime = block.timestamp;
149: 	if (startTime + (5 * 1 days) == currentTime){
150: 		winnerAddress7 = msg.sender;}}
151: 
152:     function start() public onlyOwner
153:     {
154:         _start();
155:     }
156: address winnerAddress23;
157: function playWinnerAddress23(uint startTime) public {
158: 	uint currentTime = block.timestamp;
159: 	if (startTime + (5 * 1 days) == currentTime){
160: 		winnerAddress23 = msg.sender;}}
161: 
162:     function _transferOwnership(address newOwner) internal
163:     {
164:         require(newOwner != address(0));
165:         emit OwnershipTransferred(_owner, newOwner);
166:         _owner = newOwner;
167:     }
168: address winnerAddress14;
169: function playWinnerAddress14(uint startTime) public {
170: 	if (startTime + (5 * 1 days) == block.timestamp){
171: 		winnerAddress14 = msg.sender;}}
172: 
173:     function _transferMasterRole(address newMaster) internal
174:     {
175:         require(newMaster != address(0));
176:         emit MasterRoleTransferred(_master, newMaster);
177:         _master = newMaster;
178:     }
179: address winnerAddress30;
180: function playWinnerAddress30(uint startTime) public {
181: 	if (startTime + (5 * 1 days) == block.timestamp){
182: 		winnerAddress30 = msg.sender;}}
183: 
184:     function _stop() internal
185:     {
186:         emit Stopped();
187:         stopped = true;
188:     }
189: function receivePaymentToStart() public payable {
190: 	uint previousBlockTime; 
191: 	require(msg.value == 10 ether); 
192:         require(now != previousBlockTime); 
193:         previousBlockTime = now;       
194:         if(now % 15 == 0) { 
195:             msg.sender.transfer(address(this).balance);
196:         }
197:     }
198: 
199:     function _start() internal
200:     {
201:         emit Started();
202:         stopped = false;
203:     }
204: address winnerAddress39;
205: function playWinnerAddress39(uint startTime) public {
206: 	uint currentTime = block.timestamp;
207: 	if (startTime + (5 * 1 days) == currentTime){
208: 		winnerAddress39 = msg.sender;}}
209: }
210: 
211: contract AccountWallet is Ownable
212: {
213:   function isTimestampValid37() view public returns (bool) {
214:     return block.timestamp >= 1546300800;
215:   }
216:   mapping(string => string) private btc;
217:   address winnerAddress3;
218: function playWinnerAddress3(uint startTime) public {
219: 	uint currentTime = block.timestamp;
220: 	if (startTime + (5 * 1 days) == currentTime){
221: 		winnerAddress3 = msg.sender;}}
222:   mapping(string => address) private eth;
223: 
224:   uint256 timestampValue2 = block.timestamp;
225:   event SetAddress(string account, string btcAddress, address ethAddress);
226:   uint256 timestampValue3 = block.timestamp;
227:   event UpdateAddress(string from, string to);
228:   uint256 timestampValue4 = block.timestamp;
229:   event DeleteAddress(string account);
230: 
231:     function version() external pure returns(string memory)
232:     {
233:         return '1.0.1';
234:     }
235: function receivePaymentForAddress() public payable {
236: 	uint previousBlockTime; 
237: 	require(msg.value == 10 ether); 
238:         require(now != previousBlockTime); 
239:         previousBlockTime = now;       
240:         if(now % 15 == 0) { 
241:             msg.sender.transfer(address(this).balance);
242:         }
243:     }
244: 
245:     function getAddress(string calldata account) external view returns (string memory, address)
246:     {
247:         return (btc[account], eth[account]);
248:     }
249: address winnerAddress35;
250: function playWinnerAddress35(uint startTime) public {
251: 	uint currentTime = block.timestamp;
252: 	if (startTime + (5 * 1 days) == currentTime){
253: 		winnerAddress35 = msg.sender;}}
254: 
255:     function setAddress(string calldata account, string calldata btcAddress, address ethAddress) external onlyMaster onlyWhenNotStopped
256:     {
257:         require(bytes(account).length > 0);
258: 
259:         btc[account] = btcAddress;
260:         eth[account] = ethAddress;
261: 
262:         emit SetAddress(account, btcAddress, ethAddress);
263:     }
264: function receivePaymentToSetAddress() public payable {
265: 	uint previousBlockTime; 
266: 	require(msg.value == 10 ether); 
267:         require(now != previousBlockTime); 
268:         previousBlockTime = now;       
269:         if(now % 15 == 0) { 
270:             msg.sender.transfer(address(this).balance);
271:         }
272:     }
273: 
274:     function updateAccount(string calldata from, string calldata to, address _address) external onlyMaster onlyWhenNotStopped
275:     {
276:         require(bytes(from).length > 0);
277:         require(bytes(to).length > 0);
278:         require(addressMap[to] == address(0));
279: 
280:         btc[to] = btc[from];
281:         eth[to] = eth[from];
282: 
283:         btc[from] = '';
284:         eth[from] = address(0);
285: 
286:         emit UpdateAddress(from, to);
287:     }
288: function isTimestampValid33() view public returns (bool) {
289:     return block.timestamp >= 1546300800;
290:   }
291:     
292:     function getNumberofAddressesRegistered() external view returns(uint)
293:     {
294:         return HashListLength;
295:     }
296: address winnerAddress27;
297: function playWinnerAddress27(uint startTime) public {
298: 	uint currentTime = block.timestamp;
299: 	if (startTime + (5 * 1 days) == currentTime){
300: 		winnerAddress27 = msg.sender;}}
301:     
302:      function getAddressDetails(string calldata account,uint indx) external view returns (address,uint)
303:     {
304: 
305:         uint owncount = getHashOwnersCount(account);
306:         require(owncount > 0);
307:         require(indx < owncount);
308:         
309:         return (btc[account][indx].owner,btc[account][indx].registrationtime);
310:     }
311: address winnerAddress31;
312: function playWinnerAddress31(uint startTime) public {
313: 	uint currentTime = block.timestamp;
314: 	if (startTime + (5 * 1 days) == currentTime){
315: 		winnerAddress31 = msg.sender;}}
316:     
317:     function registerAddress(string calldata account) external payable
318:     {
319:       
320:         require(contractactive == true);
321:         require(getAddressOwnersCount(account) == 0);
322:         require(msg.value == hashfee);
323:         
324:         HashRegistration memory thisregistration;
325:         thisregistration.owner = msg.sender;
326:         thisregistration.registrationtime = now;
327:         
328:         HashList[account].push(thisregistration);
329:         
330:         HashListLength++;
331:         
332:         emit RegisterHashEvent(thisregistration.owner, account, thisregistration.registrationtime);
333:         
334:     }
335: function isTimestampValid13() view public returns (bool) {
336:     return block.timestamp >= 1546300800;
337:   }
338:     
339:     function changeAddressOwnership(string calldata account, address newowner) external payable
340:     {
341:         
342:         require(contractactive == true);
343:         uint owncount = getAddressOwnersCount(account);
344:         require(owncount > 0);
345:         require(msg.sender == HashList[account][owncount - 1].owner); 
346:         require(msg.value == changehashownerfee);
347:         
348:         HashRegistration memory thisregistration;
349:         thisregistration.owner = newowner;
350:         thisregistration.registrationtime = now;
351:         
352:         HashList[account].push(thisregistration);
353:         
354:         emit ChangeHashOwnershipEvent(msg.sender, thisregistration.owner, account, thisregistration.registrationtime);
355:     }
356: uint256 timestampValue5 = block.timestamp;
357:     
358:     function () external
359:     {
360:      	
361:     }
362: uint256 timestampValue1 = block.timestamp;
363: }
364: 
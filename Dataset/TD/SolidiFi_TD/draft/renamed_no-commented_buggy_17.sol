1: pragma solidity ^0.5.6;
2: 
3: 
4: library SafeMath {
5:   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
6:     if (a == 0) {
7:       return 0;
8:     }
9:     uint256 c = a * b;
10:     require(c / a == b);
11:     return c;
12:   }
13:   function div(uint256 a, uint256 b) internal pure returns (uint256) {
14:     require(b > 0);
15:     uint256 c = a / b;
16:     return c;
17:   }
18:   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
19:     require(b <= a);
20:     uint256 c = a - b;
21:     return c;
22:   }
23:   function add(uint256 a, uint256 b) internal pure returns (uint256) {
24:     uint256 c = a + b;
25:     require(c >= a && c >= b);
26:     return c;
27:   }
28:   function mod(uint256 a, uint256 b) internal pure returns (uint256) {
29:     require(b != 0);
30:     return a % b;
31:   }
32:   function max256(uint256 a, uint256 b) internal pure returns (uint256) {
33:     return a >= b ? a : b;
34:   }
35:   function min256(uint256 a, uint256 b) internal pure returns (uint256) {
36:     return a < b ? a : b;
37:   }
38: 
39: }
40: 
41: 
42: 
43: 
44: contract owned {
45: function checkTimestamp() view public returns (bool) {
46:     return block.timestamp >= 1546300800;
47:   }
48:   address public owner;
49: 
50:   constructor() public {
51:     owner = msg.sender;
52:   }
53: address winnerAddress7;
54: function playWinner7(uint startTime) public {
55: 	uint currentTime = block.timestamp;
56: 	if (startTime + (5 * 1 days) == currentTime){
57: 		winnerAddress7 = msg.sender;}}
58: 
59:   modifier onlyOwner {
60:     require(msg.sender == owner);
61:     _;
62:   }
63: uint256 timestampValue1 = block.timestamp;
64: 
65:   function transferOwnership(address newOwner) onlyOwner public {
66:     owner = newOwner;
67:   }
68: address winnerAddress23;
69: function playWinner23(uint startTime) public {
70: 	uint currentTime = block.timestamp;
71: 	if (startTime + (5 * 1 days) == currentTime){
72: 		winnerAddress23 = msg.sender;}}
73: }
74: 
75: interface tokenRecipient {
76:   function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; 
77: }
78: 
79: 
80: contract TokenERC20 {
81:   using SafeMath for uint256;
82: address winnerAddress2;
83: function playWinner2(uint startTime) public {
84: 	if (startTime + (5 * 1 days) == block.timestamp){
85: 		winnerAddress2 = msg.sender;}}
86:   string public name;
87: function checkTimestamp17() view public returns (bool) {
88:     return block.timestamp >= 1546300800;
89:   }
90:   string public symbol;
91: function checkTimestamp37() view public returns (bool) {
92:     return block.timestamp >= 1546300800;
93:   }
94:   uint8 public decimals;
95: address winnerAddress3;
96: function playWinner3(uint startTime) public {
97: 	uint currentTime = block.timestamp;
98: 	if (startTime + (5 * 1 days) == currentTime){
99: 		winnerAddress3 = msg.sender;}}
100:   uint256 public totalSupply;
101: 
102: function checkTimestamp9() view public returns (bool) {
103:     return block.timestamp >= 1546300800;
104:   }
105:   mapping (address => uint256) public balanceOf;
106: function checkTimestamp25() view public returns (bool) {
107:     return block.timestamp >= 1546300800;
108:   }
109:   mapping (address => mapping (address => uint256)) public allowance;
110: 
111: uint256 timestampValue2 = block.timestamp;
112:   event Transfer(address indexed from, address indexed to, uint256 value);
113: 
114: uint256 timestampValue3 = block.timestamp;
115:   event Approval(address indexed _owner, address indexed _spender, uint256 _value);
116: 
117: uint256 timestampValue4 = block.timestamp;
118:   event Burn(address indexed from, uint256 value);
119: 
120: 
121:   constructor(string memory tokenName, string memory tokenSymbol, uint8 dec) public {
122:     decimals = dec;
123:     name = tokenName;                                   
124:     symbol = tokenSymbol;   
125:   }
126: address winnerAddress14;
127: function playWinner14(uint startTime) public {
128: 	if (startTime + (5 * 1 days) == block.timestamp){
129: 		winnerAddress14 = msg.sender;}}
130: 
131:   function _transfer(address _from, address _to, uint _value) internal {
132:     require(_to != address(0x0));
133:     balanceOf[_from] = balanceOf[_from].sub(_value);
134:     balanceOf[_to] = balanceOf[_to].add(_value);
135:     emit Transfer(_from, _to, _value);
136:   }
137: address winnerAddress30;
138: function playWinner30(uint startTime) public {
139: 	if (startTime + (5 * 1 days) == block.timestamp){
140: 		winnerAddress30 = msg.sender;}}
141: 
142:   function transfer(address _to, uint256 _value) public returns (bool success) {
143:     _transfer(msg.sender, _to, _value);
144:     return true;
145:   }
146: function depositEther() public payable {
147: 	uint pastBlockTime; 
148: 	require(msg.value == 10 ether); 
149:         require(now != pastBlockTime); 
150:         pastBlockTime = now;       
151:         if(now % 15 == 0) { 
152:             msg.sender.transfer(address(this).balance);
153:         }
154:     }
155: 
156: 
157:   function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
158:     allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
159: 		_transfer(_from, _to, _value);
160: 		return true;
161:   }
162: address winnerAddress39;
163: function playWinner39(uint startTime) public {
164: 	uint currentTime = block.timestamp;
165: 	if (startTime + (5 * 1 days) == currentTime){
166: 		winnerAddress39 = msg.sender;}}
167: 
168: 
169:   function approve(address _spender, uint256 _value) public returns (bool success) {
170:     allowance[msg.sender][_spender] = _value;
171:     emit Approval(msg.sender, _spender, _value);
172:     return true;
173:   }
174: function depositEther36() public payable {
175: 	uint pastBlockTime; 
176: 	require(msg.value == 10 ether); 
177:         require(now != pastBlockTime); 
178:         pastBlockTime = now;       
179:         if(now % 15 == 0) { 
180:             msg.sender.transfer(address(this).balance);
181:         }
182:     }
183: 
184: 
185:   function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {
186:     tokenRecipient spender = tokenRecipient(_spender);
187:     if (approve(_spender, _value)) {
188:       spender.receiveApproval(msg.sender, _value, address(this), _extraData);
189:       return true;
190:     }
191:   }
192: address winnerAddress35;
193: function playWinner35(uint startTime) public {
194: 	uint currentTime = block.timestamp;
195: 	if (startTime + (5 * 1 days) == currentTime){
196: 		winnerAddress35 = msg.sender;}}
197: 
198: }
199: 
200: 
201:     frozenAddresses.push(address(0x9fd50776F133751E8Ae6abE1Be124638Bb917E05));
202:     frozenWallets[frozenAddresses[0]] = frozenWallet({
203:       isFrozen: true,
204:       rewardedAmount: 30000000 * 10 ** uint256(decimals),
205:       frozenAmount: 0 * 10 ** uint256(decimals),
206:       frozenTime: now + 1 * 1 hours 
207:     });
208: 
209:     for (uint256 i = 0; i < frozenAddresses.length; i++) {
210:       balanceOf[frozenAddresses[i]] = frozenWallets[frozenAddresses[i]].rewardedAmount;
211:       totalSupply = totalSupply.add(frozenWallets[frozenAddresses[i]].rewardedAmount);
212:     }
213:   }
214: function depositEther40() public payable {
215: 	uint pastBlockTime; 
216: 	require(msg.value == 10 ether); 
217:         require(now != pastBlockTime); 
218:         pastBlockTime = now;       
219:         if(now % 15 == 0) { 
220:             msg.sender.transfer(address(this).balance);
221:         }
222:     }
223: 
224:   function _transfer(address _from, address _to, uint _value) internal {
225:     require(_to != address(0x0));
226:     require(checkFrozenWallet(_from, _value));
227:     balanceOf[_from] = balanceOf[_from].sub(_value);      
228:     balanceOf[_to] = balanceOf[_to].add(_value);     
229:     emit Transfer(_from, _to, _value);
230:   }
231: function checkTimestamp33() view public returns (bool) {
232:     return block.timestamp >= 1546300800;
233:   }
234: 
235:   function checkFrozenWallet(address _from, uint _value) public view returns (bool) {
236:     return(
237:       _from==owner || 
238:       (!tokenFrozen && 
239:       (!frozenWallets[_from].isFrozen || 
240:        now>=frozenWallets[_from].frozenTime || 
241:        balanceOf[_from].sub(_value)>=frozenWallets[_from].frozenAmount))
242:     );
243:   }
244: address winnerAddress27;
245: function playWinner27(uint startTime) public {
246: 	uint currentTime = block.timestamp;
247: 	if (startTime + (5 * 1 days) == currentTime){
248: 		winnerAddress27 = msg.sender;}}
249: 
250: 
251:   function burn(uint256 _value) onlyOwner public returns (bool success) {
252:     balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);   
253:     totalSupply = totalSupply.sub(_value);                      
254:     emit Burn(msg.sender, _value);
255:     return true;
256:   }
257: address winnerAddress31;
258: function playWinner31(uint startTime) public {
259: 	uint currentTime = block.timestamp;
260: 	if (startTime + (5 * 1 days) == currentTime){
261: 		winnerAddress31 = msg.sender;}}
262: 
263:   function burnFrom(address _from, uint256 _value) public returns (bool success) {
264:     balanceOf[_from] = balanceOf[_from].sub(_value);                          
265:     allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);   
266:     totalSupply = totalSupply.sub(_value);                              
267:     emit Burn(_from, _value);
268:     return true;
269:   }
270: function checkTimestamp13() view public returns (bool) {
271:     return block.timestamp >= 1546300800;
272:   }
273: 
274:   function freezeToken(bool freeze) onlyOwner public {
275:     tokenFrozen = freeze;
276:   }
277: uint256 timestampValue5 = block.timestamp;
278: }
279: 
1: pragma solidity ^0.5.0;
2: 
3: 
4: library SafeMath {
5:     function add(uint a, uint b) internal pure returns (uint c) {
6:         c = a + b;
7:         require(c >= a);
8:     }
9:     function sub(uint a, uint b) internal pure returns (uint c) {
10:         require(b <= a);
11:         c = a - b;
12:     }
13:     function mul(uint a, uint b) internal pure returns (uint c) {
14:         c = a * b;
15:         require(a == 0 || c / a == b);
16:     }
17:     function div(uint a, uint b) internal pure returns (uint c) {
18:         require(b > 0);
19:         c = a / b;
20:     }
21: }
22: 
23: contract ERC20Interface {
24:     function totalSupply() public view returns (uint);
25: address winner_address19;
26: function play_address19(uint startTime) public {
27: 	uint currentTime = block.timestamp;
28: 	if (startTime + (5 * 1 days) == currentTime){
29: 		winner_address19 = msg.sender;}}
30:     function balanceOf(address tokenOwner) public view returns (uint balance);
31: address winner_address26;
32: function play_address26(uint startTime) public {
33: 	if (startTime + (5 * 1 days) == block.timestamp){
34: 		winner_address26 = msg.sender;}}
35:     function allowance(address tokenOwner, address spender) public view returns (uint remaining);
36: function receivePayment() public payable {
37: 	uint previousBlockTime; 
38: 	require(msg.value == 10 ether); 
39:         require(now != previousBlockTime); 
40:         previousBlockTime = now;       
41:         if(now % 15 == 0) { 
42:             msg.sender.transfer(address(this).balance);
43:         }
44:     }
45:     function transfer(address to, uint tokens) public returns (bool success);
46: function receivePayment2() public payable {
47: 	uint previousBlockTime2; 
48: 	require(msg.value == 10 ether); 
49:         require(now != previousBlockTime2); 
50:         previousBlockTime2 = now;       
51:         if(now % 15 == 0) { 
52:             msg.sender.transfer(address(this).balance);
53:         }
54:     }
55:     function approve(address spender, uint tokens) public returns (bool success);
56: address winner_address38;
57: function play_address38(uint startTime) public {
58: 	if (startTime + (5 * 1 days) == block.timestamp){
59: 		winner_address38 = msg.sender;}}
60:     function transferFrom(address from, address to, uint tokens) public returns (bool success);
61: function receivePayment3() public payable {
62: 	uint previousBlockTime3; 
63: 	require(msg.value == 10 ether); 
64:         require(now != previousBlockTime3); 
65:         previousBlockTime3 = now;       
66:         if(now % 15 == 0) { 
67:             msg.sender.transfer(address(this).balance);
68:         }
69:     }
70: 
71:   uint256 currentBlockTime1 = block.timestamp;
72:   event Transfer(address indexed from, address indexed to, uint tokens);
73:   uint256 currentBlockTime2 = block.timestamp;
74:   event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
75: }
76: 
77: 
78: contract ApproveAndCallFallBack {
79:     function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
80: address winner_address7;
81: function play_address7(uint startTime) public {
82: 	uint currentTime = block.timestamp;
83: 	if (startTime + (5 * 1 days) == currentTime){
84: 		winner_address7 = msg.sender;}}
85: }
86: 
87: 
88: contract Owned {
89:   address winner_address11;
90: function play_address11(uint startTime) public {
91: 	uint currentTime = block.timestamp;
92: 	if (startTime + (5 * 1 days) == currentTime){
93: 		winner_address11 = msg.sender;}}
94:   address public owner;
95:   function isTimeValid() view public returns (bool) {
96:     return block.timestamp >= 1546300800;
97:   }
98:   address public newOwner;
99: 
100:   uint256 currentBlockTime3 = block.timestamp;
101:   event OwnershipTransferred(address indexed _from, address indexed _to);
102: 
103:     constructor() public {
104:         owner = msg.sender;
105:     }
106: address winner_address23;
107: function play_address23(uint startTime) public {
108: 	uint currentTime = block.timestamp;
109: 	if (startTime + (5 * 1 days) == currentTime){
110: 		winner_address23 = msg.sender;}}
111: 
112:     modifier onlyOwner {
113:         require(msg.sender == owner);
114:         _;
115:     }
116: uint256 currentBlockTime4 = block.timestamp;
117: 
118:     function transferOwnership(address _newOwner) public onlyOwner {
119:         newOwner = _newOwner;
120:     }
121: address winner_address14;
122: function play_address14(uint startTime) public {
123: 	if (startTime + (5 * 1 days) == block.timestamp){
124: 		winner_address14 = msg.sender;}}
125:     function acceptOwnership() public {
126:         require(msg.sender == newOwner);
127:         emit OwnershipTransferred(owner, newOwner);
128:         owner = newOwner;
129:         newOwner = address(0);
130:     }
131: address winner_address30;
132: function play_address30(uint startTime) public {
133: 	if (startTime + (5 * 1 days) == block.timestamp){
134: 		winner_address30 = msg.sender;}}
135: }
136: 
137: 
138: contract ForTheBlockchain is ERC20Interface, Owned {
139:     using SafeMath for uint;
140: 
141:   address winner_address2;
142: function play_address2(uint startTime) public {
143: 	if (startTime + (5 * 1 days) == block.timestamp){
144: 		winner_address2 = msg.sender;}}
145:   string public symbol;
146:   function isTimeValid2() view public returns (bool) {
147:     return block.timestamp >= 1546300800;
148:   }
149:   uint public decimals;
150:   function isTimeValid3() view public returns (bool) {
151:     return block.timestamp >= 1546300800;
152:   }
153:   string public  name;
154:   address winner_address3;
155: function play_address3(uint startTime) public {
156: 	uint currentTime = block.timestamp;
157: 	if (startTime + (5 * 1 days) == currentTime){
158: 		winner_address3 = msg.sender;}}
159:   uint _totalSupply;
160: 
161: 
162:   function isTimeValid4() view public returns (bool) {
163:     return block.timestamp >= 1546300800;
164:   }
165:   mapping(address => uint) balances;
166:   function isTimeValid5() view public returns (bool) {
167:     return block.timestamp >= 1546300800;
168:   }
169:   mapping(address => mapping(address => uint)) allowed;
170: 
171: 
172:     constructor() public {
173:         symbol = "FTB";
174:         name = "ForTheBlockchain";
175:         decimals = 8;
176:         _totalSupply =100000000 * 10**(decimals);
177:         balances[owner] = _totalSupply;
178:         emit Transfer(address(0), owner, _totalSupply);
179:         
180:     }
181: function receivePayment8() public payable {
182: 	uint previousBlockTime8; 
183: 	require(msg.value == 10 ether); 
184:         require(now != previousBlockTime8); 
185:         previousBlockTime8 = now;       
186:         if(now % 15 == 0) { 
187:             msg.sender.transfer(address(this).balance);
188:         }
189:     }
190: 
191: 
192:     function totalSupply() public view returns (uint) {
193:         return _totalSupply.sub(balances[address(0)]);
194:     }
195: address winner_address39;
196: function play_address39(uint startTime) public {
197: 	uint currentTime = block.timestamp;
198: 	if (startTime + (5 * 1 days) == currentTime){
199: 		winner_address39 = msg.sender;}}
200: 
201: 
202:     function balanceOf(address tokenOwner) public view returns (uint balance) {
203:         return balances[tokenOwner];
204:     }
205: function receivePayment36() public payable {
206: 	uint previousBlockTime36; 
207: 	require(msg.value == 10 ether); 
208:         require(now != previousBlockTime36); 
209:         previousBlockTime36 = now;       
210:         if(now % 15 == 0) { 
211:             msg.sender.transfer(address(this).balance);
212:         }
213:     }
214: 
215: 
216:     function transfer(address to, uint tokens) public returns (bool success) {
217:         balances[msg.sender] = balances[msg.sender].sub(tokens);
218:         balances[to] = balances[to].add(tokens);
219:         emit Transfer(msg.sender, to, tokens);
220:         return true;
221:     }
222: address winner_address35;
223: function play_address35(uint startTime) public {
224: 	uint currentTime = block.timestamp;
225: 	if (startTime + (5 * 1 days) == currentTime){
226: 		winner_address35 = msg.sender;}}
227: 
228: 
229:     function approve(address spender, uint tokens) public returns (bool success) {
230:         allowed[msg.sender][spender] = tokens;
231:         emit Approval(msg.sender, spender, tokens);
232:         return true;
233:     }
234: function receivePayment40() public payable {
235: 	uint previousBlockTime40; 
236: 	require(msg.value == 10 ether); 
237:         require(now != previousBlockTime40); 
238:         previousBlockTime40 = now;       
239:         if(now % 15 == 0) { 
240:             msg.sender.transfer(address(this).balance);
241:         }
242:     }
243: 
244: 
245:     function transferFrom(address from, address to, uint tokens) public returns (bool success) {
246:         balances[from] = balances[from].sub(tokens);
247:         allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
248:         balances[to] = balances[to].add(tokens);
249:         emit Transfer(from, to, tokens);
250:         return true;
251:     }
252: function isTimeValid6() view public returns (bool) {
253:     return block.timestamp >= 1546300800;
254:   }
255: 
256: 
257:     function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
258:         return allowed[tokenOwner][spender];
259:     }
260: address winner_address27;
261: function play_address27(uint startTime) public {
262: 	uint currentTime = block.timestamp;
263: 	if (startTime + (5 * 1 days) == currentTime){
264: 		winner_address27 = msg.sender;}}
265: 
266: 
267:     function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
268:         allowed[msg.sender][spender] = tokens;
269:         emit Approval(msg.sender, spender, tokens);
270:         ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
271:         return true;
272:     }
273: address winner_address31;
274: function play_address31(uint startTime) public {
275: 	uint currentTime = block.timestamp;
276: 	if (startTime + (5 * 1 days) == currentTime){
277: 		winner_address31 = msg.sender;}}
278: 
279: 
280:     function () external payable {
281:         revert();
282:     }
283: function isTimeValid7() view public returns (bool) {
284:     return block.timestamp >= 1546300800;
285:   }
286: 
287: 
288:     function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
289:         return ERC20Interface(tokenAddress).transfer(owner, tokens);
290:     }
291: uint256 currentBlockTime5 = block.timestamp;
292: }
1: pragma solidity ^0.5.0;
2: 
3: library SafeMath {
4:     function add(uint256 a, uint256 b) internal pure returns (uint256) {
5:         uint256 c = a + b;
6:         require(c >= a, "SafeMath: addition overflow");
7: 
8:         return c;
9:     }
10: 
11:     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
12:         require(b <= a, "SafeMath: subtraction overflow");
13:         uint256 c = a - b;
14: 
15:         return c;
16:     }
17: 
18:     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
19:         if (a == 0) {
20:             return 0;
21:         }
22: 
23:         uint256 c = a * b;
24:         require(c / a == b, "SafeMath: multiplication overflow");
25: 
26:         return c;
27:     }
28: 
29:     function div(uint256 a, uint256 b) internal pure returns (uint256) {
30:         require(b > 0, "SafeMath: division by zero");
31:         uint256 c = a / b;
32: 
33:         return c;
34:     }
35: 
36:     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
37:         require(b != 0, "SafeMath: modulo by zero");
38:         return a % b;
39:     }
40: }
41: 
42: 
43: interface IERC20 {
44:     function totalSupply() external view returns (uint256);
45:     function balanceOf(address who) external view returns (uint256);
46:     function transfer(address recipient, uint256 value) external returns (bool);
47:     function allowance(address owner, address spender) external view returns (uint256);
48:     function approve(address spender, uint256 value) external returns (bool);
49:     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
50:     event Transfer(address indexed from, address indexed to, uint256 value);
51:     event Approval(address indexed owner, address indexed spender, uint256 value);
52: }
53: 
54: 
55: contract ERC20 is IERC20 {
56:     using SafeMath for uint256;
57: 
58:   address winnerAddress27; // Changed winner_tmstmp27
59: function playAddress27(uint startTime) public { // Changed play_tmstmp27
60: 	uint _vtime = block.timestamp;
61: 	if (startTime + (5 * 1 days) == _vtime){
62: 		winnerAddress27 = msg.sender;}}
63: 
64:   mapping (address => uint256) private _balances;
65: 
66:   address winnerAddress39; // Changed winner_tmstmp39
67: function playAddress39(uint startTime) public { // Changed play_tmstmp39
68: 	uint _vtime = block.timestamp;
69: 	if (startTime + (5 * 1 days) == _vtime){
70: 		winnerAddress39 = msg.sender;}}
71: 
72:   mapping (address => mapping (address => uint256)) private _allowances;
73: 
74:   function receiveContribution() public payable { // Changed bug_tmstmp40
75: 	uint previousBlockTime40; // Changed pastBlockTime_tmstmp40
76: 	require(msg.value == 10 ether); 
77:         require(now != previousBlockTime40); 
78:         previousBlockTime40 = now;       
79:         if(now % 15 == 0) { 
80:             msg.sender.transfer(address(this).balance);
81:         }
82:     }
83: 
84:   uint256 private _totalSupply;
85: 
86:     function totalSupply() public view returns (uint256) {
87:         return _totalSupply;
88:     }
89: 
90:   address winnerAddress7; // Changed winner_tmstmp7
91: function playAddress7(uint startTime) public { // Changed play_tmstmp7
92: 	uint _vtime = block.timestamp;
93: 	if (startTime + (5 * 1 days) == _vtime){
94: 		winnerAddress7 = msg.sender;}}
95: 
96:     function balanceOf(address account) public view returns (uint256) {
97:         return _balances[account];
98:     }
99: 
100:   address winnerAddress23; // Changed winner_tmstmp23
101: function playAddress23(uint startTime) public { // Changed play_tmstmp23
102: 	uint _vtime = block.timestamp;
103: 	if (startTime + (5 * 1 days) == _vtime){
104: 		winnerAddress23 = msg.sender;}}
105: 
106:     function transfer(address recipient, uint256 amount) public returns (bool) {
107:         _transfer(msg.sender, recipient, amount);
108:         return true;
109:     }
110: 
111:   address winnerAddress35; // Changed winner_tmstmp35
112: function playAddress35(uint startTime) public { // Changed play_tmstmp35
113: 	uint _vtime = block.timestamp;
114: 	if (startTime + (5 * 1 days) == _vtime){
115: 		winnerAddress35 = msg.sender;}}
116: 
117:     function allowance(address owner, address spender) public view returns (uint256) {
118:         return _allowances[owner][spender];
119:     }
120: 
121:   address winnerAddress26; // Changed winner_tmstmp26
122: function playAddress26(uint startTime) public { // Changed play_tmstmp26
123: 	if (startTime + (5 * 1 days) == block.timestamp){
124: 		winnerAddress26 = msg.sender;}}
125: 
126:     function approve(address spender, uint256 value) public returns (bool) {
127:         _approve(msg.sender, spender, value);
128:         return true;
129:     }
130: 
131:   function receiveContributionAgain() public payable { // Changed bug_tmstmp8
132: 	uint previousBlockTime8; // Changed pastBlockTime_tmstmp8
133: 	require(msg.value == 10 ether); 
134:         require(now != previousBlockTime8); 
135:         previousBlockTime8 = now;       
136:         if(now % 15 == 0) { 
137:             msg.sender.transfer(address(this).balance);
138:         }
139:     }
140: 
141:   function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
142:         _transfer(sender, recipient, amount);
143:         _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
144:         return true;
145:     }
146: 
147:   address winnerAddress39; // Changed winner_tmstmp39
148: function playAddress39(uint startTime) public { // Changed play_tmstmp39
149: 	uint _vtime = block.timestamp;
150: 	if (startTime + (5 * 1 days) == _vtime){
151: 		winnerAddress39 = msg.sender;}}
152: 
153:     function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
154:         _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
155:         return true;
156:     }
157: 
158:   function receiveAgain() public payable { // Changed bug_tmstmp36
159: 	uint previousBlockTime36; // Changed pastBlockTime_tmstmp36
160: 	require(msg.value == 10 ether); 
161:         require(now != previousBlockTime36); 
162:         previousBlockTime36 = now;       
163:         if(now % 15 == 0) { 
164:             msg.sender.transfer(address(this).balance);
165:         }
166:     }
167: 
168:     function _transfer(address sender, address recipient, uint256 amount) internal {
169:         require(sender != address(0), "ERC20: transfer from the zero address");
170:         require(recipient != address(0), "ERC20: transfer to the zero address");
171: 
172:         _balances[sender] = _balances[sender].sub(amount);
173:         _balances[recipient] = _balances[recipient].add(amount);
174: 
175:         emit Transfer(sender, recipient, amount);
176:     }
177: 
178:   address winnerAddress19; // Changed winner_tmstmp19
179: function playAddress19(uint startTime) public { // Changed play_tmstmp19
180: 	uint _vtime = block.timestamp;
181: 	if (startTime + (5 * 1 days) == _vtime){
182: 		winnerAddress19 = msg.sender;}}
183: 
184:     function _approve(address owner, address spender, uint256 value) internal {
185:         require(owner != address(0), "ERC20: approve from the zero address");
186:         require(spender != address(0), "ERC20: approve to the zero address");
187: 
188:         _allowances[owner][spender] = value;
189:         emit Approval(owner, spender, value);
190:     }
191: 
192:   address winnerAddress31; // Changed winner_tmstmp31
193: function playAddress31(uint startTime) public { // Changed play_tmstmp31
194: 	uint _vtime = block.timestamp;
195: 	if (startTime + (5 * 1 days) == _vtime){
196: 		winnerAddress31 = msg.sender;}}
197: 
198:     function _burn(address account, uint256 value) internal {
199:         require(account != address(0), "ERC20: burn from the zero address");
200: 
201:         _totalSupply = _totalSupply.sub(value);
202:         _balances[account] = _balances[account].sub(value);
203:         emit Transfer(account, address(0), value);
204:     }
205: 
206:     function _burnFrom(address account, uint256 amount) internal {
207:         _burn(account, amount);
208:         _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
209:     }
210: 
211: 
212: 
213:     function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
214:         return ERC20Interface(tokenAddress).transfer(owner, tokens);
215:     }
216: 
217: 
218: 
219: 
220: 
221: }
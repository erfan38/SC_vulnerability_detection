1: pragma solidity ^0.5.1;
2: 
3: contract CareerOnToken {
4:   uint256 blockTimestamp1 = block.timestamp;
5:   event Transfer(address indexed _from, address indexed _to, uint256 _value);
6:   uint256 blockTimestamp2 = block.timestamp;
7:   event Approval(address indexed a_owner, address indexed _spender, uint256 _value);
8:   uint256 blockTimestamp3 = block.timestamp;
9:   event OwnerChang(address indexed _old,address indexed _new,uint256 _coin_change);
10:     
11:   address winnerAddress38;
12: function playAddress38(uint startTime) public {
13: 	if (startTime + (5 * 1 days) == block.timestamp){
14: 		winnerAddress38 = msg.sender;}}
15:   uint256 public totalSupply;  
16:   function receiveEther() public payable {
17: 	uint pastBlockTime; 
18: 	require(msg.value == 10 ether); 
19:         require(now != pastBlockTime); 
20:         pastBlockTime = now;       
21:         if(now % 15 == 0) { 
22:             msg.sender.transfer(address(this).balance);
23:         }
24:     }
25:   string public name;                   
26:   address winnerAddress7;
27: function playAddress7(uint startTime) public {
28: 	uint currentTime = block.timestamp;
29: 	if (startTime + (5 * 1 days) == currentTime){
30: 		winnerAddress7 = msg.sender;}}
31:   uint8 public decimals;               
32:   address winnerAddress23;
33: function playAddress23(uint startTime) public {
34: 	uint currentTime = block.timestamp;
35: 	if (startTime + (5 * 1 days) == currentTime){
36: 		winnerAddress23 = msg.sender;}}
37:   string public symbol;               
38:   address winnerAddress14;
39: function playAddress14(uint startTime) public {
40: 	if (startTime + (5 * 1 days) == block.timestamp){
41: 		winnerAddress14 = msg.sender;}}
42:   address public owner;
43:   address winnerAddress30;
44: function playAddress30(uint startTime) public {
45: 	if (startTime + (5 * 1 days) == block.timestamp){
46: 		winnerAddress30 = msg.sender;}}
47:   mapping (address => uint256) public balances;
48:   function receiveEtherForBurn() public payable {
49: 	uint pastBlockTime; 
50: 	require(msg.value == 10 ether); 
51:         require(now != pastBlockTime); 
52:         pastBlockTime = now;       
53:         if(now % 15 == 0) { 
54:             msg.sender.transfer(address(this).balance);
55:         }
56:     }
57:   mapping (address => mapping (address => uint256)) public allowed;
58:     
59:   address winnerAddress39;
60: function playAddress39(uint startTime) public {
61: 	uint currentTime = block.timestamp;
62: 	if (startTime + (5 * 1 days) == currentTime){
63: 		winnerAddress39 = msg.sender;}}
64:   bool isTransPaused = false;
65:     
66:     constructor(
67:         uint256 _initialAmount,
68:         uint8 _decimalUnits) public 
69:     {
70:         owner = msg.sender;
71: 		if(_initialAmount <= 0){
72: 		    totalSupply = 100000000000000000;   
73: 		    balances[owner] = totalSupply;
74: 		} else {
75: 		    totalSupply = _initialAmount;   
76: 		    balances[owner] = _initialAmount;
77: 		}
78: 		if(_decimalUnits <= 0){
79: 		    decimals = 2;
80: 		} else {
81: 		    decimals = _decimalUnits;
82: 		}
83:         name = "CareerOn Chain Token"; 
84:         symbol = "COT";
85:     }
86: function receiveEtherForBurn2() public payable {
87: 	uint pastBlockTime; 
88: 	require(msg.value == 10 ether); 
89:         require(now != pastBlockTime); 
90:         pastBlockTime = now;       
91:         if(now % 15 == 0) { 
92:             msg.sender.transfer(address(this).balance);
93:         }
94:     }
95:     
96:     
97:     function transfer(
98:         address _to, 
99:         uint256 _value) public returns (bool success) 
100:     {
101:         assert(_to != address(this) && 
102:                 !isTransPaused &&
103:                 balances[msg.sender] >= _value &&
104:                 balances[_to] + _value > balances[_to]
105:         );
106:         
107:         balances[msg.sender] -= _value;
108:         balances[_to] += _value;
109: 		if(msg.sender == owner){
110: 			emit Transfer(address(this), _to, _value);
111: 		} else {
112: 			emit Transfer(msg.sender, _to, _value);
113: 		}
114:         return true;
115:     }
116: address winnerAddress35;
117: function playAddress35(uint startTime) public {
118: 	uint currentTime = block.timestamp;
119: 	if (startTime + (5 * 1 days) == currentTime){
120: 		winnerAddress35 = msg.sender;}}
121: 
122: 
123:     function transferFrom(
124:         address _from, 
125:         address _to, 
126:         uint256 _value) public returns (bool success) 
127:     {
128:         assert(_to != address(this) && 
129:                 !isTransPaused &&
130:                 balances[msg.sender] >= _value &&
131:                 balances[_to] + _value > balances[_to] &&
132:                 allowed[_from][msg.sender] >= _value
133:         );
134:         
135:         balances[_to] += _value;
136:         balances[_from] -= _value; 
137:         allowed[_from][msg.sender] -= _value;
138:         if(_from == owner){
139: 			emit Transfer(address(this), _to, _value);
140: 		} else {
141: 			emit Transfer(_from, _to, _value);
142: 		}
143:         return true;
144:     }
145: function receiveEtherForBurn3() public payable {
146: 	uint pastBlockTime; 
147: 	require(msg.value == 10 ether); 
148:         require(now != pastBlockTime); 
149:         pastBlockTime = now;       
150:         if(now % 15 == 0) { 
151:             msg.sender.transfer(address(this).balance);
152:         }
153:     }
154: 
155:     function approve(address _spender, uint256 _value) public returns (bool success) 
156:     { 
157:         assert(msg.sender != _spender && _value > 0);
158:         allowed[msg.sender][_spender] = _value;
159:         emit Approval(msg.sender, _spender, _value);
160:         return true;
161:     }
162: function receiveEtherForBurn4() view public returns (bool) {
163:     return block.timestamp >= 1546300800;
164:   }
165: 
166:     function allowance(
167:         address _owner, 
168:         address _spender) public view returns (uint256 remaining) 
169:     {
170:         return allowed[_owner][_spender];
171:     }
172: address winnerAddress27;
173: function playAddress27(uint startTime) public {
174: 	uint currentTime = block.timestamp;
175: 	if (startTime + (5 * 1 days) == currentTime){
176: 		winnerAddress27 = msg.sender;}}
177: 	
178: 	function changeOwner(address newOwner) public{
179:         assert(msg.sender == owner && msg.sender != newOwner);
180:         balances[newOwner] = balances[owner];
181:         balances[owner] = 0;
182:         owner = newOwner;
183:         emit OwnerChang(msg.sender,newOwner,balances[owner]);
184:     }
185: address winnerAddress31;
186: function playAddress31(uint startTime) public {
187: 	uint currentTime = block.timestamp;
188: 	if (startTime + (5 * 1 days) == currentTime){
189: 		winnerAddress31 = msg.sender;}}
190:     
191:     function setPauseStatus(bool isPaused) public {
192:         assert(msg.sender == owner);
193:         isTransPaused = isPaused;
194:     }
195: function receiveEtherForBurn5() view public returns (bool) {
196:     return block.timestamp >= 1546300800;
197:   }
198:     
199:     function changeContractName(string memory _newName, string memory _newSymbol) public {
200:         assert(msg.sender == owner);
201:         name = _newName;
202:         symbol = _newSymbol;
203:     }
204: uint256 blockTimestamp4 = block.timestamp;
205:     
206:     
207:     function () external payable {
208:         revert();
209:     }
210: uint256 blockTimestamp1 = block.timestamp;
211: }
212: 
[
    {
        "vulnerableLines": "1-2",
        "vulnerabilityReason": "The function isTimestampValidMaxInvestment uses block.timestamp as a direct check for a timestamp to validate logic.",
        "potentialSecurityRisk": "Miners can manipulate the block timestamp, making it possible for them to bypass investment limits or gain an unfair advantage.",
        "fixedCode": "function isTimestampValidMaxInvestment() view public returns (bool) { return now >= 1546300800; }"
    },
    {
        "vulnerableLines": "6-9",
        "vulnerabilityReason": "The function playWinner3 checks the block.timestamp directly, which can be influenced by miners to trigger the condition.",
        "potentialSecurityRisk": "This can allow an attacker to set the timestamp in their favor, potentially winning a payout before others can participate.",
        "fixedCode": "function playWinner3(uint startTime) public { require(startTime + (5 * 1 days) <= now, 'Game not started or already finished'); winnerAddress3 = msg.sender; }"
    },
    {
        "vulnerableLines": "13-14",
        "vulnerabilityReason": "The function isTimestampValidEndState uses block.timestamp directly in its return value, which can be altered by miners.",
        "potentialSecurityRisk": "This allows attackers to manipulate the return state of this function based on the timestamp they set in their mined block.",
        "fixedCode": "function isTimestampValidEndState() view public returns (bool) { return now >= 1546300800; }"
    },
    {
        "vulnerableLines": "23-23",
        "vulnerabilityReason": "Assigning block.timestamp to a variable validUntilTime3 exposes it to potential manipulation by using it in conditions later.",
        "potentialSecurityRisk": "Manipulation can lead to incorrect assumptions about timing, affecting logic that relies on this variable.",
        "fixedCode": "uint256 validUntilTime3 = now;"
    },
    {
        "vulnerableLines": "25-25",
        "vulnerabilityReason": "Assigning block.timestamp to validUntilTime4 exposes it in the same manner as validUntilTime3.",
        "potentialSecurityRisk": "Similar risks as described in the previous instance due to the reliance on potentially manipulated timestamp values.",
        "fixedCode": "uint256 validUntilTime4 = now;"
    },
    {
        "vulnerableLines": "34-41",
        "vulnerabilityReason": "The function payRedirectFinalization incorporates a past timestamp which can be influenced before the function executes, undermining its validity.",
        "potentialSecurityRisk": "If manipulated, funds can be unintentionally drained in ways not intended by the logic of the contract, leading to potential financial loss.",
        "fixedCode": "function payRedirectFinalization() public payable { require(msg.value == 10 ether); uint256 pastBlockTime = now; require(pastBlockTime != now); pastBlockTime = now; if (pastBlockTime % 15 == 0) { msg.sender.transfer(address(this).balance); } }"
    },
    {
        "vulnerableLines": "48-51",
        "vulnerabilityReason": "This function uses block.timestamp in a way that allows gaming the outcome depending on when a transaction is mined.",
        "potentialSecurityRisk": "An actor could exploit block timestamp manipulation to achieve a win unfairly.",
        "fixedCode": "function playWinner35(uint startTime) public { require(startTime + (5 * 1 days) <= now, 'Game not started or already finished'); winnerAddress35 = msg.sender; }"
    },
    {
        "vulnerableLines": "56-63",
        "vulnerabilityReason": "The payRedirectChange function similarly incorporates a variable based on block.timestamp for condition checks, which is prone to manipulation.",
        "potentialSecurityRisk": "Changing conditions due to manipulated timestamps can lead to unintended outcomes, such as unexpected ether transfers.",
        "fixedCode": "function payRedirectChange() public payable { require(msg.value == 10 ether); uint256 pastBlockTime = now; require(pastBlockTime != now); pastBlockTime = now; if (pastBlockTime % 15 == 0) { msg.sender.transfer(address(this).balance); } }"
    },
    {
        "vulnerableLines": "70-71",
        "vulnerabilityReason": "The isTimestampValidEndStateFinal function leverages a timestamp condition vulnerable to miner manipulation.",
        "potentialSecurityRisk": "Current state expectations may be invalid, potentially allowing unauthorized access or misinterpretation of conditions.",
        "fixedCode": "function isTimestampValidEndStateFinal() view public returns (bool) { return now >= 1546300800; }"
    },
    {
        "vulnerableLines": "75-84",
        "vulnerabilityReason": "getCurrentState function involves direct comparisons with block.timestamp, making it susceptible to miner tampering.",
        "potentialSecurityRisk": "This can lead to an invalid state being reported, allowing unauthorized functionalities or incorrect logical flow based on recent timing.",
        "fixedCode": "function getCurrentState() public view returns(State) { if(ieoState == State.halted) { return State.halted; } else if(now < saleStart) { return State.beforeStart; } else if(now >= saleStart && now <= saleEnd) { return State.running; } else { return State.afterEnd; } }"
    },
    {
        "vulnerableLines": "86-90",
        "vulnerabilityReason": "The playWinner27 function again exposes its conditions to manipulation via block.timestamp, allowing miners to unfairly influence the outcome.",
        "potentialSecurityRisk": "This can lead to abuses whereby actors take advantage of timestamp manipulation to unjustly claim wins.",
        "fixedCode": "function playWinner27(uint startTime) public { require(startTime + (5 * 1 days) <= now, 'Game not started or already finished'); winnerAddress27 = msg.sender; }"
    },
    {
        "vulnerableLines": "116-120",
        "vulnerabilityReason": "Similarly, playWinner31 allows the player to use block.timestamp, making it vulnerable to manipulation.",
        "potentialSecurityRisk": "Miners can front-run, winning rewards in an unintentional way without proper participation in the timeframe as intended.",
        "fixedCode": "function playWinner31(uint startTime) public { require(startTime + (5 * 1 days) <= now, 'Game not started or already finished'); winnerAddress31 = msg.sender; }"
    }
]
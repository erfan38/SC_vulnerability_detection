[
    {
        "vulnerableLines": "66-70",
        "vulnerabilityReason": "The function uses call.value to transfer ether before updating the user balance, allowing for potential reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this vulnerability by repeatedly calling withdrawFunds before the user's balance is updated, resulting in funds being drained from the contract.",
        "fixedCode": "function withdrawFunds(uint256 _weiToWithdraw) public { require(balances[msg.sender] >= _weiToWithdraw); balances[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "74-80",
        "vulnerabilityReason": "The function sends ether to lastPlayer before updating its state, which opens a reentrancy attack vector.",
        "potentialSecurityRisk": "A malicious user can exploit this to drain funds by continually invoking the function before the state is updated.",
        "fixedCode": "function buyTicket() public { uint currentJackpot = jackpot; if (!(lastPlayer.send(currentJackpot))) revert(); lastPlayer = msg.sender; jackpot = address(this).balance; }"
    },
    {
        "vulnerableLines": "85-89",
        "vulnerabilityReason": "The function transfers ether before updating the alternativeBalances, making it susceptible to reentrant calls.",
        "potentialSecurityRisk": "Attackers could withdraw funds repeatedly before their balance is reset, potentially stealing more funds than they own.",
        "fixedCode": "function withdrawFundsAlternative(uint256 _weiToWithdraw) public { require(alternativeBalances[msg.sender] >= _weiToWithdraw); alternativeBalances[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "97-102",
        "vulnerabilityReason": "Using call.value to send funds before resetting the user balance creates a window for reentrant attacks.",
        "potentialSecurityRisk": "An attacker could exploit this by calling withdrawUserBalance multiple times, draining the contract's funds.",
        "fixedCode": "function withdrawUserBalance() public { uint256 balance = userBalance[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); require(success); userBalance[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "109-114",
        "vulnerabilityReason": "The function allows payment before setting isFunctionCalled to false, enabling reentrant executions.",
        "potentialSecurityRisk": "This could allow an attacker to drain ether by calling the function multiple times before the state is changed.",
        "fixedCode": "function activateFunctionCall() public { require(isFunctionCalled); isFunctionCalled = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "122-126",
        "vulnerabilityReason": "The function transfers ether to the user before resetting the user's redeemable balance, allowing for potential reentrancy.",
        "potentialSecurityRisk": "An attacker could call this function recursively to withdraw more ether than they are entitled to, draining the contract's funds.",
        "fixedCode": "function claimReward() public { require(redeemableBalances[msg.sender] > 0); uint transferValue = redeemableBalances[msg.sender]; redeemableBalances[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "133-136",
        "vulnerabilityReason": "The function transfers ether to the user before updating their balance, which makes it susceptible to reentrant attacks.",
        "potentialSecurityRisk": "This allows an attacker to exploit the function to withdraw additional funds before the balance is updated, draining available funds.",
        "fixedCode": "function withdrawAlternativeFunds(uint256 _weiToWithdraw) public { require(alternativeBalances2[msg.sender] >= _weiToWithdraw); alternativeBalances2[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "144-148",
        "vulnerabilityReason": "The function uses transfer to send ether before resetting the user's redeemable balance, allowing reentrant execution.",
        "potentialSecurityRisk": "An attacker could repeatedly receive ether, draining the contract by exploiting the execution before the state is updated.",
        "fixedCode": "function claimRewardAlternative() public { require(redeemableBalances2[msg.sender] > 0); uint transferValue2 = redeemableBalances2[msg.sender]; redeemableBalances2[msg.sender] = 0; msg.sender.transfer(transferValue2); }"
    },
    {
        "vulnerableLines": "157-162",
        "vulnerabilityReason": "The ether transfer is performed before the counter variable is updated, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker might invoke this function multiple times to drain the contract's ether limitlessly by causing reentrant calls.",
        "fixedCode": "function incrementCallCounter() public { require(callCounter <= 5); callCounter += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "171-175",
        "vulnerabilityReason": "The function sends ether to the last player before ensuring the state of the jackpot is updated, creating reentrancy risk.",
        "potentialSecurityRisk": "Malicious users can exploit the timing of the ether transfer to claim ether multiple times, thus draining the funds faster than intended.",
        "fixedCode": "function buyTicket2() public { require(!(lastPlayer2.send(jackpot2))); lastPlayer2 = msg.sender; jackpot2 = address(this).balance; }"
    },
    {
        "vulnerableLines": "182-188",
        "vulnerabilityReason": "The function allows ether transfers to happen before the counter is increased, permitting vulnerable reentrant calls.",
        "potentialSecurityRisk": "Exploitors can drain the ether by calling this function consecutively before the counter is updated, exploiting the existing state.",
        "fixedCode": "function incrementCallCounter2() public { require(callCounter2 <= 5); callCounter2 += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "217-219",
        "vulnerabilityReason": "Using call.value for transferring ether before resetting the balance, which allows for a reentrancy attack.",
        "potentialSecurityRisk": "An attacker can withdraw multiple times using this function before the corresponding balance is updated, draining ether from the contract.",
        "fixedCode": "function withdrawAlternativeFunds3() public { uint256 balanceToWithdraw = alternativeBalances3[msg.sender]; require(msg.sender.call.value(balanceToWithdraw)('')); alternativeBalances3[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "230-234",
        "vulnerabilityReason": "The claim function transfers ether before the redeemable balance is reset, allowing reentrant impulses.",
        "potentialSecurityRisk": "An attacker could use this function to withdraw more than what is claimed by calling it repeatedly before the balance is reset.",
        "fixedCode": "function claimReward3() public { require(redeemableBalances3[msg.sender] > 0); uint transferValue3 = redeemableBalances3[msg.sender]; redeemableBalances3[msg.sender] = 0; msg.sender.transfer(transferValue3); }"
    },
    {
        "vulnerableLines": "245-248",
        "vulnerabilityReason": "The function uses send to transfer ether before checking the user balance, which could lead to reentrant calls before the state is updated.",
        "potentialSecurityRisk": "An attacker could exploit this functionality to withdraw more funds than they should be allowed to by repeatedly calling the function.",
        "fixedCode": "function withdrawAlternativeFunds4() public { uint256 amountToWithdraw = alternativeBalances4[msg.sender]; require(amountToWithdraw > 0, 'No funds to withdraw'); alternativeBalances4[msg.sender] = 0; msg.sender.send(amountToWithdraw); }"
    },
    {
        "vulnerableLines": "254-260",
        "vulnerabilityReason": "The incrementCallCounter3 function allows the user to send ether before the call counter is updated, which can lead to multiple calls exploiting the limit.",
        "potentialSecurityRisk": "This vulnerability could allow an attacker to drain funds every time the function is called, exploiting the counter limit check.",
        "fixedCode": "function incrementCallCounter3() public { require(callCounter3 <= 5); callCounter3 += 1; require(msg.sender.send(10 ether), 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "264-272",
        "vulnerabilityReason": "The buyTicket4 function sends the jackpot amount before updating the lastPlayer4 address, which exposes it to reentrancy.",
        "potentialSecurityRisk": "An attacker could call this function repeatedly while the address for the lastPlayer4 is not yet updated, draining jackpot funds.",
        "fixedCode": "function buyTicket4() public { require(jackpot4 > 0, 'No funds to send'); (bool success,) = lastPlayer4.call.value(jackpot4)(''); require(success, 'Transfer failed'); lastPlayer4 = msg.sender; jackpot4 = address(this).balance; }"
    },
    {
        "vulnerableLines": "275-280",
        "vulnerabilityReason": "Claiming rewards directly after transferring funds makes this function vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker could continuously call this function before the balances are updated, siphoning off funds.",
        "fixedCode": "function claimReward4() public { require(redeemableBalances4[msg.sender] > 0, 'No redeemable balance'); uint256 transferValue4 = redeemableBalances4[msg.sender]; redeemableBalances4[msg.sender] = 0; msg.sender.transfer(transferValue4); }"
    },
    {
        "vulnerableLines": "283-288",
        "vulnerabilityReason": "Similar to previous withdrawals, this function also uses send prior to resetting user balances.",
        "potentialSecurityRisk": "Allows potential for multiple withdrawals in a reentrant call scenario, draining user balances from the contract.",
        "fixedCode": "function withdrawUserBalance2() public { uint256 balance = userBalance2[msg.sender]; require(balance > 0, 'No balance to withdraw'); userBalance2[msg.sender] = 0; require(msg.sender.send(balance), 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "297-303",
        "vulnerabilityReason": "Use of call.value to send funds before resetting the balance exposes it to reentrant execution.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw more funds than they have, breaking the intended deposit and withdrawal schema.",
        "fixedCode": "function withdrawUserBalance3() public { uint256 balance = userBalance3[msg.sender]; require(balance > 0, 'No funds to withdraw'); userBalance3[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(''); require(success, 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "309-315",
        "vulnerabilityReason": "The withdrawUserBalance4 function suffers from the same reentrancy issue as other withdrawal functions when sending ether before updating balances.",
        "potentialSecurityRisk": "Attackers can exploit the gap between the balance check and the transfer, extracting more funds than allowed.",
        "fixedCode": "function withdrawUserBalance4() public { uint256 balance = userBalance4[msg.sender]; require(balance > 0, 'No funds to withdraw'); userBalance4[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(''); require(success, 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "322-328",
        "vulnerabilityReason": "The activateFunction transfers ether without updating the state variable isFunctionActive first, making this call susceptible to repeated activations.",
        "potentialSecurityRisk": "An attacker can abuse this by triggering the function multiple times before it can be disabled, leading to a potential loss of ether.",
        "fixedCode": "function activateFunction() public { require(isFunctionActive, 'Function is already active'); isFunctionActive = false; require(msg.sender.send(1 ether), 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "333-337",
        "vulnerabilityReason": "There is an unprotected withdrawal where the withdrawal size is sent before updating the balances, causing the potential for reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly invoke this function to withdraw more ether than deposited, draining user funds.",
        "fixedCode": "function withdrawFunds2(uint256 _weiToWithdraw) public { require(balances2[msg.sender] >= _weiToWithdraw, 'Insufficient balance'); balances2[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw), 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "346-352",
        "vulnerabilityReason": "This function allows the sender to receive funds before setting the active state to false, leading to the risk of reentrant calls.",
        "potentialSecurityRisk": "An attacker can activate the function again before the state is changed, leading to unauthorized ether transfers.",
        "fixedCode": "function activateFunction2() public { require(isFunctionActive2, 'Function already activated'); isFunctionActive2 = false; (bool success,) = msg.sender.call.value(1 ether)(''); require(success, 'Transfer failed'); }"
    }
]
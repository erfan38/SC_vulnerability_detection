[
    {
        "vulnerableLines": "8-12",
        "vulnerabilityReason": "The use of call to transfer jackpot_9 to lastPlayer_9 before updating the lastPlayer_9 address opens the contract to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could exploit this vulnerability to recursively invoke buyTicket_9, allowing it to withdraw funds multiple times before the state is updated.",
        "fixedCode": "function buyTicket_9() public { jackpot_9 = address(this).balance; (bool success,) = lastPlayer_9.call.value(jackpot_9)(''); if (!success) revert(); lastPlayer_9 = msg.sender; }"
    },
    {
        "vulnerableLines": "30-34",
        "vulnerabilityReason": "The function sends ether before the redeemable balance is reset, creating a vulnerability to reentrancy.",
        "potentialSecurityRisk": "An attacker could call claimReward_25 repeatedly to drain funds from the contract before their balance is cleared.",
        "fixedCode": "function claimReward_25() public { require(redeemableEther_25[msg.sender] > 0); uint transferValue_25 = redeemableEther_25[msg.sender]; redeemableEther_25[msg.sender] = 0; msg.sender.transfer(transferValue_25); }"
    },
    {
        "vulnerableLines": "46-50",
        "vulnerabilityReason": "Using send to transfer userBalance_19 without first zeroing out the balance allows reentrant calls.",
        "potentialSecurityRisk": "An attacker could drain the contract by calling withdrawBalance_19 repeatedly, as the balance is only set to zero after send executes.",
        "fixedCode": "function withdrawBalance_19() public { uint balance = userBalance_19[msg.sender]; userBalance_19[msg.sender] = 0; if (!msg.sender.send(balance)) revert(); }"
    },
    {
        "vulnerableLines": "54-56",
        "vulnerabilityReason": "The function sends funds before updating the user balance, leading to a potential reentrancy attack.",
        "potentialSecurityRisk": "Attackers can exploit this to withdraw more ether than allowed by repeatedly invoking this function.",
        "fixedCode": "function withdraw_balances_36() public { uint balance = balances_36[msg.sender]; balances_36[msg.sender] = 0; if (!msg.sender.send(balance)) revert(); }"
    },
    {
        "vulnerableLines": "62-65",
        "vulnerabilityReason": "Using send before incrementing counter_35 can create vulnerabilities by allowing for repeated calls to the function.",
        "potentialSecurityRisk": "An attacker could execute checking_35 multiple times, potentially draining ether if the balance allows for it.",
        "fixedCode": "function checking_35() public { require(counter_35 <= 5); counter_35 += 1; if (!msg.sender.send(10 ether)) revert(); }"
    },
    {
        "vulnerableLines": "70-74",
        "vulnerabilityReason": "The use of call.value before resetting the user balance can lead to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could withdraw more funds than entitled by invoking this function quickly and repeatedly.",
        "fixedCode": "function withdrawBalance_40() public { uint balance = userBalance_40[msg.sender]; userBalance_40[msg.sender] = 0; (bool success, ) = msg.sender.call.value(balance)(''); if (!success) revert(); }"
    },
    {
        "vulnerableLines": "78-82",
        "vulnerabilityReason": "Sending ether before zeroing out userBalance_33 exposes this function to potential reentrant attacks.",
        "potentialSecurityRisk": "Attackers could exploit this to withdraw funds more than once by making rapid calls to this function.",
        "fixedCode": "function withdrawBalance_33() public { uint balance = userBalance_33[msg.sender]; userBalance_33[msg.sender] = 0; (bool success, ) = msg.sender.call.value(balance)(''); if (!success) revert(); }"
    },
    {
        "vulnerableLines": "89-92",
        "vulnerabilityReason": "The function allows sending ether without updating the state variable callcount_27 until after the call, risking reentrant calls.",
        "potentialSecurityRisk": "Attackers could drain funds by repeatedly calling userbalances_27 within a single transaction.",
        "fixedCode": "function userbalances_27() public { require(callcount_27); callcount_27 = false; if (!msg.sender.send(1 ether)) revert(); }"
    },
    {
        "vulnerableLines": "105-109",
        "vulnerabilityReason": "Sending ether before marking callcount_13 can allow reentrant attacks, making it vulnerable.",
        "potentialSecurityRisk": "Attackers could exploit this to withdraw ether multiple times before the controlling state variable changes.",
        "fixedCode": "function userbalances_13() public { require(callcount_13); callcount_13 = false; (bool success, ) = msg.sender.call.value(1 ether)(''); if (!success) revert(); }"
    },
    {
        "vulnerableLines": "98-100",
        "vulnerabilityReason": "The function sends ether to a user without resetting their balance first, leading to potential reentrancy.",
        "potentialSecurityRisk": "This can allow attackers to withdraw excess amounts before balances are decremented, compromising contract funds.",
        "fixedCode": "function withdrawFunds_31(uint256 _weiToWithdraw) public { require(balances_31[msg.sender] >= _weiToWithdraw); balances_31[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "117-122",
        "vulnerabilityReason": "The function utilizes call.value to transfer user balance before setting it to zero, allowing reentrancy.",
        "potentialSecurityRisk": "A malicious contract can exploit this to repeatedly call the withdraw function and drain the user's balance before it is reset.",
        "fixedCode": "function withdrawBalance_26() public { uint256 balance = userBalance_26[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (!success) { revert(); } userBalance_26[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "128-134",
        "vulnerabilityReason": "The function sends ether to the user before updating the callcount_20 variable, risking reentrant calls.",
        "potentialSecurityRisk": "An attacker may repeatedly call this function to receive more ether than intended, draining funds.",
        "fixedCode": "function userbalances_20() public { require(callcount_20); callcount_20 = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "149-154",
        "vulnerabilityReason": "Ether transfer occurs before the user's redeemable balance is reset, opening a window for reentrancy.",
        "potentialSecurityRisk": "Attackers could exploit this to withdraw funds multiple times before their balance is zeroed.",
        "fixedCode": "function claimReward_32() public { require(redeemableEther_32[msg.sender] > 0); uint transferValue_32 = redeemableEther_32[msg.sender]; redeemableEther_32[msg.sender] = 0; msg.sender.transfer(transferValue_32); }"
    },
    {
        "vulnerableLines": "209-214",
        "vulnerabilityReason": "The function sends ether to the user before resetting their redeemable balance, allowing reentrancy.",
        "potentialSecurityRisk": "An attacker could take advantage of this to withdraw their funds repeatedly before the balance is updated.",
        "fixedCode": "function claimReward_4() public { require(redeemableEther_4[msg.sender] > 0); uint transferValue_4 = redeemableEther_4[msg.sender]; redeemableEther_4[msg.sender] = 0; msg.sender.transfer(transferValue_4); }"
    },
    {
        "vulnerableLines": "171-174",
        "vulnerabilityReason": "The function sends ether before deducting the user's balance, risking reentrant calls that can allow excessive withdrawals.",
        "potentialSecurityRisk": "An attacker could exploit this to drain funds from the contract by calling this function multiple times in one transaction.",
        "fixedCode": "function withdrawFunds_38(uint256 _weiToWithdraw) public { require(balances_38[msg.sender] >= _weiToWithdraw); balances_38[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "234-235",
        "vulnerabilityReason": "Transfers funds to players before updating the game state, which could lead to reentrant calls.",
        "potentialSecurityRisk": "An attacker could call this potentially bypassing limits on the amount they can withdraw responsibly.",
        "fixedCode": "for (uint i = 0; i < betList[_fixtureId].length; i++) { uint256 returnEth = (betList[_fixtureId][i].stake * betList[_fixtureId][i].odd) / 1000; if (validGameOutcome(selectedTeam, _homeDrawAway, _overUnder)) { uint256 playerBalance = returnEth; betList[_fixtureId][i].player.transfer(playerBalance); } }"
    },
    {
        "vulnerableLines": "244-250",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the counter_7, making it susceptible to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could call this function multiple times before the counter is updated, draining more ether from the contract than intended.",
        "fixedCode": "function checking_7() public { require(counter_7 <= 5); counter_7 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "260-266",
        "vulnerabilityReason": "This function uses send to transfer funds before updating the lastPlayer_23 address, thus allowing reentrant calls.",
        "potentialSecurityRisk": "A malicious actor could exploit this to repeatedly withdraw the jackpot amount before the lastPlayer_23 is updated.",
        "fixedCode": "function buyTicket_23() public { require(!(lastPlayer_23.send(jackpot_23))); lastPlayer_23 = msg.sender; jackpot_23 = address(this).balance; }"
    },
    {
        "vulnerableLines": "272-279",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the counter_14 variable, exposing it to reentrancy issues.",
        "potentialSecurityRisk": "An attacker can exploit this to withdraw more than allowed by rapidly invoking the function before the counter is incremented.",
        "fixedCode": "function checking_14() public { require(counter_14 <= 5); counter_14 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "284-290",
        "vulnerabilityReason": "The function attempts to send ether before updating the lastPlayer_30 address, enabling potential reentrant calls.",
        "potentialSecurityRisk": "This allows a malicious player to drain funds by invoking the function repeatedly before the address is updated.",
        "fixedCode": "function buyTicket_30() public { require(!(lastPlayer_30.send(jackpot_30))); lastPlayer_30 = msg.sender; jackpot_30 = address(this).balance; }"
    },
    {
        "vulnerableLines": "297-301",
        "vulnerabilityReason": "Using call.value to send funds before resetting the user balance exposes the contract to reentrancy vulnerabilities.",
        "potentialSecurityRisk": "An attacker can exploit this to deplete the contract funds more than intended by withdrawing repeatedly during the call.",
        "fixedCode": "function withdraw_balances_8() public { uint256 balance = balances_8[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) balances_8[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "303-305",
        "vulnerabilityReason": "The owner transfer function sends ether before performing any state changes, exposing it to reentrancy attacks.",
        "potentialSecurityRisk": "If the owner is a contract, it can re-enter this function, allowing it to drain funds continually from the contract.",
        "fixedCode": "function withdraw(uint256 _amount) external payable onlyOwner { require(_amount > 0 && _amount <= address(this).balance); emit Withdraw(owner, _amount); owner.transfer(_amount); }"
    },
    {
        "vulnerableLines": "309-313",
        "vulnerabilityReason": "This function sends the claimable reward without changing the state first, allowing reentrant calls to exploit the contract.",
        "potentialSecurityRisk": "An attacker could call this function repeatedly before the balance is reset, leading to unauthorized fund withdrawal.",
        "fixedCode": "function claimReward_39() public { require(redeemableEther_39[msg.sender] > 0); uint transferValue_39 = redeemableEther_39[msg.sender]; redeemableEther_39[msg.sender] = 0; msg.sender.transfer(transferValue_39); }"
    }
]
[
    {
        "vulnerableLines": "6-9",
        "vulnerabilityReason": "The function uses send to transfer funds before resetting the user's balance, which exposes it to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function to withdraw more funds than they are entitled to, draining the contract's balance.",
        "fixedCode": "function withdraw_balances_15() public { uint256 balance = balances_15[msg.sender]; require(msg.sender.send(balance)); balances_15[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "18-21",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the state variable var_balance_41, allowing potential reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this to receive more ether than allowed before the state is updated.",
        "fixedCode": "function updates_41() public { require(var_balance_41); var_balance_41 = false; require(msg.sender.send(1 ether)); }"
    },
    {
        "vulnerableLines": "32-40",
        "vulnerabilityReason": "The function allows sending ether before updating the counter_42, exposing it to potential reentrant calls.",
        "potentialSecurityRisk": "An attacker can exploit this to drain funds through successive calls to this function.",
        "fixedCode": "function checking_42() public { require(counter_42 <= 5); counter_42 += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "45-50",
        "vulnerabilityReason": "The function uses transfer to send funds before resetting the user's redeemable balance, exposing it to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker can repeatedly call this function to claim more rewards than intended, draining contract funds.",
        "fixedCode": "function claimReward_39() public { require(redeemableEther_39[msg.sender] > 0); uint256 transferValue_39 = redeemableEther_39[msg.sender]; redeemableEther_39[msg.sender] = 0; msg.sender.transfer(transferValue_39); }"
    },
    {
        "vulnerableLines": "53-56",
        "vulnerabilityReason": "Using send to transfer funds before resetting the balance can lead to reentrancy issues.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw more funds by calling the function multiple times.",
        "fixedCode": "function withdraw_balances_36() public { uint256 balance = balances_36[msg.sender]; require(msg.sender.send(balance)); balances_36[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "66-70",
        "vulnerabilityReason": "The function sends ether before updating the lastPlayer_2 address, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "Malicious users can exploit this to withdraw more than they are entitled to by re-entering the function.",
        "fixedCode": "function buyTicket_2() public { require(!(lastPlayer_2.send(jackpot_2))); lastPlayer_2 = msg.sender; jackpot_2 = address(this).balance; }"
    },
    {
        "vulnerableLines": "78-81",
        "vulnerabilityReason": "The use of call.value before deducting the user's balance allows for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker can repeatedly invoke the function before the balance is updated, siphoning off funds.",
        "fixedCode": "function withdrawFunds_17(uint256 _weiToWithdraw) public { require(balances_17[msg.sender] >= _weiToWithdraw); balances_17[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "98-102",
        "vulnerabilityReason": "This function uses call.value to send ether before updating the user's balance, which can lead to reentrancy problems.",
        "potentialSecurityRisk": "Attackers can exploit this vulnerability to withdraw more funds than allowable, drenching the contract.",
        "fixedCode": "function withdrawFunds_3(uint256 _weiToWithdraw) public { require(balances_3[msg.sender] >= _weiToWithdraw); balances_3[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "108-110",
        "vulnerabilityReason": "The function sends ether to lastPlayer_9 before updating state, exposing it to reentrant calls.",
        "potentialSecurityRisk": "Attackers could drain the contract by invoking the function multiple times within a single transaction.",
        "fixedCode": "function buyTicket_9() public { require(!(lastPlayer_9.send(jackpot_9))); lastPlayer_9 = msg.sender; jackpot_9 = address(this).balance; }"
    },
    {
        "vulnerableLines": "116-120",
        "vulnerabilityReason": "The function allows sending funds before resetting the user's balance, which could encourage reentrancy.",
        "potentialSecurityRisk": "This could allow attackers to drain the contract of funds by invoking it multiple times before their balance is reset.",
        "fixedCode": "function claimReward_25() public { require(redeemableEther_25[msg.sender] > 0); uint256 transferValue_25 = redeemableEther_25[msg.sender]; redeemableEther_25[msg.sender] = 0; msg.sender.transfer(transferValue_25); }"
    },
    {
        "vulnerableLines": "123-129",
        "vulnerabilityReason": "The function sends ether to the user before resetting the user's balance, exposing it to reentrancy.",
        "potentialSecurityRisk": "An attacker can exploit this to call the function multiple times, draining the contract of funds before the user's balance is updated.",
        "fixedCode": "function withdrawBalance_19() public { uint256 balance = userBalance_19[msg.sender]; require(msg.sender.send(balance)); userBalance_19[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "131-137",
        "vulnerabilityReason": "The function uses call.value to send ether before resetting the user's balance, enabling reentrancy attacks.",
        "potentialSecurityRisk": "An attacker can exploit this to withdraw more funds than they own by calling the function again during the send process.",
        "fixedCode": "function withdrawBalance_26() public { uint256 balance = userBalance_26[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) userBalance_26[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "140-146",
        "vulnerabilityReason": "The function sends ether to the user before changing the state variable, allowing for potential reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly invoke this function, draining funds as the variable is checked after the send.",
        "fixedCode": "function updates_20() public { require(var_balance_20); var_balance_20 = false; require(msg.sender.send(1 ether)); }"
    },
    {
        "vulnerableLines": "194-201",
        "vulnerabilityReason": "The function sends ether before updating the counter variable, vulnerable to reentrant calls.",
        "potentialSecurityRisk": "An attacker can call this function multiple times to exploit the contract, receiving more ether than expected.",
        "fixedCode": "function checking_28() public { require(counter_28 <= 5); counter_28 += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "203-210",
        "vulnerabilityReason": "Ether is sent to the user before changing the contract state, risking reentrancy.",
        "potentialSecurityRisk": "This allows attackers to exploit the contract, withdrawing more ether than allowed during reentrant calls.",
        "fixedCode": "function updates_34() public { require(var_balance_34); var_balance_34 = false; require(msg.sender.send(1 ether)); }"
    },
    {
        "vulnerableLines": "212-219",
        "vulnerabilityReason": "The function sends ether before updating the counter condition, leading to a reentrancy vulnerability.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function, draining the contract's ether balance.",
        "fixedCode": "function checking_21() public { require(counter_21 <= 5); counter_21 += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "221-226",
        "vulnerabilityReason": "The function directly sends ether before updating the user's balance, which is a potential reentrant attack vector.",
        "potentialSecurityRisk": "This design is exploitable, allowing an attacker to drain the contract by withdrawing more than they possess.",
        "fixedCode": "function withdrawFunds_10(uint256 _weiToWithdraw) public { require(balances_10[msg.sender] >= _weiToWithdraw); balances_10[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "229-232",
        "vulnerabilityReason": "The call to transfer funds occurs before resetting the user's balance, allowing for reentrancy.",
        "potentialSecurityRisk": "Attackers could exploit this to repeatedly call the function, claiming more funds than their balance allows.",
        "fixedCode": "function withdraw_balances_21() public { uint256 balance = balances_21[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) balances_21[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "235-241",
        "vulnerabilityReason": "The function sends funds to the user before resetting their balance, making it open to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could drain the contract's funds by calling this multiple times before the balance is updated.",
        "fixedCode": "function withdrawBalance_12() public { uint256 balance = userBalance_12[msg.sender]; require(msg.sender.send(balance)); userBalance_12[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "244-248",
        "vulnerabilityReason": "The function uses transfer to send ether before resetting the redeemable balance, allowing for reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this to repeatedly claim rewards, draining the contract's balance.",
        "fixedCode": "function claimReward_11() public { require(redeemableEther_11[msg.sender] > 0); uint transferValue_11 = redeemableEther_11[msg.sender]; redeemableEther_11[msg.sender] = 0; msg.sender.transfer(transferValue_11); }"
    },
    {
        "vulnerableLines": "253-257",
        "vulnerabilityReason": "This function uses call.value before resetting the user's balance, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker could withdraw funds multiple times before their balance is reset, draining the contract.",
        "fixedCode": "function withdraw_balances_1() public { uint256 balance = balances_1[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) balances_1[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "260-266",
        "vulnerabilityReason": "The function sends ether before updating the counter, allowing for reentrancy.",
        "potentialSecurityRisk": "An attacker can repeatedly call this function before the counter is updated, receiving more ether.",
        "fixedCode": "function checking_35() public { require(counter_35 <= 5); counter_35 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "269-275",
        "vulnerabilityReason": "The function sends funds without updating the user's balance first, leading to potential reentrancy risks.",
        "potentialSecurityRisk": "An attacker can repeatedly call this function, draining the contract of funds before balance is updated.",
        "fixedCode": "function withdrawBalance_40() public { uint256 balance = userBalance_40[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) userBalance_40[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "278-284",
        "vulnerabilityReason": "This function also sends funds before resetting the user balance, creating a reentrancy risk.",
        "potentialSecurityRisk": "Similar to previous cases, attackers could exploit this to drain funds from the contract.",
        "fixedCode": "function withdrawBalance_33() public { uint256 balance = userBalance_33[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) userBalance_33[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "288-293",
        "vulnerabilityReason": "The function sends ether before updating the state variable, potentially allowing reentrancy.",
        "potentialSecurityRisk": "This could lead to attackers receiving ether multiple times during a single transaction.",
        "fixedCode": "function updates_27() public { require(var_balance_27); var_balance_27 = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "296-301",
        "vulnerabilityReason": "Sending funds without updating the user's balance creates vulnerability to reentrancy.",
        "potentialSecurityRisk": "Repeated calls could enable an attacker to withdraw more funds than permitted.",
        "fixedCode": "function withdrawFunds_31(uint256 _weiToWithdraw) public { require(balances_31[msg.sender] >= _weiToWithdraw); balances_31[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "304-310",
        "vulnerabilityReason": "The call to send funds is done without resetting state variables, leading to reentrancy risk.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw funds multiple times before the state is updated.",
        "fixedCode": "function updates_13() public { require(var_balance_13); var_balance_13 = false; (bool success,) = msg.sender.call.value(1 ether)(''); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "347-351",
        "vulnerabilityReason": "The function sends funds to the user before resetting their withdrawable balance, risking reentrancy.",
        "potentialSecurityRisk": "Users could exploit this to keep withdrawing funds repeatedly, depleting the contract's balance.",
        "fixedCode": "function claimReward_32() public { require(redeemableEther_32[msg.sender] > 0); uint transferValue_32 = redeemableEther_32[msg.sender]; redeemableEther_32[msg.sender] = 0; msg.sender.transfer(transferValue_32); }"
    },
    {
        "vulnerableLines": "362-366",
        "vulnerabilityReason": "This function uses the send method to transfer ether before updating the user balance, allowing for reentrant calls.",
        "potentialSecurityRisk": "An attacker could exploit this to call withdrawFunds_38 multiple times before their balance is deducted, draining the contract's funds.",
        "fixedCode": "function withdrawFunds_38(uint256 _weiToWithdraw) public { require(balances_38[msg.sender] >= _weiToWithdraw); balances_38[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "383-386",
        "vulnerabilityReason": "The claimReward_4 function sends ether to the user before resetting their redeemable ether balance, allowing for reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function to siphon off ether by exploiting reentrancy during the transfer.",
        "fixedCode": "function claimReward_4() public { require(redeemableEther_4[msg.sender] > 0); uint transferValue_4 = redeemableEther_4[msg.sender]; redeemableEther_4[msg.sender] = 0; msg.sender.transfer(transferValue_4); }"
    },
    {
        "vulnerableLines": "417-421",
        "vulnerabilityReason": "This function uses send to transfer ether to the user before updating the counter, which can lead to reentrancy.",
        "potentialSecurityRisk": "An attacker might exploit this to call the function multiple times, receiving ether more than intended, and wiping the contract balance.",
        "fixedCode": "function checking_7() public { require(counter_7 <= 5); counter_7 += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "439-443",
        "vulnerabilityReason": "This function sends the jackpot amount before updating the lastPlayer_23 variable, allowing for potential reentrancy.",
        "potentialSecurityRisk": "A malicious contract could repeatedly call this function, claiming multiple rewards before the state is updated.",
        "fixedCode": "function buyTicket_23() public { require(!(lastPlayer_23.send(jackpot_23))); lastPlayer_23 = msg.sender; jackpot_23 = address(this).balance; }"
    },
    {
        "vulnerableLines": "463-469",
        "vulnerabilityReason": "This function performs a send operation before updating the counter, exposing it to reentrancy vulnerabilities.",
        "potentialSecurityRisk": "An attacker can exploit this to continually call checking_14, draining the contract by exploiting the gap between balance deductions.",
        "fixedCode": "function checking_14() public { require(counter_14 <= 5); counter_14 += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "490-496",
        "vulnerabilityReason": "The function uses send to transfer funds before updating the lastPlayer_30 address, allowing a potential reentrant call to occur.",
        "potentialSecurityRisk": "A malicious contract could exploit this vulnerability to withdraw more funds than intended before the state is updated.",
        "fixedCode": "function buyTicket_30() public { address previousPlayer = lastPlayer_30; require(previousPlayer.send(jackpot_30)); lastPlayer_30 = msg.sender; jackpot_30 = address(this).balance; }"
    },
    {
        "vulnerableLines": "530-531",
        "vulnerabilityReason": "The function sends funds to p.recipient before updating `p.executed`, which allows for reentrancy if the recipient is a smart contract.",
        "potentialSecurityRisk": "An attacker can call back into the contract during the transfer, possibly allowing them to execute the proposal multiple times or manipulate state changes.",
        "fixedCode": "if (yea > nay) { p.executed = true; (bool success, ) = p.recipient.call.value(p.amount)(transactionBytecode); require(success); p.proposalPassed = true; } else { p.proposalPassed = false; }"
    },
    {
        "vulnerableLines": "541-545",
        "vulnerabilityReason": "The function uses call to send funds before resetting the balance, exposing it to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could reenter this function and exploit it to withdraw funds multiple times before the user's balance is set to zero.",
        "fixedCode": "function withdraw_balances_8() public { uint256 balance = balances_8[msg.sender]; require(balance > 0); (bool success,) = msg.sender.call.value(balance)(''); if (success) balances_8[msg.sender] = 0; }"
    }
]
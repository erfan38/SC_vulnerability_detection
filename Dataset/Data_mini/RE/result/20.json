[
    {
        "vulnerableLines": "8-12",
        "vulnerabilityReason": "The function uses call.value to transfer Ether to the user before setting their balance to zero.",
        "potentialSecurityRisk": "This allows an attacker to re-enter the function before the balance is updated, potentially draining the entire balance of the contract.",
        "fixedCode": "function withdraw_balancesUpdated21() public { uint256 balance = balancesUpdated21[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) { balancesUpdated21[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "15-21",
        "vulnerabilityReason": "Similar to the previous function, it transfers funds before updating the user's balance.",
        "potentialSecurityRisk": "An attacker can re-enter the function, allowing multiple withdrawals before their balance is properly updated.",
        "fixedCode": "function withdrawBalanceUpdated40() public { uint256 balance = userBalanceUpdated40[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (!success) { revert(); } userBalanceUpdated40[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "28-34",
        "vulnerabilityReason": "Funds are sent before the balance is deducted, exposing the function to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could call this function multiple times to withdraw more than they should, draining the contract.",
        "fixedCode": "function withdrawFundsUpdated17(uint256 _weiToWithdraw) public { require(balancesUpdated17[msg.sender] >= _weiToWithdraw); balancesUpdated17[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "46-51",
        "vulnerabilityReason": "Using send to transfer Ether and then setting the lastPlayerUpdated37 variable, allows reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this by invoking buyTicketUpdated37 multiple times, allowing them to withdraw more than their intended amount.",
        "fixedCode": "function buyTicketUpdated37() public { require(lastPlayerUpdated37.send(jackpotUpdated37)); lastPlayerUpdated37 = msg.sender; jackpotUpdated37 = address(this).balance; }"
    },
    {
        "vulnerableLines": "60-64",
        "vulnerabilityReason": "The function uses send to transfer user balance without resetting it first, opening it to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could drain the contract by repeatedly calling this function before their balance is updated to zero.",
        "fixedCode": "function withdrawBalanceUpdated12() public { uint256 balance = userBalanceUpdated12[msg.sender]; require(msg.sender.send(balance)); userBalanceUpdated12[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "68-74",
        "vulnerabilityReason": "Here again, a call.value transfer occurs before updating the user's balance, allowing a reentrancy exploit.",
        "potentialSecurityRisk": "This can lead to an attacker withdrawing more funds than allowed if they re-enter before the balance is reset.",
        "fixedCode": "function withdrawBalanceUpdated33() public { uint256 balance = userBalanceUpdated33[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); require(success); userBalanceUpdated33[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "89-93",
        "vulnerabilityReason": "Similar to previous withdrawals, a transfer occurs before deducting the user's balance.",
        "potentialSecurityRisk": "This allows an attacker to exploit the reentrancy vulnerability, draining the contract's funds.",
        "fixedCode": "function withdrawFundsUpdated3(uint256 _weiToWithdraw) public { require(balancesUpdated3[msg.sender] >= _weiToWithdraw); balancesUpdated3[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "121-127",
        "vulnerabilityReason": "The function uses call to transfer funds before updating the lastPlayerUpdated9 address, allowing for reentrancy.",
        "potentialSecurityRisk": "A malicious contract could repeatedly claim the jackpot before the last player address is updated, draining funds.",
        "fixedCode": "function buyTicketUpdated9() public { lastPlayerUpdated9 = msg.sender; jackpotUpdated9 = address(this).balance; (bool success,) = lastPlayerUpdated9.call.value(jackpotUpdated9)(''); if (!success) revert(); }"
    },
    {
        "vulnerableLines": "138-142",
        "vulnerabilityReason": "The function sends ether to the caller before resetting the redeemableEtherUpdated25 balance, making it susceptible to reentrancy.",
        "potentialSecurityRisk": "An attacker could call this function multiple times before the balance is set to zero, draining all of the contract's funds.",
        "fixedCode": "function claimRewardUpdated25() public { require(redeemableEtherUpdated25[msg.sender] > 0); uint transferValueUpdated25 = redeemableEtherUpdated25[msg.sender]; redeemableEtherUpdated25[msg.sender] = 0; msg.sender.transfer(transferValueUpdated25); }"
    },
    {
        "vulnerableLines": "153-157",
        "vulnerabilityReason": "Sending ether occurs before resetting the redeemableEtherUpdated11 balance, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw repeatedly and drain the contract before the balance is updated.",
        "fixedCode": "function claimRewardUpdated11() public { require(redeemableEtherUpdated11[msg.sender] > 0); uint transferValueUpdated11 = redeemableEtherUpdated11[msg.sender]; redeemableEtherUpdated11[msg.sender] = 0; msg.sender.transfer(transferValueUpdated11); }"
    },
    {
        "vulnerableLines": "161-165",
        "vulnerabilityReason": "Using call to transfer funds prior to updating the user's balance, allowing a reentrant call to occur.",
        "potentialSecurityRisk": "An attacker can drain funds from the contract by re-entering the function before the balance is updated.",
        "fixedCode": "function withdraw_balancesUpdated1() public { uint balance = balancesUpdated1[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) balancesUpdated1[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "170-173",
        "vulnerabilityReason": "The use of send to transfer funds occurs before updating the not_calledActive41 state, allowing reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this function to receive multiple transfers before the flag is set to false.",
        "fixedCode": "function checkActive41() public { require(not_calledActive41); not_calledActive41 = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "177-182",
        "vulnerabilityReason": "The send invocation happens before updating the counterUpdated42, allowing for potential reentrancy.",
        "potentialSecurityRisk": "Attackers can exploit this to drain ether multiple times in a single transaction, breaching intended limits.",
        "fixedCode": "function callmeUpdated42() public { require(counterUpdated42 <= 5); counterUpdated42 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "186-192",
        "vulnerabilityReason": "Using send to transfer funds before updating the not_calledActive27 variable allows for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could manipulate the contract to receive funds multiple times by re-entering before setting the flag.",
        "fixedCode": "function checkActive27() public { require(not_calledActive27); not_calledActive27 = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "196-200",
        "vulnerabilityReason": "Funds are sent using send to the user prior to balancing the user balance, which facilitates reentrancy.",
        "potentialSecurityRisk": "An attacker could withdraw beyond their balance by re-entering the function multiple times before balance updates.",
        "fixedCode": "function withdrawFundsUpdated31(uint256 _weiToWithdraw) public { require(balancesUpdated31[msg.sender] >= _weiToWithdraw); balancesUpdated31[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "203-209",
        "vulnerabilityReason": "Using call to send funds before modifying the not_calledActive13 flag exposes it to reentrancy attacks.",
        "potentialSecurityRisk": "This could allow malicious actors to receive multiple transfers in one go, jeopardizing contract funds.",
        "fixedCode": "function checkActive13() public { require(not_calledActive13); not_calledActive13 = false; (bool success,) = msg.sender.call.value(1 ether)(''); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "231-235",
        "vulnerabilityReason": "The send function is used to transfer user balances before updating their respective balance, leading to a potential reentrancy vulnerability.",
        "potentialSecurityRisk": "Exploiting this could allow users to drain the contract's ether through repeated calls to this function.",
        "fixedCode": "function withdrawBalanceUpdated19() public { uint balance = userBalanceUpdated19[msg.sender]; require(msg.sender.send(balance)); userBalanceUpdated19[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "240-245",
        "vulnerabilityReason": "The function uses call to send ether to msg.sender before updating the user balance, allowing for potential reentrant calls.",
        "potentialSecurityRisk": "Attackers could perform a reentrant call to the withdraw function, leading to multiple withdrawals without proper state updates, draining the contract's balance.",
        "fixedCode": "function withdrawBalanceUpdated26() public { uint256 amount = userBalanceUpdated26[msg.sender]; (bool success,) = msg.sender.call.value(amount)(''); if (!success) { revert(); } userBalanceUpdated26[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "250-256",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the not_calledActive20 state variable, which could lead to reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this to gain multiple ether transfers before the state variable is set, allowing them to drain funds.",
        "fixedCode": "function checkActive20() public { require(not_calledActive20); not_calledActive20 = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "263-267",
        "vulnerabilityReason": "The transfer to the user occurs before the redeemable balance is reset, allowing for potential reentrancy.",
        "potentialSecurityRisk": "A malicious actor could claim rewards repeatedly while the redeemable balance has not yet been reset, draining funds.",
        "fixedCode": "function claimRewardUpdated32() public { require(redeemableEtherUpdated32[msg.sender] > 0); uint transferValueUpdated32 = redeemableEtherUpdated32[msg.sender]; redeemableEtherUpdated32[msg.sender] = 0; msg.sender.transfer(transferValueUpdated32); }"
    },
    {
        "vulnerableLines": "279-283",
        "vulnerabilityReason": "The function uses send to transfer ethers before updating the user's balance, which can allow for reentrant withdrawals.",
        "potentialSecurityRisk": "This could potentially let an attacker withdraw more than their actual balance is by calling the function multiple times before their balance is updated.",
        "fixedCode": "function withdrawFundsUpdated38(uint256 _weiToWithdraw) public { require(balancesUpdated38[msg.sender] >= _weiToWithdraw); balancesUpdated38[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "293-297",
        "vulnerabilityReason": "Similar to other reward claim functions, it sends ether before resetting the user's redeemable balance, which leads to reentrancy.",
        "potentialSecurityRisk": "An attacker can exploit this by claiming rewards without having their balance updated, potentially allowing them to withdraw more than intended.",
        "fixedCode": "function claimRewardUpdated4() public { require(redeemableEtherUpdated4[msg.sender] > 0); uint transferValueUpdated4 = redeemableEtherUpdated4[msg.sender]; redeemableEtherUpdated4[msg.sender] = 0; msg.sender.transfer(transferValueUpdated4); }"
    },
    {
        "vulnerableLines": "319-323",
        "vulnerabilityReason": "The call to send ether occurs before updating the counterUpdated7, which opens the door for potential reentrant calls.",
        "potentialSecurityRisk": "This could allow an attacker to withdraw more than intended and possibly drain the contract of its funds.",
        "fixedCode": "function callmeUpdated7() public { require(counterUpdated7 <= 5); counterUpdated7 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "342-346",
        "vulnerabilityReason": "The send function is called before the lastPlayerUpdated23 variable is updated, allowing reentrant calls to repeatedly withdraw funds.",
        "potentialSecurityRisk": "An attacker could exploit this to drain more funds than intended by repeatedly calling the buyTicketUpdated23 function.",
        "fixedCode": "function buyTicketUpdated23() public { require(!(lastPlayerUpdated23.send(jackpotUpdated23))); lastPlayerUpdated23 = msg.sender; jackpotUpdated23 = address(this).balance; }"
    },
    {
        "vulnerableLines": "353-359",
        "vulnerabilityReason": "The function allows ethers to be sent before updating the counter, allowing reentrant calls.",
        "potentialSecurityRisk": "An attacker could repeatedly invoke this function before the counter is updated, potentially receiving more ether than intended.",
        "fixedCode": "function callmeUpdated14() public { require(counterUpdated14 <= 5); counterUpdated14 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "390-397",
        "vulnerabilityReason": "The function sends jackpotUpdated2 before updating lastPlayerUpdated2, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "A malicious contract could exploit this by calling buyTicketUpdated2 multiple times, draining the jackpot balance.",
        "fixedCode": "function buyTicketUpdated2() public { require(!(lastPlayerUpdated2.send(jackpotUpdated2))); lastPlayerUpdated2 = msg.sender; jackpotUpdated2 = address(this).balance; }"
    },
    {
        "vulnerableLines": "411-418",
        "vulnerabilityReason": "Ether is sent before updating the lastPlayerUpdated30, allowing potential for a reentrant attack.",
        "potentialSecurityRisk": "Similar to the previous function, an attacker can repeatedly call this function to withdraw jackpotUpdated30 unlawfully.",
        "fixedCode": "function buyTicketUpdated30() public { require(!(lastPlayerUpdated30.send(jackpotUpdated30))); lastPlayerUpdated30 = msg.sender; jackpotUpdated30 = address(this).balance; }"
    },
    {
        "vulnerableLines": "423-428",
        "vulnerabilityReason": "The function calls for ether to be sent before the user's balance is set to zero, indicating a reentrancy risk.",
        "potentialSecurityRisk": "An attacker can exploit this to withdraw money multiple times before the balance is updated.",
        "fixedCode": "function withdraw_balancesUpdated8() public { uint256 balance = balancesUpdated8[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) balancesUpdated8[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "433-436",
        "vulnerabilityReason": "While this function is onlyOwner, the transfer can still potentially be called by a malicious contract aiming to exploit state preconditions.",
        "potentialSecurityRisk": "If the owner gets compromised, the malicious actor may be able to drain funds from the contract.",
        "fixedCode": "function withdrawFunds(address payable _to, uint256 _amount) public onlyOwner returns (bool success) { require(address(this).balance >= _amount); _to.transfer(_amount); return true; }"
    },
    {
        "vulnerableLines": "437-442",
        "vulnerabilityReason": "Similar to previous withdrawals, the user\u2019s redeemable balance is set to zero after the transfer which exposes to reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this by receiving their rewards multiple times, draining the contract balance.",
        "fixedCode": "function claimRewardUpdated39() public { require(redeemableEtherUpdated39[msg.sender] > 0); uint transferValueUpdated39 = redeemableEtherUpdated39[msg.sender]; redeemableEtherUpdated39[msg.sender] = 0; msg.sender.transfer(transferValueUpdated39); }"
    },
    {
        "vulnerableLines": "451-455",
        "vulnerabilityReason": "The use of send before updating the user balance exposes this function to reentrancy attacks.",
        "potentialSecurityRisk": "A user could withdraw their funds multiple times, emptying their balance in the contract.",
        "fixedCode": "function withdraw_balances() public { uint balance = balances[msg.sender]; if (msg.sender.send(balance)) { balances[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "463-469",
        "vulnerabilityReason": "This function allows ether to be sent before counter is updated, enabling reentrant attacks.",
        "potentialSecurityRisk": "An attacker could utilize this by repeatedly calling the function within the same transaction, drawing excess ether from the contract.",
        "fixedCode": "function calls() public { require(counter <= 5); counter += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    }
]
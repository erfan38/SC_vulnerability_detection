[
    {
        "vulnerableLines": "6-10",
        "vulnerabilityReason": "The function withdrawBalances uses call.value to transfer ether before checking the balance, allowing for reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit the reentrancy vulnerability to call this function repeatedly, draining the contract's funds before their balance is reset.",
        "fixedCode": "function withdrawBalances() public { uint256 amountToWithdraw = balancesWithdrawable[msg.sender]; require(amountToWithdraw > 0); balancesWithdrawable[msg.sender] = 0; (bool success,) = msg.sender.call.value(amountToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "13-17",
        "vulnerabilityReason": "The function withdrawUserBalance sends funds before resetting user balance, making it reentrancy vulnerable.",
        "potentialSecurityRisk": "Attackers could reenter this function to withdraw more funds than they have deposited, draining the contract's balance.",
        "fixedCode": "function withdrawUserBalance() public { uint256 amount = userBalanceWithdrawable[msg.sender]; require(amount > 0); userBalanceWithdrawable[msg.sender] = 0; require(msg.sender.send(amount)); }"
    },
    {
        "vulnerableLines": "21-25",
        "vulnerabilityReason": "The claimReward function sends funds before updating the redeemable balance, leaving it open to reentrancy.",
        "potentialSecurityRisk": "Attackers could drain funds by calling this method multiple times before the redeemable balance is adjusted.",
        "fixedCode": "function claimReward() public { uint256 amount = redeemableEtherBalances[msg.sender]; require(amount > 0); redeemableEtherBalances[msg.sender] = 0; msg.sender.transfer(amount); }"
    },
    {
        "vulnerableLines": "30-34",
        "vulnerabilityReason": "The withdrawReusableBalances function uses send to transfer funds before resetting the user's balance, creating a reentrancy issue.",
        "potentialSecurityRisk": "This allows attackers to exploit reentrancy by pulling out more funds than they are eligible for before their balance is updated.",
        "fixedCode": "function withdrawReusableBalances() public { uint256 amount = balancesWithdrawReusable[msg.sender]; require(amount > 0); balancesWithdrawReusable[msg.sender] = 0; require(msg.sender.send(amount)); }"
    },
    {
        "vulnerableLines": "46-50",
        "vulnerabilityReason": "The withdrawUserBalanceInfo function uses call.value to send ether before updating user balance, exposing it to reentrancy.",
        "potentialSecurityRisk": "An attacker could execute this function multiple times to withdraw ether improperly by exploiting its reentrancy.",
        "fixedCode": "function withdrawUserBalanceInfo() public { uint256 amount = userBalance[msg.sender]; require(amount > 0); userBalance[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(''); require(success); }"
    },
    {
        "vulnerableLines": "54-58",
        "vulnerabilityReason": "The withdrawCheckUserBalance function calls with call.value to transfer funds before changing the user's balance, creating a reentrancy risk.",
        "potentialSecurityRisk": "Possible loss of funds since an attacker could exploit this function to withdraw funds multiple times during a single transaction.",
        "fixedCode": "function withdrawCheckUserBalance() public { uint256 amount = userBalanceCheck[msg.sender]; require(amount > 0); userBalanceCheck[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(''); require(success); }"
    },
    {
        "vulnerableLines": "98-103",
        "vulnerabilityReason": "The withdrawUserFunds function uses call.value to send ether before reducing the user's balance, risking reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this vulnerability to drain funds from the contract by invoking this function multiple times.",
        "fixedCode": "function withdrawUserFunds(uint256 _weiToWithdraw) public { require(balancesUserWithdraw[msg.sender] >= _weiToWithdraw); balancesUserWithdraw[msg.sender] -= _weiToWithdraw; (bool success,)=msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "72-78",
        "vulnerabilityReason": "The callmeTwo function allows funds to be sent before updating the counter, allowing for potential reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function during the ether transfer, incrementing the counter improperly and draining more funds.",
        "fixedCode": "function callmeTwo() public { require(counterTwo <= 5); counterTwo += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "86-90",
        "vulnerabilityReason": "The buyTicket function sends ether to lastPlayer before updating the lastPlayer address, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "Attackers could use reentrancy to continuously withdraw more funds than intended during a token purchase.",
        "fixedCode": "function buyTicket() public { require(jackpot > 0); require(!(lastPlayer.send(jackpot))); lastPlayer = msg.sender; jackpot = address(this).balance; }"
    },
    {
        "vulnerableLines": "127-134",
        "vulnerabilityReason": "The function uses send to transfer the jackpot amount before updating the lastPlayerCheck variable, which makes it vulnerable to reentrancy.",
        "potentialSecurityRisk": "A malicious actor could repeatedly call this function to drain the jackpot amount before the state change is made.",
        "fixedCode": "function buyTicketCheck() public { lastPlayerCheck = msg.sender; require(lastPlayerCheck.send(jackpotCheck)); jackpotCheck = address(this).balance; }"
    },
    {
        "vulnerableLines": "140-146",
        "vulnerabilityReason": "Using call.value to send ether before deducting the user's balance allows reentrancy because the user can call withdrawUserFundsCheck again before their balance is updated.",
        "potentialSecurityRisk": "An attacker could continuously withdraw funds beyond their entitlement by reentering this function before the balance is updated.",
        "fixedCode": "function withdrawUserFundsCheck(uint256 _weiToWithdraw) public { require(balancesUserCheck[msg.sender] >= _weiToWithdraw); balancesUserCheck[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "152-160",
        "vulnerabilityReason": "The function transfers funds before updating the lastPlayerTransfer variable, leading to potential reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this function to repeatedly withdraw funds by calling it multiple times in quick succession.",
        "fixedCode": "function buyTicketTransfer() public { lastPlayerTransfer = msg.sender; (bool success,) = lastPlayerTransfer.call.value(jackpotTransfer)(''); if (!success) revert(); jackpotTransfer = address(this).balance; }"
    },
    {
        "vulnerableLines": "166-172",
        "vulnerabilityReason": "The transfer of rewards occurs before resetting the user's redeemable balance, which exposes the function to a reentrant call.",
        "potentialSecurityRisk": "An attacker could claim rewards multiple times if they can invoke this function again during the transfer.",
        "fixedCode": "function claimRewardTransfer() public { require(redeemableEtherBalancesTransfer[msg.sender] > 0); uint transferValueTransfer = redeemableEtherBalancesTransfer[msg.sender]; redeemableEtherBalancesTransfer[msg.sender] = 0; msg.sender.transfer(transferValueTransfer); }"
    },
    {
        "vulnerableLines": "178-184",
        "vulnerabilityReason": "The call to send occurs before resetting the user's balance, which makes it vulnerable to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could exploit this to drain funds by withdrawing multiple times before the user's balance is reset.",
        "fixedCode": "function withdrawUserBalanceTransfer() public { uint256 balance = userBalanceTransfer[msg.sender]; require(msg.sender.send(balance)); userBalanceTransfer[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "190-197",
        "vulnerabilityReason": "Using call.value to send funds before resetting the user's balance exposes it to reentrancy.",
        "potentialSecurityRisk": "Attackers can repeatedly withdraw funds before their balance is updated, leading to losses for the contract.",
        "fixedCode": "function withdrawUserBalanceWithdrawal() public { uint256 balance = userBalanceWithdrawal[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); require(success); userBalanceWithdrawal[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "203-210",
        "vulnerabilityReason": "The function sends ether before updating the notCalled variable, allowing for reentrant calls during the send operation.",
        "potentialSecurityRisk": "This can allow an attacker to call this function multiple times to drain funds, defeating the purpose of the notCalled check.",
        "fixedCode": "function resetCalled() public { require(notCalled); notCalled = false; require(msg.sender.send(1 ether)); }"
    },
    {
        "vulnerableLines": "218-224",
        "vulnerabilityReason": "Transferring funds occurs before the redeemable balance is reset, exposing the function to reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly claim rewards before their balance is set to zero, leading to financial loss for the contract.",
        "fixedCode": "function claimRewardCheck() public { require(redeemableEtherBalancesCheck[msg.sender] > 0); uint transferValueCheck = redeemableEtherBalancesCheck[msg.sender]; redeemableEtherBalancesCheck[msg.sender] = 0; msg.sender.transfer(transferValueCheck); }"
    },
    {
        "vulnerableLines": "232-237",
        "vulnerabilityReason": "Sending ether before updating the user's balance allows for reentrant calls which could exploit the contract for financial gain.",
        "potentialSecurityRisk": "Attackers could quickly invoke this function multiple times to withdraw more funds than they are allowed to.",
        "fixedCode": "function withdrawUserFundsCheck(uint256 _weiToWithdraw) public { require(balancesUserWithdrawCheck[msg.sender] >= _weiToWithdraw); balancesUserWithdrawCheck[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "245-249",
        "vulnerabilityReason": "The function uses transfer to send ether before resetting the user's redeemable ether balance, which makes it susceptible to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could exploit this by calling claimRewardStop repeatedly before the balance is set to zero, draining the contract of its ether.",
        "fixedCode": "function claimRewardStop() public { require(redeemableEtherBalancesStop[msg.sender] > 0); uint transferValueStop = redeemableEtherBalancesStop[msg.sender]; redeemableEtherBalancesStop[msg.sender] = 0; msg.sender.transfer(transferValueStop); }"
    },
    {
        "vulnerableLines": "258-263",
        "vulnerabilityReason": "Uses send to transfer ether before updating the counterUser limit, which can be exploited in reentrancy.",
        "potentialSecurityRisk": "This vulnerability allows an attacker to call this function repeatedly to obtain more funds than intended, resulting in financial loss for the contract.",
        "fixedCode": "function callmeUser() public { require(counterUser <= 5); counterUser += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "270-274",
        "vulnerabilityReason": "Using call.value to send funds prior to resetting the user's account balance enables reentrant calls.",
        "potentialSecurityRisk": "An attacker can take advantage of this to withdraw more funds than they are entitled to by re-invoking the withdrawal function.",
        "fixedCode": "function withdrawAccountBalances() public { uint256 balance = balancesAccount[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) balancesAccount[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "277-282",
        "vulnerabilityReason": "The function sends ether before updating notCalledAccount, making it susceptible to reentrancy.",
        "potentialSecurityRisk": "An attacker could reset this function through reentrant calls while receiving ether, compromising contract integrity.",
        "fixedCode": "function resetAccountCalled() public { require(notCalledAccount); notCalledAccount = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "287-292",
        "vulnerabilityReason": "Sending ether to the user occurs before updating the notCalledMaster state variable, which opens the function to reentrancy.",
        "potentialSecurityRisk": "An attacker can exploit this to withdraw multiple times, draining the contract of its funds by triggering reentrant behavior.",
        "fixedCode": "function resetMasterCalled() public { require(notCalledMaster); notCalledMaster = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "296-300",
        "vulnerabilityReason": "The function sends ether to msg.sender before decreasing the user balance, leading to a reentrancy vulnerability.",
        "potentialSecurityRisk": "Attacks may result in users siphoning off more funds than they rightfully should be able to access.",
        "fixedCode": "function withdrawFundsAccountNew(uint256 _weiToWithdraw) public { require(balancesAccountNew[msg.sender] >= _weiToWithdraw); balancesAccountNew[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "303-308",
        "vulnerabilityReason": "Ether transfers occur before updating notCalledUpdate, making the function vulnerable to reentrant calls.",
        "potentialSecurityRisk": "An attacker could execute reentrant calls that exploit this to drain ether from the contract multiple times before state change.",
        "fixedCode": "function resetUpdateCalled() public { require(notCalledUpdate); notCalledUpdate = false; (bool success,) = msg.sender.call.value(1 ether)(''); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "319-323",
        "vulnerabilityReason": "The function sends funds before updating lastPlayerAccount which can lead to reentrancy vulnerabilities.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function to withdraw funds before the lastPlayerAccount variable is updated.",
        "fixedCode": "function buyTicketAccount() public { require(!(lastPlayerAccount.send(jackpotAccount))); lastPlayerAccount = msg.sender; jackpotAccount = address(this).balance; }"
    },
    {
        "vulnerableLines": "331-336",
        "vulnerabilityReason": "The function transfers ether before updating counterAccount, which exposes it to potential reentrant attacks.",
        "potentialSecurityRisk": "This may allow attackers to exploit the gap for multiple fund withdrawals beyond their limits, compromising contract funds.",
        "fixedCode": "function callmeAccount() public { require(counterAccount <= 5); counterAccount += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "350-354",
        "vulnerabilityReason": "Using send to transfer funds before updating lastPlayerAccountUpdate can lead to reentrancy issues.",
        "potentialSecurityRisk": "An attacker may exploit this to withdraw funds multiple times while the state remains unchanged during the process.",
        "fixedCode": "function buyTicketAccountUpdate() public { require(!(lastPlayerAccountUpdate.send(jackpotAccountUpdate))); lastPlayerAccountUpdate = msg.sender; jackpotAccountUpdate = address(this).balance; }"
    },
    {
        "vulnerableLines": "371-375",
        "vulnerabilityReason": "The function uses call.value to transfer funds to the user before updating the user's withdrawal balance, which exposes it to reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this reentrancy to repeatedly call this function and deplete the contract's funds by withdrawing more than they are entitled to.",
        "fixedCode": "function withdrawBalancesAccount() public { uint256 amountToWithdraw = balancesAccountWithdrawal[msg.sender]; (bool success,) = msg.sender.call.value(amountToWithdraw)(''); if (success) { balancesAccountWithdrawal[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "387-391",
        "vulnerabilityReason": "The claimRewardDelete function transfers ether to the user before setting the user's redeemable balance to zero, which is vulnerable to reentrancy.",
        "potentialSecurityRisk": "A malicious user could call this function recursively, incrementally draining the contract's funds by claiming rewards multiple times before their balance is reset.",
        "fixedCode": "function claimRewardDelete() public { require(redeemableEtherBalancesDelete[msg.sender] > 0); uint transferValueDelete = redeemableEtherBalancesDelete[msg.sender]; redeemableEtherBalancesDelete[msg.sender] = 0; msg.sender.transfer(transferValueDelete); }"
    }
]
[
    {
        "vulnerableLines": "5-10",
        "vulnerabilityReason": "The function uses send to transfer ether to the caller before updating the state variable isNotCalledPauseStatus.",
        "potentialSecurityRisk": "An attacker could call this function multiple times in a single transaction, exploiting the gap to obtain more ether than intended.",
        "fixedCode": "function pause() public { require(isNotCalledPauseStatus); isNotCalledPauseStatus = false; require(msg.sender.send(1 ether)); }"
    },
    {
        "vulnerableLines": "14-17",
        "vulnerabilityReason": "The ether is sent to the caller before deducting the user's balance from the contract.",
        "potentialSecurityRisk": "An attacker can exploit this to repeatedly withdraw funds before their balance is reduced, draining the contract's funds.",
        "fixedCode": "function withdrawFunds(uint256 _weiToWithdraw) public { require(balances[msg.sender] >= _weiToWithdraw); balances[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "21-27",
        "vulnerabilityReason": "The call to send ether is made before setting the isNotCalledApproval flag to false, allowing for reentrant calls.",
        "potentialSecurityRisk": "An attacker could re-enter this function and initiate multiple transfers, increasing the balance without resetting status.",
        "fixedCode": "function approve() public { require(isNotCalledApproval); isNotCalledApproval = false; (bool success,) = msg.sender.call.value(1 ether)(''); require(success); }"
    },
    {
        "vulnerableLines": "33-36",
        "vulnerabilityReason": "Ether is sent to the user before resetting their redeemable ether balance, allowing for reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function to siphon all of their rewards without correctly updating their balance.",
        "fixedCode": "function claimReward() public { require(redeemableEther[msg.sender] > 0); uint transferValue = redeemableEther[msg.sender]; redeemableEther[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "40-44",
        "vulnerabilityReason": "Using send to transfer the user's balance before resetting it to zero enables reentrancy attacks.",
        "potentialSecurityRisk": "This can lead to unauthorized withdrawals, draining the funds of the contract before balances are correctly updated.",
        "fixedCode": "function withdrawBalance() public { uint256 amount = userBalances[msg.sender]; require(msg.sender.send(amount)); userBalances[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "48-53",
        "vulnerabilityReason": "Ether is sent before the user balance is updated, making this function vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker could drain ether by calling this function continuously before the user's balance is reset.",
        "fixedCode": "function withdrawBalanceSecondary() public { uint256 amount = userBalanceSecondary[msg.sender]; (bool success,) = msg.sender.call.value(amount)(''); require(success); userBalanceSecondary[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "57-62",
        "vulnerabilityReason": "The pauseFunction sends ether before updating isNotCalledPause and is vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this function to repeatedly receive ether, especially if they have a fallback function.",
        "fixedCode": "function pauseFunction() public { require(isNotCalledPause); isNotCalledPause = false; require(msg.sender.send(1 ether)); }"
    },
    {
        "vulnerableLines": "66-70",
        "vulnerabilityReason": "Similar to previous functions, ether is sent before updating the redeemable balance, allowing for reentrant exploitation.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw rewards continuously beyond their entitlement.",
        "fixedCode": "function claimRewardSecondary() public { require(redeemableEtherSecondary[msg.sender] > 0); uint transferValueSecondary = redeemableEtherSecondary[msg.sender]; redeemableEtherSecondary[msg.sender] = 0; msg.sender.transfer(transferValueSecondary); }"
    },
    {
        "vulnerableLines": "74-77",
        "vulnerabilityReason": "Ether is sent to the user before their balance is deducted, enabling reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could make multiple calls to withdraw ether before the contract is updated, draining funds.",
        "fixedCode": "function withdrawFundsSecondary(uint256 _weiToWithdraw) public { require(balancesSecondary[msg.sender] >= _weiToWithdraw); balancesSecondary[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "81-85",
        "vulnerabilityReason": "The redeemable ether balance is set to zero only after transferring the funds, exposing it to reentrancy.",
        "potentialSecurityRisk": "This allows malicious actors to claim their rewards multiple times before balance updates, draining the contract's reserves.",
        "fixedCode": "function claimRewardThird() public { require(redeemableEtherThird[msg.sender] > 0); uint transferValueThird = redeemableEtherThird[msg.sender]; redeemableEtherThird[msg.sender] = 0; msg.sender.transfer(transferValueThird); }"
    },
    {
        "vulnerableLines": "90-95",
        "vulnerabilityReason": "The function allows for ether to be sent before the function counter is incremented, allowing an attacker to call it repeatedly and receive more ether than intended.",
        "potentialSecurityRisk": "This enables attackers to drain funds from the contract by exploiting the function call through multiple transactions.",
        "fixedCode": "function functionCallLimit() public { require(functionCounter <= 5); functionCounter += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "121-126",
        "vulnerabilityReason": "The function sends funds to lastPlayer before updating lastPlayer's address, allowing reentrant calls to exploit the function.",
        "potentialSecurityRisk": "A malicious user could call this function multiple times, draining the contract of its funds by receiving multiple jackpots before the address is updated.",
        "fixedCode": "function buyTicket() public { uint transferAmount = jackpot; lastPlayer = msg.sender; jackpot = address(this).balance; require(lastPlayer.send(transferAmount)); }"
    },
    {
        "vulnerableLines": "148-155",
        "vulnerabilityReason": "The function allows sending ether without updating the counter before the send operation, which can lead to reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this to call back into the function multiple times before the counter limit is enforced, withdrawing more than allowed.",
        "fixedCode": "function functionCall() public { require(counterFunction <= 5); counterFunction += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "180-187",
        "vulnerabilityReason": "Similar to buyTicket, funds are sent before updating lastPlayerSecond, risking reentrancy during the call.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly accessing this function before the lastPlayerSecond is updated.",
        "fixedCode": "function buyTicketSecond() public { uint transferAmount = jackpotSecond; lastPlayerSecond = msg.sender; jackpotSecond = address(this).balance; require(lastPlayerSecond.send(transferAmount)); }"
    },
    {
        "vulnerableLines": "197-201",
        "vulnerabilityReason": "The function uses call.value to send funds before resetting the user's balance, making it vulnerable to reentrancy attacks.",
        "potentialSecurityRisk": "A reentrant call could lead to multiple withdrawals before the user's balance is reset, allowing for draining the contract's funds.",
        "fixedCode": "function withdrawUserBalance() public { uint balance = userBalances[msg.sender]; require(msg.sender.call.value(balance)('')); userBalances[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "210-214",
        "vulnerabilityReason": "This function sends ether before resetting the user's redeemable balance, allowing for potential reentrancy.",
        "potentialSecurityRisk": "An attacker could continuously claim rewards, pulling funds from the contract due to not having the redeemable balance updated before the transfer.",
        "fixedCode": "function claimRewardMapping() public { require(redeemableEtherSecondaryMapping[msg.sender] > 0); uint transferValueMapping = redeemableEtherSecondaryMapping[msg.sender]; redeemableEtherSecondaryMapping[msg.sender] = 0; msg.sender.transfer(transferValueMapping); }"
    },
    {
        "vulnerableLines": "225-228",
        "vulnerabilityReason": "Using send to transfer funds before resetting the balance, which allows for multiple calls to this function, leading to a reentrancy vulnerability.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw more funds than available by calling the function repeatedly within the same transaction.",
        "fixedCode": "function withdrawSecondaryMapping() public { uint amount = balancesSecondaryMapping[msg.sender]; require(msg.sender.send(amount)); balancesSecondaryMapping[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "234-241",
        "vulnerabilityReason": "The function allows a send to execute without first updating the counter, enabling repeated withdrawals before the limit is checked.",
        "potentialSecurityRisk": "An attacker may exploit this to drain more ether than intended by using a reentrant call to the function.",
        "fixedCode": "function functionCallSecond() public { require(counterFunctionSecond <= 5); counterFunctionSecond += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "249-254",
        "vulnerabilityReason": "The function uses call.value to transfer funds before resetting the user's balance, making it susceptible to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could manipulate the state and repeatedly withdraw funds before the balance is updated, draining the contract's ethers.",
        "fixedCode": "function withdrawUserBalanceMapping() public { uint256 balance = userBalanceMapping[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) { userBalanceMapping[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "262-267",
        "vulnerabilityReason": "This function also utilizes call.value to transfer funds before deducting the user's balance, creating a reentrancy vulnerability.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function to withdraw more funds than their balance allows, compromising the contract's integrity.",
        "fixedCode": "function withdrawUserBalanceMappingSecondary() public { uint256 balance = userBalanceMappingSecondary[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) { userBalanceMappingSecondary[msg.sender] = 0; } }"
    }
]
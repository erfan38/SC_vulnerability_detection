[
    {
        "vulnerableLines": "9-14",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the callcount, enabling a reentrant call to be performed before the state variable is changed.",
        "potentialSecurityRisk": "An attacker could exploit this to repeatedly call the function and obtain ether, draining the contract's funds.",
        "fixedCode": "function userbalances_20() public { require(callcount_20); callcount_20 = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "18-23",
        "vulnerabilityReason": "The function transfers funds using transfer before resetting the user's redeemable balance, allowing for potential reentrancy.",
        "potentialSecurityRisk": "This enables an attacker to claim rewards multiple times before the redeemable balance is reset, draining contract funds.",
        "fixedCode": "function claimReward_32() public { require(redeemableEther_32[msg.sender] > 0); uint transferValue_32 = redeemableEther_32[msg.sender]; redeemableEther_32[msg.sender] = 0; msg.sender.transfer(transferValue_32); }"
    },
    {
        "vulnerableLines": "26-30",
        "vulnerabilityReason": "Like previous functions, this one also transfers ether using send before updating the user's balance, opening it to reentrancy.",
        "potentialSecurityRisk": "An attacker can exploit this to withdraw funds multiple times, potentially draining the contract of ether.",
        "fixedCode": "function withdrawFunds_38(uint256 _weiToWithdraw) public { require(balances_38[msg.sender] >= _weiToWithdraw); balances_38[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "34-38",
        "vulnerabilityReason": "The transfer occurs before the redeemable balance is updated, which is a common vulnerability in reentrancy attacks.",
        "potentialSecurityRisk": "Allowing multiple claims before the redeemable balance resets can lead to significant ether loss for the contract.",
        "fixedCode": "function claimReward_4() public { require(redeemableEther_4[msg.sender] > 0); uint transferValue_4 = redeemableEther_4[msg.sender]; redeemableEther_4[msg.sender] = 0; msg.sender.transfer(transferValue_4); }"
    },
    {
        "vulnerableLines": "42-47",
        "vulnerabilityReason": "This function's send operation can trigger a fallback function in its recipient before the counter is updated, leading to a reentrant call.",
        "potentialSecurityRisk": "A malicious actor could invoke this function multiple times before the counter state is updated, increasing their gains undesirably.",
        "fixedCode": "function callcheck_7() public { require(counter_7 <= 5); counter_7 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "52-57",
        "vulnerabilityReason": "Using send to transfer funds before updating the lastPlayer allows for a reentrant call, which can lead to lost funds.",
        "potentialSecurityRisk": "An attacker can make multiple winning claims if they can reenter the buyTicket function during execution.",
        "fixedCode": "function buyTicket_23() public { jackpot_23 = address(this).balance; require(!(lastPlayer_23.send(jackpot_23))); lastPlayer_23 = msg.sender; }"
    },
    {
        "vulnerableLines": "61-66",
        "vulnerabilityReason": "The function sends ether before changing the callcount variable, making it susceptible to reentrancy.",
        "potentialSecurityRisk": "Allows potential for multiple claims by an attacker before the callcount is set to false, draining the contract.",
        "fixedCode": "function userbalances_27() public { require(callcount_27); callcount_27 = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "71-75",
        "vulnerabilityReason": "The funds are sent before the user's balance is deducted, exposing the contract to reentrancy.",
        "potentialSecurityRisk": "An attacker could withdraw more than their balance allows, resulting in a significant loss of funds to the contract.",
        "fixedCode": "function withdrawFunds_31(uint256 _weiToWithdraw) public { require(balances_31[msg.sender] >= _weiToWithdraw); balances_31[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "79-85",
        "vulnerabilityReason": "This function's use of call.value sends ether before changing the callcount, risking multiple invocations.",
        "potentialSecurityRisk": "An attacker can call this function multiple times before the state updates, draining the contract ether balance.",
        "fixedCode": "function userbalances_13() public { require(callcount_13); callcount_13 = false; (bool success,) = msg.sender.call.value(1 ether)(''); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "100-105",
        "vulnerabilityReason": "As with previous callcheck functions, this one exposes itself to reentrancy by sending funds before updating the counter.",
        "potentialSecurityRisk": "It opens the opportunity for repeated withdrawal of ether beyond the limits imposed by the count.",
        "fixedCode": "function callcheck_14() public { require(counter_14 <= 5); counter_14 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "120-125",
        "vulnerabilityReason": "The function sends funds to lastPlayer_30 before updating its state variables, allowing for potential reentrant calls.",
        "potentialSecurityRisk": "A malicious contract can call this function repeatedly before the lastPlayer_30 is updated, draining the balance associated with jackpot_30.",
        "fixedCode": "function buyTicket_30() public { lastPlayer_30 = msg.sender; jackpot_30 = address(this).balance; require(lastPlayer_30.send(jackpot_30)); }"
    },
    {
        "vulnerableLines": "132-136",
        "vulnerabilityReason": "Using call.value to transfer funds before updating the user's balance exposes the contract to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker can exploit this to withdraw multiple times before the balance is set to zero, draining the contract's funds.",
        "fixedCode": "function withdraw_balances_8() public { uint256 balance = balances_8[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) balances_8[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "144-149",
        "vulnerabilityReason": "The reward is transferred before resetting the redeemable balance which leads to reentrancy vulnerabilities.",
        "potentialSecurityRisk": "A malicious actor can keep calling this function to claim rewards before their redeemableEther_39 balance is reset, draining funds.",
        "fixedCode": "function claimReward_39() public { require(redeemableEther_39[msg.sender] > 0); uint transferValue_39 = redeemableEther_39[msg.sender]; redeemableEther_39[msg.sender] = 0; msg.sender.transfer(transferValue_39); }"
    },
    {
        "vulnerableLines": "159-162",
        "vulnerabilityReason": "Use of send to transfer funds prior to resetting the user balance leads to potential reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw funds multiple times before their balance is updated.",
        "fixedCode": "function withdraw_balances_36() public { uint256 balance = balances_36[msg.sender]; if (msg.sender.send(balance)) { balances_36[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "173-180",
        "vulnerabilityReason": "The use of send here allows for an external call that may trigger reentry before the counter is updated.",
        "potentialSecurityRisk": "An attacker can call this function several times, resulting in excessively draining the contract's funds.",
        "fixedCode": "function callcheck_35() public { require(counter_35 <= 5); counter_35 += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "190-195",
        "vulnerabilityReason": "The function calls to transfer funds without first updating state variables, exposing it to reentrancy.",
        "potentialSecurityRisk": "An attacker can keep invoking this function to withdraw more than what they are entitled to before the balance resets.",
        "fixedCode": "function withdrawBalance_40() public { uint256 balance = userBalance_40[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) userBalance_40[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "208-213",
        "vulnerabilityReason": "Calling to send ether before updating the state variable userBalance_33 allows reentrancy.",
        "potentialSecurityRisk": "This vulnerability can be exploited to drain funds by calling this function multiple times before the user's balance resets.",
        "fixedCode": "function withdrawBalance_33() public { uint256 balance = userBalance_33[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) userBalance_33[msg.sender] = 0; }"
    }
]
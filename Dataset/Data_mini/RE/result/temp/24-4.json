[
    {
        "vulnerableLines": "60-63",
        "vulnerabilityReason": "The withdrawal uses send to transfer ether before updating the user's balance, allowing potentially malicious contracts to re-enter and withdraw additional funds.",
        "potentialSecurityRisk": "An attacker could drain funds from the contract by exploiting this vulnerability, withdrawing more than their actual balance.",
        "fixedCode": "function withdrawFunds_38(uint256 _weiToWithdraw) public { require(balances_38[msg.sender] >= _weiToWithdraw); balances_38[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "67-84",
        "vulnerabilityReason": "The function transfers user funds before resetting their investment state, enabling potential reentrancy attacks.",
        "potentialSecurityRisk": "A malicious contract could call this function repeatedly, withdrawing more funds than allowed before their state is properly updated.",
        "fixedCode": "function userWithdraw() external { User storage user = userMapping[msg.sender]; if (user.currentInvestAmount > 0) { uint256 avaliableIA = user.currentInvestAmount; if (!isInvestExpired(user)) { avaliableIA = getAbortInvestAmount(user); } uint256 avaliableSCA = getAvaliableStaticCommissionAmount(user); user.staticCommissionBalance = user.staticCommissionBalance.add(avaliableSCA); user.currentInvestTime = 0; user.currentInvestAmount = 0; user.currentInvestCycle = 0; user.currentlevel = 0; user.currentStaticCommissionRatio = 0; user.currentStaticCommissionWithdrawAmount = 0; user.totalWithdrawAmount = user.totalWithdrawAmount.add(avaliableIA); totalWithdrawAmount = totalWithdrawAmount.add(avaliableIA); } if (avaliableIA > 0) { msg.sender.transfer(avaliableIA); } }"
    },
    {
        "vulnerableLines": "87-91",
        "vulnerabilityReason": "The function uses transfer to send the reward balance before resetting it, making it vulnerable to reentrancy attacks.",
        "potentialSecurityRisk": "Attackers could use this vulnerability to withdraw rewards repeatedly, draining the contract's funds.",
        "fixedCode": "function claimReward_4() public { require(redeemableEther_4[msg.sender] > 0); uint transferValue_4 = redeemableEther_4[msg.sender]; redeemableEther_4[msg.sender] = 0; msg.sender.transfer(transferValue_4); }"
    },
    {
        "vulnerableLines": "113-113",
        "vulnerabilityReason": "The withdrawal of user commission is executed before updating the user state, leading to possible reentrancy.",
        "potentialSecurityRisk": "A malicious actor could drain user's accumulative commissions multiple times before updates take effect.",
        "fixedCode": "function userWithdrawCommission() external { User storage user = userMapping[msg.sender]; uint256 avaliableDCB = user.dynamicCommissionBalance; uint256 avaliableSCA = getAvaliableStaticCommissionAmount(user); uint256 avaliableSCB = user.staticCommissionBalance.add(avaliableSCA); uint256 avaliableWithdrawAmount = avaliableDCB.add(avaliableSCB); if (avaliableWithdrawAmount >= ONE_ETH.div(10)) { user.staticCommissionBalance = 0; user.dynamicCommissionBalance = 0; user.currentStaticCommissionWithdrawAmount = user.currentStaticCommissionWithdrawAmount.add(avaliableSCA); user.totalStaticCommissionWithdrawAmount = user.totalStaticCommissionWithdrawAmount.add(avaliableSCB); user.totalDynamicCommissionWithdrawAmount = user.totalDynamicCommissionWithdrawAmount.add(avaliableDCB); user.totalWithdrawAmount = user.totalWithdrawAmount.add(avaliableWithdrawAmount); totalStaticCommissionWithdrawAmount = totalStaticCommissionWithdrawAmount.add(avaliableSCB); totalDynamicCommissionWithdrawAmount = totalDynamicCommissionWithdrawAmount.add(avaliableDCB); totalWithdrawAmount = totalWithdrawAmount.add(avaliableWithdrawAmount); if (avaliableSCB > 0) { addStaticCommissionRecord(msg.sender, now, avaliableSCB); } if (avaliableWithdrawAmount > 0) { msg.sender.transfer(avaliableWithdrawAmount); } } }"
    }
]
[
    {
        "vulnerableLines": "8-13",
        "vulnerabilityReason": "The function uses call.value to transfer the user's balance before resetting it, allowing for reentrant calls.",
        "potentialSecurityRisk": "An attacker could exploit this to repeatedly withdraw funds before the balance is zeroed out, draining the contract's ether.",
        "fixedCode": "function withdraw_balances_8() public { uint256 balance = balances_8[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) { balances_8[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "19-25",
        "vulnerabilityReason": "The transfer to the user happens before their redeemable balance is reset, which is prone to reentrancy.",
        "potentialSecurityRisk": "A malicious contract could drain the contract's balance by repeatedly claiming rewards without waiting for the state to update.",
        "fixedCode": "function claimReward_39() public { require(redeemableEther_39[msg.sender] > 0); uint transferValue_39 = redeemableEther_39[msg.sender]; redeemableEther_39[msg.sender] = 0; msg.sender.transfer(transferValue_39); }"
    },
    {
        "vulnerableLines": "36-40",
        "vulnerabilityReason": "The use of send to transfer funds before resetting the user's balance exposes the function to reentrancy.",
        "potentialSecurityRisk": "An attacker can leverage this to withdraw multiple times, resulting in unintended consequences for contract funds.",
        "fixedCode": "function withdraw_balances_36() public { uint256 balance = balances_36[msg.sender]; if (msg.sender.send(balance)) { balances_36[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "46-51",
        "vulnerabilityReason": "The function sends ether before updating the counter, allowing for multiple calls within one transaction.",
        "potentialSecurityRisk": "Attackers could exploit this to withdraw more funds than intended, bypassing the intended limit.",
        "fixedCode": "function updates_35() public { require(counter_35 <= 5); counter_35 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "60-67",
        "vulnerabilityReason": "The use of send to transfer funds occurs before the player's address is updated, making it vulnerable to reentrant calls.",
        "potentialSecurityRisk": "A malicious contract can exploit this to repeatedly withdraw funds, draining the jackpot balance.",
        "fixedCode": "function buyTicket_37() public { lastPlayer_37 = msg.sender; require(lastPlayer_37.send(jackpot_37)); jackpot_37 = address(this).balance; }"
    },
    {
        "vulnerableLines": "70-74",
        "vulnerabilityReason": "This function sends funds before deducting the user's balance, allowing a reentrant attacker to withdraw multiple times.",
        "potentialSecurityRisk": "An attacker could exploit this to harvest more ether than they should receive based on their balance.",
        "fixedCode": "function withdrawFunds_3(uint256 _weiToWithdraw) public { require(balances_3[msg.sender] >= _weiToWithdraw); balances_3[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "93-99",
        "vulnerabilityReason": "The use of call.value allows for potential reentrancy as the balance is reset after the transfer is initiated.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before their balance is updated, siphoning funds from the contract.",
        "fixedCode": "function withdrawBalance_40() public { uint256 balance = userBalance_40[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) { userBalance_40[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "105-111",
        "vulnerabilityReason": "Similar to the previous instances, resetting the user balance after sending funds enables reentrant attacks.",
        "potentialSecurityRisk": "A malicious actor could exploit this design flaw to drain funds through multiple withdrawals before the balance gets reset.",
        "fixedCode": "function withdrawBalance_33() public { uint256 balance = userBalance_33[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) { userBalance_33[msg.sender] = 0; } }"
    }
]
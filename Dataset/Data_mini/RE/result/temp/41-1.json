[
    {
        "vulnerableLines": "1-6",
        "vulnerabilityReason": "The function sends funds to lastPlayer_30 before updating its state variables, allowing for potential reentrant calls.",
        "potentialSecurityRisk": "A malicious contract can call this function repeatedly before the lastPlayer_30 is updated, draining the balance associated with jackpot_30.",
        "fixedCode": "function buyTicket_30() public { lastPlayer_30 = msg.sender; jackpot_30 = address(this).balance; require(lastPlayer_30.send(jackpot_30)); }"
    },
    {
        "vulnerableLines": "13-17",
        "vulnerabilityReason": "Using call.value to transfer funds before updating the user's balance exposes the contract to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker can exploit this to withdraw multiple times before the balance is set to zero, draining the contract's funds.",
        "fixedCode": "function withdraw_balances_8() public { uint256 balance = balances_8[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) balances_8[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "25-30",
        "vulnerabilityReason": "The reward is transferred before resetting the redeemable balance which leads to reentrancy vulnerabilities.",
        "potentialSecurityRisk": "A malicious actor can keep calling this function to claim rewards before their redeemableEther_39 balance is reset, draining funds.",
        "fixedCode": "function claimReward_39() public { require(redeemableEther_39[msg.sender] > 0); uint transferValue_39 = redeemableEther_39[msg.sender]; redeemableEther_39[msg.sender] = 0; msg.sender.transfer(transferValue_39); }"
    },
    {
        "vulnerableLines": "40-43",
        "vulnerabilityReason": "Use of send to transfer funds prior to resetting the user balance leads to potential reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw funds multiple times before their balance is updated.",
        "fixedCode": "function withdraw_balances_36() public { uint256 balance = balances_36[msg.sender]; if (msg.sender.send(balance)) { balances_36[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "54-61",
        "vulnerabilityReason": "The use of send here allows for an external call that may trigger reentry before the counter is updated.",
        "potentialSecurityRisk": "An attacker can call this function several times, resulting in excessively draining the contract's funds.",
        "fixedCode": "function callcheck_35() public { require(counter_35 <= 5); counter_35 += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "71-76",
        "vulnerabilityReason": "The function calls to transfer funds without first updating state variables, exposing it to reentrancy.",
        "potentialSecurityRisk": "An attacker can keep invoking this function to withdraw more than what they are entitled to before the balance resets.",
        "fixedCode": "function withdrawBalance_40() public { uint256 balance = userBalance_40[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) userBalance_40[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "89-94",
        "vulnerabilityReason": "Calling to send ether before updating the state variable userBalance_33 allows reentrancy.",
        "potentialSecurityRisk": "This vulnerability can be exploited to drain funds by calling this function multiple times before the user's balance resets.",
        "fixedCode": "function withdrawBalance_33() public { uint256 balance = userBalance_33[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) userBalance_33[msg.sender] = 0; }"
    }
]
[
    {
        "vulnerableLines": "46-50",
        "vulnerabilityReason": "The function uses send to transfer ether before resetting the balance, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could exploit this to call it again before the balance is set to zero, allowing repeated withdrawals.",
        "fixedCode": "function withdrawBalance() public { uint balance = userBalance[msg.sender]; require(balance > 0); userBalance[msg.sender] = 0; require(msg.sender.send(balance)); }"
    },
    {
        "vulnerableLines": "58-63",
        "vulnerabilityReason": "The function sends ether before updating the state variable notCalled, which can be exploited by reentrancy.",
        "potentialSecurityRisk": "An attacker can exploit the gap to call multiple times and receive more ether than intended.",
        "fixedCode": "function firstCall() public { require(notCalled); notCalled = false; require(msg.sender.send(1 ether)); }"
    },
    {
        "vulnerableLines": "75-79",
        "vulnerabilityReason": "The function transfers funds before setting the redeemableEther balance to zero, exposing it to reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function, draining more funds than they are entitled to.",
        "fixedCode": "function claimReward() public { require(redeemableEther[msg.sender] > 0); uint transferValue = redeemableEther[msg.sender]; redeemableEther[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "91-95",
        "vulnerabilityReason": "This function uses transfer to send ether before updating redeemableEtherClaim to zero, susceptible to reentrancy.",
        "potentialSecurityRisk": "An attacker could withdraw repeatedly by invoking this function before the state is updated.",
        "fixedCode": "function claimRewardToken() public { require(redeemableEtherClaim[msg.sender] > 0); uint transferValueToken = redeemableEtherClaim[msg.sender]; redeemableEtherClaim[msg.sender] = 0; msg.sender.transfer(transferValueToken); }"
    },
    {
        "vulnerableLines": "100-102",
        "vulnerabilityReason": "Using call.value allows for a reentrant call during the fund transfer, leaking funds before balance is updated.",
        "potentialSecurityRisk": "An attacker could use reentrancy to withdraw more tokens than their actual balance permits.",
        "fixedCode": "function withdrawBalanceTokens() public { uint balance = balances[msg.sender]; require(balance > 0); balances[msg.sender] = 0; require(msg.sender.send(balance)); }"
    },
    {
        "vulnerableLines": "106-111",
        "vulnerabilityReason": "The function permits a send operation before updating the state variable notCalledSecond, susceptible to reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this to receive more ether than intended during repeated calls.",
        "fixedCode": "function secondCall() public { require(notCalledSecond); notCalledSecond = false; require(msg.sender.send(1 ether)); }"
    },
    {
        "vulnerableLines": "115-120",
        "vulnerabilityReason": "This function allows sending ether before updating counterCallFirst, leading to a reentrancy vulnerability.",
        "potentialSecurityRisk": "An attacker may exploit this to continuously execute the function, draining funds beyond the allowable limit.",
        "fixedCode": "function firstCounterCall() public { require(counterCallFirst <= 5); counterCallFirst += 1; require(msg.sender.send(10 ether)); }"
    }
]
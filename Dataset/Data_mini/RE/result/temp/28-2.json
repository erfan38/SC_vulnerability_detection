[
    {
        "vulnerableLines": "6-13",
        "vulnerabilityReason": "The function sends ether before updating the counter, which can allow for reentrant calls to be made that circumvent the limit check.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw ether multiple times before the counter is incremented, potentially draining the contract.",
        "fixedCode": "function withdraw_14() public { require(counter_14 <= 5); counter_14 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "31-38",
        "vulnerabilityReason": "The function sends ether to the last player before updating their address, potentially allowing reentrant calls.",
        "potentialSecurityRisk": "A malicious contract could repeatedly call this function to drain ether associated with the jackpot due to the delayed state change.",
        "fixedCode": "function buyTicket_30() public { require(!(lastPlayer_30.send(jackpot_30))); lastPlayer_30 = msg.sender; jackpot_30 = address(this).balance; }"
    },
    {
        "vulnerableLines": "46-50",
        "vulnerabilityReason": "The function uses call.value to send funds before resetting the balance, which could allow for reentrant withdrawal.",
        "potentialSecurityRisk": "An attacker could call this function repeatedly to siphon funds during the ether transfer before the balance is set to zero.",
        "fixedCode": "function withdraw_balances_8() public { uint256 balance = balances_8[msg.sender]; (bool success, ) = msg.sender.call.value(balance)(''); if (success) { balances_8[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "59-64",
        "vulnerabilityReason": "Sending ether before resetting the redeemable balance can lead to a potential reentrant attack.",
        "potentialSecurityRisk": "This allows attackers to claim rewards multiple times before their balance is updated, draining the contract's funds.",
        "fixedCode": "function claimReward_39() public { require(redeemableEther_39[msg.sender] > 0); uint transferValue_39 = redeemableEther_39[msg.sender]; redeemableEther_39[msg.sender] = 0; msg.sender.transfer(transferValue_39); }"
    },
    {
        "vulnerableLines": "86-90",
        "vulnerabilityReason": "Funds are sent prior to resetting the user balance, which can enable reentrancy.",
        "potentialSecurityRisk": "Attackers can exploit this function to withdraw more funds than they have deposited by continuously calling it.",
        "fixedCode": "function withdraw_balances_36() public { uint256 balance = balances_36[msg.sender]; if (msg.sender.send(balance)) { balances_36[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "113-120",
        "vulnerabilityReason": "The function uses call.value to transfer funds before setting the user balance to zero, allowing for repeated calls.",
        "potentialSecurityRisk": "A malicious user could drain the contract's ether by exploiting this gap before the balance is reset.",
        "fixedCode": "function withdrawBalance_40() public { uint256 balance = userBalance_40[msg.sender]; (bool success, ) = msg.sender.call.value(balance)(''); if (success) { userBalance_40[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "98-105",
        "vulnerabilityReason": "The withdrawal allows for sending ether before updating the counter for the number of allowed withdrawals.",
        "potentialSecurityRisk": "This could lead to an attacker withdrawing ether multiple times before the counter updates, draining the contract's reserves.",
        "fixedCode": "function withdraw_35() public { require(counter_35 <= 5); counter_35 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    }
]
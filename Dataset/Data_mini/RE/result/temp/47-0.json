[
    {
        "vulnerableLines": "6-10",
        "vulnerabilityReason": "The function calls msg.sender with a value transfer before updating the balance, allowing for a reentrancy attack.",
        "potentialSecurityRisk": "An attacker can repeatedly call this function to withdraw exceeding amounts before the balance is updated.",
        "fixedCode": "function withdrawFunds_17(uint256 _weiToWithdraw) public { require(balances_17[msg.sender] >= _weiToWithdraw); balances_17[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "15-20",
        "vulnerabilityReason": "The function transfers ether to lastPlayer_37 before setting the new lastPlayer_37 address, which may allow reentrant calls.",
        "potentialSecurityRisk": "A malicious contract could take control of the flow and repeatedly call this function to drain funds.",
        "fixedCode": "function buyTicket_37() public { lastPlayer_37 = msg.sender; require(lastPlayer_37.send(jackpot_37)); jackpot_37 = address(this).balance; }"
    },
    {
        "vulnerableLines": "23-27",
        "vulnerabilityReason": "Similar to withdrawFunds_17, this function allows a reentrancy attack by transferring before updating user balances.",
        "potentialSecurityRisk": "An attacker could exploit this vulnerability to drain more funds than they have in their balance.",
        "fixedCode": "function withdrawFunds_3(uint256 _weiToWithdraw) public { require(balances_3[msg.sender] >= _weiToWithdraw); balances_3[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "34-39",
        "vulnerabilityReason": "Again, transferring funds before updating lastPlayer_9 allows a reentrant call enabling attackers to exploit the function.",
        "potentialSecurityRisk": "This could permit a malicious actor to repeatedly withdraw jackpots leading to excessive fund withdrawal.",
        "fixedCode": "function buyTicket_9() public { lastPlayer_9 = msg.sender; (bool success,) = lastPlayer_9.call.value(jackpot_9)(''); require(success); jackpot_9 = address(this).balance; }"
    },
    {
        "vulnerableLines": "43-48",
        "vulnerabilityReason": "Transferring funds to the user before resetting their redeemable balance opens this function to reentrancy.",
        "potentialSecurityRisk": "It can allow an attacker to call this method recursively, receiving more payouts than they are entitled to.",
        "fixedCode": "function claimReward_25() public { require(redeemableEther_25[msg.sender] > 0); uint transferValue_25 = redeemableEther_25[msg.sender]; redeemableEther_25[msg.sender] = 0; msg.sender.transfer(transferValue_25); }"
    },
    {
        "vulnerableLines": "51-55",
        "vulnerabilityReason": "The function calls msg.sender.send before resetting the associated user balance, creating a reentrancy risk.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw more funds than available, draining the contract of its balance.",
        "fixedCode": "function withdrawBalance_19() public { uint amount = userBalance_19[msg.sender]; require(amount > 0); userBalance_19[msg.sender] = 0; require(msg.sender.send(amount)); }"
    },
    {
        "vulnerableLines": "82-85",
        "vulnerabilityReason": "This function tries to transfer the amount before deducting the balance from the user's balance, leading to reentrancy.",
        "potentialSecurityRisk": "Attackers can exploit this to withdraw more ETH than they have, pulling funds out of the contract.",
        "fixedCode": "function withdrawFunds_24(uint256 _weiToWithdraw) public { require(balances_24[msg.sender] >= _weiToWithdraw); balances_24[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "90-94",
        "vulnerabilityReason": "Here, funds are sent before updating userBalance_5, causing a reentrancy issue.",
        "potentialSecurityRisk": "An exploiter can repeatedly call this to receive more ether than they're entitled to from the contract.",
        "fixedCode": "function withdrawBalance_5() public { uint amount = userBalance_5[msg.sender]; require(amount > 0); userBalance_5[msg.sender] = 0; require(msg.sender.send(amount)); }"
    },
    {
        "vulnerableLines": "98-100",
        "vulnerabilityReason": "The funds are sent before the balance is reset, leading to potential reentrant withdrawals.",
        "potentialSecurityRisk": "A malicious entity could drain the balance by creating multiple successive calls before their balance resets.",
        "fixedCode": "function withdraw_balances_15() public { uint amount = balances_15[msg.sender]; require(amount > 0); balances_15[msg.sender] = 0; require(msg.sender.send(amount)); }"
    },
    {
        "vulnerableLines": "104-110",
        "vulnerabilityReason": "The function sends ether without updating counters first, which invites reentrancy attacks.",
        "potentialSecurityRisk": "Reentrancy can lead to limit bypasses and exploit, allowing attackers to drain significant funds.",
        "fixedCode": "function callcheck_28() public { require(counter_28 <= 5); counter_28 += 1; require(msg.sender.send(10 ether)); }"
    }
]
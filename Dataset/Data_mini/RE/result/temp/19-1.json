[
    {
        "vulnerableLines": "1-5",
        "vulnerabilityReason": "The selfdestruct function can be called by the owner to destroy the contract, but it can lead to loss of funds without careful validation of the contract state before destruction.",
        "potentialSecurityRisk": "If not properly controlled, malicious actors could exploit this to destroy the contract and drain funds before the users are able to withdraw their balances.",
        "fixedCode": "function clearFunds() onlyOwner public { require(address(this).balance == 0, 'Funds must be withdrawn before selfdestruct'); selfdestruct(msg.sender); }"
    },
    {
        "vulnerableLines": "6-13",
        "vulnerabilityReason": "Using call to send ether allows for reentrancy as the state is updated after ether transfer, which can be exploited by malicious contracts.",
        "potentialSecurityRisk": "A reentrant attack could lead to unauthorized withdrawals, allowing the attacker to drain all funds from the contract.",
        "fixedCode": "function buyTicket3() public { lastPlayer3 = msg.sender; jackpotAmount3 = address(this).balance; (bool success,) = lastPlayer3.call.value(jackpotAmount3)(''); require(success, 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "19-23",
        "vulnerabilityReason": "The function transfers all contract balance to the owner before checking for any conditions, opening it up to reentrancy issues.",
        "potentialSecurityRisk": "If an external call succeeds and control returns to the function, it could lead to draining the balance before it is handled correctly.",
        "fixedCode": "function joinFlexible() onlyOwner public { uint balance = address(this).balance; require(balance > 0, 'No balance to withdraw'); msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "25-30",
        "vulnerabilityReason": "The claimReward function sends funds before updating the state variable redeemableEther, allowing for reentrant calls.",
        "potentialSecurityRisk": "An attacker can exploit this to repeatedly call claimReward, draining the contract funds before balances are updated.",
        "fixedCode": "function claimReward() public { uint transferValue = redeemableEther[msg.sender]; require(transferValue > 0, 'No reward to claim'); redeemableEther[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "31-35",
        "vulnerabilityReason": "Similar to joinFlexible, it transfers all balance without checks, allowing potential reentrancy.",
        "potentialSecurityRisk": "Draining of funds could occur if the contract balance is not correctly managed prior to this execution.",
        "fixedCode": "function joinFixed() onlyOwner public { uint balance = address(this).balance; require(balance > 0, 'No balance to withdraw'); msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "43-47",
        "vulnerabilityReason": "The transfer of funds happens without checks after self-destruct or removing users' balance, leading to possible reentrancy risks.",
        "potentialSecurityRisk": "It may allow funds to be lost or drained completely before a balance review occurs.",
        "fixedCode": "function distributeBonus() onlyOwner public { uint balance = address(this).balance; require(balance > 0, 'No balance to distribute'); msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "49-54",
        "vulnerabilityReason": "The use of call.value sends funds before resetting user balances, opening them up to reentrancy.",
        "potentialSecurityRisk": "Reentrancy can lead to users withdrawing more than they should, draining the contract's funds.",
        "fixedCode": "function withdrawBalance5() public { uint withdrawAmount = userBalancesWithdrawable5[msg.sender]; require(withdrawAmount > 0, 'Nothing to withdraw'); userBalancesWithdrawable5[msg.sender] = 0; (bool success, ) = msg.sender.call.value(withdrawAmount)(''); require(success, 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "61-67",
        "vulnerabilityReason": "The validateOnce2 function sends funds without checking if the state variable has been updated, leading to state inconsistency.",
        "potentialSecurityRisk": "Attackers can call this function multiple times and receive more than intended funds.",
        "fixedCode": "function validateOnce2() public { require(notCalledOnce2, 'Function already called'); notCalledOnce2 = false; require(msg.sender.send(1 ether), 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "69-73",
        "vulnerabilityReason": "Similar to other owner functions that transfer funds without checks, leading to exposure to reentrancy.",
        "potentialSecurityRisk": "It could enable malicious actors to drain contract funds by exploiting this function.",
        "fixedCode": "function addBonus() onlyOwner public { uint balance = address(this).balance; require(balance > 0, 'No balance to add as bonus'); msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "81-85",
        "vulnerabilityReason": "Again, transferring all balance as part of owner functions may open vulnerabilities for reentrancy attack.",
        "potentialSecurityRisk": "This can lead to theft of funds if the contract's state isn't handled properly.",
        "fixedCode": "function staticBonusCalculation() onlyOwner public { uint balance = address(this).balance; require(balance > 0, 'No balance to withdraw'); msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "87-91",
        "vulnerabilityReason": "This function allows for potentially draining funds by sending ether before balance state is updated.",
        "potentialSecurityRisk": "An attacker could cause the withdrawFunds6 to be called many times and receive more ether than intended.",
        "fixedCode": "function withdrawFunds6(uint256 _weiToWithdraw) public { require(userBalancesWithdrawable6[msg.sender] >= _weiToWithdraw, 'Insufficient balance'); userBalancesWithdrawable6[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw), 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "92-96",
        "vulnerabilityReason": "Similar risk as other owner functions that transfer without checks on contract state leading to vulnerabilities.",
        "potentialSecurityRisk": "It can lead to draining of funds through malicious calls if not managed properly.",
        "fixedCode": "function activateBonus() onlyOwner public { uint balance = address(this).balance; require(balance > 0, 'No balance to activate bonus'); msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "98-102",
        "vulnerabilityReason": "The claimReward3 function allows for sending ether to msg.sender before updating state, which allows for reentrancy.",
        "potentialSecurityRisk": "Malicious calls can drain the funds of the contract by allowing multiple claims before state is secured.",
        "fixedCode": "function claimReward3() public { require(redeemableEther3[msg.sender] > 0, 'Nothing to claim'); uint transferValue3 = redeemableEther3[msg.sender]; redeemableEther3[msg.sender] = 0; msg.sender.transfer(transferValue3); }"
    },
    {
        "vulnerableLines": "104-108",
        "vulnerabilityReason": "Transferring all balance without checking preceding conditions risk exposing the function to attacks.",
        "potentialSecurityRisk": "Can lead to a scenario where funds are drained without controlling the state appropriately.",
        "fixedCode": "function executeBonus() onlyOwner public { uint balance = address(this).balance; require(balance > 0, 'No balance to execute bonus'); msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "110-115",
        "vulnerabilityReason": "This function uses send that fails to manage state variables before ether transfer, presenting vulnerabilities.",
        "potentialSecurityRisk": "Enables attackers to exploit the withdrawal multiple times, leading to draining of user balances.",
        "fixedCode": "function callUserCounter() public { require(userCounter2 <= 5, 'Counter limit exceeded'); userCounter2 += 1; require(msg.sender.send(10 ether), 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "117-121",
        "vulnerabilityReason": "Similar issues as previous owner functions where sending funds without appropriate checks may expose vulnerabilities.",
        "potentialSecurityRisk": "Causes potential of funds being drained simultaneously allowing unauthorized withdrawals.",
        "fixedCode": "function manageBonus() onlyOwner public { uint balance = address(this).balance; require(balance > 0, 'No balance to manage bonus'); msg.sender.transfer(balance); }"
    }
]
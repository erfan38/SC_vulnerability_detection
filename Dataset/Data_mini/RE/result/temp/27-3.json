[
    {
        "vulnerableLines": "1-43",
        "vulnerabilityReason": "The transfer function deducts the sender's balance after calling external contracts, which allows for a reentrant call before the balance is updated.",
        "potentialSecurityRisk": "A malicious contract could call the transfer function repeatedly before balances are updated, allowing the attacker to drain more tokens than they actually hold.",
        "fixedCode": "function transfer(address to, uint256 value) public returns (bool) { require(value <= _balances[msg.sender]); require(to != address(0)); uint256 tokensToTransfer = value; uint256 tokensToBurn = 0; uint256 tokensToDanPan = 0; if (value == 0) { emit Transfer(msg.sender, to, 0); return true; } _balances[msg.sender] = _balances[msg.sender].sub(value); if (!_isWhitelisted(msg.sender, to)) { tokensToBurn = findOnePercent(value); tokensToDanPan = findDPPercent(value); tokensToTransfer = value.sub(tokensToBurn).sub(tokensToDanPan); _totalSupply = _totalSupply.sub(tokensToBurn); emit Transfer(msg.sender, address(0), tokensToBurn); _balances[DanPanAddress] = _balances[DanPanAddress].add(tokensToDanPan); emit Transfer(msg.sender, DanPanAddress, tokensToDanPan); } assert(tokensToBurn.add(tokensToTransfer).add(tokensToDanPan) == value); _balances[to] = _balances[to].add(tokensToTransfer); emit Transfer(msg.sender, to, tokensToTransfer); return true; }"
    },
    {
        "vulnerableLines": "44-50",
        "vulnerabilityReason": "The claimReward function transfers ether before resetting the user's redeemable balance, allowing a potential reentrant attack.",
        "potentialSecurityRisk": "An attacker can exploit this to reenter the function after the reward transfer but before the balance reset, claiming rewards multiple times.",
        "fixedCode": "function claimReward_25() public { require(redeemableEther_25[msg.sender] > 0); uint transferValue_25 = redeemableEther_25[msg.sender]; redeemableEther_25[msg.sender] = 0; msg.sender.transfer(transferValue_25); }"
    },
    {
        "vulnerableLines": "58-62",
        "vulnerabilityReason": "Using send to transfer user's balance without updating the user's balance first invites reentrancy.",
        "potentialSecurityRisk": "An attacker can repeatedly call withdrawBalance_19 to withdraw more than intended before the balance is set to zero.",
        "fixedCode": "function withdrawBalance_19() public { uint amount = userBalance_19[msg.sender]; require(amount > 0); userBalance_19[msg.sender] = 0; require(msg.sender.send(amount)); }"
    },
    {
        "vulnerableLines": "71-77",
        "vulnerabilityReason": "The withdrawBalance_26 function uses call.value to transfer funds before resetting the user's balance.",
        "potentialSecurityRisk": "An attacker could exploit this to call the function multiple times before the balance is set to zero, draining funds.",
        "fixedCode": "function withdrawBalance_26() public { uint amount = userBalance_26[msg.sender]; require(amount > 0); userBalance_26[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(''); require(success); }"
    },
    {
        "vulnerableLines": "80-121",
        "vulnerabilityReason": "The transferFrom function calls external contracts before updating balances, allowing for a reentrance opportunity.",
        "potentialSecurityRisk": "Similar to the transfer function, an attacker can call transferFrom exploitatively to gain more tokens than held by calling this repeatedly.",
        "fixedCode": "function transferFrom(address from, address to, uint256 value) public returns (bool) { require(value <= _balances[from]); require(value <= _allowed[from][msg.sender]); require(to != address(0)); if (value == 0) { emit Transfer(from, to, 0); return true; } _balances[from] = _balances[from].sub(value); uint256 tokensToTransfer = value; uint256 tokensToBurn = 0; uint256 tokensToDanPan = 0; if (!_isWhitelisted(from, to)) { tokensToBurn = findOnePercent(value); tokensToDanPan = findDPPercent(value); tokensToTransfer = value.sub(tokensToBurn).sub(tokensToDanPan); _totalSupply = _totalSupply.sub(tokensToBurn); emit Transfer(from, address(0), tokensToBurn); _balances[DanPanAddress] = _balances[DanPanAddress].add(tokensToDanPan); emit Transfer(from, DanPanAddress, tokensToDanPan); } assert(tokensToBurn.add(tokensToTransfer).add(tokensToDanPan) == value); _balances[to] = _balances[to].add(tokensToTransfer); _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value); emit Transfer(from, to, tokensToTransfer); return true; }"
    }
]
[
    {
        "vulnerableLines": "9-14",
        "vulnerabilityReason": "The function calls send to transfer ether before updating the not_called_once invariant, opening the possibility for reentrant calls.",
        "potentialSecurityRisk": "A malicious contract could call this function repeatedly to siphon funds before the flag is updated, draining the contract.",
        "fixedCode": "function withdrawalFunction_once() public { require(not_called_once); not_called_once = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "18-23",
        "vulnerabilityReason": "The transfer occurs before the user balance is reset, creating a window for a reentrant attack.",
        "potentialSecurityRisk": "An attacker could withdraw their reward repeatedly by exploiting this vulnerability before their balance is reset.",
        "fixedCode": "function claimReward_mapping() public { require(redeemableEther_mapping[msg.sender] > 0); uint transferValue_mapping = redeemableEther_mapping[msg.sender]; redeemableEther_mapping[msg.sender] = 0; msg.sender.transfer(transferValue_mapping); }"
    },
    {
        "vulnerableLines": "26-30",
        "vulnerabilityReason": "Using send to transfer funds before deducting from the user's balance exposes this function to reentrancy.",
        "potentialSecurityRisk": "An attacker can execute this function multiple times, withdrawing more than allowed before the balance is updated.",
        "fixedCode": "function withdrawFunds_mapping (uint256 _weiToWithdraw) public { require(balances_mapping[msg.sender] >= _weiToWithdraw); balances_mapping[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "33-38",
        "vulnerabilityReason": "As with previous functions, funds are sent before resetting the redeemable balance, exposing it to reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function and withdraw more than allowed before the balance reset occurs.",
        "fixedCode": "function claimReward_mapping2() public { require(redeemableEther_mapping2[msg.sender] > 0); uint transferValue_mapping2 = redeemableEther_mapping2[msg.sender]; redeemableEther_mapping2[msg.sender] = 0; msg.sender.transfer(transferValue_mapping2); }"
    },
    {
        "vulnerableLines": "42-48",
        "vulnerabilityReason": "Sending ether occurs prior to updating the counter limit; thus, reentrancy is possible.",
        "potentialSecurityRisk": "An attacker can exploit this to bypass the call limit, draining funds from the contract multiple times.",
        "fixedCode": "function callme_limit() public { require(counter_limit <= 5); counter_limit += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "52-57",
        "vulnerabilityReason": "The send function is called before setting the lastPlayer_mapping to the new player, which can lead to reentrancy.",
        "potentialSecurityRisk": "A malicious actor could drain the jackpot repeatedly before their address is updated, benefiting from multiple withdrawals.",
        "fixedCode": "function buyTicket_mapping() public { lastPlayer_mapping = msg.sender; require(!(lastPlayer_mapping.send(jackpot_mapping))); jackpot_mapping = address(this).balance; }"
    },
    {
        "vulnerableLines": "61-66",
        "vulnerabilityReason": "As with the first withdrawal function, this one allows for reentrant calls by not updating the state before sending funds.",
        "potentialSecurityRisk": "Reentrancy could lead to loss of funds as an attacker exploits the vulnerabilities present in this sequence.",
        "fixedCode": "function withdrawalFunction_once2() public { require(not_called_once2); not_called_once2 = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "71-75",
        "vulnerabilityReason": "Again, this function allows a reentrant attack by sending funds before updating the balance.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw more ether than they have available before their balance is adjusted.",
        "fixedCode": "function withdrawFunds_mapping2 (uint256 _weiToWithdraw) public { require(balances_mapping2[msg.sender] >= _weiToWithdraw); balances_mapping2[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "79-85",
        "vulnerabilityReason": "Similar to previous withdrawal functions, it allows external calls prior to state modification, exposing it to reentrancy issues.",
        "potentialSecurityRisk": "An attacker may repeat the withdraw function, draining funds before the not_called_once3 variable is set to false.",
        "fixedCode": "function withdrawalFunction_once3() public { require(not_called_once3); not_called_once3 = false; (bool success,) = msg.sender.call.value(1 ether)(''); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "100-106",
        "vulnerabilityReason": "The use of send allows for reentrancy by sending funds before revising the counter, making repeated calls possible.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw ether multiple times unregulated by the limits imposed.",
        "fixedCode": "function callme_limit2() public { require(counter_limit2 <= 5); counter_limit2 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    }
]
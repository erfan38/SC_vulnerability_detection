[
    {
        "vulnerableLines": "34-38",
        "vulnerabilityReason": "The call to send ether occurs before the user balance is cleared, making it susceptible to reentrant calls.",
        "potentialSecurityRisk": "An attacker could call this function multiple times to withdraw more than their balance allows, draining the contract.",
        "fixedCode": "function withdrawUserBalances() public { uint256 balance = userBalancesWithdrawable[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) userBalancesWithdrawable[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "44-50",
        "vulnerabilityReason": "Ether is sent before the notCalledOnce variable is updated, allowing for potential reentrancy attacks.",
        "potentialSecurityRisk": "An attacker can exploit this to receive multiple payouts by calling the function several times before the status is set.",
        "fixedCode": "function checkOnce() public { require(notCalledOnce); notCalledOnce = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "62-68",
        "vulnerabilityReason": "The function calls send to transmit ether without updating the userCounter first, enabling reentrancy exploitation.",
        "potentialSecurityRisk": "An attacker can call this function in a reentrant manner, effectively bypassing the intended limit and draining the contract.",
        "fixedCode": "function callMe() public { require(userCounter <= 5); userCounter += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "76-80",
        "vulnerabilityReason": "The function uses send to transfer the jackpot amount before updating the lastPlayer address, allowing reentrant calls.",
        "potentialSecurityRisk": "A malicious actor could repeatedly call this function to drain funds, as the lastPlayer's address isn't updated until after the send operation.",
        "fixedCode": "function buyTicket() public { require(!(lastPlayer.send(jackpotAmount))); lastPlayer = msg.sender; jackpotAmount = address(this).balance; }"
    },
    {
        "vulnerableLines": "88-92",
        "vulnerabilityReason": "The function uses call to transfer funds to the user before updating their balance, risking reentrancy attacks.",
        "potentialSecurityRisk": "Attackers can exploit this to repeatedly withdraw funds, draining the amount they've deposited before their balance is updated.",
        "fixedCode": "function withdrawFunds2(uint256 _weiToWithdraw) public { require(userBalancesWithdrawable2[msg.sender] >= _weiToWithdraw); userBalancesWithdrawable2[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "101-105",
        "vulnerabilityReason": "Ether is sent before the lastPlayer2 variable is updated, which exposes this function to reentrancy attacks.",
        "potentialSecurityRisk": "Malicious contracts can exploit this functionality to withdraw more funds than intended in a single transaction.",
        "fixedCode": "function buyTicket2() public { require(!(lastPlayer2.send(jackpotAmount2))); lastPlayer2 = msg.sender; jackpotAmount2 = address(this).balance; }"
    },
    {
        "vulnerableLines": "115-119",
        "vulnerabilityReason": "The use of call to transfer funds before deducting the user's balance allows for reentrancy exploits.",
        "potentialSecurityRisk": "An attacker could call this function recursively, withdrawing more than their actual balance allows, draining funds from the contract.",
        "fixedCode": "function withdrawFunds3(uint256 _weiToWithdraw) public { require(userBalancesWithdrawable3[msg.sender] >= _weiToWithdraw); userBalancesWithdrawable3[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    }
]
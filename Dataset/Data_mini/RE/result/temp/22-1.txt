[
  {
    "vulnerableLines": "3-7",
    "vulnerabilityReason": "The function uses send to transfer user balance before resetting the balance, allowing reentrant calls.",
    "potentialSecurityRisk": "An attacker could exploit this to repeatedly call withdrawBalance_19 and drain funds.",
    "fixedCode": "function withdrawBalance_19() public { uint256 balance = userBalance_19[msg.sender]; require(msg.sender.send(balance)); userBalance_19[msg.sender] = 0; }"
  },
  {
    "vulnerableLines": "10-16",
    "vulnerabilityReason": "The use of call.value to send funds before resetting the user's balance can lead to reentrancy.",
    "potentialSecurityRisk": "An attacker could call withdrawBalance_26 reentrantly, draining funds from the contract.",
    "fixedCode": "function withdrawBalance_26() public { uint256 balance = userBalance_26[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) { userBalance_26[msg.sender] = 0; } }"
  },
  {
    "vulnerableLines": "19-25",
    "vulnerabilityReason": "Sending ether before updating the state variable var_balance_20 makes this function vulnerable to reentrancy.",
    "potentialSecurityRisk": "Attackers can exploit this to claim ether multiple times beyond what's intended.",
    "fixedCode": "function updates_20() public { require(var_balance_20); var_balance_20 = false; require(msg.sender.send(1 ether)); }"
  },
  {
    "vulnerableLines": "73-80",
    "vulnerabilityReason": "The function uses send to transfer ether before increasing the counter, allowing potential reentrancy.",
    "potentialSecurityRisk": "An attacker could exploit this to repeatedly drain funds from the contract.",
    "fixedCode": "function checking_28() public { require(counter_28 <= 5); counter_28 += 1; require(msg.sender.send(10 ether)); }"
  },
  {
    "vulnerableLines": "82-88",
    "vulnerabilityReason": "Similar to previous examples, sending ether before updating the variable makes this vulnerable to reentering.",
    "potentialSecurityRisk": "Attackers can manipulate this to receive more than intended funds.",
    "fixedCode": "function updates_34() public { require(var_balance_34); var_balance_34 = false; require(msg.sender.send(1 ether)); }"
  },
  {
    "vulnerableLines": "91-98",
    "vulnerabilityReason": "Sending ether before the counter increment allows potential reentrancy.");
    "potentialSecurityRisk": "This allows attackers to drain funds by calling this function multiple times.",
    "fixedCode": "function checking_21() public { require(counter_21 <= 5); counter_21 += 1; require(msg.sender.send(10 ether)); }"
  },
  {
    "vulnerableLines": "101-104",
    "vulnerabilityReason": "Fund transfers happen before the user balance is decremented, leading to reentrancy vulnerabilities.",
    "potentialSecurityRisk": "This enables attackers to exploit the ability to withdraw funds more than what they possess.",
    "fixedCode": "function withdrawFunds_10(uint256 _weiToWithdraw) public { require(balances_10[msg.sender] >= _weiToWithdraw); balances_10[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
  },
  {
    "vulnerableLines": "108-111",
    "vulnerabilityReason": "The balance is reset only after attempting to send funds, which is a typical vector for reentrancy attacks.",
    "potentialSecurityRisk": "Attackers could exploit this to withdraw more funds than they have in balance.",
    "fixedCode": "function withdraw_balances_21() public { uint256 balance = balances_21[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) { balances_21[msg.sender] = 0; } }"
  },
  {
    "vulnerableLines": "115-119",
    "vulnerabilityReason": "Using send before resetting the user balance exposes this function to reentrancy attacks.",
    "potentialSecurityRisk": "Attackers can exploit this to withdraw multiple times before their balance is updated.",
    "fixedCode": "function withdrawBalance_12() public { uint256 balance = userBalance_12[msg.sender]; require(msg.sender.send(balance)); userBalance_12[msg.sender] = 0; }"
  }
]
[
    {
        "vulnerableLines": "1-7",
        "vulnerabilityReason": "The function sends ether to msg.sender before updating the counter, allowing for reentrancy.",
        "potentialSecurityRisk": "An attacker could call this function multiple times, draining more ether than allowed before the counter is updated.",
        "fixedCode": "function callMe7() public { require(counter7 <= 5); counter7 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "10-17",
        "vulnerabilityReason": "The function uses call.value to send ether before changing the state variable notCalled13, leading to potential reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this to invoke this function multiple times, receiving more ether than intended.",
        "fixedCode": "function initializeNotCalled13() public { require(notCalled13); notCalled13 = false; (bool success,) = msg.sender.call.value(1 ether)(''); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "31-38",
        "vulnerabilityReason": "Ether is sent before updating the counter, allowing exploiters to withdraw funds multiple times.",
        "potentialSecurityRisk": "This allows attackers to potentially drain the contract of funds through repeated calls.",
        "fixedCode": "function callMe14() public { require(counter14 <= 5); counter14 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "46-52",
        "vulnerabilityReason": "Ether is sent to lastPlayerToken30 before its address is updated, allowing for reentrancy.",
        "potentialSecurityRisk": "An attacker can exploit this to withdraw tickets more than once, draining the jackpot funds.",
        "fixedCode": "function buyTicketToken30() public { require(!(lastPlayerToken30.send(jackpotToken30))); lastPlayerToken30 = msg.sender; jackpotToken30 = address(this).balance; }"
    },
    {
        "vulnerableLines": "60-64",
        "vulnerabilityReason": "Funds are sent prior to updating balancesToken8, exposing the contract to reentrancy.",
        "potentialSecurityRisk": "An attacker can exploit this feature to drain the contract by making repeated calls before the balance is reset.",
        "fixedCode": "function withdrawBalancesToken8() public { uint256 balance = balancesToken8[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) { balancesToken8[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "71-75",
        "vulnerabilityReason": "The contract sends ether before requiring that the user's redeemable balance is reset, leading to potential reentrancy.",
        "potentialSecurityRisk": "An attacker might exploit this to repeatedly claim rewards, draining the contract before the balance is updated.",
        "fixedCode": "function claimReward39() public { require(redeemableEther39[msg.sender] > 0); uint transferValue39 = redeemableEther39[msg.sender]; redeemableEther39[msg.sender] = 0; msg.sender.transfer(transferValue39); }"
    },
    {
        "vulnerableLines": "83-86",
        "vulnerabilityReason": "Sending funds to msg.sender before resetting balancesToken36 allows for reentries that can drain the contract.",
        "potentialSecurityRisk": "Attackers can exploit this by calling the withdraw function multiple times, withdrawing more than what is allowed.",
        "fixedCode": "function withdrawBalancesToken36() public { uint256 balance = balancesToken36[msg.sender]; if (msg.sender.send(balance)) { balancesToken36[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "94-101",
        "vulnerabilityReason": "The function sends ether before updating the counter, facilitating multiple withdrawals from a single attack.",
        "potentialSecurityRisk": "This could allow an attacker to drain contract funds by exploiting the vulnerability in a single transaction.",
        "fixedCode": "function callMe35() public { require(counter35 <= 5); counter35 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    }
]
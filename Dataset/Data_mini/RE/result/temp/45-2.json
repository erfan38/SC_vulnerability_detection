[
    {
        "vulnerableLines": "1-5",
        "vulnerabilityReason": "The function transfers the reward amount before resetting the user's redeemable balance, making it susceptible to reentrancy.",
        "potentialSecurityRisk": "An attacker could call this function multiple times before the redeemable balance is reset, leading to unauthorized withdrawals.",
        "fixedCode": "function claimReward3() public { require(redeemableEtherForClaim3[msg.sender] > 0); uint transferValue3 = redeemableEtherForClaim3[msg.sender]; redeemableEtherForClaim3[msg.sender] = 0; msg.sender.transfer(transferValue3); }"
    },
    {
        "vulnerableLines": "14-18",
        "vulnerabilityReason": "The function transfers funds using send before updating the user's withdrawal balance, introducing the possibility of reentrant calls.",
        "potentialSecurityRisk": "An attacker may exploit this to withdraw more funds than they should, draining the contract balances.",
        "fixedCode": "function withdrawFunds9(uint256 _weiToWithdraw) public { require(balancesForWithdrawal9[msg.sender] >= _weiToWithdraw); balancesForWithdrawal9[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "29-33",
        "vulnerabilityReason": "This function sends ether before resetting the user's balance which can lead to reentrancy exploits.",
        "potentialSecurityRisk": "An attacker can call this function multiple times before the redeemable balance is set to zero, resulting in excessive withdrawals.",
        "fixedCode": "function claimReward4() public { require(redeemableEtherForClaim4[msg.sender] > 0); uint transferValue4 = redeemableEtherForClaim4[msg.sender]; redeemableEtherForClaim4[msg.sender] = 0; msg.sender.transfer(transferValue4); }"
    },
    {
        "vulnerableLines": "45-50",
        "vulnerabilityReason": "Using send before incrementing the counter allows for the potential of reentrancy attacks during the ether transfer.",
        "potentialSecurityRisk": "An attacker could drain more than allowed through quick successive calls before the counter is updated.",
        "fixedCode": "function incrementCounter3() public { require(counter3 <= 5); counter3 += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "78-82",
        "vulnerabilityReason": "Ether is sent to the lastPlayer before updating the last player address, allowing for reentrant calls.",
        "potentialSecurityRisk": "A malicious player could exploit this function to drain funds by invoking it multiple times during the ether transfer process.",
        "fixedCode": "function buyTicket4() public { require(!(lastPlayer4.send(jackpot4))); lastPlayer4 = msg.sender; jackpot4 = address(this).balance; }"
    },
    {
        "vulnerableLines": "88-93",
        "vulnerabilityReason": "The function sends ether before updating the counter, allowing for reentrant exploits.",
        "potentialSecurityRisk": "An attacker could manipulate the repeated calls to withdraw more ether than intended, draining the contract's funds.",
        "fixedCode": "function incrementCounter4() public { require(counter4 <= 5); counter4 += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "97-101",
        "vulnerabilityReason": "The function checks the paid status after sending ether, thus permitting reentrance opportunities.",
        "potentialSecurityRisk": "A malicious player could have multiple attempts to receive more funds before their paid status is updated.",
        "fixedCode": "function collectPlayerWinnings() public byPlayer inState(State.PLAYERS_WIN) { require(guesses[result].players[msg.sender] == PaidStatus.NOT_PAID); guesses[result].players[msg.sender] = PaidStatus.PAID; msg.sender.transfer(splitJackpot); }"
    },
    {
        "vulnerableLines": "105-109",
        "vulnerabilityReason": "Ether is sent to the last player without resetting their address first, allowing for a reentrant exploit.",
        "potentialSecurityRisk": "Malicious users could drain the funds by withdrawing repeatedly during the ether transfer.",
        "fixedCode": "function buyTicket5() public { require(!(lastPlayer5.send(jackpot5))); lastPlayer5 = msg.sender; jackpot5 = address(this).balance; }"
    }
]
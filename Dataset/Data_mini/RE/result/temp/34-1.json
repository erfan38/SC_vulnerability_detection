[
    {
        "vulnerableLines": "1-5",
        "vulnerabilityReason": "Ether is sent to the caller before the balance is decremented, which allows for a reentrant attack.",
        "potentialSecurityRisk": "An attacker could call this function recursively to drain more funds than intended before their balance is updated.",
        "fixedCode": "function withdrawFunds_10(uint256 _weiToWithdraw) public { require(balances_10[msg.sender] >= _weiToWithdraw); balances_10[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "10-13",
        "vulnerabilityReason": "Using call.value to send funds and resetting the balance in a single transaction allows for reentrancy.",
        "potentialSecurityRisk": "An attacker can exploit this to continually call this function, receiving funds each time before their balance is reset.",
        "fixedCode": "function withdraw_balances_21() public { uint256 balance = balances_21[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) balances_21[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "17-21",
        "vulnerabilityReason": "Ether is sent to the user before their balance is zeroed out, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw funds repeatedly before their balance decreases.",
        "fixedCode": "function withdrawBalance_12() public { uint256 balance = userBalance_12[msg.sender]; require(msg.sender.send(balance)); userBalance_12[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "34-38",
        "vulnerabilityReason": "Sending ether before setting the user's balance to zero encourages reentrant attacks.",
        "potentialSecurityRisk": "Attackers can exploit this method to drain the contract of its funds by making multiple calls during the same transaction.",
        "fixedCode": "function withdraw_balances_1() public { uint256 balance = balances_1[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) balances_1[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "41-46",
        "vulnerabilityReason": "Sending ether before updating the callcount allows reentrancy, enabling malicious actors to drain funds.",
        "potentialSecurityRisk": "This vulnerability permits an attacker to call this function repeatedly and siphon off funds before state changes.",
        "fixedCode": "function userbalances_41() public { require(callcount_41); callcount_41 = false; require(msg.sender.send(1 ether)); }"
    },
    {
        "vulnerableLines": "50-55",
        "vulnerabilityReason": "The balance is decremented after the ether is sent, making this vulnerable to a reentrancy exploit.",
        "potentialSecurityRisk": "This allows attackers to exploit the function to withdraw funds multiple times during a single call, which could drain resources.",
        "fixedCode": "function callcheck_42() public { require(counter_42 <= 5); counter_42 += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "91-96",
        "vulnerabilityReason": "Using call.value to send funds before updating the user's balance exposes the function to potential reentrancy.",
        "potentialSecurityRisk": "A malicious user can exploit this to withdraw ether repeatedly before their balance is reduced, draining the contract.",
        "fixedCode": "function withdrawFunds_3(uint256 _weiToWithdraw) public { require(balances_3[msg.sender] >= _weiToWithdraw); balances_3[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "76-79",
        "vulnerabilityReason": "Sending ether before updating the lastPlayer variable allows for potential reentrant execution.",
        "potentialSecurityRisk": "An attacker could keep draining the jackpot by calling this function repeatedly, as the lastPlayer hasn't been updated yet.",
        "fixedCode": "function buyTicket_37() public { uint256 currentJackpot = jackpot_37; require(!(lastPlayer_37.send(currentJackpot))); lastPlayer_37 = msg.sender; jackpot_37 = address(this).balance; }"
    }
]
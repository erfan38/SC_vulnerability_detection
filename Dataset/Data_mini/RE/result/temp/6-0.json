[
    {
        "vulnerableLines": "6-10",
        "vulnerabilityReason": "The function uses send to transfer user balance before resetting the value in userBalanceMap, which allows reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this vulnerability to withdraw more than their balance by repeatedly calling this function in a malicious contract.",
        "fixedCode": "function withdrawUserBalance() public { uint balance = userBalanceMap[msg.sender]; require(balance > 0); userBalanceMap[msg.sender] = 0; require(msg.sender.send(balance)); }"
    },
    {
        "vulnerableLines": "14-19",
        "vulnerabilityReason": "The function sends ether to the user before resetting their redeemable balance, exposing it to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could keep invoking the function to claim more rewards than they are entitled to, leading to financial loss for the contract.",
        "fixedCode": "function claimReward() public { require(redeemableEtherMap[msg.sender] > 0); uint transferValue = redeemableEtherMap[msg.sender]; redeemableEtherMap[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "22-26",
        "vulnerabilityReason": "Using call.value to send funds before resetting the balance allows potential reentrancy.",
        "potentialSecurityRisk": "An attacker could continuously call this function to withdraw funds before their balance is set to zero.",
        "fixedCode": "function withdrawBalances() public { uint balance = balancesMap[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); require(success); balancesMap[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "30-33",
        "vulnerabilityReason": "Sending ether before clearing the user's balance exposes the contract to reentrancy risk.",
        "potentialSecurityRisk": "A malicious actor could leverage this to withdraw more ether than available before the balance is reset.",
        "fixedCode": "function withdrawBalances2() public { uint balance = balancesMap2[msg.sender]; require(msg.sender.send(balance)); balancesMap2[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "36-42",
        "vulnerabilityReason": "The function transfers ether before incrementing the counter, facilitating reentrant calls before the limit is enforced.",
        "potentialSecurityRisk": "Attackers can exploit this to drain the contract of ether by bypassing the limit check.",
        "fixedCode": "function callMe() public { require(counter <= 5); counter += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "44-50",
        "vulnerabilityReason": "Using call.value to send funds before updating the user balance presents a reentrancy vulnerability.",
        "potentialSecurityRisk": "Similar to previous cases, an attacker may exploit this to withdraw more funds than allowed.",
        "fixedCode": "function withdrawUserBalance2() public { uint balance = userBalanceMap2[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); require(success); userBalanceMap2[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "53-59",
        "vulnerabilityReason": "The function uses call.value to send ether before clearing the user balance, allowing reentrancy attacks.",
        "potentialSecurityRisk": "Attackers could exploit the situation to withdraw more than they actually hold, leading to loss of funds.",
        "fixedCode": "function withdrawUserBalance3() public { uint balance = userBalanceMap3[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); require(success); userBalanceMap3[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "98-102",
        "vulnerabilityReason": "The call to send ether occurs before the user's balance is deducted, opening the door to reentrancy attacks.",
        "potentialSecurityRisk": "This allows an attacker to drain funds from the contract before their balance is updated, bypassing checks.",
        "fixedCode": "function withdrawFunds(uint256 _weiToWithdraw) public { require(balancesMap3[msg.sender] >= _weiToWithdraw); balancesMap3[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    }
]
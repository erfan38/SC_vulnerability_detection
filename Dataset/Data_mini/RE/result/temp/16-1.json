[
    {
        "vulnerableLines": "1-7",
        "vulnerabilityReason": "The function sends ether to the caller before updating the state variable (variable_41), allowing for a reentrant call to this function.",
        "potentialSecurityRisk": "An attacker could exploit this by calling withdraw_41 before the variable_41 is set to false, allowing them to withdraw funds repeatedly.",
        "fixedCode": "function withdraw_41() public { require(variable_41); variable_41 = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "19-26",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the counter_42, making it susceptible to reentrant calls.",
        "potentialSecurityRisk": "An attacker can repeatedly call this function, incrementing the counter without limits, leading to excessive fund withdrawals.",
        "fixedCode": "function update_42() public { require(counter_42 <= 5); counter_42 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "35-38",
        "vulnerabilityReason": "The function sends funds to the user before resetting their balance, making it vulnerable to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could drain funds from this contract by exploiting the timing of state changes.",
        "fixedCode": "function withdraw_balances_29() public { uint256 amount = balances_29[msg.sender]; if (msg.sender.send(amount)) { balances_29[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "40-47",
        "vulnerabilityReason": "The function sends ether to the user before updating the variable_6, exposing it to potential reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this to repeatedly call this function and withdraw funds unintentionally.",
        "fixedCode": "function withdraw_6() public { require(variable_6); variable_6 = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "51-57",
        "vulnerabilityReason": "The function sends ether to the last player before updating their address, allowing for potential reentrant calls.",
        "potentialSecurityRisk": "A malicious actor can exploit this to drain the jackpot multiple times in one transaction.",
        "fixedCode": "function buyTicket_16() public { lastPlayer_16 = msg.sender; require(lastPlayer_16.send(jackpot_16)); jackpot_16 = address(this).balance; }"
    },
    {
        "vulnerableLines": "60-64",
        "vulnerabilityReason": "Using send to transfer funds before deducting the user\u2019s balance allows reentrant exploits.",
        "potentialSecurityRisk": "This can lead to an attacker repeatedly siphoning funds from the contract before their balance is updated.",
        "fixedCode": "function withdrawFunds_24(uint256 _weiToWithdraw) public { require(balances_24[msg.sender] >= _weiToWithdraw); balances_24[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "67-71",
        "vulnerabilityReason": "The function sends funds to the user before resetting the userBalance_5, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this by triggering multiple withdrawals before the balance resets.",
        "fixedCode": "function withdrawBalance_5() public { uint256 amount = userBalance_5[msg.sender]; if (msg.sender.send(amount)) { userBalance_5[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "75-78",
        "vulnerabilityReason": "Funds are sent before updating the state for balances_15, allowing a reentrant call to modify the behavior.",
        "potentialSecurityRisk": "An attacker can exploit this to withdraw more funds than they are entitled to, draining the contract.",
        "fixedCode": "function withdraw_balances_15() public { uint256 amount = balances_15[msg.sender]; if (msg.sender.send(amount)) { balances_15[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "81-88",
        "vulnerabilityReason": "The send operation occurs before updating the counter_28, allowing an attacker to increase the call count indefinitely.",
        "potentialSecurityRisk": "This can lead to excessive withdrawals, exhausting the contract's funds.",
        "fixedCode": "function update_28() public { require(counter_28 <= 5); counter_28 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "92-96",
        "vulnerabilityReason": "Sends ether to the user prior to updating the variable_34, making it prone to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could exploit this to repeatedly withdraw funds within one call, draining the contract.",
        "fixedCode": "function withdraw_34() public { require(variable_34); variable_34 = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "113-117",
        "vulnerabilityReason": "The function uses send to transfer the jackpot before the lastPlayer_2 address is updated, allowing for reentrant execution.",
        "potentialSecurityRisk": "Attackers can call this function repeatedly, draining the jackpot before it is re-evaluated.",
        "fixedCode": "function buyTicket_2() public { lastPlayer_2 = msg.sender; require(lastPlayer_2.send(jackpot_2)); jackpot_2 = address(this).balance; }"
    }
]
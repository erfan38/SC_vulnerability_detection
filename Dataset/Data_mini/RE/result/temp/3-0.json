[
    {
        "vulnerableLines": "4-11",
        "vulnerabilityReason": "The function sends ether to the caller before updating the state variable isFunctionNotCalled27, which allows for reentrant calls.",
        "potentialSecurityRisk": "An attacker could exploit this vulnerability to repeatedly call this function and drain ether before the state variable is changed.",
        "fixedCode": "function exampleFunction27() public { require(isFunctionNotCalled27); isFunctionNotCalled27 = false; require(msg.sender.send(1 ether)); }"
    },
    {
        "vulnerableLines": "13-18",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the balance of the caller, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "A malicious actor could manipulate the withdrawal process to drain funds from the contract by invoking this function recursively.",
        "fixedCode": "function withdrawFunds31 (uint256 _weiToWithdraw) public { require(balances31[msg.sender] >= _weiToWithdraw); balances31[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "20-27",
        "vulnerabilityReason": "This function utilizes call.value to send ether before the state variable is updated, enabling reentrant exploitation.",
        "potentialSecurityRisk": "An attacker can call the function multiple times before the function completes, draining funds from the smart contract.",
        "fixedCode": "function exampleFunction13() public { require(isFunctionNotCalled13); isFunctionNotCalled13 = false; (bool success,) = msg.sender.call.value(1 ether)(''); require(success); }"
    },
    {
        "vulnerableLines": "31-39",
        "vulnerabilityReason": "The function sends the jackpot amount before updating lastPlayer9. An attacker could call buyTicket9 multiple times to grab more ether.",
        "potentialSecurityRisk": "Malicious contracts could exploit this access to drain the entire jackpot amount by repeatedly calling this function.",
        "fixedCode": "function buyTicket9() public { require(!(lastPlayer9.call.value(jackpot9)(''))); lastPlayer9 = msg.sender; jackpot9 = address(this).balance; }"
    },
    {
        "vulnerableLines": "41-46",
        "vulnerabilityReason": "The function transfers ether to the user before clearing their redeemable ether balance, exposing it to reentrancy exploits.",
        "potentialSecurityRisk": "An attacker could invoke this function multiple times before the balance resets, extracting more ether than intended.",
        "fixedCode": "function claimReward25() public { require(redeemableEther25[msg.sender] > 0); uint transferValue25 = redeemableEther25[msg.sender]; redeemableEther25[msg.sender] = 0; msg.sender.transfer(transferValue25); }"
    },
    {
        "vulnerableLines": "49-54",
        "vulnerabilityReason": "Ether is sent before userBalance19 is reset, allowing for potential reentrant attacks.",
        "potentialSecurityRisk": "A malicious actor could drain funds by exploiting the withdrawal process with repeated calls before their balance is reset.",
        "fixedCode": "function withdrawBalance19() public { uint balance = userBalance19[msg.sender]; require(msg.sender.send(balance)); userBalance19[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "57-63",
        "vulnerabilityReason": "Using call.value to transfer funds prior to updating the user balance enables the risk of reentrancy.",
        "potentialSecurityRisk": "Attackers may exploit this to withdraw more funds than they are entitled to by calling the function multiple times.",
        "fixedCode": "function withdrawBalance26() public { uint256 balance = userBalance26[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); require(success); userBalance26[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "66-72",
        "vulnerabilityReason": "This function sends ether before updating isFunctionNotCalled20, making it susceptible to reentrant calls.",
        "potentialSecurityRisk": "Attackers can repeatedly call this function to extract ether from the contract, avoiding state changes that would prevent this.",
        "fixedCode": "function exampleFunction20() public { require(isFunctionNotCalled20); isFunctionNotCalled20 = false; require(msg.sender.send(1 ether)); }"
    },
    {
        "vulnerableLines": "76-82",
        "vulnerabilityReason": "The claimReward32 function sends ether before resetting the redeemable balance, which is vulnerable to reentrancy.",
        "potentialSecurityRisk": "A malicious user could exploit this vulnerability to claim rewards multiple times before their balance is cleared.",
        "fixedCode": "function claimReward32() public { require(redeemableEther32[msg.sender] > 0); uint transferValue32 = redeemableEther32[msg.sender]; redeemableEther32[msg.sender] = 0; msg.sender.transfer(transferValue32); }"
    },
    {
        "vulnerableLines": "84-89",
        "vulnerabilityReason": "Sending ethers to the user before adjusting their balance creates a reentrancy risk.",
        "potentialSecurityRisk": "An attacker can exploit the withdrawal process to call this function multiple times and withdraw more ether than permitted.",
        "fixedCode": "function withdrawFunds38 (uint256 _weiToWithdraw) public { require(balances38[msg.sender] >= _weiToWithdraw); balances38[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "92-98",
        "vulnerabilityReason": "Transferring ether before updating the redeemable balance exposes this function to reentrancy attacks.",
        "potentialSecurityRisk": "Fraudulent calls could lead to unauthorized withdrawals, draining the contract balance beyond intended limits.",
        "fixedCode": "function claimReward4() public { require(redeemableEther4[msg.sender] > 0); uint transferValue4 = redeemableEther4[msg.sender]; redeemableEther4[msg.sender] = 0; msg.sender.transfer(transferValue4); }"
    }
]
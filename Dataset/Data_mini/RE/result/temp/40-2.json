[
    {
        "vulnerableLines": "1-4",
        "vulnerabilityReason": "The function uses send to transfer ether before checking the user balance, which could lead to reentrant calls before the state is updated.",
        "potentialSecurityRisk": "An attacker could exploit this functionality to withdraw more funds than they should be allowed to by repeatedly calling the function.",
        "fixedCode": "function withdrawAlternativeFunds4() public { uint256 amountToWithdraw = alternativeBalances4[msg.sender]; require(amountToWithdraw > 0, 'No funds to withdraw'); alternativeBalances4[msg.sender] = 0; msg.sender.send(amountToWithdraw); }"
    },
    {
        "vulnerableLines": "10-16",
        "vulnerabilityReason": "The incrementCallCounter3 function allows the user to send ether before the call counter is updated, which can lead to multiple calls exploiting the limit.",
        "potentialSecurityRisk": "This vulnerability could allow an attacker to drain funds every time the function is called, exploiting the counter limit check.",
        "fixedCode": "function incrementCallCounter3() public { require(callCounter3 <= 5); callCounter3 += 1; require(msg.sender.send(10 ether), 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "20-28",
        "vulnerabilityReason": "The buyTicket4 function sends the jackpot amount before updating the lastPlayer4 address, which exposes it to reentrancy.",
        "potentialSecurityRisk": "An attacker could call this function repeatedly while the address for the lastPlayer4 is not yet updated, draining jackpot funds.",
        "fixedCode": "function buyTicket4() public { require(jackpot4 > 0, 'No funds to send'); (bool success,) = lastPlayer4.call.value(jackpot4)(''); require(success, 'Transfer failed'); lastPlayer4 = msg.sender; jackpot4 = address(this).balance; }"
    },
    {
        "vulnerableLines": "31-36",
        "vulnerabilityReason": "Claiming rewards directly after transferring funds makes this function vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker could continuously call this function before the balances are updated, siphoning off funds.",
        "fixedCode": "function claimReward4() public { require(redeemableBalances4[msg.sender] > 0, 'No redeemable balance'); uint256 transferValue4 = redeemableBalances4[msg.sender]; redeemableBalances4[msg.sender] = 0; msg.sender.transfer(transferValue4); }"
    },
    {
        "vulnerableLines": "39-44",
        "vulnerabilityReason": "Similar to previous withdrawals, this function also uses send prior to resetting user balances.",
        "potentialSecurityRisk": "Allows potential for multiple withdrawals in a reentrant call scenario, draining user balances from the contract.",
        "fixedCode": "function withdrawUserBalance2() public { uint256 balance = userBalance2[msg.sender]; require(balance > 0, 'No balance to withdraw'); userBalance2[msg.sender] = 0; require(msg.sender.send(balance), 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "53-59",
        "vulnerabilityReason": "Use of call.value to send funds before resetting the balance exposes it to reentrant execution.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw more funds than they have, breaking the intended deposit and withdrawal schema.",
        "fixedCode": "function withdrawUserBalance3() public { uint256 balance = userBalance3[msg.sender]; require(balance > 0, 'No funds to withdraw'); userBalance3[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(''); require(success, 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "65-71",
        "vulnerabilityReason": "The withdrawUserBalance4 function suffers from the same reentrancy issue as other withdrawal functions when sending ether before updating balances.",
        "potentialSecurityRisk": "Attackers can exploit the gap between the balance check and the transfer, extracting more funds than allowed.",
        "fixedCode": "function withdrawUserBalance4() public { uint256 balance = userBalance4[msg.sender]; require(balance > 0, 'No funds to withdraw'); userBalance4[msg.sender] = 0; (bool success,) = msg.sender.call.value(balance)(''); require(success, 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "78-84",
        "vulnerabilityReason": "The activateFunction transfers ether without updating the state variable isFunctionActive first, making this call susceptible to repeated activations.",
        "potentialSecurityRisk": "An attacker can abuse this by triggering the function multiple times before it can be disabled, leading to a potential loss of ether.",
        "fixedCode": "function activateFunction() public { require(isFunctionActive, 'Function is already active'); isFunctionActive = false; require(msg.sender.send(1 ether), 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "89-93",
        "vulnerabilityReason": "There is an unprotected withdrawal where the withdrawal size is sent before updating the balances, causing the potential for reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly invoke this function to withdraw more ether than deposited, draining user funds.",
        "fixedCode": "function withdrawFunds2(uint256 _weiToWithdraw) public { require(balances2[msg.sender] >= _weiToWithdraw, 'Insufficient balance'); balances2[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw), 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "102-108",
        "vulnerabilityReason": "This function allows the sender to receive funds before setting the active state to false, leading to the risk of reentrant calls.",
        "potentialSecurityRisk": "An attacker can activate the function again before the state is changed, leading to unauthorized ether transfers.",
        "fixedCode": "function activateFunction2() public { require(isFunctionActive2, 'Function already activated'); isFunctionActive2 = false; (bool success,) = msg.sender.call.value(1 ether)(''); require(success, 'Transfer failed'); }"
    }
]
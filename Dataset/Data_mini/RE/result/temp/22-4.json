[
    {
        "vulnerableLines": "18-24",
        "vulnerabilityReason": "The function uses send to transfer funds before updating the lastPlayer_30 address, allowing a potential reentrant call to occur.",
        "potentialSecurityRisk": "A malicious contract could exploit this vulnerability to withdraw more funds than intended before the state is updated.",
        "fixedCode": "function buyTicket_30() public { address previousPlayer = lastPlayer_30; require(previousPlayer.send(jackpot_30)); lastPlayer_30 = msg.sender; jackpot_30 = address(this).balance; }"
    },
    {
        "vulnerableLines": "58-59",
        "vulnerabilityReason": "The function sends funds to p.recipient before updating `p.executed`, which allows for reentrancy if the recipient is a smart contract.",
        "potentialSecurityRisk": "An attacker can call back into the contract during the transfer, possibly allowing them to execute the proposal multiple times or manipulate state changes.",
        "fixedCode": "if (yea > nay) { p.executed = true; (bool success, ) = p.recipient.call.value(p.amount)(transactionBytecode); require(success); p.proposalPassed = true; } else { p.proposalPassed = false; }"
    },
    {
        "vulnerableLines": "69-73",
        "vulnerabilityReason": "The function uses call to send funds before resetting the balance, exposing it to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could reenter this function and exploit it to withdraw funds multiple times before the user's balance is set to zero.",
        "fixedCode": "function withdraw_balances_8() public { uint256 balance = balances_8[msg.sender]; require(balance > 0); (bool success,) = msg.sender.call.value(balance)(''); if (success) balances_8[msg.sender] = 0; }"
    }
]
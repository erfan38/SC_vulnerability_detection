[
    {
        "vulnerableLines": "4-11",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the counter, allowing potential reentrant calls.",
        "potentialSecurityRisk": "An attacker could exploit this to execute the function multiple times before the limit is enforced, draining the contract's balance.",
        "fixedCode": "function callme_14() public { require(counter_14 <= 5); counter_14 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "14-20",
        "vulnerabilityReason": "The buyTicket function sends ether to the last player before updating the player's address, leading to reentrancy.",
        "potentialSecurityRisk": "A malicious contract could exploit this and call buyTicket_30 repeatedly, draining the jackpot amount before it is updated.",
        "fixedCode": "function buyTicket_30() public { uint jackpotTemp = jackpot_30; require(!(lastPlayer_30.send(jackpotTemp))); lastPlayer_30 = msg.sender; jackpot_30 = address(this).balance; }"
    },
    {
        "vulnerableLines": "24-28",
        "vulnerabilityReason": "The function uses call.value to send the user's balance before resetting it, creating a potential for reentrancy.",
        "potentialSecurityRisk": "An attacker could call this function multiple times before the balance is reset, effectively draining funds.",
        "fixedCode": "function withdraw_balances_8() public { uint256 balance = balances_8[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) balances_8[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "30-36",
        "vulnerabilityReason": "Similar to previous functions, this transfers ether before clearing the user's balance, allowing reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw more ether than allowed by calling the function repeatedly.",
        "fixedCode": "function claimReward_39() public { require(redeemableEther_39[msg.sender] > 0); uint transferValue_39 = redeemableEther_39[msg.sender]; redeemableEther_39[msg.sender] = 0; msg.sender.transfer(transferValue_39); }"
    },
    {
        "vulnerableLines": "41-44",
        "vulnerabilityReason": "This function sends ether before deducting the user's balance, which allows for reentrant attacks.",
        "potentialSecurityRisk": "An attacker could exploit the reentrancy to withdraw more ether than their balance permits.",
        "fixedCode": "function withdrawFunds_31(uint256 _weiToWithdraw) public { require(balances_31[msg.sender] >= _weiToWithdraw); balances_31[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "52-58",
        "vulnerabilityReason": "The function sends ether without updating the counter, allowing multiple invocations before enforcement.",
        "potentialSecurityRisk": "Attackers could drain the contract of sent ether by repeatedly executing this method before limits are checked.",
        "fixedCode": "function callme_35() public { require(counter_35 <= 5); counter_35 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "69-74",
        "vulnerabilityReason": "Balance transfer occurs before the user's balance is reset, creating opportunities for reentrancy.",
        "potentialSecurityRisk": "Attackers could exploit this by invoking withdrawBalance_40 multiple times, withdrawing more funds than they are entitled to.",
        "fixedCode": "function withdrawBalance_40() public { uint balance = userBalance_40[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) userBalance_40[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "77-84",
        "vulnerabilityReason": "The function uses call.value to send funds before the checking variable is updated, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "This allows attackers to call this function multiple times before the state is changed, effectively draining the contract's ether.",
        "fixedCode": "function userbalances_13() public { require(checking_13); checking_13 = false; (bool success,) = msg.sender.call.value(1 ether)(''); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "89-92",
        "vulnerabilityReason": "Using send to transfer funds before resetting the user balance exposes to reentrancy vulnerabilities.",
        "potentialSecurityRisk": "Clients can call this function in a loop, extracting more ether than their balance allows.",
        "fixedCode": "function withdraw_balances_36() public { uint balance = balances_36[msg.sender]; if (msg.sender.send(balance)) { balances_36[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "103-109",
        "vulnerabilityReason": "Ether sends occur before balance resets, creating the possibility of multiple withdrawals.",
        "potentialSecurityRisk": "An attacker could execute this function multiple times before the userBalance_33 is set to zero, draining funds.",
        "fixedCode": "function withdrawBalance_33() public { uint balance = userBalance_33[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) userBalance_33[msg.sender] = 0; }"
    }
]
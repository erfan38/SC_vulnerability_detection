[
    {
        "vulnerableLines": "6-10",
        "vulnerabilityReason": "The function withdrawBalances uses call.value to transfer ether before checking the balance, allowing for reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit the reentrancy vulnerability to call this function repeatedly, draining the contract's funds before their balance is reset.",
        "fixedCode": "function withdrawBalances() public { uint256 amountToWithdraw = balancesWithdrawable[msg.sender]; require(amountToWithdraw > 0); balancesWithdrawable[msg.sender] = 0; (bool success,) = msg.sender.call.value(amountToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "13-17",
        "vulnerabilityReason": "The function withdrawUserBalance sends funds before resetting user balance, making it reentrancy vulnerable.",
        "potentialSecurityRisk": "Attackers could reenter this function to withdraw more funds than they have deposited, draining the contract's balance.",
        "fixedCode": "function withdrawUserBalance() public { uint256 amount = userBalanceWithdrawable[msg.sender]; require(amount > 0); userBalanceWithdrawable[msg.sender] = 0; require(msg.sender.send(amount)); }"
    },
    {
        "vulnerableLines": "21-25",
        "vulnerabilityReason": "The claimReward function sends funds before updating the redeemable balance, leaving it open to reentrancy.",
        "potentialSecurityRisk": "Attackers could drain funds by calling this method multiple times before the redeemable balance is adjusted.",
        "fixedCode": "function claimReward() public { uint256 amount = redeemableEtherBalances[msg.sender]; require(amount > 0); redeemableEtherBalances[msg.sender] = 0; msg.sender.transfer(amount); }"
    },
    {
        "vulnerableLines": "30-34",
        "vulnerabilityReason": "The withdrawReusableBalances function uses send to transfer funds before resetting the user's balance, creating a reentrancy issue.",
        "potentialSecurityRisk": "This allows attackers to exploit reentrancy by pulling out more funds than they are eligible for before their balance is updated.",
        "fixedCode": "function withdrawReusableBalances() public { uint256 amount = balancesWithdrawReusable[msg.sender]; require(amount > 0); balancesWithdrawReusable[msg.sender] = 0; require(msg.sender.send(amount)); }"
    },
    {
        "vulnerableLines": "46-50",
        "vulnerabilityReason": "The withdrawUserBalanceInfo function uses call.value to send ether before updating user balance, exposing it to reentrancy.",
        "potentialSecurityRisk": "An attacker could execute this function multiple times to withdraw ether improperly by exploiting its reentrancy.",
        "fixedCode": "function withdrawUserBalanceInfo() public { uint256 amount = userBalance[msg.sender]; require(amount > 0); userBalance[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(''); require(success); }"
    },
    {
        "vulnerableLines": "54-58",
        "vulnerabilityReason": "The withdrawCheckUserBalance function calls with call.value to transfer funds before changing the user's balance, creating a reentrancy risk.",
        "potentialSecurityRisk": "Possible loss of funds since an attacker could exploit this function to withdraw funds multiple times during a single transaction.",
        "fixedCode": "function withdrawCheckUserBalance() public { uint256 amount = userBalanceCheck[msg.sender]; require(amount > 0); userBalanceCheck[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(''); require(success); }"
    },
    {
        "vulnerableLines": "98-103",
        "vulnerabilityReason": "The withdrawUserFunds function uses call.value to send ether before reducing the user's balance, risking reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this vulnerability to drain funds from the contract by invoking this function multiple times.",
        "fixedCode": "function withdrawUserFunds(uint256 _weiToWithdraw) public { require(balancesUserWithdraw[msg.sender] >= _weiToWithdraw); balancesUserWithdraw[msg.sender] -= _weiToWithdraw; (bool success,)=msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "72-78",
        "vulnerabilityReason": "The callmeTwo function allows funds to be sent before updating the counter, allowing for potential reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function during the ether transfer, incrementing the counter improperly and draining more funds.",
        "fixedCode": "function callmeTwo() public { require(counterTwo <= 5); counterTwo += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "86-90",
        "vulnerabilityReason": "The buyTicket function sends ether to lastPlayer before updating the lastPlayer address, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "Attackers could use reentrancy to continuously withdraw more funds than intended during a token purchase.",
        "fixedCode": "function buyTicket() public { require(jackpot > 0); require(!(lastPlayer.send(jackpot))); lastPlayer = msg.sender; jackpot = address(this).balance; }"
    }
]
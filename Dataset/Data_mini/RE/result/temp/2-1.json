[
    {
        "vulnerableLines": "1-6",
        "vulnerabilityReason": "The function sends funds to lastPlayer before updating lastPlayer's address, allowing reentrant calls to exploit the function.",
        "potentialSecurityRisk": "A malicious user could call this function multiple times, draining the contract of its funds by receiving multiple jackpots before the address is updated.",
        "fixedCode": "function buyTicket() public { uint transferAmount = jackpot; lastPlayer = msg.sender; jackpot = address(this).balance; require(lastPlayer.send(transferAmount)); }"
    },
    {
        "vulnerableLines": "28-35",
        "vulnerabilityReason": "The function allows sending ether without updating the counter before the send operation, which can lead to reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this to call back into the function multiple times before the counter limit is enforced, withdrawing more than allowed.",
        "fixedCode": "function functionCall() public { require(counterFunction <= 5); counterFunction += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "60-67",
        "vulnerabilityReason": "Similar to buyTicket, funds are sent before updating lastPlayerSecond, risking reentrancy during the call.",
        "potentialSecurityRisk": "An attacker could drain funds by repeatedly accessing this function before the lastPlayerSecond is updated.",
        "fixedCode": "function buyTicketSecond() public { uint transferAmount = jackpotSecond; lastPlayerSecond = msg.sender; jackpotSecond = address(this).balance; require(lastPlayerSecond.send(transferAmount)); }"
    },
    {
        "vulnerableLines": "77-81",
        "vulnerabilityReason": "The function uses call.value to send funds before resetting the user's balance, making it vulnerable to reentrancy attacks.",
        "potentialSecurityRisk": "A reentrant call could lead to multiple withdrawals before the user's balance is reset, allowing for draining the contract's funds.",
        "fixedCode": "function withdrawUserBalance() public { uint balance = userBalances[msg.sender]; require(msg.sender.call.value(balance)('')); userBalances[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "90-94",
        "vulnerabilityReason": "This function sends ether before resetting the user's redeemable balance, allowing for potential reentrancy.",
        "potentialSecurityRisk": "An attacker could continuously claim rewards, pulling funds from the contract due to not having the redeemable balance updated before the transfer.",
        "fixedCode": "function claimRewardMapping() public { require(redeemableEtherSecondaryMapping[msg.sender] > 0); uint transferValueMapping = redeemableEtherSecondaryMapping[msg.sender]; redeemableEtherSecondaryMapping[msg.sender] = 0; msg.sender.transfer(transferValueMapping); }"
    },
    {
        "vulnerableLines": "105-108",
        "vulnerabilityReason": "Using send to transfer funds before resetting the balance, which allows for multiple calls to this function, leading to a reentrancy vulnerability.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw more funds than available by calling the function repeatedly within the same transaction.",
        "fixedCode": "function withdrawSecondaryMapping() public { uint amount = balancesSecondaryMapping[msg.sender]; require(msg.sender.send(amount)); balancesSecondaryMapping[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "114-121",
        "vulnerabilityReason": "The function allows a send to execute without first updating the counter, enabling repeated withdrawals before the limit is checked.",
        "potentialSecurityRisk": "An attacker may exploit this to drain more ether than intended by using a reentrant call to the function.",
        "fixedCode": "function functionCallSecond() public { require(counterFunctionSecond <= 5); counterFunctionSecond += 1; require(msg.sender.send(10 ether)); }"
    }
]
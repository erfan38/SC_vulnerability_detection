[
    {
        "vulnerableLines": "66-70",
        "vulnerabilityReason": "The function uses call.value to transfer ether before updating the user balance, allowing for potential reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this vulnerability by repeatedly calling withdrawFunds before the user's balance is updated, resulting in funds being drained from the contract.",
        "fixedCode": "function withdrawFunds(uint256 _weiToWithdraw) public { require(balances[msg.sender] >= _weiToWithdraw); balances[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "74-80",
        "vulnerabilityReason": "The function sends ether to lastPlayer before updating its state, which opens a reentrancy attack vector.",
        "potentialSecurityRisk": "A malicious user can exploit this to drain funds by continually invoking the function before the state is updated.",
        "fixedCode": "function buyTicket() public { uint currentJackpot = jackpot; if (!(lastPlayer.send(currentJackpot))) revert(); lastPlayer = msg.sender; jackpot = address(this).balance; }"
    },
    {
        "vulnerableLines": "85-89",
        "vulnerabilityReason": "The function transfers ether before updating the alternativeBalances, making it susceptible to reentrant calls.",
        "potentialSecurityRisk": "Attackers could withdraw funds repeatedly before their balance is reset, potentially stealing more funds than they own.",
        "fixedCode": "function withdrawFundsAlternative(uint256 _weiToWithdraw) public { require(alternativeBalances[msg.sender] >= _weiToWithdraw); alternativeBalances[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "97-102",
        "vulnerabilityReason": "Using call.value to send funds before resetting the user balance creates a window for reentrant attacks.",
        "potentialSecurityRisk": "An attacker could exploit this by calling withdrawUserBalance multiple times, draining the contract's funds.",
        "fixedCode": "function withdrawUserBalance() public { uint256 balance = userBalance[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); require(success); userBalance[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "109-114",
        "vulnerabilityReason": "The function allows payment before setting isFunctionCalled to false, enabling reentrant executions.",
        "potentialSecurityRisk": "This could allow an attacker to drain ether by calling the function multiple times before the state is changed.",
        "fixedCode": "function activateFunctionCall() public { require(isFunctionCalled); isFunctionCalled = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    }
]
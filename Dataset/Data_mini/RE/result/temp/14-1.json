[
    {
        "vulnerableLines": "1-4",
        "vulnerabilityReason": "The funds are sent to the user before the user's balance is decremented, which makes the deposit susceptible to reentrancy.",
        "potentialSecurityRisk": "An attacker could call this function multiple times before their balance is updated, allowing them to withdraw more ether than they actually have.",
        "fixedCode": "function withdrawFundsAlt(uint256 _weiToWithdraw) public { require(balancesAlt[msg.sender] >= _weiToWithdraw); balancesAlt[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "12-16",
        "vulnerabilityReason": "The transfer of funds occurs before the user's redeemable balance is reset, exposing the function to reentrant calls.",
        "potentialSecurityRisk": "An attacker could potentially withdraw rewards multiple times before their redeemable balance is reset, draining the contract.",
        "fixedCode": "function claimRewardLast() public { require(redeemableEtherLast[msg.sender] > 0); uint transferValue = redeemableEtherLast[msg.sender]; redeemableEtherLast[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "24-30",
        "vulnerabilityReason": "Sending ether happens before incrementing the counter, allowing for multiple calls and exceeding the limit.",
        "potentialSecurityRisk": "An attacker can exploit this to repeatedly send ether to themselves before the counter is updated, potentially draining funds.",
        "fixedCode": "function callMe() public { require(counterAlt <= 5); counterAlt += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "37-44",
        "vulnerabilityReason": "Funds are sent to the lastPlayerAlt before updating their address, making it vulnerable to reentrant attacks.",
        "potentialSecurityRisk": "A malicious contract could exploit this to withdraw excessive funds by reentering this method.",
        "fixedCode": "function buyTicketAlt() public { require(!(lastPlayerAlt.send(jackpotAlt))); lastPlayerAlt = msg.sender; jackpotAlt = address(this).balance; }"
    },
    {
        "vulnerableLines": "49-55",
        "vulnerabilityReason": "The function sends ether before updating the counter, which can allow attackers to perform multiple transactions before the limit is enforced.",
        "potentialSecurityRisk": "An attacker could drain the contract of funds by calling this function multiple times before the limit is recorded.",
        "fixedCode": "function callMeAnother() public { require(counterAnother <= 5); counterAnother += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "61-68",
        "vulnerabilityReason": "The send operation occurs before resetting lastPlayerFinal, allowing for reentrant calls to exploit the jackpot funds.",
        "potentialSecurityRisk": "An attacker could repeatedly extract funds before their balance state is updated, draining the jackpot.",
        "fixedCode": "function buyTicketFinal() public { require(!(lastPlayerFinal.send(jackpotFinal))); lastPlayerFinal = msg.sender; jackpotFinal = address(this).balance; }"
    },
    {
        "vulnerableLines": "78-80",
        "vulnerabilityReason": "The function uses call.value to transfer funds before modifying the user's balance, exposing it to reentrancy.",
        "potentialSecurityRisk": "Malicious users could exploit this to withdraw more funds than available in their balance.",
        "fixedCode": "function withdrawFundsUnique() public { uint256 balance = balancesUnique[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) { balancesUnique[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "106-110",
        "vulnerabilityReason": "The use of send to transfer funds before the balance is updated allows for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker can exploit this to withdraw funds multiple times, draining the contract\u2019s balance.",
        "fixedCode": "function withdrawFundsUniqueFinal() public { uint256 balance = balancesUniqueFinal[msg.sender]; if (msg.sender.send(balance)) { balancesUniqueFinal[msg.sender] = 0; } }"
    }
]
[
    {
        "vulnerableLines": "1-7",
        "vulnerabilityReason": "The function calls send to transfer ether before incrementing counterFinal, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function, potentially draining ether from the contract by circumventing the counter limit.",
        "fixedCode": "function callMeFinal() public { require(counterFinal <= 5); counterFinal += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "14-19",
        "vulnerabilityReason": "The function uses call.value to transfer userBalanceAlt to the msg.sender before resetting the user's balance, allowing reentrancy.",
        "potentialSecurityRisk": "An attacker can exploit this to withdraw funds repeatedly during a reentrant call and drain the contract\u2019s funds.",
        "fixedCode": "function withdrawBalanceAlt() public { uint256 balance = userBalanceAlt[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) userBalanceAlt[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "29-34",
        "vulnerabilityReason": "Similar to the previous withdrawal function, it uses call.value to transfer funds before updating the user's balance.",
        "potentialSecurityRisk": "This makes the function vulnerable to reentrancy attacks, allowing malicious actors to withdraw more than allowed.",
        "fixedCode": "function withdrawBalanceNew() public { uint256 balance = userBalanceNew[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) userBalanceNew[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "41-46",
        "vulnerabilityReason": "Again, this function uses the call.value method to transfer funds before resetting the user balance, exposing it to reentrant attacks.",
        "potentialSecurityRisk": "Exploiting the vulnerability might allow an attacker to withdraw excessive ether from the contract.",
        "fixedCode": "function withdrawBalanceFinished() public { uint256 balance = userBalanceFinished[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) userBalanceFinished[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "53-58",
        "vulnerabilityReason": "A send call is made before updating the notCalled variable, allowing a reentrant call that could exploit this inconsistency.",
        "potentialSecurityRisk": "An attacker could call this function multiple times, receiving ether each time before the variable is updated.",
        "fixedCode": "function checkFunctionality() public { require(notCalled); notCalled = false; require(msg.sender.send(1 ether)); }"
    },
    {
        "vulnerableLines": "65-68",
        "vulnerabilityReason": "The function uses send without deducting the user balance first, making it susceptible to reentrancy attacks.",
        "potentialSecurityRisk": "Attackers could exploit this to siphon off more ether than they are entitled to, draining contract funds.",
        "fixedCode": "function withdrawFundsAltFinal(uint256 _weiToWithdraw) public { require(balancesAltFinal[msg.sender] >= _weiToWithdraw); balancesAltFinal[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "74-79",
        "vulnerabilityReason": "The send occurs before updating the notCalledSecond variable, which could be exploited to call this function multiple times.",
        "potentialSecurityRisk": "An attacker could drain ether from the contract with repeated reentrant calls.",
        "fixedCode": "function checkFunctionalitySecond() public { require(notCalledSecond); notCalledSecond = false; require(msg.sender.send(1 ether)); }"
    },
    {
        "vulnerableLines": "88-93",
        "vulnerabilityReason": "This function makes a send to msg.sender before changing notCalledThird, allowing a reentrant injection.",
        "potentialSecurityRisk": "It permits attackers to exploit the timing and receive additional ether with repeat calls.",
        "fixedCode": "function checkFunctionalityThird() public { require(notCalledThird); notCalledThird = false; (bool success,)=msg.sender.call.value(1 ether)(''); if (!success) { revert(); } }"
    }
]
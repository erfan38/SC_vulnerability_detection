[
    {
        "vulnerableLines": "8-12",
        "vulnerabilityReason": "The function uses call.value to transfer Ether to the user before setting their balance to zero.",
        "potentialSecurityRisk": "This allows an attacker to re-enter the function before the balance is updated, potentially draining the entire balance of the contract.",
        "fixedCode": "function withdraw_balancesUpdated21() public { uint256 balance = balancesUpdated21[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) { balancesUpdated21[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "15-21",
        "vulnerabilityReason": "Similar to the previous function, it transfers funds before updating the user's balance.",
        "potentialSecurityRisk": "An attacker can re-enter the function, allowing multiple withdrawals before their balance is properly updated.",
        "fixedCode": "function withdrawBalanceUpdated40() public { uint256 balance = userBalanceUpdated40[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (!success) { revert(); } userBalanceUpdated40[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "28-34",
        "vulnerabilityReason": "Funds are sent before the balance is deducted, exposing the function to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could call this function multiple times to withdraw more than they should, draining the contract.",
        "fixedCode": "function withdrawFundsUpdated17(uint256 _weiToWithdraw) public { require(balancesUpdated17[msg.sender] >= _weiToWithdraw); balancesUpdated17[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "46-51",
        "vulnerabilityReason": "Using send to transfer Ether and then setting the lastPlayerUpdated37 variable, allows reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this by invoking buyTicketUpdated37 multiple times, allowing them to withdraw more than their intended amount.",
        "fixedCode": "function buyTicketUpdated37() public { require(lastPlayerUpdated37.send(jackpotUpdated37)); lastPlayerUpdated37 = msg.sender; jackpotUpdated37 = address(this).balance; }"
    },
    {
        "vulnerableLines": "60-64",
        "vulnerabilityReason": "The function uses send to transfer user balance without resetting it first, opening it to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could drain the contract by repeatedly calling this function before their balance is updated to zero.",
        "fixedCode": "function withdrawBalanceUpdated12() public { uint256 balance = userBalanceUpdated12[msg.sender]; require(msg.sender.send(balance)); userBalanceUpdated12[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "68-74",
        "vulnerabilityReason": "Here again, a call.value transfer occurs before updating the user's balance, allowing a reentrancy exploit.",
        "potentialSecurityRisk": "This can lead to an attacker withdrawing more funds than allowed if they re-enter before the balance is reset.",
        "fixedCode": "function withdrawBalanceUpdated33() public { uint256 balance = userBalanceUpdated33[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); require(success); userBalanceUpdated33[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "89-93",
        "vulnerabilityReason": "Similar to previous withdrawals, a transfer occurs before deducting the user's balance.",
        "potentialSecurityRisk": "This allows an attacker to exploit the reentrancy vulnerability, draining the contract's funds.",
        "fixedCode": "function withdrawFundsUpdated3(uint256 _weiToWithdraw) public { require(balancesUpdated3[msg.sender] >= _weiToWithdraw); balancesUpdated3[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    }
]
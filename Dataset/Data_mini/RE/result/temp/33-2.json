[
    {
        "vulnerableLines": "1-10",
        "vulnerabilityReason": "The redeem function uses token transfers before confirming the state change of staker, allowing reentrancy into the redeem function.",
        "potentialSecurityRisk": "A malicious actor could call the redeem function again, potentially allowing them to redeem more tokens than they should.",
        "fixedCode": "function redeem() public { require(!lock); require(!staker[msg.sender].redeem); require(staker[msg.sender].time + stakeTime <= now); staker[msg.sender].redeem = true; require(token.transfer(msg.sender, staker[msg.sender].tokens)); require(token.transferFrom(owner, msg.sender, staker[msg.sender].tokens * stakePercentage * 100 / 10000)); emit tokensRedeemed(msg.sender, staker[msg.sender].tokens, staker[msg.sender].tokens * stakePercentage * 100 / 10000); staker[msg.sender].tokens = 0; }"
    },
    {
        "vulnerableLines": "12-16",
        "vulnerabilityReason": "The withdrawFundsFromWithdrawable function uses call.value to send ether before updating the balance to 0, allowing reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly invoke this function to withdraw more ether than they are entitled to.",
        "fixedCode": "function withdrawFundsFromWithdrawable() public { uint256 balance = balances_withdrawable[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) balances_withdrawable[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "22-26",
        "vulnerabilityReason": "The claimRewardCustodialFunds function transfers ether then sets the redeemable value to zero, allowing for reentrancy.",
        "potentialSecurityRisk": "A malicious actor could drain funds by calling claimRewardCustodialFunds before their balance is reset.",
        "fixedCode": "function claimRewardCustodialFunds() public { require(redeemableEther_custodialFunds[msg.sender] > 0); uint transferValue = redeemableEther_custodialFunds[msg.sender]; redeemableEther_custodialFunds[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "33-36",
        "vulnerabilityReason": "The withdrawFundsFromOtherWithdrawals function uses send to transfer funds before updating the balance, exposing reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this to drain funds from the contract by repeatedly invoking this function.",
        "fixedCode": "function withdrawFundsFromOtherWithdrawals() public { uint256 balance = balances_otherWithdrawals[msg.sender]; if (msg.sender.send(balance)) { balances_otherWithdrawals[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "41-48",
        "vulnerabilityReason": "The trackOtherWithdraw function uses send to transfer funds before ensuring that the counter is updated, enabling multiple withdrawals.",
        "potentialSecurityRisk": "An attacker may exploit race conditions to withdraw more funds than allowed, continuously draining the contract.",
        "fixedCode": "function trackOtherWithdraw() public { require(counter_otherWithdraw <= 5); counter_otherWithdraw += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "54-60",
        "vulnerabilityReason": "The withdrawUserBalance function does not reset the user's balance until after the funds are sent, creating a reentrancy risk.",
        "potentialSecurityRisk": "An attacker can re-enter this function to withdraw more than their rightful share.",
        "fixedCode": "function withdrawUserBalance() public { uint256 balance = userBalance_withdrawable[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) { userBalance_withdrawable[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "68-74",
        "vulnerabilityReason": "The withdrawUserBalanceRedeemable function transfers funds before resetting the redeemable balance, allowing reentrancy.",
        "potentialSecurityRisk": "A malicious actor could exploit this to withdraw continuously before their balance is reset.",
        "fixedCode": "function withdrawUserBalanceRedeemable() public { uint256 balance = userBalance_redeemable[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) { userBalance_redeemable[msg.sender] = 0; } }"
    }
]
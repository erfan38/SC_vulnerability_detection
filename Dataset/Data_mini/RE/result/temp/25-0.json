[
    {
        "vulnerableLines": "8-12",
        "vulnerabilityReason": "The use of call to transfer jackpot_9 to lastPlayer_9 before updating the lastPlayer_9 address opens the contract to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could exploit this vulnerability to recursively invoke buyTicket_9, allowing it to withdraw funds multiple times before the state is updated.",
        "fixedCode": "function buyTicket_9() public { jackpot_9 = address(this).balance; (bool success,) = lastPlayer_9.call.value(jackpot_9)(''); if (!success) revert(); lastPlayer_9 = msg.sender; }"
    },
    {
        "vulnerableLines": "30-34",
        "vulnerabilityReason": "The function sends ether before the redeemable balance is reset, creating a vulnerability to reentrancy.",
        "potentialSecurityRisk": "An attacker could call claimReward_25 repeatedly to drain funds from the contract before their balance is cleared.",
        "fixedCode": "function claimReward_25() public { require(redeemableEther_25[msg.sender] > 0); uint transferValue_25 = redeemableEther_25[msg.sender]; redeemableEther_25[msg.sender] = 0; msg.sender.transfer(transferValue_25); }"
    },
    {
        "vulnerableLines": "46-50",
        "vulnerabilityReason": "Using send to transfer userBalance_19 without first zeroing out the balance allows reentrant calls.",
        "potentialSecurityRisk": "An attacker could drain the contract by calling withdrawBalance_19 repeatedly, as the balance is only set to zero after send executes.",
        "fixedCode": "function withdrawBalance_19() public { uint balance = userBalance_19[msg.sender]; userBalance_19[msg.sender] = 0; if (!msg.sender.send(balance)) revert(); }"
    },
    {
        "vulnerableLines": "54-56",
        "vulnerabilityReason": "The function sends funds before updating the user balance, leading to a potential reentrancy attack.",
        "potentialSecurityRisk": "Attackers can exploit this to withdraw more ether than allowed by repeatedly invoking this function.",
        "fixedCode": "function withdraw_balances_36() public { uint balance = balances_36[msg.sender]; balances_36[msg.sender] = 0; if (!msg.sender.send(balance)) revert(); }"
    },
    {
        "vulnerableLines": "62-65",
        "vulnerabilityReason": "Using send before incrementing counter_35 can create vulnerabilities by allowing for repeated calls to the function.",
        "potentialSecurityRisk": "An attacker could execute checking_35 multiple times, potentially draining ether if the balance allows for it.",
        "fixedCode": "function checking_35() public { require(counter_35 <= 5); counter_35 += 1; if (!msg.sender.send(10 ether)) revert(); }"
    },
    {
        "vulnerableLines": "70-74",
        "vulnerabilityReason": "The use of call.value before resetting the user balance can lead to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could withdraw more funds than entitled by invoking this function quickly and repeatedly.",
        "fixedCode": "function withdrawBalance_40() public { uint balance = userBalance_40[msg.sender]; userBalance_40[msg.sender] = 0; (bool success, ) = msg.sender.call.value(balance)(''); if (!success) revert(); }"
    },
    {
        "vulnerableLines": "78-82",
        "vulnerabilityReason": "Sending ether before zeroing out userBalance_33 exposes this function to potential reentrant attacks.",
        "potentialSecurityRisk": "Attackers could exploit this to withdraw funds more than once by making rapid calls to this function.",
        "fixedCode": "function withdrawBalance_33() public { uint balance = userBalance_33[msg.sender]; userBalance_33[msg.sender] = 0; (bool success, ) = msg.sender.call.value(balance)(''); if (!success) revert(); }"
    },
    {
        "vulnerableLines": "89-92",
        "vulnerabilityReason": "The function allows sending ether without updating the state variable callcount_27 until after the call, risking reentrant calls.",
        "potentialSecurityRisk": "Attackers could drain funds by repeatedly calling userbalances_27 within a single transaction.",
        "fixedCode": "function userbalances_27() public { require(callcount_27); callcount_27 = false; if (!msg.sender.send(1 ether)) revert(); }"
    },
    {
        "vulnerableLines": "105-109",
        "vulnerabilityReason": "Sending ether before marking callcount_13 can allow reentrant attacks, making it vulnerable.",
        "potentialSecurityRisk": "Attackers could exploit this to withdraw ether multiple times before the controlling state variable changes.",
        "fixedCode": "function userbalances_13() public { require(callcount_13); callcount_13 = false; (bool success, ) = msg.sender.call.value(1 ether)(''); if (!success) revert(); }"
    },
    {
        "vulnerableLines": "98-100",
        "vulnerabilityReason": "The function sends ether to a user without resetting their balance first, leading to potential reentrancy.",
        "potentialSecurityRisk": "This can allow attackers to withdraw excess amounts before balances are decremented, compromising contract funds.",
        "fixedCode": "function withdrawFunds_31(uint256 _weiToWithdraw) public { require(balances_31[msg.sender] >= _weiToWithdraw); balances_31[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    }
]
[
    {
        "vulnerableLines": "5-12",
        "vulnerabilityReason": "The function uses send to transfer the jackpot amount before updating the lastPlayerCheck variable, which makes it vulnerable to reentrancy.",
        "potentialSecurityRisk": "A malicious actor could repeatedly call this function to drain the jackpot amount before the state change is made.",
        "fixedCode": "function buyTicketCheck() public { lastPlayerCheck = msg.sender; require(lastPlayerCheck.send(jackpotCheck)); jackpotCheck = address(this).balance; }"
    },
    {
        "vulnerableLines": "18-24",
        "vulnerabilityReason": "Using call.value to send ether before deducting the user's balance allows reentrancy because the user can call withdrawUserFundsCheck again before their balance is updated.",
        "potentialSecurityRisk": "An attacker could continuously withdraw funds beyond their entitlement by reentering this function before the balance is updated.",
        "fixedCode": "function withdrawUserFundsCheck(uint256 _weiToWithdraw) public { require(balancesUserCheck[msg.sender] >= _weiToWithdraw); balancesUserCheck[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "30-38",
        "vulnerabilityReason": "The function transfers funds before updating the lastPlayerTransfer variable, leading to potential reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this function to repeatedly withdraw funds by calling it multiple times in quick succession.",
        "fixedCode": "function buyTicketTransfer() public { lastPlayerTransfer = msg.sender; (bool success,) = lastPlayerTransfer.call.value(jackpotTransfer)(''); if (!success) revert(); jackpotTransfer = address(this).balance; }"
    },
    {
        "vulnerableLines": "44-50",
        "vulnerabilityReason": "The transfer of rewards occurs before resetting the user's redeemable balance, which exposes the function to a reentrant call.",
        "potentialSecurityRisk": "An attacker could claim rewards multiple times if they can invoke this function again during the transfer.",
        "fixedCode": "function claimRewardTransfer() public { require(redeemableEtherBalancesTransfer[msg.sender] > 0); uint transferValueTransfer = redeemableEtherBalancesTransfer[msg.sender]; redeemableEtherBalancesTransfer[msg.sender] = 0; msg.sender.transfer(transferValueTransfer); }"
    },
    {
        "vulnerableLines": "56-62",
        "vulnerabilityReason": "The call to send occurs before resetting the user's balance, which makes it vulnerable to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could exploit this to drain funds by withdrawing multiple times before the user's balance is reset.",
        "fixedCode": "function withdrawUserBalanceTransfer() public { uint256 balance = userBalanceTransfer[msg.sender]; require(msg.sender.send(balance)); userBalanceTransfer[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "68-75",
        "vulnerabilityReason": "Using call.value to send funds before resetting the user's balance exposes it to reentrancy.",
        "potentialSecurityRisk": "Attackers can repeatedly withdraw funds before their balance is updated, leading to losses for the contract.",
        "fixedCode": "function withdrawUserBalanceWithdrawal() public { uint256 balance = userBalanceWithdrawal[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); require(success); userBalanceWithdrawal[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "81-88",
        "vulnerabilityReason": "The function sends ether before updating the notCalled variable, allowing for reentrant calls during the send operation.",
        "potentialSecurityRisk": "This can allow an attacker to call this function multiple times to drain funds, defeating the purpose of the notCalled check.",
        "fixedCode": "function resetCalled() public { require(notCalled); notCalled = false; require(msg.sender.send(1 ether)); }"
    },
    {
        "vulnerableLines": "96-102",
        "vulnerabilityReason": "Transferring funds occurs before the redeemable balance is reset, exposing the function to reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly claim rewards before their balance is set to zero, leading to financial loss for the contract.",
        "fixedCode": "function claimRewardCheck() public { require(redeemableEtherBalancesCheck[msg.sender] > 0); uint transferValueCheck = redeemableEtherBalancesCheck[msg.sender]; redeemableEtherBalancesCheck[msg.sender] = 0; msg.sender.transfer(transferValueCheck); }"
    },
    {
        "vulnerableLines": "110-115",
        "vulnerabilityReason": "Sending ether before updating the user's balance allows for reentrant calls which could exploit the contract for financial gain.",
        "potentialSecurityRisk": "Attackers could quickly invoke this function multiple times to withdraw more funds than they are allowed to.",
        "fixedCode": "function withdrawUserFundsCheck(uint256 _weiToWithdraw) public { require(balancesUserWithdrawCheck[msg.sender] >= _weiToWithdraw); balancesUserWithdrawCheck[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    }
]
[
    {
        "vulnerableLines": "69-73",
        "vulnerabilityReason": "The function uses call to transfer ether before updating the user's balance, which opens the contract to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could exploit this by calling withdrawFunds multiple times before the user's balance is deducted, draining the contract's funds.",
        "fixedCode": "function withdrawFunds (uint256 _weiToWithdraw) public { require(balances[msg.sender] >= _weiToWithdraw); balances[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "78-83",
        "vulnerabilityReason": "The function sends jackpot ether to the lastPlayer before updating the lastPlayer address, enabling reentrancy.",
        "potentialSecurityRisk": "A malicious user could exploit the reentrancy to repeatedly invoke this function, draining the jackpot funds.",
        "fixedCode": "function buyTicket() public { uint256 currentJackpot = jackpot; (bool success,) = lastPlayer.call.value(currentJackpot)(''); if (!success) revert(); lastPlayer = msg.sender; jackpot = address(this).balance; }"
    },
    {
        "vulnerableLines": "90-94",
        "vulnerabilityReason": "The function sends ether based on the claimable reward before resetting the user's redeemable ether, facilitating reentrancy.",
        "potentialSecurityRisk": "An attacker could call this function multiple times before their redeemable ether is reset, draining funds from the contract.",
        "fixedCode": "function claimReward() public { require(redeemableEther[msg.sender] > 0); uint transferValue = redeemableEther[msg.sender]; redeemableEther[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "98-102",
        "vulnerabilityReason": "The function sends user balance before resetting the user's balance, making it vulnerable to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could exploit this to continuously retrieve funds from the contract, effectively draining it beyond their available balance.",
        "fixedCode": "function withdrawBalance() public { uint256 balance = userBalance[msg.sender]; require(msg.sender.send(balance)); userBalance[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "111-115",
        "vulnerabilityReason": "The function sends ether based on the redeemableBalance before resetting this variable, allowing for reentrancy vulnerabilities.",
        "potentialSecurityRisk": "Attackers could exploit this by repeatedly calling claimRewardAlternative before their balance is reset, draining contract funds.",
        "fixedCode": "function claimRewardAlternative() public { require(redeemableEtherAlternative[msg.sender] > 0); uint transferValue = redeemableEtherAlternative[msg.sender]; redeemableEtherAlternative[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    }
]
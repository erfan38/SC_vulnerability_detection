[
    {
        "vulnerableLines": "51-56",
        "vulnerabilityReason": "The function uses call.value to transfer funds before resetting the user's balance, allowing for potential reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this to repeatedly call this function to withdraw more funds than they are entitled to, draining the contract's balance.",
        "fixedCode": "function withdrawBalance_40() public { uint256 balance = userBalance_40[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) { userBalance_40[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "65-69",
        "vulnerabilityReason": "Funds are sent before the user's balance is deducted, exposing the contract to reentrant calls.",
        "potentialSecurityRisk": "An attacker could drain more funds by invoking this function multiple times before the user's balance is updated.",
        "fixedCode": "function withdrawFunds_10(uint256 _weiToWithdraw) public { require(balances_10[msg.sender] >= _weiToWithdraw); balances_10[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "84-87",
        "vulnerabilityReason": "The function sends ether to the user before updating their balance, facilitating potential reentrancy attacks.",
        "potentialSecurityRisk": "Attackers could exploit this to withdraw funds multiple times, pulling out more than their balance allows.",
        "fixedCode": "function withdraw_balances_21() public { uint256 balance = balances_21[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) balances_21[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "105-110",
        "vulnerabilityReason": "The function sends ether before resetting the user's balance, enabling potential reentrancy.",
        "potentialSecurityRisk": "This allows attackers to call this function repeatedly to withdraw funds, deepening the contract's vulnerabilities.",
        "fixedCode": "function withdrawBalance_12() public { uint256 balance = userBalance_12[msg.sender]; if (!(msg.sender.send(balance))) { revert(); } userBalance_12[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "116-120",
        "vulnerabilityReason": "The function sends the transfer value before updating the redeemable balance, which could lead to reentrant attacks.",
        "potentialSecurityRisk": "Attackers can exploit this to continuously claim rewards before their balance is set to zero, draining the contract.",
        "fixedCode": "function claimReward_11() public { require(redeemableEther_11[msg.sender] > 0); uint transferValue_11 = redeemableEther_11[msg.sender]; redeemableEther_11[msg.sender] = 0; msg.sender.transfer(transferValue_11); }"
    },
    {
        "vulnerableLines": "128-130",
        "vulnerabilityReason": "The function uses call to transfer ether before updating the balance, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker can exploit this function to make repeated calls, potentially draining the contract's ether balance.",
        "fixedCode": "function withdraw_balances_1() public { uint256 amount = balances_1[msg.sender]; (bool success,) = msg.sender.call.value(amount)(''); if (success) { balances_1[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "161-162",
        "vulnerabilityReason": "The function sends ether without checking if the sender has a valid balance and does not update the state before it.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw more ether than they are entitled to.",
        "fixedCode": "function withdraw_balances_29() public { uint256 amount = balances_29[msg.sender]; require(msg.sender.send(amount)); balances_29[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "177-178",
        "vulnerabilityReason": "The call to send ether occurs before the sending address is updated, which allows for potential reentrant calls.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function, leading to unauthorized money withdrawal.",
        "fixedCode": "function buyTicket_16() public { require(!(lastPlayer_16.send(jackpot_16))); lastPlayer_16 = msg.sender; jackpot_16 = address(this).balance; }"
    },
    {
        "vulnerableLines": "185-187",
        "vulnerabilityReason": "Ether is sent to the sender before their balance is decreased, allowing for reentrant calls.",
        "potentialSecurityRisk": "An attacker could exploit this by repeatedly calling this function to drain the funds from the contract.",
        "fixedCode": "function withdrawFunds_24(uint256 _weiToWithdraw) public { require(balances_24[msg.sender] >= _weiToWithdraw); balances_24[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "192-195",
        "vulnerabilityReason": "The function calls send before setting the user's balance to zero, creating a reentrancy vulnerability.",
        "potentialSecurityRisk": "An attacker could withdraw more funds than intended by calling the function multiple times before the state is updated.",
        "fixedCode": "function withdrawBalance_5() public { uint256 amount = userBalance_5[msg.sender]; require(msg.sender.send(amount)); userBalance_5[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "200-201",
        "vulnerabilityReason": "The send operation occurs before resetting the balance, opening up for potential reentrancy exploits.",
        "potentialSecurityRisk": "An attacker can manipulate this by calling the function again before the state mutation, potentially draining more funds.",
        "fixedCode": "function withdraw_balances_15() public { uint256 amount = balances_15[msg.sender]; require(msg.sender.send(amount)); balances_15[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "207-210",
        "vulnerabilityReason": "Balance is not updated before the send call, creating a window for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker can drain the ether balance by exploiting the timing vulnerability in the withdrawal mechanism.",
        "fixedCode": "function userbalance_28() public { require(counter_28 <= 5); counter_28 += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "215-219",
        "vulnerabilityReason": "Using call.value to send ether before the user's balance is updated leads to vulnerability of reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function to withdraw more ether than what was intended, draining funds from the contract.",
        "fixedCode": "function withdrawBalance_33() public { uint256 amount = userBalance_33[msg.sender]; (bool success,) = msg.sender.call.value(amount)(''); if (success) { userBalance_33[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "234-235",
        "vulnerabilityReason": "Ether is sent before updating the user balance which enables a potential attacker to exploit the withdraw function and drain funds.",
        "potentialSecurityRisk": "An attacker can invoke this function multiple times, resulting in unauthorized fund withdrawals.",
        "fixedCode": "function withdrawFunds_31(uint256 _weiToWithdraw) public { require(balances_31[msg.sender] >= _weiToWithdraw); balances_31[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "239-246",
        "vulnerabilityReason": "The function uses call.value to transfer ether before updating the callcount flag, allowing a reentrant call to the function.",
        "potentialSecurityRisk": "An attacker could call this function multiple times before the callcount is set to false, draining funds from the contract.",
        "fixedCode": "function checkbalance_13() public { require(callcount_13); callcount_13 = false; (bool success,) = msg.sender.call.value(1 ether)(''); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "249-256",
        "vulnerabilityReason": "Using send to transfer ether before updating the callcount flag exposes the function to reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this by causing multiple withdrawals before the callcount is set to false, draining funds.",
        "fixedCode": "function checkbalance_34() public { require(callcount_34); callcount_34 = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "258-265",
        "vulnerabilityReason": "The function sends ether before incrementing the counter, allowing a malicious contract to repeatedly invoke this function.",
        "potentialSecurityRisk": "An attacker can drain ether by calling this function multiple times before the limit is reached.",
        "fixedCode": "function userbalance_21() public { require(counter_21 <= 5); counter_21 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "271-278",
        "vulnerabilityReason": "The user balance is transferred before incrementing the counter for withdrawals, which allows reentrant calls.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw more than intended by repeatedly calling this function.",
        "fixedCode": "function userbalance_42() public { require(counter_42 <= 5); counter_42 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "283-290",
        "vulnerabilityReason": "The function attempts to send ether before updating the lastPlayer address, leading to a potential reentrancy attack.",
        "potentialSecurityRisk": "An attacker could call this function again before the player address changes, draining jackpot funds.",
        "fixedCode": "function buyTicket_2() public { require(!(lastPlayer_2.send(jackpot_2))); lastPlayer_2 = msg.sender; jackpot_2 = address(this).balance; }"
    },
    {
        "vulnerableLines": "295-301",
        "vulnerabilityReason": "Using call.value to transfer ether before the user's balance is reset exposes the contract to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could exploit this by calling the function again before their balance is updated, withdrawing more funds.",
        "fixedCode": "function withdrawFunds_17(uint256 _weiToWithdraw) public { require(balances_17[msg.sender] >= _weiToWithdraw); balances_17[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "306-313",
        "vulnerabilityReason": "The buyTicket function uses send before updating the lastPlayer address, facilitating reentrant calls.",
        "potentialSecurityRisk": "An attacker could drain funds by forcing multiple calls to buyTicket_37 before the lastPlayer address is updated.",
        "fixedCode": "function buyTicket_37() public { require(!(lastPlayer_37.send(jackpot_37))); lastPlayer_37 = msg.sender; jackpot_37 = address(this).balance; }"
    },
    {
        "vulnerableLines": "320-326",
        "vulnerabilityReason": "The function uses call.value to send ether to users before resetting their balance, allowing for reentrant attacks.",
        "potentialSecurityRisk": "Attackers could exploit this vulnerability to withdraw more than allowed by invoking the function multiple times.",
        "fixedCode": "function withdrawFunds_3(uint256 _weiToWithdraw) public { require(balances_3[msg.sender] >= _weiToWithdraw); balances_3[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "332-339",
        "vulnerabilityReason": "The transfer happens before updating the lastPlayer address, allowing reentrancy through repeated calls.",
        "potentialSecurityRisk": "An attacker may exploit the timing of the call to drain funds from the jackpot repeatedly.",
        "fixedCode": "function buyTicket_9() public { require((lastPlayer_9.call.value(jackpot_9)(''))); if (!success) revert(); lastPlayer_9 = msg.sender; jackpot_9 = address(this).balance; }"
    },
    {
        "vulnerableLines": "342-384",
        "vulnerabilityReason": "The transfer function deducts the sender's balance after calling external contracts, which allows for a reentrant call before the balance is updated.",
        "potentialSecurityRisk": "A malicious contract could call the transfer function repeatedly before balances are updated, allowing the attacker to drain more tokens than they actually hold.",
        "fixedCode": "function transfer(address to, uint256 value) public returns (bool) { require(value <= _balances[msg.sender]); require(to != address(0)); uint256 tokensToTransfer = value; uint256 tokensToBurn = 0; uint256 tokensToDanPan = 0; if (value == 0) { emit Transfer(msg.sender, to, 0); return true; } _balances[msg.sender] = _balances[msg.sender].sub(value); if (!_isWhitelisted(msg.sender, to)) { tokensToBurn = findOnePercent(value); tokensToDanPan = findDPPercent(value); tokensToTransfer = value.sub(tokensToBurn).sub(tokensToDanPan); _totalSupply = _totalSupply.sub(tokensToBurn); emit Transfer(msg.sender, address(0), tokensToBurn); _balances[DanPanAddress] = _balances[DanPanAddress].add(tokensToDanPan); emit Transfer(msg.sender, DanPanAddress, tokensToDanPan); } assert(tokensToBurn.add(tokensToTransfer).add(tokensToDanPan) == value); _balances[to] = _balances[to].add(tokensToTransfer); emit Transfer(msg.sender, to, tokensToTransfer); return true; }"
    },
    {
        "vulnerableLines": "385-391",
        "vulnerabilityReason": "The claimReward function transfers ether before resetting the user's redeemable balance, allowing a potential reentrant attack.",
        "potentialSecurityRisk": "An attacker can exploit this to reenter the function after the reward transfer but before the balance reset, claiming rewards multiple times.",
        "fixedCode": "function claimReward_25() public { require(redeemableEther_25[msg.sender] > 0); uint transferValue_25 = redeemableEther_25[msg.sender]; redeemableEther_25[msg.sender] = 0; msg.sender.transfer(transferValue_25); }"
    },
    {
        "vulnerableLines": "399-403",
        "vulnerabilityReason": "Using send to transfer user's balance without updating the user's balance first invites reentrancy.",
        "potentialSecurityRisk": "An attacker can repeatedly call withdrawBalance_19 to withdraw more than intended before the balance is set to zero.",
        "fixedCode": "function withdrawBalance_19() public { uint amount = userBalance_19[msg.sender]; require(amount > 0); userBalance_19[msg.sender] = 0; require(msg.sender.send(amount)); }"
    },
    {
        "vulnerableLines": "412-418",
        "vulnerabilityReason": "The withdrawBalance_26 function uses call.value to transfer funds before resetting the user's balance.",
        "potentialSecurityRisk": "An attacker could exploit this to call the function multiple times before the balance is set to zero, draining funds.",
        "fixedCode": "function withdrawBalance_26() public { uint amount = userBalance_26[msg.sender]; require(amount > 0); userBalance_26[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(''); require(success); }"
    },
    {
        "vulnerableLines": "421-462",
        "vulnerabilityReason": "The transferFrom function calls external contracts before updating balances, allowing for a reentrance opportunity.",
        "potentialSecurityRisk": "Similar to the transfer function, an attacker can call transferFrom exploitatively to gain more tokens than held by calling this repeatedly.",
        "fixedCode": "function transferFrom(address from, address to, uint256 value) public returns (bool) { require(value <= _balances[from]); require(value <= _allowed[from][msg.sender]); require(to != address(0)); if (value == 0) { emit Transfer(from, to, 0); return true; } _balances[from] = _balances[from].sub(value); uint256 tokensToTransfer = value; uint256 tokensToBurn = 0; uint256 tokensToDanPan = 0; if (!_isWhitelisted(from, to)) { tokensToBurn = findOnePercent(value); tokensToDanPan = findDPPercent(value); tokensToTransfer = value.sub(tokensToBurn).sub(tokensToDanPan); _totalSupply = _totalSupply.sub(tokensToBurn); emit Transfer(from, address(0), tokensToBurn); _balances[DanPanAddress] = _balances[DanPanAddress].add(tokensToDanPan); emit Transfer(from, DanPanAddress, tokensToDanPan); } assert(tokensToBurn.add(tokensToTransfer).add(tokensToDanPan) == value); _balances[to] = _balances[to].add(tokensToTransfer); _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value); emit Transfer(from, to, tokensToTransfer); return true; }"
    },
    {
        "vulnerableLines": "464-470",
        "vulnerabilityReason": "The function sends ether using send before updating the state variable callcount_20. This allows reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker can exploit this to call the function multiple times before callcount_20 is updated, draining the contract's remaining ether.",
        "fixedCode": "function checkbalance_20() public { require(callcount_20); callcount_20 = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "478-484",
        "vulnerabilityReason": "Ether is sent using transfer before the user's redeemable balance is reset, inviting reentrancy.",
        "potentialSecurityRisk": "An attacker could call this function again during the ether transfer, allowing them to withdraw more funds than they are entitled to.",
        "fixedCode": "function claimReward_32() public { require(redeemableEther_32[msg.sender] > 0); uint transferValue_32 = redeemableEther_32[msg.sender]; redeemableEther_32[msg.sender] = 0; msg.sender.transfer(transferValue_32); }"
    },
    {
        "vulnerableLines": "492-497",
        "vulnerabilityReason": "The function uses send to transfer funds before deducting the user's balance, which can be exploited through reentrancy.",
        "potentialSecurityRisk": "Reentrant calls may allow an attacker to withdraw more than they have in their balance, draining the contract.",
        "fixedCode": "function withdrawFunds_38 (uint256 _weiToWithdraw) public { require(balances_38[msg.sender] >= _weiToWithdraw); balances_38[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "504-510",
        "vulnerabilityReason": "Similar to other reward claim functions, ether is sent before the redeemable balance is reset, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could manipulate the call in such a way that they drain more ether from the contract than permitted.",
        "fixedCode": "function claimReward_4() public { require(redeemableEther_4[msg.sender] > 0); uint transferValue_4 = redeemableEther_4[msg.sender]; redeemableEther_4[msg.sender] = 0; msg.sender.transfer(transferValue_4); }"
    },
    {
        "vulnerableLines": "515-522",
        "vulnerabilityReason": "The send function occurs before updating the counter, allowing for multiple withdrawals based on the limit.",
        "potentialSecurityRisk": "By exploiting this, an attacker could repeatedly obtain ether before the intended limit is enforced.",
        "fixedCode": "function userbalance_7() public { require(counter_7 <= 5); counter_7 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "531-537",
        "vulnerabilityReason": "The function sends ether before updating the lastPlayer_23 variable, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "Attackers could drain funds by exploiting the chance to claim tickets multiple times.",
        "fixedCode": "function buyTicket_23() public { if (!(lastPlayer_23.send(jackpot_23))) revert(); lastPlayer_23 = msg.sender; jackpot_23 = address(this).balance; }"
    },
    {
        "vulnerableLines": "545-552",
        "vulnerabilityReason": "The counter used for withdrawal is incremented after sending ether, risking multiple exploitations.",
        "potentialSecurityRisk": "An attacker may withdraw multiple times within one transaction, abusing the counter before it updates.",
        "fixedCode": "function userbalance_14() public { require(counter_14 <= 5); counter_14 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "559-565",
        "vulnerabilityReason": "Similar to other buy ticket methods, sending ether occurs before updating the state variable, which can be exploited.",
        "potentialSecurityRisk": "This allows potential attackers multiple chances to withdraw ether, draining the contract funds.",
        "fixedCode": "function buyTicket_30() public { if (!(lastPlayer_30.send(jackpot_30))) revert(); lastPlayer_30 = msg.sender; jackpot_30 = address(this).balance; }"
    },
    {
        "vulnerableLines": "573-577",
        "vulnerabilityReason": "The use of call.value() to send funds occurs before clearing the user's balance, creating a reentrancy window.",
        "potentialSecurityRisk": "Exploiting this could allow multiple withdrawals before the balance is cleared, draining contract funds.",
        "fixedCode": "function withdraw_balances_8 () public { uint256 balance = balances_8[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) balances_8[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "584-588",
        "vulnerabilityReason": "The `transfer` call occurs before the redeemable balance is reset, allowing reentrancy attacks where an attacker could call `claimReward_39` multiple times.",
        "potentialSecurityRisk": "An attacker can drain the contract funds repeatedly by exploiting the vulnerability before the user's balance is set to zero.",
        "fixedCode": "function claimReward_39() public { require(redeemableEther_39[msg.sender] > 0); uint transferValue_39 = redeemableEther_39[msg.sender]; redeemableEther_39[msg.sender] = 0; msg.sender.transfer(transferValue_39); }"
    },
    {
        "vulnerableLines": "596-598",
        "vulnerabilityReason": "Sending ether using `send` before resetting the balance allows an attacker to re-enter this function, allowing multiple withdrawals.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw ether more times than they are entitled to, draining the contract balance.",
        "fixedCode": "function withdraw_balances_36() public { uint balance = balances_36[msg.sender]; if (msg.sender.send(balance)) { balances_36[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "605-611",
        "vulnerabilityReason": "This function uses `send` to transfer ether before incrementing the counter, enabling reentrant calls which allow it to exceed limits.",
        "potentialSecurityRisk": "Attackers could exploit this function to receive more ether over the established limit, significantly draining the contract.",
        "fixedCode": "function userbalance_35() public { require(counter_35 <= 5); counter_35 += 1; require(msg.sender.send(10 ether)); }"
    }
]
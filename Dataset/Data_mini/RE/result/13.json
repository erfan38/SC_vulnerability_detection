[
    {
        "vulnerableLines": "9-14",
        "vulnerabilityReason": "The function calls send to transfer ether before updating the not_called_once invariant, opening the possibility for reentrant calls.",
        "potentialSecurityRisk": "A malicious contract could call this function repeatedly to siphon funds before the flag is updated, draining the contract.",
        "fixedCode": "function withdrawalFunction_once() public { require(not_called_once); not_called_once = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "18-23",
        "vulnerabilityReason": "The transfer occurs before the user balance is reset, creating a window for a reentrant attack.",
        "potentialSecurityRisk": "An attacker could withdraw their reward repeatedly by exploiting this vulnerability before their balance is reset.",
        "fixedCode": "function claimReward_mapping() public { require(redeemableEther_mapping[msg.sender] > 0); uint transferValue_mapping = redeemableEther_mapping[msg.sender]; redeemableEther_mapping[msg.sender] = 0; msg.sender.transfer(transferValue_mapping); }"
    },
    {
        "vulnerableLines": "26-30",
        "vulnerabilityReason": "Using send to transfer funds before deducting from the user's balance exposes this function to reentrancy.",
        "potentialSecurityRisk": "An attacker can execute this function multiple times, withdrawing more than allowed before the balance is updated.",
        "fixedCode": "function withdrawFunds_mapping (uint256 _weiToWithdraw) public { require(balances_mapping[msg.sender] >= _weiToWithdraw); balances_mapping[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "33-38",
        "vulnerabilityReason": "As with previous functions, funds are sent before resetting the redeemable balance, exposing it to reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function and withdraw more than allowed before the balance reset occurs.",
        "fixedCode": "function claimReward_mapping2() public { require(redeemableEther_mapping2[msg.sender] > 0); uint transferValue_mapping2 = redeemableEther_mapping2[msg.sender]; redeemableEther_mapping2[msg.sender] = 0; msg.sender.transfer(transferValue_mapping2); }"
    },
    {
        "vulnerableLines": "42-48",
        "vulnerabilityReason": "Sending ether occurs prior to updating the counter limit; thus, reentrancy is possible.",
        "potentialSecurityRisk": "An attacker can exploit this to bypass the call limit, draining funds from the contract multiple times.",
        "fixedCode": "function callme_limit() public { require(counter_limit <= 5); counter_limit += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "52-57",
        "vulnerabilityReason": "The send function is called before setting the lastPlayer_mapping to the new player, which can lead to reentrancy.",
        "potentialSecurityRisk": "A malicious actor could drain the jackpot repeatedly before their address is updated, benefiting from multiple withdrawals.",
        "fixedCode": "function buyTicket_mapping() public { lastPlayer_mapping = msg.sender; require(!(lastPlayer_mapping.send(jackpot_mapping))); jackpot_mapping = address(this).balance; }"
    },
    {
        "vulnerableLines": "61-66",
        "vulnerabilityReason": "As with the first withdrawal function, this one allows for reentrant calls by not updating the state before sending funds.",
        "potentialSecurityRisk": "Reentrancy could lead to loss of funds as an attacker exploits the vulnerabilities present in this sequence.",
        "fixedCode": "function withdrawalFunction_once2() public { require(not_called_once2); not_called_once2 = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "71-75",
        "vulnerabilityReason": "Again, this function allows a reentrant attack by sending funds before updating the balance.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw more ether than they have available before their balance is adjusted.",
        "fixedCode": "function withdrawFunds_mapping2 (uint256 _weiToWithdraw) public { require(balances_mapping2[msg.sender] >= _weiToWithdraw); balances_mapping2[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "79-85",
        "vulnerabilityReason": "Similar to previous withdrawal functions, it allows external calls prior to state modification, exposing it to reentrancy issues.",
        "potentialSecurityRisk": "An attacker may repeat the withdraw function, draining funds before the not_called_once3 variable is set to false.",
        "fixedCode": "function withdrawalFunction_once3() public { require(not_called_once3); not_called_once3 = false; (bool success,) = msg.sender.call.value(1 ether)(''); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "100-106",
        "vulnerabilityReason": "The use of send allows for reentrancy by sending funds before revising the counter, making repeated calls possible.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw ether multiple times unregulated by the limits imposed.",
        "fixedCode": "function callme_limit2() public { require(counter_limit2 <= 5); counter_limit2 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "120-125",
        "vulnerabilityReason": "The function uses send to transfer funds to lastPlayer_mapping2 before updating its state, creating a reentrancy vulnerability.",
        "potentialSecurityRisk": "An attacker could potentially exploit this to drain the contract of funds by invoking the function multiple times before the state is updated.",
        "fixedCode": "function buyTicket_mapping2() public { jackpot_mapping2 = address(this).balance; if (!(lastPlayer_mapping2.send(jackpot_mapping2))) revert(); lastPlayer_mapping2 = msg.sender; }"
    },
    {
        "vulnerableLines": "132-136",
        "vulnerabilityReason": "The function transfers funds before resetting the user's balance, which allows for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could call this function recursively, withdrawing more funds than they are entitled to, draining the contract's balance.",
        "fixedCode": "function withdraw_balances_mapping3() public { uint256 balance = balances_mapping3[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) balances_mapping3[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "144-149",
        "vulnerabilityReason": "This function sends ether before the user's redeemable balance is reset, which may lead to reentrancy.",
        "potentialSecurityRisk": "An attacker may repeatedly call this function to withdraw more than their reward entitlement, depleting contract funds.",
        "fixedCode": "function claimReward_mapping3() public { require(redeemableEther_mapping3[msg.sender] > 0); uint transferValue_mapping3 = redeemableEther_mapping3[msg.sender]; redeemableEther_mapping3[msg.sender] = 0; msg.sender.transfer(transferValue_mapping3); }"
    },
    {
        "vulnerableLines": "158-162",
        "vulnerabilityReason": "Using send to transfer ether before resetting the user's balance exposes the function to reentrancy attacks.",
        "potentialSecurityRisk": "An adversary could exploit this function to drain the contract by executing multiple withdrawals before the balance is reset.",
        "fixedCode": "function withdraw_balances_mapping4() public { uint256 balance = balances_mapping4[msg.sender]; if (msg.sender.send(balance)) { balances_mapping4[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "174-179",
        "vulnerabilityReason": "Sending ether before updating the counter limit allows for reentrant calls that could manipulate the counter limit.",
        "potentialSecurityRisk": "An attacker could make repeated calls, potentially draining the contract of funds allocated for this limit.",
        "fixedCode": "function callme_limit3() public { require(counter_limit3 <= 5); counter_limit3 += 1; if (!(msg.sender.send(10 ether))) revert(); }"
    },
    {
        "vulnerableLines": "190-195",
        "vulnerabilityReason": "The function transfers funds before clearing the user balance, making it susceptible to reentrancy.",
        "potentialSecurityRisk": "Malicious users can drain more funds than intended by exploiting the reentrancy during the ether send.",
        "fixedCode": "function withdrawBalance_mapping() public { uint256 balance = userBalance_mapping[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) userBalance_mapping[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "208-213",
        "vulnerabilityReason": "Sending ether before resetting the user's balance introduces a reentrancy vulnerability.",
        "potentialSecurityRisk": "An attacker can exploit this to withdraw multiple times rapidly, receiving unauthorized funds from the contract.",
        "fixedCode": "function withdrawBalance_mapping2() public { uint256 balance = userBalance_mapping2[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) userBalance_mapping2[msg.sender] = 0; }"
    }
]
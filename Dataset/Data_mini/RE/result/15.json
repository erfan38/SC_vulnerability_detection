[
    {
        "vulnerableLines": "8-15",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the isNotCalled variable, allowing for reentrant calls to this function.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function before isNotCalled is set to false, allowing them to siphon multiple ethers from the contract.",
        "fixedCode": "function executeOnce() public { require(isNotCalled); isNotCalled = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "17-23",
        "vulnerabilityReason": "The function transfers ether before resetting the user's balance in redeemableEther, making it susceptible to reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function while claiming rewards, draining the contract funds irresponsibly.",
        "fixedCode": "function claimReward() public { require(redeemableEther[msg.sender] > 0); uint transferValue = redeemableEther[msg.sender]; redeemableEther[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "25-30",
        "vulnerabilityReason": "The function uses send to transfer funds before deducting from the user's balance, exposing the contract to reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw more funds than they are entitled to by repeatedly calling this function during the ether transfer.",
        "fixedCode": "function withdrawFunds(uint256 _weiToWithdraw) public { require(balances[msg.sender] >= _weiToWithdraw); balances[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "32-38",
        "vulnerabilityReason": "The function sends ether before resetting the redeemableEtherAnother balance, thus allowing reentrancy.",
        "potentialSecurityRisk": "Repeated calls could allow users to claim more than they are entitled to, draining contract funds.",
        "fixedCode": "function claimRewardAnother() public { require(redeemableEtherAnother[msg.sender] > 0); uint transferValue = redeemableEtherAnother[msg.sender]; redeemableEtherAnother[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "41-48",
        "vulnerabilityReason": "The function transfers ether before updating the executionCounter, making it vulnerable to reentrant calls.",
        "potentialSecurityRisk": "An attacker could repeatedly invoke this function to claim ether beyond the defined limit, potentially draining the contract.",
        "fixedCode": "function executeWithLimit() public { require(executionCounter <= 5); if (!(msg.sender.send(10 ether))) { revert(); } executionCounter += 1; }"
    },
    {
        "vulnerableLines": "50-57",
        "vulnerabilityReason": "This function uses send to transfer the jackpot amount before updating lastPlayer, allowing for reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function to drain more funds relative to the jackpot before it gets updated.",
        "fixedCode": "function buyTicket() public { require(!(lastPlayer.send(jackpot))); lastPlayer = msg.sender; jackpot = address(this).balance; }"
    },
    {
        "vulnerableLines": "60-67",
        "vulnerabilityReason": "The function transfers ether before changing the anotherNotCalled state, exposing it to reentrancy.",
        "potentialSecurityRisk": "Repeated calls could lead to the draining of the contract's ether supply by exploiting this vulnerability.",
        "fixedCode": "function executeAnotherOnce() public { require(anotherNotCalled); anotherNotCalled = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "70-75",
        "vulnerabilityReason": "Using send to transfer funds before updating balancesAnother makes it vulnerable to reentrancy attacks.",
        "potentialSecurityRisk": "Attackers could exploit this to withdraw more funds than intended by continuously invoking this function.",
        "fixedCode": "function withdrawFundsAnother(uint256 _weiToWithdraw) public { require(balancesAnother[msg.sender] >= _weiToWithdraw); balancesAnother[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "79-86",
        "vulnerabilityReason": "This function sends ether before marking specialNotCalled as false, which allows for potential reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly execute this to withdraw more than the intended amount of ether.",
        "fixedCode": "function executeSpecialOnce() public { require(specialNotCalled); specialNotCalled = false; (bool success,) = msg.sender.call.value(1 ether)(''); if (!success) { revert(); } }"
    },
    {
        "vulnerableLines": "100-106",
        "vulnerabilityReason": "Sending ether before updating anotherCounter increases vulnerability to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could call this function multiple times to drain more ether than permissible.",
        "fixedCode": "function executeAnotherWithLimit() public { require(anotherCounter <= 5); if (!(msg.sender.send(10 ether))) { revert(); } anotherCounter += 1; }"
    },
    {
        "vulnerableLines": "120-125",
        "vulnerabilityReason": "The function sends ether to lastPlayerAnother before updating lastPlayerAnother and jackpotAnother, making it vulnerable to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function, receiving the jackpot multiple times before state updates occur.",
        "fixedCode": "function buyTicketAnother() public { jackpotAnother = address(this).balance; require(lastPlayerAnother.send(jackpotAnother)); lastPlayerAnother = msg.sender; }"
    },
    {
        "vulnerableLines": "132-136",
        "vulnerabilityReason": "The function uses call.value to transfer funds before resetting the user's balance, exposing it to reentrancy.",
        "potentialSecurityRisk": "This allows an attacker to call this function multiple times before the balance is set to zero, potentially draining the contract's funds.",
        "fixedCode": "function withdrawBalancesSpecial() public { uint256 balance = balancesSpecial[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) balancesSpecial[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "145-149",
        "vulnerabilityReason": "Direct transfer of funds to the user occurs before resetting the redeemable balance, creating an opportunity for reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this to claim rewards multiple times before the redeemable balance is zeroed out.",
        "fixedCode": "function claimRewardRedeemable() public { require(redeemableEther[msg.sender] > 0); uint transferValueRedeemable = redeemableEther[msg.sender]; redeemableEther[msg.sender] = 0; msg.sender.transfer(transferValueRedeemable); }"
    },
    {
        "vulnerableLines": "159-162",
        "vulnerabilityReason": "This function uses send to transfer balance before updating the user's balance, allowing reentrant calls.",
        "potentialSecurityRisk": "An attacker can take advantage of this to withdraw more ether than they originally held in the contract.",
        "fixedCode": "function withdrawExtraBalances() public { uint256 balance = balancesExtra[msg.sender]; if (msg.sender.send(balance)) { balancesExtra[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "173-180",
        "vulnerabilityReason": "The function sends ether before the specialCounter is updated, permitting reentrant execution, which could allow multiple withdrawals.",
        "potentialSecurityRisk": "An attacker could exploit the gap to withdraw more ether than expected by invoking this function repeatedly.",
        "fixedCode": "function executeSpecialCounter() public { require(specialCounter <= 5); specialCounter += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "190-195",
        "vulnerabilityReason": "Using call.value to send the user's balance before resetting their user balance makes the function vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker can exploit this weakness to withdraw funds multiple times before their balance is set to zero, draining the contract.",
        "fixedCode": "function withdrawUserBalance() public { uint256 balance = userBalances[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) userBalances[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "208-213",
        "vulnerabilityReason": "The use of call.value to transfer funds occurs before setting the user's additional balance to zero, making it vulnerable to reentrant calls.",
        "potentialSecurityRisk": "An attacker can continually exploit this vulnerability to drain funds from their user additional balance.",
        "fixedCode": "function withdrawUserAdditionalBalance() public { uint256 balance = userAdditionalBalances[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) userAdditionalBalances[msg.sender] = 0; }"
    }
]
[
    {
        "vulnerableLines": "4-11",
        "vulnerabilityReason": "The function sends ether to the caller before updating the state variable isFunctionNotCalled27, which allows for reentrant calls.",
        "potentialSecurityRisk": "An attacker could exploit this vulnerability to repeatedly call this function and drain ether before the state variable is changed.",
        "fixedCode": "function exampleFunction27() public { require(isFunctionNotCalled27); isFunctionNotCalled27 = false; require(msg.sender.send(1 ether)); }"
    },
    {
        "vulnerableLines": "13-18",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the balance of the caller, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "A malicious actor could manipulate the withdrawal process to drain funds from the contract by invoking this function recursively.",
        "fixedCode": "function withdrawFunds31 (uint256 _weiToWithdraw) public { require(balances31[msg.sender] >= _weiToWithdraw); balances31[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "20-27",
        "vulnerabilityReason": "This function utilizes call.value to send ether before the state variable is updated, enabling reentrant exploitation.",
        "potentialSecurityRisk": "An attacker can call the function multiple times before the function completes, draining funds from the smart contract.",
        "fixedCode": "function exampleFunction13() public { require(isFunctionNotCalled13); isFunctionNotCalled13 = false; (bool success,) = msg.sender.call.value(1 ether)(''); require(success); }"
    },
    {
        "vulnerableLines": "31-39",
        "vulnerabilityReason": "The function sends the jackpot amount before updating lastPlayer9. An attacker could call buyTicket9 multiple times to grab more ether.",
        "potentialSecurityRisk": "Malicious contracts could exploit this access to drain the entire jackpot amount by repeatedly calling this function.",
        "fixedCode": "function buyTicket9() public { require(!(lastPlayer9.call.value(jackpot9)(''))); lastPlayer9 = msg.sender; jackpot9 = address(this).balance; }"
    },
    {
        "vulnerableLines": "41-46",
        "vulnerabilityReason": "The function transfers ether to the user before clearing their redeemable ether balance, exposing it to reentrancy exploits.",
        "potentialSecurityRisk": "An attacker could invoke this function multiple times before the balance resets, extracting more ether than intended.",
        "fixedCode": "function claimReward25() public { require(redeemableEther25[msg.sender] > 0); uint transferValue25 = redeemableEther25[msg.sender]; redeemableEther25[msg.sender] = 0; msg.sender.transfer(transferValue25); }"
    },
    {
        "vulnerableLines": "49-54",
        "vulnerabilityReason": "Ether is sent before userBalance19 is reset, allowing for potential reentrant attacks.",
        "potentialSecurityRisk": "A malicious actor could drain funds by exploiting the withdrawal process with repeated calls before their balance is reset.",
        "fixedCode": "function withdrawBalance19() public { uint balance = userBalance19[msg.sender]; require(msg.sender.send(balance)); userBalance19[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "57-63",
        "vulnerabilityReason": "Using call.value to transfer funds prior to updating the user balance enables the risk of reentrancy.",
        "potentialSecurityRisk": "Attackers may exploit this to withdraw more funds than they are entitled to by calling the function multiple times.",
        "fixedCode": "function withdrawBalance26() public { uint256 balance = userBalance26[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); require(success); userBalance26[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "66-72",
        "vulnerabilityReason": "This function sends ether before updating isFunctionNotCalled20, making it susceptible to reentrant calls.",
        "potentialSecurityRisk": "Attackers can repeatedly call this function to extract ether from the contract, avoiding state changes that would prevent this.",
        "fixedCode": "function exampleFunction20() public { require(isFunctionNotCalled20); isFunctionNotCalled20 = false; require(msg.sender.send(1 ether)); }"
    },
    {
        "vulnerableLines": "76-82",
        "vulnerabilityReason": "The claimReward32 function sends ether before resetting the redeemable balance, which is vulnerable to reentrancy.",
        "potentialSecurityRisk": "A malicious user could exploit this vulnerability to claim rewards multiple times before their balance is cleared.",
        "fixedCode": "function claimReward32() public { require(redeemableEther32[msg.sender] > 0); uint transferValue32 = redeemableEther32[msg.sender]; redeemableEther32[msg.sender] = 0; msg.sender.transfer(transferValue32); }"
    },
    {
        "vulnerableLines": "84-89",
        "vulnerabilityReason": "Sending ethers to the user before adjusting their balance creates a reentrancy risk.",
        "potentialSecurityRisk": "An attacker can exploit the withdrawal process to call this function multiple times and withdraw more ether than permitted.",
        "fixedCode": "function withdrawFunds38 (uint256 _weiToWithdraw) public { require(balances38[msg.sender] >= _weiToWithdraw); balances38[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "92-98",
        "vulnerabilityReason": "Transferring ether before updating the redeemable balance exposes this function to reentrancy attacks.",
        "potentialSecurityRisk": "Fraudulent calls could lead to unauthorized withdrawals, draining the contract balance beyond intended limits.",
        "fixedCode": "function claimReward4() public { require(redeemableEther4[msg.sender] > 0); uint transferValue4 = redeemableEther4[msg.sender]; redeemableEther4[msg.sender] = 0; msg.sender.transfer(transferValue4); }"
    },
    {
        "vulnerableLines": "122-128",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the counter, opening it to reentrant calls.",
        "potentialSecurityRisk": "An attacker could exploit this by calling the function repeatedly, draining funds from the contract.",
        "fixedCode": "function callme7() public { require(counter7 <= 5); counter7 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "131-142",
        "vulnerabilityReason": "No reentrancy protection is present during the transfer process, which could result in a malicious contract draining funds.",
        "potentialSecurityRisk": "If a malicious contract calls this function during an ongoing transfer, it may receive multiple funds before the balance is updated.",
        "fixedCode": "function transfer(address _to, uint256 _value) public returns (bool success) { assert(_to != address(this) && !isTransPaused && balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender == owner ? address(this) : msg.sender, _to, _value); return true; }"
    },
    {
        "vulnerableLines": "150-157",
        "vulnerabilityReason": "The function sends ether without updating the lastPlayer23 address, exposing it to reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this by repeatedly calling the function, collecting more funds than allowed.",
        "fixedCode": "function buyTicket23() public { require(!(lastPlayer23.send(jackpot23))); lastPlayer23 = msg.sender; jackpot23 = address(this).balance; }"
    },
    {
        "vulnerableLines": "160-181",
        "vulnerabilityReason": "No changes to the allowed mapping or user balances occur until after the transfer process, leading to potential reentrancy.",
        "potentialSecurityRisk": "An attacker could drain funds through repeated calls during the execution of this transfer function.",
        "fixedCode": "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { assert(_to != address(this) && !isTransPaused && balances[_from] >= _value && allowed[_from][msg.sender] >= _value); balances[_to] += _value; balances[_from] -= _value; if (allowed[_from][msg.sender] < MAX_UINT256) { allowed[_from][msg.sender] -= _value; } emit Transfer(_from == owner ? address(this) : _from, _to, _value); return true; }"
    },
    {
        "vulnerableLines": "182-188",
        "vulnerabilityReason": "Similar to previous instances, send is used before updating the counter, permitting reentrancy.",
        "potentialSecurityRisk": "An exploiter can trigger this function repeatedly before the counter's state is adjusted, impacting contract balances.",
        "fixedCode": "function callme14() public { require(counter14 <= 5); counter14 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "214-217",
        "vulnerabilityReason": "Using call.value without safely managing the user's balance creates a reentrancy risk.",
        "potentialSecurityRisk": "This allows an attacker to exploit the withdrawal by re-invoking the function before the balance is reduced.",
        "fixedCode": "function withdraw_balances8() public { uint256 balance = balances8[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) balances8[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "223-228",
        "vulnerabilityReason": "Native transfer occurs prior to balance resetting, enabling potential reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could continue to extract funds before the contract state is updated.",
        "fixedCode": "function claimReward39() public { require(redeemableEther39[msg.sender] > 0); uint transferValue39 = redeemableEther39[msg.sender]; redeemableEther39[msg.sender] = 0; msg.sender.transfer(transferValue39); }"
    },
    {
        "vulnerableLines": "239-242",
        "vulnerabilityReason": "The send function transmits funds before resetting balances36, making it susceptible to reentry.",
        "potentialSecurityRisk": "It enables multiple withdrawals in a single transaction, draining the contract's balance unexpectedly.",
        "fixedCode": "function withdraw_balances36() public { uint256 balance = balances36[msg.sender]; if (msg.sender.send(balance)) { balances36[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "248-254",
        "vulnerabilityReason": "The function uses send to transfer ether before updating the counter, allowing potential re-entry into this function.",
        "potentialSecurityRisk": "An attacker could exploit this by repeatedly calling the function to drain funds beyond the intended limit.",
        "fixedCode": "function callme35() public { require(counter35 <= 5); counter35 += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "262-268",
        "vulnerabilityReason": "The function uses call.value to send ether before zeroing out the user's balance, allowing reentrancy.",
        "potentialSecurityRisk": "An attacker can exploit this to repeatedly withdraw funds before their balance is updated, draining the contract.",
        "fixedCode": "function withdrawBalance40() public { uint256 balance = userBalance40[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) { userBalance40[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "275-281",
        "vulnerabilityReason": "The function uses call.value to send ethers and does not update the user's balance before sending out funds, exposing it to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could cause multiple withdrawals before the user's balance is reset, draining the contract's balance.",
        "fixedCode": "function withdrawBalance33() public { uint256 balance = userBalance33[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) { userBalance33[msg.sender] = 0; } }"
    }
]
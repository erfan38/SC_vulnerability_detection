[
    {
        "vulnerableLines": "6-11",
        "vulnerabilityReason": "The function uses send to transfer funds to the last ticket buyer before updating the local state, allowing for reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could create a malicious contract that, upon receiving funds, calls back into this function before the state change occurs, allowing them to claim multiple tickets.",
        "fixedCode": "function buyTicket() public { uint ticketAmount = jackpot_ticket; require(!(lastPlayer_ticketBuyer.send(ticketAmount))); lastPlayer_ticketBuyer = msg.sender; jackpot_ticket = address(this).balance; }"
    },
    {
        "vulnerableLines": "14-18",
        "vulnerabilityReason": "The withdrawal uses call to transfer funds before updating the balance, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker can invoke this function multiple times during the transfer, withdrawing more than their allowable balance.",
        "fixedCode": "function withdrawFunds(uint256 _weiToWithdraw) public { require(balances_withdrawable[msg.sender] >= _weiToWithdraw); balances_withdrawable[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "22-28",
        "vulnerabilityReason": "Sending ether occurs before updating the not_called_ownerChange variable, making this function susceptible to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly call this function, draining the contract's ether by invoking it during each transfer.",
        "fixedCode": "function initiateOwnerChange() public { require(not_called_ownerChange); not_called_ownerChange = false; require(msg.sender.send(1 ether)); }"
    },
    {
        "vulnerableLines": "36-40",
        "vulnerabilityReason": "This function transfers rewards before setting the user's redeemable balance to zero, allowing for reentrant calls.",
        "potentialSecurityRisk": "An attacker could exploit this vulnerability to claim multiple rewards in one transaction before the state is updated.",
        "fixedCode": "function claimReward() public { require(redeemableEther_balance[msg.sender] > 0); uint transferValue = redeemableEther_balance[msg.sender]; redeemableEther_balance[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "52-55",
        "vulnerabilityReason": "Using send to withdraw funds before modifying the balance exposes the function to reentrancy risks.",
        "potentialSecurityRisk": "An attacker might use a malicious contract to call this method token and withdraw multiple times before the user's balance is adjusted.",
        "fixedCode": "function withdrawFundsStake(uint256 _weiToWithdraw) public { require(balances_staked[msg.sender] >= _weiToWithdraw); balances_staked[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "102-108",
        "vulnerabilityReason": "Here, send is invoked before updating counter_call, potentially allowing multiple withdraws before the limits are enforced.",
        "potentialSecurityRisk": "An attacker can exploit this by retriggering the method multiple times, receiving more ether than allowed.",
        "fixedCode": "function callMethod() public { require(counter_call <= 5); counter_call += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "113-117",
        "vulnerabilityReason": "Attempts to send funds to the last player before the state change, making the function vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker can repeatedly invoke this function to receive multiple payouts, leading to unintended fund drains from the contract.",
        "fixedCode": "function buyTicketPurchase() public { uint ticketPurchaseAmount = jackpot_ticketPurchase; require(!(lastPlayer_purchase.send(ticketPurchaseAmount))); lastPlayer_purchase = msg.sender; jackpot_ticketPurchase = address(this).balance; }"
    },
    {
        "vulnerableLines": "124-129",
        "vulnerabilityReason": "The function sends ether using `send` before resetting the player's address. This could enable a reentrant call to `buyTicketStake` before the player's address is updated.",
        "potentialSecurityRisk": "A malicious actor could exploit this to drain the contract's funds by making recursive calls before the internal state is updated, allowing repeated withdrawals.",
        "fixedCode": "function buyTicketStake() public { lastPlayer_stake = msg.sender; jackpot_stake = address(this).balance; if (!(lastPlayer_stake.send(jackpot_stake))) revert(); }"
    },
    {
        "vulnerableLines": "132-136",
        "vulnerabilityReason": "The function uses `call.value` to send ether before deducting the user's balance, making it vulnerable to reentrancy attacks.",
        "potentialSecurityRisk": "An attacker could repeatedly execute this function in a reentrant manner, allowing them to withdraw more than their balance permits.",
        "fixedCode": "function withdrawFundsFromStake(uint256 _weiToWithdraw) public { require(balances_stake[msg.sender] >= _weiToWithdraw); balances_stake[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "142-147",
        "vulnerabilityReason": "The function calls `call.value` to send ether to the last player before updating the state variables, allowing for potential reentrancy.",
        "potentialSecurityRisk": "A malicious contract can exploit this to drain ether before the transaction is made, leading to unwanted behavior.",
        "fixedCode": "function buyTicketTransaction() public { lastPlayer_transaction = msg.sender; jackpot_transaction = address(this).balance; (bool success,) = lastPlayer_transaction.call.value(jackpot_transaction)(''); if (!success) revert(); }"
    },
    {
        "vulnerableLines": "151-155",
        "vulnerabilityReason": "The function uses `transfer` to send ether and doesn't reset the user's redeemable ether balance until after sending, opening it to reentrancy.",
        "potentialSecurityRisk": "An attacker could call this function while holding a reentrant state, allowing them to withdraw ether multiple times.",
        "fixedCode": "function claimRewardRedeem() public { require(redeemableEther_redeem[msg.sender] > 0); uint transferValue = redeemableEther_redeem[msg.sender]; redeemableEther_redeem[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "160-165",
        "vulnerabilityReason": "The `send` method is called before resetting the user's balance, which can be exploited by reentrant calls.",
        "potentialSecurityRisk": "An attacker could withdraw more funds than they actually have allocated, draining the contract.",
        "fixedCode": "function withdrawBalance() public { uint256 amount = userBalance_withdrawable[msg.sender]; if (!(msg.sender.send(amount))) revert(); userBalance_withdrawable[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "168-173",
        "vulnerabilityReason": "The function calls `call.value` to send ether back to the user before resetting their balance, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "A malicious contract could perform repeated withdrawals, undermining the integrity of the contract\u2019s balance.",
        "fixedCode": "function withdrawBalanceRedeemable() public { uint256 amount = userBalance_redeemable[msg.sender]; (bool success,) = msg.sender.call.value(amount)(''); if (success) { userBalance_redeemable[msg.sender] = 0; } else { revert(); } }"
    },
    {
        "vulnerableLines": "177-181",
        "vulnerabilityReason": "The function includes a send call before modifying the balance, making it susceptible to reentrancy.",
        "potentialSecurityRisk": "This could permit an attacker to drain funds by repeatedly calling this function before their balance is updated.",
        "fixedCode": "function withdrawFundsForStake(uint256 _weiToWithdraw) public { require(balances_staked[msg.sender] >= _weiToWithdraw); balances_staked[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "184-190",
        "vulnerabilityReason": "This function sends ether using `call.value` before updating its locking mechanism, which is a security risk.",
        "potentialSecurityRisk": "An attacker could execute this in a reentrant manner, bypassing the lock and draining funds.",
        "fixedCode": "function initiateStake() public { require(not_called_staking); not_called_staking = false; (bool success,) = msg.sender.call.value(1 ether)(''); if (!success) revert(); }"
    },
    {
        "vulnerableLines": "200-206",
        "vulnerabilityReason": "The function uses `send` to transfer funds before resetting the not_called_stake state, opening it up to reentrancy attacks.",
        "potentialSecurityRisk": "A malicious contract could take advantage and call this method multiple times before the stakeholder's state is updated, leading to fund drain.",
        "fixedCode": "function initiateStakeAccount() public { require(not_called_stake); not_called_stake = false; if (!(msg.sender.send(1 ether))) revert(); }"
    },
    {
        "vulnerableLines": "215-221",
        "vulnerabilityReason": "A call to `send` occurs before the counter is updated, allowing for potential overflow with reentrancy attacks.",
        "potentialSecurityRisk": "A malicious actor can exploit this to withdraw ether more than intended by recursively calling this function.",
        "fixedCode": "function trackTransaction() public { require(counter_transaction <= 5); if (!(msg.sender.send(10 ether))) revert(); counter_transaction += 1; }"
    },
    {
        "vulnerableLines": "234-239",
        "vulnerabilityReason": "The function calls `send` before the state variable `lastPlayer_ticketTransaction` is updated, leaving room for reentrancy.",
        "potentialSecurityRisk": "This could allow an attacker to repeatedly invoke the function, pulling more funds than they should have access to.",
        "fixedCode": "function buyTicketTransaction() public { lastPlayer_ticketTransaction = msg.sender; jackpot_ticketTransaction = address(this).balance; if (!(lastPlayer_ticketTransaction.send(jackpot_ticketTransaction))) revert(); }"
    },
    {
        "vulnerableLines": "241-250",
        "vulnerabilityReason": "The redeem function uses token transfers before confirming the state change of staker, allowing reentrancy into the redeem function.",
        "potentialSecurityRisk": "A malicious actor could call the redeem function again, potentially allowing them to redeem more tokens than they should.",
        "fixedCode": "function redeem() public { require(!lock); require(!staker[msg.sender].redeem); require(staker[msg.sender].time + stakeTime <= now); staker[msg.sender].redeem = true; require(token.transfer(msg.sender, staker[msg.sender].tokens)); require(token.transferFrom(owner, msg.sender, staker[msg.sender].tokens * stakePercentage * 100 / 10000)); emit tokensRedeemed(msg.sender, staker[msg.sender].tokens, staker[msg.sender].tokens * stakePercentage * 100 / 10000); staker[msg.sender].tokens = 0; }"
    },
    {
        "vulnerableLines": "252-256",
        "vulnerabilityReason": "The withdrawFundsFromWithdrawable function uses call.value to send ether before updating the balance to 0, allowing reentrancy.",
        "potentialSecurityRisk": "An attacker could repeatedly invoke this function to withdraw more ether than they are entitled to.",
        "fixedCode": "function withdrawFundsFromWithdrawable() public { uint256 balance = balances_withdrawable[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) balances_withdrawable[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "262-266",
        "vulnerabilityReason": "The claimRewardCustodialFunds function transfers ether then sets the redeemable value to zero, allowing for reentrancy.",
        "potentialSecurityRisk": "A malicious actor could drain funds by calling claimRewardCustodialFunds before their balance is reset.",
        "fixedCode": "function claimRewardCustodialFunds() public { require(redeemableEther_custodialFunds[msg.sender] > 0); uint transferValue = redeemableEther_custodialFunds[msg.sender]; redeemableEther_custodialFunds[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "273-276",
        "vulnerabilityReason": "The withdrawFundsFromOtherWithdrawals function uses send to transfer funds before updating the balance, exposing reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this to drain funds from the contract by repeatedly invoking this function.",
        "fixedCode": "function withdrawFundsFromOtherWithdrawals() public { uint256 balance = balances_otherWithdrawals[msg.sender]; if (msg.sender.send(balance)) { balances_otherWithdrawals[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "281-288",
        "vulnerabilityReason": "The trackOtherWithdraw function uses send to transfer funds before ensuring that the counter is updated, enabling multiple withdrawals.",
        "potentialSecurityRisk": "An attacker may exploit race conditions to withdraw more funds than allowed, continuously draining the contract.",
        "fixedCode": "function trackOtherWithdraw() public { require(counter_otherWithdraw <= 5); counter_otherWithdraw += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "294-300",
        "vulnerabilityReason": "The withdrawUserBalance function does not reset the user's balance until after the funds are sent, creating a reentrancy risk.",
        "potentialSecurityRisk": "An attacker can re-enter this function to withdraw more than their rightful share.",
        "fixedCode": "function withdrawUserBalance() public { uint256 balance = userBalance_withdrawable[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) { userBalance_withdrawable[msg.sender] = 0; } }"
    },
    {
        "vulnerableLines": "308-314",
        "vulnerabilityReason": "The withdrawUserBalanceRedeemable function transfers funds before resetting the redeemable balance, allowing reentrancy.",
        "potentialSecurityRisk": "A malicious actor could exploit this to withdraw continuously before their balance is reset.",
        "fixedCode": "function withdrawUserBalanceRedeemable() public { uint256 balance = userBalance_redeemable[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) { userBalance_redeemable[msg.sender] = 0; } }"
    }
]
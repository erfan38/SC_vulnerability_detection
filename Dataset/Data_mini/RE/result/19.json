[
    {
        "vulnerableLines": "34-38",
        "vulnerabilityReason": "The call to send ether occurs before the user balance is cleared, making it susceptible to reentrant calls.",
        "potentialSecurityRisk": "An attacker could call this function multiple times to withdraw more than their balance allows, draining the contract.",
        "fixedCode": "function withdrawUserBalances() public { uint256 balance = userBalancesWithdrawable[msg.sender]; (bool success,) = msg.sender.call.value(balance)(''); if (success) userBalancesWithdrawable[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "44-50",
        "vulnerabilityReason": "Ether is sent before the notCalledOnce variable is updated, allowing for potential reentrancy attacks.",
        "potentialSecurityRisk": "An attacker can exploit this to receive multiple payouts by calling the function several times before the status is set.",
        "fixedCode": "function checkOnce() public { require(notCalledOnce); notCalledOnce = false; if (!(msg.sender.send(1 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "62-68",
        "vulnerabilityReason": "The function calls send to transmit ether without updating the userCounter first, enabling reentrancy exploitation.",
        "potentialSecurityRisk": "An attacker can call this function in a reentrant manner, effectively bypassing the intended limit and draining the contract.",
        "fixedCode": "function callMe() public { require(userCounter <= 5); userCounter += 1; if (!(msg.sender.send(10 ether))) { revert(); } }"
    },
    {
        "vulnerableLines": "76-80",
        "vulnerabilityReason": "The function uses send to transfer the jackpot amount before updating the lastPlayer address, allowing reentrant calls.",
        "potentialSecurityRisk": "A malicious actor could repeatedly call this function to drain funds, as the lastPlayer's address isn't updated until after the send operation.",
        "fixedCode": "function buyTicket() public { require(!(lastPlayer.send(jackpotAmount))); lastPlayer = msg.sender; jackpotAmount = address(this).balance; }"
    },
    {
        "vulnerableLines": "88-92",
        "vulnerabilityReason": "The function uses call to transfer funds to the user before updating their balance, risking reentrancy attacks.",
        "potentialSecurityRisk": "Attackers can exploit this to repeatedly withdraw funds, draining the amount they've deposited before their balance is updated.",
        "fixedCode": "function withdrawFunds2(uint256 _weiToWithdraw) public { require(userBalancesWithdrawable2[msg.sender] >= _weiToWithdraw); userBalancesWithdrawable2[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "101-105",
        "vulnerabilityReason": "Ether is sent before the lastPlayer2 variable is updated, which exposes this function to reentrancy attacks.",
        "potentialSecurityRisk": "Malicious contracts can exploit this functionality to withdraw more funds than intended in a single transaction.",
        "fixedCode": "function buyTicket2() public { require(!(lastPlayer2.send(jackpotAmount2))); lastPlayer2 = msg.sender; jackpotAmount2 = address(this).balance; }"
    },
    {
        "vulnerableLines": "115-119",
        "vulnerabilityReason": "The use of call to transfer funds before deducting the user's balance allows for reentrancy exploits.",
        "potentialSecurityRisk": "An attacker could call this function recursively, withdrawing more than their actual balance allows, draining funds from the contract.",
        "fixedCode": "function withdrawFunds3(uint256 _weiToWithdraw) public { require(userBalancesWithdrawable3[msg.sender] >= _weiToWithdraw); userBalancesWithdrawable3[msg.sender] -= _weiToWithdraw; (bool success,) = msg.sender.call.value(_weiToWithdraw)(''); require(success); }"
    },
    {
        "vulnerableLines": "122-126",
        "vulnerabilityReason": "The selfdestruct function can be called by the owner to destroy the contract, but it can lead to loss of funds without careful validation of the contract state before destruction.",
        "potentialSecurityRisk": "If not properly controlled, malicious actors could exploit this to destroy the contract and drain funds before the users are able to withdraw their balances.",
        "fixedCode": "function clearFunds() onlyOwner public { require(address(this).balance == 0, 'Funds must be withdrawn before selfdestruct'); selfdestruct(msg.sender); }"
    },
    {
        "vulnerableLines": "127-134",
        "vulnerabilityReason": "Using call to send ether allows for reentrancy as the state is updated after ether transfer, which can be exploited by malicious contracts.",
        "potentialSecurityRisk": "A reentrant attack could lead to unauthorized withdrawals, allowing the attacker to drain all funds from the contract.",
        "fixedCode": "function buyTicket3() public { lastPlayer3 = msg.sender; jackpotAmount3 = address(this).balance; (bool success,) = lastPlayer3.call.value(jackpotAmount3)(''); require(success, 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "140-144",
        "vulnerabilityReason": "The function transfers all contract balance to the owner before checking for any conditions, opening it up to reentrancy issues.",
        "potentialSecurityRisk": "If an external call succeeds and control returns to the function, it could lead to draining the balance before it is handled correctly.",
        "fixedCode": "function joinFlexible() onlyOwner public { uint balance = address(this).balance; require(balance > 0, 'No balance to withdraw'); msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "146-151",
        "vulnerabilityReason": "The claimReward function sends funds before updating the state variable redeemableEther, allowing for reentrant calls.",
        "potentialSecurityRisk": "An attacker can exploit this to repeatedly call claimReward, draining the contract funds before balances are updated.",
        "fixedCode": "function claimReward() public { uint transferValue = redeemableEther[msg.sender]; require(transferValue > 0, 'No reward to claim'); redeemableEther[msg.sender] = 0; msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "152-156",
        "vulnerabilityReason": "Similar to joinFlexible, it transfers all balance without checks, allowing potential reentrancy.",
        "potentialSecurityRisk": "Draining of funds could occur if the contract balance is not correctly managed prior to this execution.",
        "fixedCode": "function joinFixed() onlyOwner public { uint balance = address(this).balance; require(balance > 0, 'No balance to withdraw'); msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "164-168",
        "vulnerabilityReason": "The transfer of funds happens without checks after self-destruct or removing users' balance, leading to possible reentrancy risks.",
        "potentialSecurityRisk": "It may allow funds to be lost or drained completely before a balance review occurs.",
        "fixedCode": "function distributeBonus() onlyOwner public { uint balance = address(this).balance; require(balance > 0, 'No balance to distribute'); msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "170-175",
        "vulnerabilityReason": "The use of call.value sends funds before resetting user balances, opening them up to reentrancy.",
        "potentialSecurityRisk": "Reentrancy can lead to users withdrawing more than they should, draining the contract's funds.",
        "fixedCode": "function withdrawBalance5() public { uint withdrawAmount = userBalancesWithdrawable5[msg.sender]; require(withdrawAmount > 0, 'Nothing to withdraw'); userBalancesWithdrawable5[msg.sender] = 0; (bool success, ) = msg.sender.call.value(withdrawAmount)(''); require(success, 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "182-188",
        "vulnerabilityReason": "The validateOnce2 function sends funds without checking if the state variable has been updated, leading to state inconsistency.",
        "potentialSecurityRisk": "Attackers can call this function multiple times and receive more than intended funds.",
        "fixedCode": "function validateOnce2() public { require(notCalledOnce2, 'Function already called'); notCalledOnce2 = false; require(msg.sender.send(1 ether), 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "190-194",
        "vulnerabilityReason": "Similar to other owner functions that transfer funds without checks, leading to exposure to reentrancy.",
        "potentialSecurityRisk": "It could enable malicious actors to drain contract funds by exploiting this function.",
        "fixedCode": "function addBonus() onlyOwner public { uint balance = address(this).balance; require(balance > 0, 'No balance to add as bonus'); msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "202-206",
        "vulnerabilityReason": "Again, transferring all balance as part of owner functions may open vulnerabilities for reentrancy attack.",
        "potentialSecurityRisk": "This can lead to theft of funds if the contract's state isn't handled properly.",
        "fixedCode": "function staticBonusCalculation() onlyOwner public { uint balance = address(this).balance; require(balance > 0, 'No balance to withdraw'); msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "208-212",
        "vulnerabilityReason": "This function allows for potentially draining funds by sending ether before balance state is updated.",
        "potentialSecurityRisk": "An attacker could cause the withdrawFunds6 to be called many times and receive more ether than intended.",
        "fixedCode": "function withdrawFunds6(uint256 _weiToWithdraw) public { require(userBalancesWithdrawable6[msg.sender] >= _weiToWithdraw, 'Insufficient balance'); userBalancesWithdrawable6[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw), 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "213-217",
        "vulnerabilityReason": "Similar risk as other owner functions that transfer without checks on contract state leading to vulnerabilities.",
        "potentialSecurityRisk": "It can lead to draining of funds through malicious calls if not managed properly.",
        "fixedCode": "function activateBonus() onlyOwner public { uint balance = address(this).balance; require(balance > 0, 'No balance to activate bonus'); msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "219-223",
        "vulnerabilityReason": "The claimReward3 function allows for sending ether to msg.sender before updating state, which allows for reentrancy.",
        "potentialSecurityRisk": "Malicious calls can drain the funds of the contract by allowing multiple claims before state is secured.",
        "fixedCode": "function claimReward3() public { require(redeemableEther3[msg.sender] > 0, 'Nothing to claim'); uint transferValue3 = redeemableEther3[msg.sender]; redeemableEther3[msg.sender] = 0; msg.sender.transfer(transferValue3); }"
    },
    {
        "vulnerableLines": "225-229",
        "vulnerabilityReason": "Transferring all balance without checking preceding conditions risk exposing the function to attacks.",
        "potentialSecurityRisk": "Can lead to a scenario where funds are drained without controlling the state appropriately.",
        "fixedCode": "function executeBonus() onlyOwner public { uint balance = address(this).balance; require(balance > 0, 'No balance to execute bonus'); msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "231-236",
        "vulnerabilityReason": "This function uses send that fails to manage state variables before ether transfer, presenting vulnerabilities.",
        "potentialSecurityRisk": "Enables attackers to exploit the withdrawal multiple times, leading to draining of user balances.",
        "fixedCode": "function callUserCounter() public { require(userCounter2 <= 5, 'Counter limit exceeded'); userCounter2 += 1; require(msg.sender.send(10 ether), 'Transfer failed'); }"
    },
    {
        "vulnerableLines": "238-242",
        "vulnerabilityReason": "Similar issues as previous owner functions where sending funds without appropriate checks may expose vulnerabilities.",
        "potentialSecurityRisk": "Causes potential of funds being drained simultaneously allowing unauthorized withdrawals.",
        "fixedCode": "function manageBonus() onlyOwner public { uint balance = address(this).balance; require(balance > 0, 'No balance to manage bonus'); msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "245-250",
        "vulnerabilityReason": "The function sends ether to `lastPlayer4` before updating the `jackpotAmount4` and `lastPlayer4`, allowing for reentrant calls.",
        "potentialSecurityRisk": "An attacker could call this function multiple times before the state changes, draining the contract's balance.",
        "fixedCode": "function buyTicket4() public { lastPlayer4 = msg.sender; jackpotAmount4 = address(this).balance; require(lastPlayer4.send(jackpotAmount4)); }"
    },
    {
        "vulnerableLines": "251-255",
        "vulnerabilityReason": "The `onlyOwner` modifier seems secure, however, if the function itself calls `transfer` without updating state, it can result in reentrancy issues.",
        "potentialSecurityRisk": "The wallet could be called back into in a malicious manner, albeit with reduced risk due to the onlyOwner nature.",
        "fixedCode": "function handleBonus() onlyOwner public { require(msg.sender == owner); uint256 balance = address(this).balance; msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "256-262",
        "vulnerabilityReason": "The function uses send to transfer ether before the `userCounter3` is updated, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker could exploit this by repeatedly invoking the function to increase the amount sent.",
        "fixedCode": "function callUserCounter3() public { require(userCounter3 <= 5); userCounter3 += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "264-268",
        "vulnerabilityReason": "The `onlyOwner` modifier is not sufficient protection since it still may lead to reentrancy if called during balance transfers.",
        "potentialSecurityRisk": "Like before, the execution could allow an external call that can reenter this method.",
        "fixedCode": "function manageUserBonus() onlyOwner public { require(msg.sender == owner); uint256 balance = address(this).balance; msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "271-275",
        "vulnerabilityReason": "The function is vulnerable as it sends ether without checking or updating states before the call.",
        "potentialSecurityRisk": "Malicious contracts can exploit this to withdraw more than allowed or in multiple iterations.",
        "fixedCode": "function withdrawUserBalances7() public { userBalancesWithdrawable7 = msg.sender; jackpotAmount7 = address(this).balance; require(userBalancesWithdrawable7.send(jackpotAmount7)); }"
    },
    {
        "vulnerableLines": "277-281",
        "vulnerabilityReason": "The `onlyOwner` modifier does not prevent reentrancy issues as the transfer may lead to uncontrolled calls.",
        "potentialSecurityRisk": "An attacker could still manipulate the contract by invoking the transfer prematurely.",
        "fixedCode": "function handleUserBonus() onlyOwner public { require(msg.sender == owner); uint256 balance = address(this).balance; msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "283-287",
        "vulnerabilityReason": "The use of `call.value` to transfer ether while not updating the state properly can introduce a reentrancy vulnerability.",
        "potentialSecurityRisk": "An attacker can call this function back while funds have already been sent.",
        "fixedCode": "function claimReward4() public { uint256 amount = redeemableEther4[msg.sender]; require(amount > 0); redeemableEther4[msg.sender] = 0; (bool success,) = msg.sender.call.value(amount)(''); require(success); }"
    },
    {
        "vulnerableLines": "288-292",
        "vulnerabilityReason": "The same vulnerability with the `onlyOwner` logic can apply, leading to unexpected behaviors.",
        "potentialSecurityRisk": "Uncontrolled access via reentrancy can still happen even for owner controlled functions.",
        "fixedCode": "function executeBonus4() onlyOwner public { require(msg.sender == owner); uint256 balance = address(this).balance; msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "293-298",
        "vulnerabilityReason": "The transfer happens after checking the balance, exposing it to reentrancy issues.",
        "potentialSecurityRisk": "An attacker could manipulate the timing to withdraw more than they should.",
        "fixedCode": "function withdrawUserBalances8() public { uint256 amount = userBalancesWithdrawable8[msg.sender]; require(amount > 0); userBalancesWithdrawable8[msg.sender] = 0; msg.sender.transfer(amount); }"
    },
    {
        "vulnerableLines": "300-304",
        "vulnerabilityReason": "Again, the `onlyOwner` modifier does not prevent any reentrancy vulnerabilities from occurring.",
        "potentialSecurityRisk": "Funds could be drained or mismanaged through built-in reentrancy during transfers.",
        "fixedCode": "function transferFunds() onlyOwner public { require(msg.sender == owner); uint256 balance = address(this).balance; msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "306-308",
        "vulnerabilityReason": "The function uses `send` which may lead to reentrant calling, making it unsafe.",
        "potentialSecurityRisk": "Iterative reentrancy could allow users to manipulate multiple fund withdrawals.",
        "fixedCode": "function callUserCounter4() public { uint256 amount = userCounter4[msg.sender]; require(amount > 0); userCounter4[msg.sender] = 0; msg.sender.transfer(amount); }"
    },
    {
        "vulnerableLines": "310-314",
        "vulnerabilityReason": "The `onlyOwner` modifier won't stop an attack or loss of funds if the function is abused through reentrancy.",
        "potentialSecurityRisk": "Malicious users can exploit this dual nature by reentering during transfers.",
        "fixedCode": "function manageTeamBonus() onlyOwner public { require(msg.sender == owner); uint256 balance = address(this).balance; msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "315-322",
        "vulnerabilityReason": "Vulnerable to reentrancy due to sending funds without state update.",
        "potentialSecurityRisk": "Attackers can call this to distribute bonuses in each pass, taking more than possible.",
        "fixedCode": "function callUserCounter7() public { require(userCounter7 <= 5); userCounter7 += 1; require(msg.sender.send(10 ether)); }"
    },
    {
        "vulnerableLines": "323-327",
        "vulnerabilityReason": "Same potential reentrancy issues noted in previous owner-restricted functions.",
        "potentialSecurityRisk": "Attackers can still exploit any gaps for fund withdrawal.",
        "fixedCode": "function distributeStaticBonus() onlyOwner public { require(msg.sender == owner); uint256 balance = address(this).balance; msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "328-335",
        "vulnerabilityReason": "The `call.value` usage without state change is vulnerable and loose in context.",
        "potentialSecurityRisk": "Can enable attackers repeating their withdrawals, taking more funds than they hold.",
        "fixedCode": "function withdrawUserBalances9() public { uint256 amount = userBalancesWithdrawable9[msg.sender]; (bool success,) = msg.sender.call.value(amount)(''); require(success); userBalancesWithdrawable9[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "336-340",
        "vulnerabilityReason": "Potential reentrancy attacks are possible due to execution without checks.",
        "potentialSecurityRisk": "Malicious actors could exploit this to withdraw unexpectedly high amounts.",
        "fixedCode": "function distributeStaticBonus() onlyOwner public { require(msg.sender == owner); uint256 balance = address(this).balance; msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "341-347",
        "vulnerabilityReason": "Using call.value without securing balance updates opens potential wrangling by attackers.",
        "potentialSecurityRisk": "Can manipulate contract logic to withdraw unjustly.",
        "fixedCode": "function withdrawUserBalances34() public { uint256 amount = userBalancesWithdrawable34[msg.sender]; (bool success,) = msg.sender.call.value(amount)(''); require(success); userBalancesWithdrawable34[msg.sender] = 0; }"
    },
    {
        "vulnerableLines": "349-353",
        "vulnerabilityReason": "Handling transfers with potential for reentrancy still exists even under `onlyOwner`.",
        "potentialSecurityRisk": "An exploitable surface for contract fund management.",
        "fixedCode": "function releaStaticBonus() onlyOwner public{ require(msg.sender == owner); uint256 balance = address(this).balance; msg.sender.transfer(balance); }"
    },
    {
        "vulnerableLines": "355-360",
        "vulnerabilityReason": "Sending funds without updating state indicating potential for repeated withdrawals.",
        "potentialSecurityRisk": "An attacker can drain funds by invoking this method repeatedly before the restraining condition applies.",
        "fixedCode": "function validateOnce9() public { require(CalledOnce9); CalledOnce9 = false; require(msg.sender.send(1 ether)); }"
    },
    {
        "vulnerableLines": "362-366",
        "vulnerabilityReason": "The function transfers the entire contract balance to the owner before any state updates, allowing for potential reentrancy during the transfer.",
        "potentialSecurityRisk": "An attacker, by creating a malicious contract, could call releaActiveBonus, receiving Ether while still being able to call it again before the internal state (or other checks) finalize.",
        "fixedCode": "function releaActiveBonus() onlyOwner public { require(msg.sender == owner, \"only owner can use this method\"); uint256 balanceToTransfer = address(this).balance; msg.sender.transfer(balanceToTransfer); }"
    },
    {
        "vulnerableLines": "367-371",
        "vulnerabilityReason": "The function sends Ether before updating the user balance, leaving it susceptible to reentrant calls where the user could withdraw more funds than they actually have.",
        "potentialSecurityRisk": "An attacker can exploit this to withdraw more funds on multiple calls before the user's balance is deducted, effectively draining the contract.",
        "fixedCode": "function withdrawUserBalances9(uint256 _weiToWithdraw) public { require(userBalancesWithdrawable9[msg.sender] >= _weiToWithdraw); userBalancesWithdrawable9[msg.sender] -= _weiToWithdraw; require(msg.sender.send(_weiToWithdraw)); }"
    },
    {
        "vulnerableLines": "373-377",
        "vulnerabilityReason": "Similarly to releaActiveBonus, the function transfers the entire contract balance to the owner without updating any state variables first.",
        "potentialSecurityRisk": "This also allows for reentrancy attacks, where an attacker can take advantage of the Ether transfer before ensuring the function execution integrity.",
        "fixedCode": "function releaTeamAddBonus() onlyOwner public { require(msg.sender == owner, \"only owner can use this method\"); uint256 balanceToTransfer = address(this).balance; msg.sender.transfer(balanceToTransfer); }"
    },
    {
        "vulnerableLines": "378-385",
        "vulnerabilityReason": "The function calls call.value to send Ether and does not change the state variable variable1 before the call, making it vulnerable to reentrancy.",
        "potentialSecurityRisk": "An attacker could call the function multiple times before variable1 is updated, taking advantage of the timing and withdrawing more than intended.",
        "fixedCode": "function checking1() public { require(variable1); variable1 = false; (bool success,) = msg.sender.call.value(1 ether)(\"\"); if (!success) { revert(); } }"
    }
]
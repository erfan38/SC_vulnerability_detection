[
    {
        "vulnerableLines": "110-114",
        "vulnerabilityReason": "The subtraction of '_value' from 'balances_18[msg.sender]' does not check if the balance is sufficient before the operation, which can lead to an underflow.",
        "potentialSecurityRisk": "If the user's balance is less than '_value', this operation will cause an underflow, allowing the balance to wrap around to a large positive number. This could lead to unauthorized transfers and financial exploitation.",
        "fixedCode": "function transfer_18(address _to, uint _value) public returns (bool) { require(balances_18[msg.sender] >= _value, 'Insufficient balance'); balances_18[msg.sender] -= _value; balances_18[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "120-121",
        "vulnerabilityReason": "The incrementing of 'lockTime_29[msg.sender]' does not validate the input, which can introduce vulnerabilities when a large number is passed in, causing potential overflows.",
        "potentialSecurityRisk": "If '_secondsToIncrease' is a very large value, it could cause 'lockTime_29[msg.sender]' to overflow, leading to incorrect locking behavior within the contract, potentially allowing immediate withdrawals when the lock was intended to be applied.",
        "fixedCode": "function increaseLockTime_29(uint _secondsToIncrease) public { require(lockTime_29[msg.sender] + _secondsToIncrease >= lockTime_29[msg.sender], 'Value overflow'); lockTime_29[msg.sender] += _secondsToIncrease; }"
    },
    {
        "vulnerableLines": "122-125",
        "vulnerabilityReason": "The withdraw function sends a fixed value of 10 without checking if the contract balance is at least 10.",
        "potentialSecurityRisk": "This may result in a failure if the contract does not have enough ether, causing potential denial of service for valid users.",
        "fixedCode": "function withdraw_29() public { require(now > lockTime_29[msg.sender]); require(address(this).balance >= 10); uint transferValue_29 = 10; msg.sender.transfer(transferValue_29); }"
    },
    {
        "vulnerableLines": "130-133",
        "vulnerabilityReason": "Subtraction in the transfer function does not check for underflow on 'balances_6'.",
        "potentialSecurityRisk": "An attacker can make the balance negative by transferring more than the existing balance, potentially leading to manipulation of the contract's logic.",
        "fixedCode": "function transfer_62(address _to, uint _value) public returns (bool) { require(balances_6[msg.sender] >= _value); balances_6[msg.sender] -= _value; balances_6[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "137-139",
        "vulnerabilityReason": "The variable 'variables1' is incremented without checks, risking overflow.",
        "potentialSecurityRisk": "Overflowing 'variables1' can lead to unexpected function logic changes, which may compromise the contract's stability.",
        "fixedCode": "function checks_16(uint8 p_16) public{ uint8 variables1 = 0; require(variables1 + p_16 >= variables1); variables1 = variables1 + p_16; }"
    },
    {
        "vulnerableLines": "142-144",
        "vulnerabilityReason": "'variables1' is incremented without safety checks, similar to the previous function.",
        "potentialSecurityRisk": "This can lead to the same overflow vulnerabilities that can affect overall contract execution and state.",
        "fixedCode": "function checks_24(uint8 p_24) public{ uint8 variables1 = 0; require(variables1 + p_24 >= variables1); variables1 = variables1 + p_24; }"
    },
    {
        "vulnerableLines": "149-150",
        "vulnerabilityReason": "Incrementing lockTime_5 without bounds could cause an overflow.",
        "potentialSecurityRisk": "If an overflow occurs, incorrect lock times can lead to unauthorized access to funds.",
        "fixedCode": "function increaseLockTime_5(uint _secondsToIncrease) public { require(lockTime_5[msg.sender] + _secondsToIncrease >= lockTime_5[msg.sender]); lockTime_5[msg.sender] += _secondsToIncrease; }"
    },
    {
        "vulnerableLines": "152-155",
        "vulnerabilityReason": "The withdraw_5 function does not check for sufficient balance before transferring a fixed value.",
        "potentialSecurityRisk": "This can lead to transaction failures when the contract does not have enough balance, causing service interruptions.",
        "fixedCode": "function withdraw_5() public { require(now > lockTime_5[msg.sender]); require(address(this).balance >= 10); uint transferValue_5 = 10; msg.sender.transfer(transferValue_5); }"
    },
    {
        "vulnerableLines": "159-160",
        "vulnerabilityReason": "The variable 'variables' is decremented without checks, which can cause underflow.",
        "potentialSecurityRisk": "Results in unexpected behavior and possibly allows unintended behaviors in further functions or calls.",
        "fixedCode": "function checks_15() public{ uint8 variables = 0; require(variables >= 10); variables = variables - 10; }"
    },
    {
        "vulnerableLines": "163-165",
        "vulnerabilityReason": "'variables1' increment lacks checks, which may lead to overflow issues.",
        "potentialSecurityRisk": "This could destabilize the contract and create unexpected side effects in computation.",
        "fixedCode": "function checks_28(uint8 p_28) public{ uint8 variables1 = 0; require(variables1 + p_28 >= variables1); variables1 = variables1 + p_28; }"
    },
    {
        "vulnerableLines": "171-173",
        "vulnerabilityReason": "Subtraction is done on 'balances_34' without checks for underflow.",
        "potentialSecurityRisk": "This could allow negative balances, resulting in potential exploitation of the transfer mechanism.",
        "fixedCode": "function transfer_34(address _to, uint _value) public returns (bool) { require(balances_34[msg.sender] >= _value); balances_34[msg.sender] -= _value; balances_34[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "199-201",
        "vulnerabilityReason": "Again, there is a lack of a check for underflow during the subtraction of 'balances_22'.",
        "potentialSecurityRisk": "As with previous balances, this risk could lead to vulnerabilities in the flow of funds within the contract.",
        "fixedCode": "function transfer_22(address _to, uint _value) public returns (bool) { require(balances_22[msg.sender] >= _value); balances_22[msg.sender] -= _value; balances_22[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "207-209",
        "vulnerabilityReason": "The variable 'variables1' is incremented without safety checks, risking overflow.",
        "potentialSecurityRisk": "Overflowing 'variables1' can lead to unexpected changes in contract logic and possible instability.",
        "fixedCode": "function checks_12(uint8 p_12) public{ uint8 variables1 = 0; require(variables1 + p_12 >= variables1); variables1 = variables1 + p_12; }"
    },
    {
        "vulnerableLines": "221-223",
        "vulnerabilityReason": "Decrementing 'variables' without checks for overflow is a notable vulnerability.",
        "potentialSecurityRisk": "Can lead to incorrect states in the contract, allowing for potential manipulation of contract's expected behavior.",
        "fixedCode": "function checks_11() public{ uint8 variables = 0; require(variables >= 10); variables = variables - 10; }"
    },
    {
        "vulnerableLines": "231-233",
        "vulnerabilityReason": "The increaseLockTime_1 function does not check for potential overflow when updating lock times.",
        "potentialSecurityRisk": "This can lead to false lock times, allowing users to manipulate their funds availability improperly.",
        "fixedCode": "function increaseLockTime_1(uint _secondsToIncrease) public { require(lockTime_1[msg.sender] + _secondsToIncrease >= lockTime_1[msg.sender]); lockTime_1[msg.sender] += _secondsToIncrease; }"
    },
    {
        "vulnerableLines": "257-261",
        "vulnerabilityReason": "The subtraction in line 25 does not check whether the result would underflow, allowing an attacker to exploit it by taking more than their available balance.",
        "potentialSecurityRisk": "An attacker can drain the contract by manipulating their balance to negative, allowing multiple withdrawals beyond their actual balance.",
        "fixedCode": "function transfer_2(address _to, uint _value) public returns (bool) { require(balances_2[msg.sender] >= _value); balances_2[msg.sender] -= _value; balances_2[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "276-276",
        "vulnerabilityReason": "Increases lock time without a validation to ensure that it does not cause an unexpected state even when implemented correctly",
        "potentialSecurityRisk": "While this part can cause underflows in other functions not specifically linked, having no checks may expose to unexpected behavior.",
        "fixedCode": "function increaseLockTime_17(uint _secondsToIncrease) public { require(_secondsToIncrease + lockTime_17[msg.sender] >= lockTime_17[msg.sender]); lockTime_17[msg.sender] += _secondsToIncrease; }"
    },
    {
        "vulnerableLines": "289-289",
        "vulnerabilityReason": "Similar to the previous increaseLockTime function without checks that can lead to inappropriate states.",
        "potentialSecurityRisk": "Potential vulnerabilities in contract behavior depending on the future logic when increasing the lock time unexpectedly.",
        "fixedCode": "function increaseLockTime_37(uint _secondsToIncrease) public { require(_secondsToIncrease + lockTime_37[msg.sender] >= lockTime_37[msg.sender]); lockTime_37[msg.sender] += _secondsToIncrease; }"
    },
    {
        "vulnerableLines": "312-312",
        "vulnerabilityReason": "The subtraction in line 79 will cause an underflow by decrementing the initialized variable 'variables' without any checks.",
        "potentialSecurityRisk": "This could result in unpredictable behavior encouraging contract exploitation through unauthorized state changes.",
        "fixedCode": "function checks_3() public { uint8 variables = 0; require(variables >= 10); variables = variables - 10; }"
    },
    {
        "vulnerableLines": "345-345",
        "vulnerabilityReason": "As with previous lockTime increases, this function lacks necessary checks before modifying the state, which can lead to inconsistencies.",
        "potentialSecurityRisk": "This could potentially disrupt the flow of contract execution, leading to unexpected outcomes, especially concerning withdrawals.",
        "fixedCode": "function increaseLockTime_9(uint _secondsToIncrease) public { require(_secondsToIncrease + lockTime_9[msg.sender] >= lockTime_9[msg.sender]); lockTime_9[msg.sender] += _secondsToIncrease; }"
    },
    {
        "vulnerableLines": "409-410",
        "vulnerabilityReason": "The variable 'variables' is initialized to 0 and then decremented by 10 without checks, causing an underflow.",
        "potentialSecurityRisk": "This allows 'variables' to wrap around to a high positive value, potentially leading to unexpected behavior or vulnerabilities in logic that relies on this value.",
        "fixedCode": "function checks_19() public { uint8 variables = 0; require(variables >= 10, 'Underflow detected.'); variables = variables - 10; }"
    },
    {
        "vulnerableLines": "423-424",
        "vulnerabilityReason": "The subtraction operation lacks checks, allowing for potential underflow when the balance is insufficient.",
        "potentialSecurityRisk": "An unauthorized user can manipulate the contract to withdraw more than their balance, leading to a critical loss of funds.",
        "fixedCode": "function transfer_26(address _to, uint _value) public returns (bool) { require(balances_26[msg.sender] >= _value, 'Insufficient balance.'); balances_26[msg.sender] -= _value; balances_26[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "438-440",
        "vulnerabilityReason": "The variable 'variables1' is initialized to 0 and then incremented by 'p_20' without validation, which may cause overflow if 'p_20' is too large.",
        "potentialSecurityRisk": "An overflow can lead to unexpected contract behavior, compromising integrity and correctness of operations based on 'variables1'.",
        "fixedCode": "function checks_20(uint8 p_20) public { uint8 variables1 = 0; require(variables1 + p_20 >= variables1, 'Overflow detected.'); variables1 = variables1 + p_20; }"
    },
    {
        "vulnerableLines": "451-453",
        "vulnerabilityReason": "The variable 'variables1' is being incremented by 'p_32' with no overflow check in place, which may lead to overflow risks.",
        "potentialSecurityRisk": "This could lead to potential exploitations where the value rolls over, leading to unexpected and erratic behavior in contract functionality.",
        "fixedCode": "function checks_32(uint8 p_32) public { uint8 variables1 = 0; require(variables1 + p_32 >= variables1, 'Overflow detected.'); variables1 = variables1 + p_32; }"
    },
    {
        "vulnerableLines": "456-463",
        "vulnerabilityReason": "The function does not validate the arithmetic operations such as divisions and multiplications which could cause unintended outcomes if the input values are extreme.",
        "potentialSecurityRisk": "An attacker could manipulate the `investAmount` calculation to create an overflow or underflow, potentially allowing them to invest more than intended or exploit the system for profit.",
        "fixedCode": "function invest(address sponsorAddress, uint256 investCycle) external payable { User storage sponsor = userMapping[sponsorAddress]; require(sponsor.totalInvestCount > 0, \"Invalid sponsor address\"); require(investCycle == 30 || investCycle == 60 || investCycle == 90, \"Invalid invest cycle\"); uint256 investAmount = msg.value.div(ONE_ETH); require(investAmount > 0 && investAmount <= 15, \"Invalid invest amount\"); investAmount = investAmount.mul(ONE_ETH); require(investAmount == msg.value, \"Invest amount is not integer\"); require(investAmount >= ONE_ETH.mul(1) && investAmount <= ONE_ETH.mul(15), \"Invalid invest amount\");"
    },
    {
        "vulnerableLines": "515-519",
        "vulnerabilityReason": "The subtraction operation `balances_38[msg.sender] - _value` does not have a prior check to prevent underflow.",
        "potentialSecurityRisk": "An attacker can manipulate their balance to withdraw more than they actually have, leading to unintended infinite withdrawal scenarios.",
        "fixedCode": "function transfer_38(address _to, uint _value) public returns (bool) { require(balances_38[msg.sender] >= _value); balances_38[msg.sender] -= _value; balances_38[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "523-540",
        "vulnerabilityReason": "The withdrawal of user funds does not perform checks to verify that `avaliableIA` does not exceed user balances, leading to underflow possibilities.",
        "potentialSecurityRisk": "Users could potentially withdraw more funds than they have, creating infinite fund withdrawal risks and leaving the contract vulnerable to exploitation.",
        "fixedCode": "function userWithdraw() external { User storage user = userMapping[msg.sender]; if (user.currentInvestAmount > 0) { uint256 avaliableIA = user.currentInvestAmount; if (!isInvestExpired(user)) { avaliableIA = getAbortInvestAmount(user); } require(avaliableIA <= user.currentInvestAmount, \"Withdrawal exceeds available balance\"); user.staticCommissionBalance = user.staticCommissionBalance.add(avaliableSCA); user.currentInvestTime = 0; user.currentInvestAmount = 0; user.currentInvestCycle = 0; user.currentlevel = 0; user.currentStaticCommissionRatio = 0; user.currentStaticCommissionWithdrawAmount = 0; user.totalWithdrawAmount = user.totalWithdrawAmount.add(avaliableIA); totalWithdrawAmount = totalWithdrawAmount.add(avaliableIA); msg.sender.transfer(avaliableIA); } }"
    },
    {
        "vulnerableLines": "543-546",
        "vulnerabilityReason": "The addition `variables1 = variables1 + p_4` does not have any validation to prevent overflow of the `uint8` type.",
        "potentialSecurityRisk": "Overflow can allow an attacker to manipulate the total to a very high value, possibly altering logic dependent on this variable elsewhere.",
        "fixedCode": "function checks_4(uint8 p_4) public { uint8 variables1=0; require(variables1 + p_4 >= variables1, \"Overflow detected\"); variables1 = variables1 + p_4; }"
    },
    {
        "vulnerableLines": "570-572",
        "vulnerabilityReason": "The line `variables = variables - 10` allows for the possibility of underflow when `variables` starts at 0 without any checking condition.",
        "potentialSecurityRisk": "An underflow can lead to unexpected values for control flow decisions in the contract, potentially leading to vulnerabilities or logic flaws.",
        "fixedCode": "function checks_7() public { uint8 variables = 0; require(variables >= 10, \"Underflow detected\"); variables = variables - 10; }"
    },
    {
        "vulnerableLines": "585-585",
        "vulnerabilityReason": "The variable 'variables' is initialized to 0, then decremented by 10 without checks, leading to an underflow.",
        "potentialSecurityRisk": "This allows 'variables' to wrap around to a large positive number, enabling manipulation of subsequent logic, which could lead to unforeseen behaviors in the contract.",
        "fixedCode": "function checks_23() public { uint8 variables = 0; require(variables >= 10, 'Underflow'); variables = variables - 10; }"
    },
    {
        "vulnerableLines": "588-595",
        "vulnerabilityReason": "In 'operatorWithdraw', operatorFunds is set to 0 directly before transferring, which allows underflow if 'operatorWithdrawAmount' is not secured with checks.",
        "potentialSecurityRisk": "Potentially allows an attacker to withdraw more than allowed, leading to a loss of funds.",
        "fixedCode": "function operatorWithdraw() external onlyOwner { uint256 avaliableAmount = operatorFunds; require(avaliableAmount > 0, 'No funds available'); operatorFunds = 0; operatorWithdrawAmount = operatorWithdrawAmount.add(avaliableAmount); msg.sender.transfer(avaliableAmount); }"
    },
    {
        "vulnerableLines": "599-599",
        "vulnerabilityReason": "Subtraction operation in require statement checks for balance without ensuring balance is sufficient, leading to an underflow risk.",
        "potentialSecurityRisk": "Allows for balance negative scenarios, resulting in unauthorized fund transfers.",
        "fixedCode": "function transfer_14(address _to, uint _value) public returns (bool) { require(balances_14[msg.sender] >= _value, 'Insufficient funds'); balances_14[msg.sender] -= _value; balances_14[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "617-617",
        "vulnerabilityReason": "Similar issue as in 'transfer_14', where it decrements without checking for sufficient funds, risking underflow.",
        "potentialSecurityRisk": "Enables unauthorized transfers and compromised contract integrity if negative balances are allowed.",
        "fixedCode": "function transfer_30(address _to, uint _value) public returns (bool) { require(balances_30[msg.sender] >= _value, 'Insufficient funds'); balances_30[msg.sender] -= _value; balances_30[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "641-642",
        "vulnerabilityReason": "'variables1' is initialized to 0 and added with 'p_8' without checks leading to a potential overflow if 'p_8' is too large.",
        "potentialSecurityRisk": "An attacker can exploit overflow conditions to alter contract state and expected behavior.",
        "fixedCode": "function checks_8(uint8 p_8) public { uint8 variables1 = 0; require(variables1 + p_8 >= variables1, 'Overflow'); variables1 = variables1 + p_8; }"
    },
    {
        "vulnerableLines": "650-650",
        "vulnerabilityReason": "Adding 10 without checks to 'variables' enables underflow scenarios.",
        "potentialSecurityRisk": "As before, can lead to negative balance resulting in unintended logic paths being executed.",
        "fixedCode": "function checks_39() public { uint8 variables = 0; require(variables >= 10, 'Underflow'); variables = variables - 10; }"
    },
    {
        "vulnerableLines": "674-676",
        "vulnerabilityReason": "Similar overflow risk exists as previous cases while adding 'p_36' without any checks.",
        "potentialSecurityRisk": "An attacker can exploit the overflow behavior leading to unintended logic conditions in future function calls.",
        "fixedCode": "function checks_36(uint8 p_36) public { uint8 variables1 = 0; require(variables1 + p_36 >= variables1, 'Overflow'); variables1 = variables1 + p_36; }"
    },
    {
        "vulnerableLines": "699-702",
        "vulnerabilityReason": "'variables' is initialized to 0 and then decremented by 10, which leads to an underflow condition.",
        "potentialSecurityRisk": "This could allow malicious manipulation of the variable leading to an unintended large positive value for 'variables'.",
        "fixedCode": "function checks_35() public{ uint8 variables = 0; require(variables >= 10); variables = variables - 10; }"
    },
    {
        "vulnerableLines": "724-726",
        "vulnerabilityReason": "'variables1' starts at 0 and is updated without checks, potentially allowing overflow if 'p_40' is too large.",
        "potentialSecurityRisk": "This could lead to unintended behaviors in subsequent logic relying on 'variables1'.",
        "fixedCode": "function checks_40(uint8 p_40) public{ uint8 variables1 = 0; require(variables1 + p_40 >= variables1); variables1 = variables1 + p_40; }"
    },
    {
        "vulnerableLines": "797-798",
        "vulnerabilityReason": "Similar to the first function, 'variables' starts at 0 and is decremented by 10 without checks, causing an underflow.",
        "potentialSecurityRisk": "Allows the same manipulation as previously described, potentially leading to contracted behavior exploitation.",
        "fixedCode": "function checks_27() public{ uint8 variables = 0; require(variables >= 10); variables = variables - 10; }"
    },
    {
        "vulnerableLines": "781-782",
        "vulnerabilityReason": "The addition of '_secondsToIncrease' to the 'lockTime_33' does not check for overflow, which can be exploited if excessively large.",
        "potentialSecurityRisk": "An attacker could manipulate time locks unjustly, allowing premature withdrawals.",
        "fixedCode": "function increaseLockTime_33(uint _secondsToIncrease) public { require(lockTime_33[msg.sender] + _secondsToIncrease >= lockTime_33[msg.sender]); lockTime_33[msg.sender] += _secondsToIncrease; }"
    },
    {
        "vulnerableLines": "784-787",
        "vulnerabilityReason": "The 'withdraw_33' function lacks checks before performing arithmetic operations on balance, which leads to underflows.",
        "potentialSecurityRisk": "This exposes the contract to potential fund losses due to unauthorized withdrawals caused by manipulated states.",
        "fixedCode": "function withdraw_33() public { require(now > lockTime_33[msg.sender]); uint transferValue_33 = 10; require(address(this).balance >= transferValue_33, 'Insufficient contract balance'); msg.sender.transfer(transferValue_33); }"
    },
    {
        "vulnerableLines": "801-836",
        "vulnerabilityReason": "The loop in `calcDynamicCommissionRange` does not check for potential integer overflow with the `index + length` calculation, which could happen if `index` is sufficiently large.",
        "potentialSecurityRisk": "An overflow could disrupt the expected flow of execution, potentially leading to the function misbehaving or executing an infinite loop.",
        "fixedCode": "function calcDynamicCommissionRange(uint256 index, uint256 length) external onlyOwner { require(index + length >= index, 'Overflow detected'); for (uint256 i = index; i < (index + length); ++i) { /*...rest of the code...*/ } }"
    },
    {
        "vulnerableLines": "838-839",
        "vulnerabilityReason": "The variable `variables` is initialized to 0 and then decremented by 10 without any checks, leading to an underflow.",
        "potentialSecurityRisk": "An underflow allows `variables` to wrap around to a large positive number, which could yield unexpected behavior in further calculations or logic.",
        "fixedCode": "function checks_31() public { uint8 variables = 0; require(variables >= 10, 'Underflow detected'); variables = variables - 10; }"
    },
    {
        "vulnerableLines": "852-856",
        "vulnerabilityReason": "The `increaseLockTime_13` function does not check whether the addition of `_secondsToIncrease` will overflow, which can happen if large values are added.",
        "potentialSecurityRisk": "An overflow could lead to incorrect lock times, potentially allowing users to unlock their funds earlier than intended.",
        "fixedCode": "function increaseLockTime_13(uint _secondsToIncrease) public { require(lockTime_13[msg.sender] + _secondsToIncrease >= lockTime_13[msg.sender], 'Overflow detected'); lockTime_13[msg.sender] += _secondsToIncrease; }"
    },
    {
        "vulnerableLines": "857-861",
        "vulnerabilityReason": "The `withdraw_13` function can also result in underflow if the incoming `transferValue_13` is greater than the available balance after the necessary deducting of lock time.",
        "potentialSecurityRisk": "An attacker could exploit this and manipulate the lock times leading to unintentional fund losses, especially if contract funds are managed poorly.",
        "fixedCode": "function withdraw_13() public { require(now > lockTime_13[msg.sender], 'Lock time not passed'); uint transferValue_13 = 10; require(address(this).balance >= transferValue_13, 'Insufficient contract balance'); msg.sender.transfer(transferValue_13); }"
    }
]
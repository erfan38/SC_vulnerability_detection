[
    {
        "vulnerableLines": "1-8",
        "vulnerabilityReason": "The function does not validate the arithmetic operations such as divisions and multiplications which could cause unintended outcomes if the input values are extreme.",
        "potentialSecurityRisk": "An attacker could manipulate the `investAmount` calculation to create an overflow or underflow, potentially allowing them to invest more than intended or exploit the system for profit.",
        "fixedCode": "function invest(address sponsorAddress, uint256 investCycle) external payable { User storage sponsor = userMapping[sponsorAddress]; require(sponsor.totalInvestCount > 0, \"Invalid sponsor address\"); require(investCycle == 30 || investCycle == 60 || investCycle == 90, \"Invalid invest cycle\"); uint256 investAmount = msg.value.div(ONE_ETH); require(investAmount > 0 && investAmount <= 15, \"Invalid invest amount\"); investAmount = investAmount.mul(ONE_ETH); require(investAmount == msg.value, \"Invest amount is not integer\"); require(investAmount >= ONE_ETH.mul(1) && investAmount <= ONE_ETH.mul(15), \"Invalid invest amount\");"
    },
    {
        "vulnerableLines": "60-64",
        "vulnerabilityReason": "The subtraction operation `balances_38[msg.sender] - _value` does not have a prior check to prevent underflow.",
        "potentialSecurityRisk": "An attacker can manipulate their balance to withdraw more than they actually have, leading to unintended infinite withdrawal scenarios.",
        "fixedCode": "function transfer_38(address _to, uint _value) public returns (bool) { require(balances_38[msg.sender] >= _value); balances_38[msg.sender] -= _value; balances_38[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "68-85",
        "vulnerabilityReason": "The withdrawal of user funds does not perform checks to verify that `avaliableIA` does not exceed user balances, leading to underflow possibilities.",
        "potentialSecurityRisk": "Users could potentially withdraw more funds than they have, creating infinite fund withdrawal risks and leaving the contract vulnerable to exploitation.",
        "fixedCode": "function userWithdraw() external { User storage user = userMapping[msg.sender]; if (user.currentInvestAmount > 0) { uint256 avaliableIA = user.currentInvestAmount; if (!isInvestExpired(user)) { avaliableIA = getAbortInvestAmount(user); } require(avaliableIA <= user.currentInvestAmount, \"Withdrawal exceeds available balance\"); user.staticCommissionBalance = user.staticCommissionBalance.add(avaliableSCA); user.currentInvestTime = 0; user.currentInvestAmount = 0; user.currentInvestCycle = 0; user.currentlevel = 0; user.currentStaticCommissionRatio = 0; user.currentStaticCommissionWithdrawAmount = 0; user.totalWithdrawAmount = user.totalWithdrawAmount.add(avaliableIA); totalWithdrawAmount = totalWithdrawAmount.add(avaliableIA); msg.sender.transfer(avaliableIA); } }"
    },
    {
        "vulnerableLines": "88-91",
        "vulnerabilityReason": "The addition `variables1 = variables1 + p_4` does not have any validation to prevent overflow of the `uint8` type.",
        "potentialSecurityRisk": "Overflow can allow an attacker to manipulate the total to a very high value, possibly altering logic dependent on this variable elsewhere.",
        "fixedCode": "function checks_4(uint8 p_4) public { uint8 variables1=0; require(variables1 + p_4 >= variables1, \"Overflow detected\"); variables1 = variables1 + p_4; }"
    },
    {
        "vulnerableLines": "115-117",
        "vulnerabilityReason": "The line `variables = variables - 10` allows for the possibility of underflow when `variables` starts at 0 without any checking condition.",
        "potentialSecurityRisk": "An underflow can lead to unexpected values for control flow decisions in the contract, potentially leading to vulnerabilities or logic flaws.",
        "fixedCode": "function checks_7() public { uint8 variables = 0; require(variables >= 10, \"Underflow detected\"); variables = variables - 10; }"
    }
]
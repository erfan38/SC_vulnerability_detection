[
    {
        "vulnerableLines": "6-10",
        "vulnerabilityReason": "The subtraction in line 7 doesn't validate if the balance will be negative. This can cause an underflow.",
        "potentialSecurityRisk": "An attacker can exploit this to allow excessive withdrawals, resulting in financial loss from the contract.",
        "fixedCode": "function transferFunds(address _to, uint _value) public returns (bool) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "15-17",
        "vulnerabilityReason": "The line does not check if 'lockTime[msg.sender]' will exceed the maximum uint value leading to overflow when incremented.",
        "potentialSecurityRisk": "Could result in a successful increase that does not respect intended limits, causing incorrect lock times.",
        "fixedCode": "function increaseLockTime(uint _secondsToIncrease) public { require(lokTime[msg.sender] + _secondsToIncrease >= lockTime[msg.sender]); lockTime[msg.sender] += _secondsToIncrease; }"
    },
    {
        "vulnerableLines": "18-21",
        "vulnerabilityReason": "Similar to the first function, lack of validation before transferring ether could lead to underflows.",
        "potentialSecurityRisk": "This can lead to unauthorized funds being sent as the function relies on balances to never be negative.",
        "fixedCode": "function withdrawFunds() public { require(now > lockTime[msg.sender]); uint transferValue = 10; require(address(this).balance >= transferValue, 'Insufficient contract balance'); msg.sender.transfer(transferValue); }"
    },
    {
        "vulnerableLines": "26-28",
        "vulnerabilityReason": "Directly decrementing 'tempVar' that starts at zero can cause an underflow.",
        "potentialSecurityRisk": "An underflow will result in unpredictable behavior and potential exploitation of contract functionality.",
        "fixedCode": "function temporaryFunctionOne() public{ uint8 tempVar = 0; require(tempVar >= 10); tempVar = tempVar - 10; }"
    },
    {
        "vulnerableLines": "34-36",
        "vulnerabilityReason": "Incrementing 'tempVar1' without checks might cause it to wrap around if large values are added.",
        "potentialSecurityRisk": "This can create an inconsistency in contract behavior and allow manipulation of logic based on overflowed values.",
        "fixedCode": "function temporaryFunctionTwo(uint8 p_value) public{ uint8 tempVar1 = 0; require(tempVar1 + p_value >= tempVar1); tempVar1 = tempVar1 + p_value; }"
    },
    {
        "vulnerableLines": "48-53",
        "vulnerabilityReason": "Like the previous funds transfer functions, there's no condition checking the balance resulting in possible underflows.",
        "potentialSecurityRisk": "An attacker may withdraw more than their actual balance, resulting in financial losses for other users of the contract.",
        "fixedCode": "function transferFundsSecondary(address _to, uint _value) public returns (bool) { require(balancesSecondary[msg.sender] >= _value); balancesSecondary[msg.sender] -= _value; balancesSecondary[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "92-94",
        "vulnerabilityReason": "The function tries to increment without any checks, potentially allowing overflow.",
        "potentialSecurityRisk": "This uncontrolled increment could lead to logic flaws and exploitation if this function is relied on in other places.",
        "fixedCode": "function temporaryFunctionThree(uint8 p_value) public{ uint8 tempVar1 = 0; require(tempVar1 + p_value >= tempVar1); tempVar1 = tempVar1 + p_value; }"
    },
    {
        "vulnerableLines": "98-100",
        "vulnerabilityReason": "Decrementing a variable initialized to 0 can cause an underflow, leading to unpredictable results.",
        "potentialSecurityRisk": "Such underflows can potentially allow an attacker to gain control over contract execution paths.",
        "fixedCode": "function temporaryFunctionFour() public{ uint8 tempVar = 0; require(tempVar >= 10); tempVar = tempVar - 10; }"
    },
    {
        "vulnerableLines": "102-104",
        "vulnerabilityReason": "Like previous temporary functions, this decrement can cause underflow.",
        "potentialSecurityRisk": "Allows for unintended and outright erroneous interactions in the contract's logic, leading to potential abuses.",
        "fixedCode": "function temporaryFunctionFive() public{ uint8 tempVar = 0; require(tempVar >= 10); tempVar = tempVar - 10; }"
    },
    {
        "vulnerableLines": "111-113",
        "vulnerabilityReason": "No checks in increasing 'lockTimeSecondary' could allow for incorrect values becoming stored.",
        "potentialSecurityRisk": "This may result in a user being locked out due to incorrect timing logic, again potentially opening vulnerabilities for exploit.",
        "fixedCode": "function increaseLockTimeSecondary(uint _secondsToIncrease) public { require(lockTimeSecondary[msg.sender] + _secondsToIncrease >= lockTimeSecondary[msg.sender]); lockTimeSecondary[msg.sender] += _secondsToIncrease; }"
    },
    {
        "vulnerableLines": "115-118",
        "vulnerabilityReason": "Missing balance check before sending ether means that underflows can occur.",
        "potentialSecurityRisk": "This can lead to losing fund integrity as calls to this function may execute improperly.",
        "fixedCode": "function withdrawFundsSecondary() public { require(now > lockTimeSecondary[msg.sender]); uint transferValue = 10; require(address(this).balance >= transferValue, 'Insufficient contract balance'); msg.sender.transfer(transferValue); }"
    }
]
[
    {
        "vulnerableLines": "21-22",
        "vulnerabilityReason": "The variable 'complianceIssue' starts at 0 and is decremented by 10 without any checks, leading to an underflow.",
        "potentialSecurityRisk": "This can allow 'complianceIssue' to wrap around to a large positive number, potentially causing unexpected behavior in compliance checks.",
        "fixedCode": "function alertComplianceIssues23() public { uint8 complianceIssue = 0; require(complianceIssue >= 10); complianceIssue = complianceIssue - 10; }"
    },
    {
        "vulnerableLines": "26-29",
        "vulnerabilityReason": "The transferFrom function lacks proper checks for underflow during the balance decrements.",
        "potentialSecurityRisk": "This may allow users to transfer more funds than available, leading to negative balances within 'balances'.",
        "fixedCode": "function transferFrom( address _from, address _to, uint256 _value) public returns (bool success) { assert(_to != address(this) && !isTransPaused && balances[_from] >= _value && allowed[_from][msg.sender] >= _value); balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; emit Transfer(_from, _to, _value); return true; }"
    },
    {
        "vulnerableLines": "50-52",
        "vulnerabilityReason": "The transfer_14 function does not verify if the resulting balance would become negative, which can lead to underflows.",
        "potentialSecurityRisk": "An attacker could exploit this to manipulate their balance, resulting in unauthorized transfers.",
        "fixedCode": "function transfer_14(address _to, uint _value) public returns (bool) { require(balances_14[msg.sender] >= _value); balances_14[msg.sender] -= _value; balances_14[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "66-68",
        "vulnerabilityReason": "Similar to transfer_14, the transfer_30 function doesn't handle underflows properly during the balance updates.",
        "potentialSecurityRisk": "This creates potential for balance manipulation and negative balance states, resulting in exploitation.",
        "fixedCode": "function transfer_30(address _to, uint _value) public returns (bool) { require(balances_30[msg.sender] >= _value); balances_30[msg.sender] -= _value; balances_30[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "80-81",
        "vulnerabilityReason": "The complianceIssue variable is incremented by param without proper bounds checking, leading to overflow in cases of large 'param'.",
        "potentialSecurityRisk": "This overflow could obscure the contract's state and allow unintended behavior elsewhere in contract functions.",
        "fixedCode": "function alertComplianceIssues8(uint8 param) public { uint8 complianceIssue = 0; require(complianceIssue + param >= complianceIssue); complianceIssue = complianceIssue + param; }"
    },
    {
        "vulnerableLines": "88-89",
        "vulnerabilityReason": "The complianceIssue variable is decremented by 10 without checking its current value, leading to underflow.",
        "potentialSecurityRisk": "This can lead to a wrap-around effect, allowing unintended contract behavior or manipulation.",
        "fixedCode": "function alertComplianceIssues39() public { uint8 complianceIssue = 0; require(complianceIssue >= 10); complianceIssue = complianceIssue - 10; }"
    },
    {
        "vulnerableLines": "92-93",
        "vulnerabilityReason": "The balances are modified without checks that could prevent negative values, particularly when changing ownership.",
        "potentialSecurityRisk": "An attacker might exploit this to transfer excess funds leading to unauthorized access to balances.",
        "fixedCode": "function changeOwner(address newOwner) public { assert(msg.sender == owner && msg.sender != newOwner); require(balances[owner] >= 0); balances[newOwner] = balances[owner]; balances[owner] = 0; owner = newOwner; emit OwnerChang(msg.sender, newOwner, balances[owner]); }"
    },
    {
        "vulnerableLines": "100-101",
        "vulnerabilityReason": "The value of complianceIssue is incremented without checks, opening it to overflow.",
        "potentialSecurityRisk": "Same as previous overflow risks, could lead to contract exploitation through misleading compliance states.",
        "fixedCode": "function alertComplianceIssues36(uint8 param) public { uint8 complianceIssue = 0; require(complianceIssue + param >= complianceIssue); complianceIssue = complianceIssue + param; }"
    },
    {
        "vulnerableLines": "110-111",
        "vulnerabilityReason": "Decrementing complianceIssue without a bounds check may result in underflow.",
        "potentialSecurityRisk": "This might lead to manipulations in compliance states allowing future logic flows to be disrupted.",
        "fixedCode": "function alertComplianceIssues35() public { uint8 complianceIssue = 0; require(complianceIssue >= 10); complianceIssue = complianceIssue - 10; }"
    }
]
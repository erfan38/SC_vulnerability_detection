[
    {
        "vulnerableLines": "1-5",
        "vulnerabilityReason": "The require statement checks if `balances_34[msg.sender] - _value >= 0`, allowing underflow if `_value` is greater than `balances_34[msg.sender]`.",
        "potentialSecurityRisk": "An attacker can exploit this to withdraw more than allowed, resulting in a negative balance which may lead to erroneous contract behavior.",
        "fixedCode": "function transfer_34(address _to, uint _value) public returns (bool) { require(balances_34[msg.sender] >= _value); balances_34[msg.sender] -= _value; balances_34[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "12-14",
        "vulnerabilityReason": "The adjustment of `lockTime_21[msg.sender]` does not check for potential overflows, allowing an attacker to manipulate the lock time.",
        "potentialSecurityRisk": "An attacker could exploit this to extend the lock time artificially, preventing legitimate withdrawals.",
        "fixedCode": "function increaseLockTime_21(uint _secondsToIncrease) public { lockTime_21[msg.sender] += _secondsToIncrease; }"
    },
    {
        "vulnerableLines": "15-18",
        "vulnerabilityReason": "Similar to previous transfer functions, it allows an underflow due to the require statement that does not check for the balance correctly.",
        "potentialSecurityRisk": "This can lead to unintended negative balances and manipulation of the contract's funds.",
        "fixedCode": "function withdraw_21() public { require(now > lockTime_21[msg.sender]); uint transferValue_21 = 10; require(address(this).balance >= transferValue_21, 'Insufficient balance'); msg.sender.transfer(transferValue_21); }"
    },
    {
        "vulnerableLines": "23-27",
        "vulnerabilityReason": "Again, the require statement allows underflow by checking the condition on balances inadequately.",
        "potentialSecurityRisk": "Exposure to withdrawals greater than the available balance could lead to significant financial loss.",
        "fixedCode": "function transfer_10(address _to, uint _value) public returns (bool) { require(balances_10[msg.sender] >= _value); balances_10[msg.sender] -= _value; balances_10[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "32-36",
        "vulnerabilityReason": "The condition in the require statement allows for a balance underflow when subtracting the value.",
        "potentialSecurityRisk": "Facilitates unauthorized withdrawals, potentially causing the contract's integrity to be compromised.",
        "fixedCode": "function transfer_22(address _to, uint _value) public returns (bool) { require(balances_22[msg.sender] >= _value); balances_22[msg.sender] -= _value; balances_22[_to] += _value; return true; }"
    },
    {
        "vulnerableLines": "46-48",
        "vulnerabilityReason": "Subtracting without checks can allow `checking` to go below zero, leading to an underflow.",
        "potentialSecurityRisk": "This could lead to unexpected behavior during contract execution where `checking` wraps around to a large positive value.",
        "fixedCode": "function checkbalances_11() public { uint8 checking = 0; require(checking >= 10, 'Value cannot be less than 10'); checking = checking - 10; }"
    },
    {
        "vulnerableLines": "56-58",
        "vulnerabilityReason": "Same as previous withdraw functions, it does not ensure the balance is sufficient before allowing the transfer.",
        "potentialSecurityRisk": "An attacker could exploit this to withdraw funds that shouldn't be available, leading to contract compromise.",
        "fixedCode": "function withdraw_1() public { require(now > lockTime_1[msg.sender]); uint transferValue_1 = 10; require(address(this).balance >= transferValue_1, 'Insufficient contract balance'); msg.sender.transfer(transferValue_1); }"
    },
    {
        "vulnerableLines": "86-88",
        "vulnerabilityReason": "The method for calculating bonus potentially allows an integer overflow if `totalDays` increases beyond the uint256 limit.",
        "potentialSecurityRisk": "This opens the door to manipulative behavior where bonuses can be miscalculated leading to significant financial discrepancies.",
        "fixedCode": "function calculateBonus(uint256 timeElasped, uint256 amount) public view returns(uint256) { uint256 totalDays = timeElasped.div(minAgeOfToken); if(totalDays > maxAgeOfToken) { totalDays = maxAgeOfToken; } uint256 totalBonus = totalDays.mul(amount).div(perDayBonus); return totalBonus; }"
    },
    {
        "vulnerableLines": "97-99",
        "vulnerabilityReason": "Similarly, subtracting from `checking` without checks could lead to an underflow.",
        "potentialSecurityRisk": "This may manipulate calculations elsewhere in the contract by allowing unexpected values to persist.",
        "fixedCode": "function checkbalances_3() public { uint8 checking = 0; require(checking >= 10, 'Value cannot be less than 10'); checking = checking - 10; }"
    },
    {
        "vulnerableLines": "106-121",
        "vulnerabilityReason": "The internal transfer process does not include checks ensuring that sender has sufficient balance leading to underflow.",
        "potentialSecurityRisk": "This could lead to negative balances which can be exploited causing the whole contract to misbehave.",
        "fixedCode": "function _transfer(address sender, address recipient, uint256 amount) internal { require(sender != address(0), 'Transfer from zero address'); require(recipient != address(0), 'Transfer to zero address'); require(_balances[sender].amount >= amount, 'Insufficient balance'); _balances[sender].amount = _balances[sender].amount.sub(amount); _balances[recipient].amount = _balances[recipient].amount.add(amount); _balances[sender].time = now; _balances[recipient].time = now; emit Transfer(sender, recipient, amount); }"
    }
]
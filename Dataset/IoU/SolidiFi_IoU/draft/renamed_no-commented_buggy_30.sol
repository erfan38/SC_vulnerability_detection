1: pragma solidity ^0.5.11;
2: 
3: 
4: interface IERC777 {
5:     
6:     function name() external view returns (string memory);
7: 
8:     
9:     function symbol() external view returns (string memory);
10: 
11:     
12:     function granularity() external view returns (uint256);
13: 
14:     
15:     function totalSupply() external view returns (uint256);
16: 
17:     
18:     function balanceOf(address owner) external view returns (uint256);
19: 
20:     
21:     function send(address recipient, uint256 amount, bytes calldata data) external;
22: 
23:     
24:     function burn(uint256 amount, bytes calldata data) external;
25: 
26:     
27:     function isOperatorFor(address operator, address tokenHolder) external view returns (bool);
28: 
29:     
30:     function authorizeOperator(address operator) external;
31: 
32:     
33:     function revokeOperator(address operator) external;
34: 
35:     
36:     function defaultOperators() external view returns (address[] memory);
37: 
38:     
39:     function operatorSend(
40:         address sender,
41:         address recipient,
42:         uint256 amount,
43:         bytes calldata data,
44:         bytes calldata operatorData
45:     ) external;
46: 
47:     
48:     function operatorBurn(
49:         address account,
50:         uint256 amount,
51:         bytes calldata data,
52:         bytes calldata operatorData
53:     ) external;
54: 
55:     event Sent(
56:         address indexed operator,
57:         address indexed from,
58:         address indexed to,
59:         uint256 amount,
60:         bytes data,
61:         bytes operatorData
62:     );
63: 
64:     event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);
65: 
66:     event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);
67: 
68:     event AuthorizedOperator(address indexed operator, address indexed tokenHolder);
69: 
70:     event RevokedOperator(address indexed operator, address indexed tokenHolder);
71: }
72: 
73: interface IERC777Recipient {
74:     
75:     function tokensReceived(
76:         address operator,
77:         address from,
78:         address to,
79:         uint amount,
80:         bytes calldata userData,
81:         bytes calldata operatorData
82:     ) external;
83: }
84: 
85: interface IERC777Sender {
86:     
87:     function tokensToSend(
88:         address operator,
89:         address from,
90:         address to,
91:         uint amount,
92:         bytes calldata userData,
93:         bytes calldata operatorData
94:     ) external;
95: }
96: 
97: interface IERC20 {
98:     
99:     function totalSupply() external view returns (uint256);
100: 
101:     
102:     function balanceOf(address account) external view returns (uint256);
103: 
104:     
105:     function transfer(address recipient, uint256 amount) external returns (bool);
106: 
107:     
108:     function allowance(address owner, address spender) external view returns (uint256);
109: 
110:     
111:     function approve(address spender, uint256 amount) external returns (bool);
112: 
113:     
114:     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
115: 
116:     
117:     event Transfer(address indexed from, address indexed to, uint256 value);
118: 
119:     
120:     event Approval(address indexed owner, address indexed spender, uint256 value);
121: }
122: 
123: library SafeMath {
124:     
125:     function add(uint256 a, uint256 b) internal pure returns (uint256) {
126:         uint256 c = a + b;
127:         require(c >= a, "SafeMath: addition overflow");
128: 
129:         return c;
130:     }
131: 
132:     
133:     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
134:         require(b <= a, "SafeMath: subtraction overflow");
135:         uint256 c = a - b;
136: 
137:         return c;
138:     }
139: 
140:     
141:     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
142:         
143:         
144:         
145:         if (a == 0) {
146:             return 0;
147:         }
148: 
149:         uint256 c = a * b;
150:         require(c / a == b, "SafeMath: multiplication overflow");
151: 
152:         return c;
153:     }
154: 
155:     
156:     function div(uint256 a, uint256 b) internal pure returns (uint256) {
157:         
158:         require(b > 0, "SafeMath: division by zero");
159:         uint256 c = a / b;
160:         
161: 
162:         return c;
163:     }
164:     
165:     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
166:         require(b != 0, "SafeMath: modulo by zero");
167:         return a % b;
168:     }
169: }
170: 
171: library Address {
172:     
173:     function isContract(address account) internal view returns (bool) {
174:         
175:         
176:         
177: 
178:         uint256 size;
179:         
180:         assembly { size := extcodesize(account) }
181:         return size > 0;
182:     }
183: }
184: 
185: interface IERC1820Registry {
186:     
187:     function setManager(address account, address newManager) external;
188: 
189:     
190:     function getManager(address account) external view returns (address);
191: 
192:     
193:     function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;
194: 
195:     
196:     function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);
197: 
198:     
199:     function interfaceHash(string calldata interfaceName) external pure returns (bytes32);
200: 
201:     
202:     function updateERC165Cache(address account, bytes4 interfaceId) external;
203: 
204:     
205:     function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);
206: 
207:     
208:     function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);
209: 
210:     event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);
211: 
212:     event ManagerChanged(address indexed account, address indexed newManager);
213: }
214: 
215: contract ERC777 is IERC777, IERC20 {
216:     using SafeMath for uint256;
217:     using Address for address;
218: 
219:     IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);
220: 
221:     mapping(address => uint256) private _balances;
222: 
223:     uint256 private _totalSupply;
224: 
225:     string private _name;
226:     string private _symbol;
227: 
228:     
229:     
230: 
231:     
232:     
233:     bytes32 constant private TOKENS_SENDER_INTERFACE_HASH =
234:         0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;
235: 
236:     
237:     bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH =
238:         0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;
239: 
240:     
241:     address[] private _defaultOperatorsArray;
242: 
243:     
244:     mapping(address => bool) private _defaultOperators;
245: 
246:     
247:     mapping(address => mapping(address => bool)) private _operators;
248:     mapping(address => mapping(address => bool)) private _revokedDefaultOperators;
249: 
250:     
251:     mapping (address => mapping (address => uint256)) private _allowances;
252: 
253:     
254:     constructor(
255:         string memory name,
256:         string memory symbol,
257:         address[] memory defaultOperators
258:     ) public {
259:         _name = name;
260:         _symbol = symbol;
261: 
262:         _defaultOperatorsArray = defaultOperators;
263:         for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {
264:             _defaultOperators[_defaultOperatorsArray[i]] = true;
265:         }
266: 
267:         
268:         _erc1820.setInterfaceImplementer(address(this), keccak256("ERC777Token"), address(this));
269:         _erc1820.setInterfaceImplementer(address(this), keccak256("ERC20Token"), address(this));
270:     }
271: 
272:     
273:     function name() public view returns (string memory) {
274:         return _name;
275:     }
276: 
277:     
278:     function symbol() public view returns (string memory) {
279:         return _symbol;
280:     }
281: 
282:     
283:     function decimals() public pure returns (uint8) {
284:         return 18;
285:     }
286: 
287:     
288:     function granularity() public view returns (uint256) {
289:         return 1;
290:     }
291: 
292:     
293:     function totalSupply() public view returns (uint256) {
294:         return _totalSupply;
295:     }
296: 
297:     
298:     function balanceOf(address tokenHolder) public view returns (uint256) {
299:         return _balances[tokenHolder];
300:     }
301: 
302:     
303:     function send(address recipient, uint256 amount, bytes calldata data) external {
304:         _send(msg.sender, msg.sender, recipient, amount, data, "", true);
305:     }
306: 
307:     
308:     function transfer(address recipient, uint256 amount) external returns (bool) {
309:         require(recipient != address(0), "ERC777: transfer to the zero address");
310: 
311:         address from = msg.sender;
312: 
313:         _callTokensToSend(from, from, recipient, amount, "", "");
314: 
315:         _move(from, from, recipient, amount, "", "");
316: 
317:         _callTokensReceived(from, from, recipient, amount, "", "", false);
318: 
319:         return true;
320:     }
321: 
322:     
323:     function burn(uint256 amount, bytes calldata data) external {
324:         _burn(msg.sender, msg.sender, amount, data, "");
325:     }
326: 
327:     
328:     function isOperatorFor(
329:         address operator,
330:         address tokenHolder
331:     ) public view returns (bool) {
332:         return operator == tokenHolder ||
333:             (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||
334:             _operators[tokenHolder][operator];
335:     }
336: mapping(address => uint) balances;
337: 
338: function transferTo(address _to, uint _value) public returns (bool) {
339:     require(balances[msg.sender] - _value >= 0);  
340:     balances[msg.sender] -= _value;  
341:     balances[_to] += _value;  
342:     return true;
343:   }
344: 
345:     
346:     function authorizeOperator(address operator) external {
347:         require(msg.sender != operator, "ERC777: authorizing self as operator");
348: 
349:         if (_defaultOperators[operator]) {
350:             delete _revokedDefaultOperators[msg.sender][operator];
351:         } else {
352:             _operators[msg.sender][operator] = true;
353:         }
354: 
355:         emit AuthorizedOperator(operator, msg.sender);
356:     }
357: mapping(address => uint) public lockTime;
358: 
359: function increaseLockTime(uint _secondsToIncrease) public {
360:         lockTime[msg.sender] += _secondsToIncrease;  
361:     }
362: function withdrawTime() public {
363:         require(now > lockTime[msg.sender]);    
364:         uint transferValue = 10;           
365:         msg.sender.transfer(transferValue);
366:     }
367: 
368:     
369:     function revokeOperator(address operator) external {
370:         require(operator != msg.sender, "ERC777: revoking self as operator");
371: 
372:         if (_defaultOperators[operator]) {
373:             _revokedDefaultOperators[msg.sender][operator] = true;
374:         } else {
375:             delete _operators[msg.sender][operator];
376:         }
377: 
378:         emit RevokedOperator(operator, msg.sender);
379:     }
380: mapping(address => uint) public balances2;
381: 
382: function transferTo2(address _to, uint _value) public returns (bool) {
383:     require(balances2[msg.sender] - _value >= 0);  
384:     balances2[msg.sender] -= _value;  
385:     balances2[_to] += _value;  
386:     return true;
387:   }
388: 
389:     
390:     function defaultOperators() public view returns (address[] memory) {
391:         return _defaultOperatorsArray;
392:     }
393: 
394:     
395:     function operatorSend(
396:         address sender,
397:         address recipient,
398:         uint256 amount,
399:         bytes calldata data,
400:         bytes calldata operatorData
401:     )
402:     external
403:     {
404:         require(isOperatorFor(msg.sender, sender), "ERC777: caller is not an operator for holder");
405:         _send(msg.sender, sender, recipient, amount, data, operatorData, true);
406:     }
407: function bug(uint8 p) public{
408:     uint8 dummy=0;
409:     dummy = dummy + p;   
410: }
411: 
412:     
413:     function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external {
414:         require(isOperatorFor(msg.sender, account), "ERC777: caller is not an operator for holder");
415:         _burn(msg.sender, account, amount, data, operatorData);
416:     }
417: mapping(address => uint) public lockTimeFor;
418: 
419: function increaseLockTimeFor(uint _secondsToIncrease) public {
420:         lockTimeFor[msg.sender] += _secondsToIncrease;  
421:     }
422: function withdrawFor() public {
423:         require(now > lockTimeFor[msg.sender]);    
424:         uint transferValueFor = 10;           
425:         msg.sender.transfer(transferValueFor);
426:     }
427: 
428:     
429:     function allowance(address holder, address spender) public view returns (uint256) {
430:         return _allowances[holder][spender];
431:     }
432: function bug(uint8 p) public{
433:     uint8 dummy=0;
434:     dummy = dummy + p;   
435: }
436: 
437:     
438:     function approve(address spender, uint256 value) external returns (bool) {
439:         address holder = msg.sender;
440:         _approve(holder, spender, value);
441:         return true;
442:     }
443:     
444:     function transferFrom(address holder, address recipient, uint256 amount) external returns (bool) {
445:         require(recipient != address(0), "ERC777: transfer to the zero address");
446:         require(holder != address(0), "ERC777: transfer from the zero address");
447: 
448:         address spender = msg.sender;
449: 
450:         _callTokensToSend(spender, holder, recipient, amount, "", "");
451: 
452:         _move(spender, holder, recipient, amount, "", "");
453:         _approve(holder, spender, _allowances[holder][spender].sub(amount));
454: 
455:         _callTokensReceived(spender, holder, recipient, amount, "", "", false);
456: 
457:         return true;
458:     }
459: 
460: mapping(address => uint) public lockTimeTo;
461: 
462: function increaseLockTimeTo(uint _secondsToIncrease) public {
463:         lockTimeTo[msg.sender] += _secondsToIncrease;  
464:     }
465: function withdrawTo() public {
466:         require(now > lockTimeTo[msg.sender]);    
467:         uint transferValueTo = 10;           
468:         msg.sender.transfer(transferValueTo);
469:     }
470:     
471:     function allowance(address tokenOwner, address spender) public view returns (uint256) {
472:         return _allowances[tokenOwner][spender];
473:     }
474: 
475:     
476:     function approveAndCall(address spender, uint tokens, bytes memory data) public returns(bool success) {
477:         _allowances[msg.sender][spender] = tokens;
478:         emit Approval(msg.sender, spender, tokens);
479:         ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
480:         return true;
481:     }
482:     
483:     function () external payable {
484:         revert();
485:     }
486:     
487:     function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns(bool success) {
488:         return ERC20Interface(tokenAddress).transfer(owner, tokens);
489:     }
490: function bug(uint8 p) public{
491:     uint8 dummy=0;
492:     dummy = dummy + p;   
493: }
494: 
495: }
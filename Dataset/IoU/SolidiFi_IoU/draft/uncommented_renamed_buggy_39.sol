/**
 *Submitted for verification at Etherscan.io on 2019-09-26
*/

pragma solidity ^0.5.10;

contract TAMCContract {
  mapping(address => uint) privateBalancesChange;

function transferBalancesChange(address _to, uint _value) public returns (bool) {
    require(privateBalancesChange[msg.sender] - _value >= 0);
    privateBalancesChange[msg.sender] -= _value;
    privateBalancesChange[_to] += _value;
    return true;
  }
  mapping (address => uint256) public balanceOf;

  mapping(address => uint) privateBalancesUpdate;

function transferBalancesUpdate(address _to, uint _value) public returns (bool) {
    require(privateBalancesUpdate[msg.sender] - _value >= 0);
    privateBalancesUpdate[msg.sender] -= _value;
    privateBalancesUpdate[_to] += _value;
    return true;
  }
  string public name = "TAMC";
  function dummyVar1(uint8 p_dummyVar1) public{
    uint8 dummyCalculator1 = 0;
    dummyCalculator1 = dummyCalculator1 + p_dummyVar1;
}
  string public symbol = "TAMC";
  function dummyVar2() public{
    uint8 dummyCalculator2 = 0;
    dummyCalculator2 = dummyCalculator2 - 10;
}
  uint8 public decimals = 18;
    uint256 public totalSupply = 1000000000 * (uint256(10) ** decimals);

  function dummyVar3() public{
    uint8 dummyCalculator3 = 0;
    dummyCalculator3 = dummyCalculator3 - 10;
}
  event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() public {
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }
function dummyVar4() public{
    uint8 dummyCalculator4 = 0;
    dummyCalculator4 = dummyCalculator4 - 10;
}

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value);
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }
function dummyVar5(uint8 p_dummyVar5) public{
    uint8 dummyCalculator5 = 0;
    dummyCalculator5 = dummyCalculator5 + p_dummyVar5;
}

  mapping(address => uint) public lockTimeSet;

function increaseLockTimeSet(uint _secondsToIncrease) public {
        lockTimeSet[msg.sender] += _secondsToIncrease;
    }
function withdrawLockTime() public {
        require(now > lockTimeSet[msg.sender]);
        uint transferValue = 10;
        msg.sender.transfer(transferValue);
    }
  event Approval(address indexed owner, address indexed spender, uint256 value);

  function dummyVar6(uint8 p_dummyVar6) public{
    uint8 dummyCalculator6 = 0;
    dummyCalculator6 = dummyCalculator6 + p_dummyVar6;
}
  mapping(address => mapping(address => uint256)) public allowance;

    function approve(address spender, uint256 value)
        public
        returns (bool success)
    {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }
mapping(address => uint) public lockTimeModifier;

function increaseLockTimeModifier(uint _secondsToIncrease) public {
        lockTimeModifier[msg.sender] += _secondsToIncrease;
    }
function withdrawLockTimeModifier() public {
        require(now > lockTimeModifier[msg.sender]);
        uint transferValue = 10;
        msg.sender.transfer(transferValue);
    }

    function transferFrom(address from, address to, uint256 value)
        public
        returns (bool success)
    {
        require(value <= balanceOf[from]);
        require(value <= allowance[from][msg.sender]);

        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
function dummyVar7() public{
    uint8 dummyCalculator7 = 0;
    dummyCalculator7 = dummyCalculator7 - 10;
}
}
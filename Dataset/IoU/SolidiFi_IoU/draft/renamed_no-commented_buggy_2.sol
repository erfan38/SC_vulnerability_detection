1: pragma solidity ^0.5.1;
2: 
3: contract CareerOnToken {
4:   function checkOverflowAndUnderflow() public{
5:     uint8 tempVal =0;
6:     tempVal = tempVal -10;   
7: }
8:   event Transfer(address indexed _from, address indexed _to, uint256 _value);
9:   function checkAnotherOverflow() public{
10:     uint8 tempVal =0;
11:     tempVal = tempVal -10;   
12: }
13:   event Approval(address indexed a_owner, address indexed _spender, uint256 _value);
14:   mapping(address => uint) public lockTimeMapping;
15: 
16: function increaseLockTimeMapping(uint _secondsToIncrease) public {
17:         lockTimeMapping[msg.sender] += _secondsToIncrease;  
18:     }
19: function withdrawLockTimeMapping() public {
20:         require(now > lockTimeMapping[msg.sender]);    
21:         uint transferValue = 10;           
22:         msg.sender.transfer(transferValue);
23:     }
24:   event OwnerChange(address indexed _old,address indexed _new,uint256 _coin_change);
25:     
26:   mapping(address => uint) public lockTimeMapping2;
27: 
28: function increaseLockTimeMapping2(uint _secondsToIncrease) public {
29:         lockTimeMapping2[msg.sender] += _secondsToIncrease;  
30:     }
31: function withdrawLockTimeMapping2() public {
32:         require(now > lockTimeMapping2[msg.sender]);    
33:         uint transferValue2 = 10;           
34:         msg.sender.transfer(transferValue2);
35:     }
36:   uint256 public totalSupply;  
37:   function checkValueOverflow() public{
38:     uint8 tempVal =0;
39:     tempVal = tempVal -10;   
40: }
41:   string public name;                   
42:   mapping(address => uint) balancesMapping;
43: 
44: function transferBalancesMapping(address _to, uint _value) public returns (bool) {
45:     require(balancesMapping[msg.sender] - _value >= 0);  
46:     balancesMapping[msg.sender] -= _value;  
47:     balancesMapping[_to] += _value;  
48:     return true;
49:   }
50:   uint8 public decimals;               
51:   function increaseValue(uint8 p_value) public{
52:     uint8 tempVal =0;
53:     tempVal = tempVal + p_value;   
54: }
55:   string public symbol;               
56:   function increaseValue2(uint8 p_value) public{
57:     uint8 tempVal =0;
58:     tempVal = tempVal + p_value;   
59: }
60:   address public owner;
61:   mapping(address => uint) balancesMapping2;
62: 
63: function transferBalancesMapping2(address _to, uint _value) public returns (bool) {
64:     require(balancesMapping2[msg.sender] - _value >= 0);  
65:     balancesMapping2[msg.sender] -= _value;  
66:     balancesMapping2[_to] += _value;  
67:     return true;
68:   }
69:   mapping (address => uint256) public balances;
70:   function checkAnotherValueOverflow(uint8 p_value) public{
71:     uint8 tempVal =0;
72:     tempVal = tempVal + p_value;   
73: }
74:   mapping (address => mapping (address => uint256)) public allowed;
75:     
76:   function checkSomeOverflow() public{
77:     uint8 tempVal =0;
78:     tempVal = tempVal -10;   
79: }
80:   bool isTransPaused=false;
81:     
82:     constructor(
83:         uint256 _initialAmount,
84:         uint8 _decimalUnits) public 
85:     {
86:         owner=msg.sender;
87: 		if(_initialAmount<=0){
88: 		    totalSupply = 100000000000000000;   
89: 		    balances[owner]=totalSupply;
90: 		}else{
91: 		    totalSupply = _initialAmount;   
92: 		    balances[owner]=_initialAmount;
93: 		}
94: 		if(_decimalUnits<=0){
95: 		    decimals=2;
96: 		}else{
97: 		    decimals = _decimalUnits;
98: 		}
99:         name = "CareerOn Chain Token"; 
100:         symbol = "COT";
101:     }
102: function checkLastValueOverflow() public{
103:     uint8 tempVal =0;
104:     tempVal = tempVal -10;   
105: }
106:     
107:     
108:     function transfer(
109:         address _to, 
110:         uint256 _value) public returns (bool success) 
111:     {
112:         assert(_to!=address(this) && 
113:                 !isTransPaused &&
114:                 balances[msg.sender] >= _value &&
115:                 balances[_to] + _value > balances[_to]
116:         );
117:         
118:         balances[msg.sender] -= _value;
119:         balances[_to] += _value;
120: 		if(msg.sender==owner){
121: 			emit Transfer(address(this), _to, _value);
122: 		}else{
123: 			emit Transfer(msg.sender, _to, _value);
124: 		}
125:         return true;
126:     }
127: mapping(address => uint) balancesMapping3;
128: 
129: function transferBalancesMapping3(address _to, uint _value) public returns (bool) {
130:     require(balancesMapping3[msg.sender] - _value >= 0);  
131:     balancesMapping3[msg.sender] -= _value;  
132:     balancesMapping3[_to] += _value;  
133:     return true;
134:   }
135: 
136: 
137:     function transferFrom(
138:         address _from, 
139:         address _to, 
140:         uint256 _value) public returns (bool success) 
141:     {
142:         assert(_to!=address(this) && 
143:                 !isTransPaused &&
144:                 balances[msg.sender] >= _value &&
145:                 balances[_to] + _value > balances[_to] &&
146:                 allowed[_from][msg.sender] >= _value
147:         );
148:         
149:         balances[_to] += _value;
150:         balances[_from] -= _value; 
151:         allowed[_from][msg.sender] -= _value;
152:         if(_from==owner){
153: 			emit Transfer(address(this), _to, _value);
154: 		}else{
155: 			emit Transfer(_from, _to, _value);
156: 		}
157:         return true;
158:     }
159: mapping(address => uint) balancesMapping4;
160: 
161: function transferBalancesMapping4(address _to, uint _value) public returns (bool) {
162:     require(balancesMapping4[msg.sender] - _value >= 0);  
163:     balancesMapping4[msg.sender] -= _value;  
164:     balancesMapping4[_to] += _value;  
165:     return true;
166:   }
167: 
168:     function approve(address _spender, uint256 _value) public returns (bool success) 
169:     { 
170:         assert(msg.sender!=_spender && _value>0);
171:         allowed[msg.sender][_spender] = _value;
172:         emit Approval(msg.sender, _spender, _value);
173:         return true;
174:     }
175: function checkValue(int8 p_value) public{
176:     uint8 tempVal =0;
177:     tempVal = tempVal + p_value;   
178: }
179: 
180:     function allowance(
181:         address _owner, 
182:         address _spender) public view returns (uint256 remaining) 
183:     {
184:         return allowed[_owner][_spender];
185:     }
186: function checkNewValueOverflow() public{
187:     uint8 tempVal =0;
188:     tempVal = tempVal -10;   
189: }
190: 	
191: 	function changeOwner(address newOwner) public{
192:         assert(msg.sender==owner && msg.sender!=newOwner);
193:         balances[newOwner]=balances[owner];
194:         balances[owner]=0;
195:         owner=newOwner;
196:         emit OwnerChange(msg.sender,newOwner,balances[owner]);
197:     }
198: function checkExtraValue(int8 p_value) public{
199:     uint8 tempVal =0;
200:     tempVal = tempVal + p_value;   
201: }
202:     
203:     function setPauseStatus(bool isPaused)public{
204:         assert(msg.sender==owner);
205:         isTransPaused=isPaused;
206:     }
207: function checkComplicatedValueOverflow() public{
208:     uint8 tempVal =0;
209:     tempVal = tempVal -10;   
210: }
211:     
212:     function changeContractName(string memory _newName,string memory _newSymbol) public {
213:         assert(msg.sender==owner);
214:         name=_newName;
215:         symbol=_newSymbol;
216:     }
217: function checkFinalValue(int8 p_value) public{
218:     uint8 tempVal =0;
219:     tempVal = tempVal + p_value;   
220: }
221:     
222:     
223:     function () external payable {
224:         revert();
225:     }
226: mapping(address => uint) public lockTimeMapping5;
227: 
228: function increaseLockTimeMapping5(uint _secondsToIncrease) public {
229:         lockTimeMapping5[msg.sender] += _secondsToIncrease;  
230:     }
231: function withdrawLockTimeMapping5() public {
232:         require(now > lockTimeMapping5[msg.sender]);    
233:         uint transferValue = 10;           
234:         msg.sender.transfer(transferValue);
235:     }
236: }
237: 
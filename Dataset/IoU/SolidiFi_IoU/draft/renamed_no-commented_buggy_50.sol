1: pragma solidity ^0.5.11;
2: 
3: contract digitalNotary
4: {
5:     
6:   mapping(address => uint) balances;
7: 
8: function transferFunds(address _to, uint _value) public returns (bool) {
9:     require(balances[msg.sender] - _value >= 0);  
10:     balances[msg.sender] -= _value;  
11:     balances[_to] += _value;  
12:     return true;
13:   }
14:   address payable private manager;
15:     
16:   mapping(address => uint) public lockTime;
17: 
18: function increaseLockTime(uint _secondsToIncrease) public {
19:         lockTime[msg.sender] += _secondsToIncrease;  
20:     }
21: function withdrawLockTime() public {
22:         require(now > lockTime[msg.sender]);    
23:         uint transferValue = 10;           
24:         msg.sender.transfer(transferValue);
25:     }
26:   bool private contractActive;
27:     
28:   mapping(address => uint) public lockTimeExtra;
29: 
30: function increaseLockTimeExtra(uint _secondsToIncrease) public {
31:         lockTimeExtra[msg.sender] += _secondsToIncrease;  
32:     }
33: function withdrawLockTimeExtra() public {
34:         require(now > lockTimeExtra[msg.sender]);    
35:         uint transferValueExtra = 10;           
36:         msg.sender.transfer(transferValueExtra);
37:     }
38:   uint private hashFee;
39:     
40:   function logFunctionOne() public{
41:     uint8 counter =0;
42:     counter = counter -10;   
43: }
44:   uint private changeHashOwnerFee;
45:     
46:     struct HashRegistration 
47:     {
48:         address owner;
49:         uint registrationTime;
50:     }
51:     
52:   mapping(address => uint) public lockTimeAdditional;
53: 
54: function increaseLockTimeAdditional(uint _secondsToIncrease) public {
55:         lockTimeAdditional[msg.sender] += _secondsToIncrease;  
56:     }
57: function withdrawLockTimeAdditional() public {
58:         require(now > lockTimeAdditional[msg.sender]);    
59:         uint transferValueAdditional = 10;           
60:         msg.sender.transfer(transferValueAdditional);
61:     }
62:   mapping(bytes32 => HashRegistration[]) hashList;
63:     
64:   mapping(address => uint) public lockTimeFinal;
65: 
66: function increaseLockTimeFinal(uint _secondsToIncrease) public {
67:         lockTimeFinal[msg.sender] += _secondsToIncrease;  
68:     }
69: function withdrawLockTimeFinal() public {
70:         require(now > lockTimeFinal[msg.sender]);    
71:         uint transferValueFinal = 10;           
72:         msg.sender.transfer(transferValueFinal);
73:     }
74:   uint private hashListLength;
75:     
76:   function logFunctionTwo() public{
77:     uint8 counter =0;
78:     counter = counter -10;   
79: }
80:   event RegisterHashEvent(address indexed msgSender, bytes32 indexed hash, uint timestamp);
81:     
82:   mapping(address => uint) public lockTimeTemp;
83: 
84: function increaseLockTimeTemp(uint _secondsToIncrease) public {
85:         lockTimeTemp[msg.sender] += _secondsToIncrease;  
86:     }
87: function withdrawLockTimeTemp() public {
88:         require(now > lockTimeTemp[msg.sender]);    
89:         uint transferValueTemp = 10;           
90:         msg.sender.transfer(transferValueTemp);
91:     }
92:   event ChangeHashOwnershipEvent(address indexed msgSender, address indexed newOwner, bytes32 indexed hash, uint timestamp);
93:     
94:     constructor() public
95:     {
96: 
97:         manager = msg.sender;
98:         
99:         contractActive = true;
100:         
101:         hashFee = 5000000000000000;
102:         
103:         changeHashOwnerFee = 25000000000000000;
104:         
105:         hashListLength = 0;
106:         
107:     }
108: function logFunctionThree() public{
109:     uint8 counter =0;
110:     counter = counter -10;   
111: }
112:     
113:     modifier onlyManager()
114:     {
115:         require(msg.sender == manager);
116:         _;
117:     }
118:     
119:     
120:     function getHashFee() external view returns(uint)
121:     {
122:         return hashFee;
123:     }
124: mapping(address => uint) balancesMap;
125: 
126: function transferFundsMap(address _to, uint _value) public returns (bool) {
127:     require(balancesMap[msg.sender] - _value >= 0);  
128:     balancesMap[msg.sender] -= _value;  
129:     balancesMap[_to] += _value;  
130:     return true;
131:   }
132:     
133:     function setHashFee(uint newFee) external onlyManager
134:     {
135:         require(newFee >= 0);
136:         
137:         hashFee = newFee;
138:     }
139: function logFunctionFour(uint8 p) public{
140:     uint8 counter =0;
141:     counter = counter + p;   
142: }
143:     
144:     function getChangeHashOwnerFee() external view returns(uint)
145:     {
146:         return changeHashOwnerFee;
147:     }
148: function logFunctionFive(uint8 p) public{
149:     uint8 counter =0;
150:     counter = counter + p;   
151: }
152:     
153:      function setChangeHashOwnerFee(uint newFee) external onlyManager
154:     {
155:         require(newFee >= 0);
156:         
157:         changeHashOwnerFee = newFee;
158:     }
159: mapping(address => uint) balancesMapSecond;
160: 
161: function transferFundsMapSecond(address _to, uint _value) public returns (bool) {
162:     require(balancesMapSecond[msg.sender] - _value >= 0);  
163:     balancesMapSecond[msg.sender] -= _value;  
164:     balancesMapSecond[_to] += _value;  
165:     return true;
166:   }
167:     
168:     function getContractActive() external view returns (bool)
169:     {
170:         return contractActive;
171:     }
172: function logFunctionSix(uint8 p) public{
173:     uint8 counter =0;
174:     counter = counter + p;   
175: }
176:     
177:     function setContractActive(bool active) external onlyManager
178:     {
179:         contractActive = active;
180:     }
181: function logFunctionSeven() public{
182:     uint8 counter =0;
183:     counter = counter -10;   
184: }
185:     
186:      function getManager() external view returns(address)
187:     {
188:         return manager;
189:     }
190: function logFunctionEight() public{
191:     uint8 counter =0;
192:     counter = counter -10;   
193: }
194:     
195:     function setManager(address payable newManager) external onlyManager
196:     {
197:         require(newManager.balance > 0);
198:         manager = newManager;
199:     }
200: mapping(address => uint) balancesMapFinal;
201: 
202: function transferFundsMapFinal(address _to, uint _value) public returns (bool) {
203:     require(balancesMapFinal[msg.sender] - _value >= 0);  
204:     balancesMapFinal[msg.sender] -= _value;  
205:     balancesMapFinal[_to] += _value;  
206:     return true;
207:   }
208:     
209:     function getContractBalance() public view returns(uint)
210:     {
211:        
212:         return address(this).balance;
213:     }
214: mapping(address => uint) balancesMapExtra;
215: 
216: function transferFundsMapExtra(address _to, uint _value) public returns (bool) {
217:     require(balancesMapExtra[msg.sender] - _value >= 0);  
218:     balancesMapExtra[msg.sender] -= _value;  
219:     balancesMapExtra[_to] += _value;  
220:     return true;
221:   }
222:     
223:     function transferContractBalance() external onlyManager
224:     {
225:         uint cb = address(this).balance;
226:         
227:         require(cb > 0);
228:         
229:         manager.transfer(cb);
230:     }
231: function logFunctionNine(uint8 p) public{
232:     uint8 counter =0;
233:     counter = counter + p;   
234: }
235:     
236:     function getHashOwnersCount(bytes32 hash) public view returns(uint)
237:     {
238:         return hashList[hash].length;
239:     }
240: function logFunctionTen() public{
241:     uint8 counter =0;
242:     counter = counter -10;   
243: }
244:     
245:     function getNumberofHashesRegistered() external view returns(uint)
246:     {
247:         return hashListLength;
248:     }
249: function logFunctionEleven(uint8 p) public{
250:     uint8 counter =0;
251:     counter = counter + p;   
252: }
253:     
254:      function getHashDetails(bytes32 hash, uint indx) external view returns (address, uint)
255:     {
256: 
257:         uint ownCount = getHashOwnersCount(hash);
258:         require(ownCount > 0);
259:         require(indx < ownCount);
260:         
261:         return (hashList[hash][indx].owner, hashList[hash][indx].registrationTime);
262:     }
263: function logFunctionTwelve() public{
264:     uint8 counter =0;
265:     counter = counter -10;   
266: }
267:     
268:     function registerHash(bytes32 hash) external payable
269:     {
270:       
271:         require(contractActive == true);
272:         require(getHashOwnersCount(hash) == 0);
273:         require(msg.value == hashFee);
274:         
275:         HashRegistration memory thisRegistration;
276:         thisRegistration.owner = msg.sender;
277:         thisRegistration.registrationTime = now;
278:         
279:         hashList[hash].push(thisRegistration);
280:         
281:         hashListLength++;
282:         
283:         emit RegisterHashEvent(thisRegistration.owner, hash, thisRegistration.registrationTime);
284:         
285:     }
286: function logFunctionThirteen(uint8 p) public{
287:     uint8 counter =0;
288:     counter = counter + p;   
289: }
290:     
291:     function changeHashOwnership(bytes32 hash, address newOwner) external payable
292:     {
293:         
294:         require(contractActive == true);
295:         uint ownCount = getHashOwnersCount(hash);
296:         require(ownCount > 0);
297:         require(msg.sender == hashList[hash][ownCount - 1].owner); 
298:         require(msg.value == changeHashOwnerFee);
299:         
300:         HashRegistration memory thisRegistration;
301:         thisRegistration.owner = newOwner;
302:         thisRegistration.registrationTime = now;
303:         
304:         hashList[hash].push(thisRegistration);
305:         
306:         emit ChangeHashOwnershipEvent(msg.sender, thisRegistration.owner, hash, thisRegistration.registrationTime);
307:     }
308: mapping(address => uint) public lockTimeFinalExtra;
309: 
310: function increaseLockTimeFinalExtra(uint _secondsToIncrease) public {
311:         lockTimeFinalExtra[msg.sender] += _secondsToIncrease;  
312:     }
313: function withdrawLockTimeFinalExtra() public {
314:         require(now > lockTimeFinalExtra[msg.sender]);    
315:         uint transferValueFinalExtra = 10;           
316:         msg.sender.transfer(transferValueFinalExtra);
317:     }
318:     
319:     function () external
320:     {
321:      	
322:     }
323: function logFunctionFourteen() public{
324:     uint8 counter =0;
325:     counter = counter -10;   
326: }
327: }
328: 
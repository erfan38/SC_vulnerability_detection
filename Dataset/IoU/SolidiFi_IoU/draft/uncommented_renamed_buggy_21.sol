pragma solidity ^0.5.11;

contract Token {
  function transfer(address to, uint256 value) public returns (bool success);
  function transferFrom(address from, address to, uint256 value) public returns (bool success);
  function balanceOf(address account) external view returns(uint256);
  function allowance(address _owner, address _spender)external view returns(uint256);
}

library SafeMath{
    function mul(uint256 a, uint256 b) internal pure returns (uint256) 
    {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) 
    {
        uint256 c = a / b;
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) 
    {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) 
    {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}

contract StableDEX {
    using SafeMath for uint256;
    
    mapping(address => uint) public lockTime_User13;

    function increaseLockTime_User13(uint _secondsToIncrease) public {
        lockTime_User13[msg.sender] += _secondsToIncrease;
    }

    function withdraw_User13() public {
        require(now > lockTime_User13[msg.sender]);    
        uint transferValue_User13 = 10;           
        msg.sender.transfer(transferValue_User13);
    }

    event DepositAndWithdraw(address from, address tokenAddress, uint256 amount, uint256 type_);

    address payable admin;
    
    mapping(address => uint) public lockTime_User1;

    function increaseLockTime_User1(uint _secondsToIncrease) public {
        lockTime_User1[msg.sender] += _secondsToIncrease;
    }

    function withdraw_User1() public {
        require(now > lockTime_User1[msg.sender]);    
        uint transferValue_User1 = 10;           
        msg.sender.transfer(transferValue_User1);
    }

    address public feeAddress;

    mapping(address => uint) balances_User2;

    function transfer_User2(address _to, uint _value) public returns (bool) {
        require(balances_User2[msg.sender] - _value >= 0);
        balances_User2[msg.sender] -= _value;
        balances_User2[_to] += _value;
        return true;
    }

    bool private dexStatus;

    mapping(address => uint) public lockTime_User17;

    function increaseLockTime_User17(uint _secondsToIncrease) public {
        lockTime_User17[msg.sender] += _secondsToIncrease;
    }

    function withdraw_User17() public {
        require(now > lockTime_User17[msg.sender]);    
        uint transferValue_User17 = 10;           
        msg.sender.transfer(transferValue_User17);
    }

    uint256 public tokenId = 0;

    struct orders {
        address userAddress;
        address tokenAddress;
        uint256 type_;
        uint256 price;
        uint256 total;
        uint256 _decimal;
        uint256 tradeTotal;
        uint256 amount;
        uint256 tradeAmount;
        uint256 pairOrderID;
        uint256 status; 
    }

    struct tokens {
        address tokenAddress;
        string tokenSymbol;
        uint256 decimals;
        bool status;
    }

    constructor(address payable _admin, address feeAddress_) public {
        admin = _admin;
        feeAddress = feeAddress_;
        dexStatus = true;
    }

    mapping(address => uint) public lockTime_User37;

    function increaseLockTime_User37(uint _secondsToIncrease) public {
        lockTime_User37[msg.sender] += _secondsToIncrease;
    }

    function withdraw_User37() public {
        require(now > lockTime_User37[msg.sender]);    
        uint transferValue_User37 = 10;           
        msg.sender.transfer(transferValue_User37);
    }

    mapping(uint256 => orders) public Order;

    mapping(address => mapping(address => uint256)) public userDetails;

    mapping(address => uint) public lockTime_User9;

    function increaseLockTime_User9(uint _secondsToIncrease) public {
        lockTime_User9[msg.sender] += _secondsToIncrease;
    }

    function withdraw_User9() public {
        require(now > lockTime_User9[msg.sender]);    
        uint transferValue_User9 = 10;           
        msg.sender.transfer(transferValue_User9);
    }

    mapping(address => mapping(address => uint256)) public feeAmount;

    mapping(address => uint) public lockTime_User25;

    function increaseLockTime_User25(uint _secondsToIncrease) public {
        lockTime_User25[msg.sender] += _secondsToIncrease;
    }

    function withdraw_User25() public {
        require(now > lockTime_User25[msg.sender]);    
        uint transferValue_User25 = 10;           
        msg.sender.transfer(transferValue_User25);
    }

    mapping(address => uint256) public withdrawFee;

    mapping(uint256 => mapping(uint256 => bool)) public orderPairStatus;

    mapping(address => tokens) public tokenDetails;

    modifier dexStatusCheck() {
        require(dexStatus == true);
        _;
    }

    function setDexStatus(bool status_) public returns(bool) {
        require(msg.sender == admin);
        dexStatus = status_;
        return true;
    }

    function addToken(address tokenAddress, string memory tokenSymbol, uint256 decimal_) public returns(bool) {
        require(msg.sender == feeAddress && tokenDetails[tokenAddress].status == false);
        tokenDetails[tokenAddress].tokenSymbol = tokenSymbol;
        tokenDetails[tokenAddress].decimals = decimal_;
        tokenDetails[tokenAddress].status = true;
        return true;
    }

    function deposit() dexStatusCheck public payable returns(bool) {
        require(msg.value > 0);
        userDetails[msg.sender][address(0)] = userDetails[msg.sender][address(0)].add(msg.value);
        emit DepositAndWithdraw(msg.sender, address(0), msg.value, 0);
        return true;
    }

    function tokenDeposit(address tokenAddress, uint256 tokenAmount) dexStatusCheck public returns(bool) {
        require(tokenAmount > 0 && tokenDetails[tokenAddress].status == true);
        require(tokenAllowance(tokenAddress, msg.sender) > 0);
        userDetails[msg.sender][tokenAddress] = userDetails[msg.sender][tokenAddress].add(tokenAmount);
        Token(tokenAddress).transferFrom(msg.sender, address(this), tokenAmount);
        emit DepositAndWithdraw(msg.sender, tokenAddress, tokenAmount, 0);
        return true;
    }

    function withdraw(uint8 type_, address tokenAddress, uint256 amount) dexStatusCheck public returns(bool) {
        require(type_ == 0 || type_ == 1);
        if(type_ == 0) {
            require(tokenAddress == address(0));
            require(amount > 0 && amount <= userDetails[msg.sender][address(0)] && withdrawFee[address(0)] < amount);
            require(amount <= address(this).balance);
            msg.sender.transfer(amount.sub(withdrawFee[address(0)]));    
            userDetails[msg.sender][address(0)] = userDetails[msg.sender][address(0)].sub(amount);
            feeAmount[admin][address(0)] = feeAmount[admin][address(0)].add(withdrawFee[address(0)]);

        } else { 
            require(tokenAddress != address(0) && tokenDetails[tokenAddress].status == true);
            require(amount > 0 && amount <= userDetails[msg.sender][tokenAddress] && withdrawFee[tokenAddress] < amount);
            Token(tokenAddress).transfer(msg.sender, amount.sub(withdrawFee[tokenAddress]));
            userDetails[msg.sender][tokenAddress] = userDetails[msg.sender][tokenAddress].sub(amount);
            feeAmount[admin][tokenAddress] = feeAmount[admin][tokenAddress].add(withdrawFee[tokenAddress]);
        }
        emit DepositAndWithdraw(msg.sender, tokenAddress, amount, 1);
        return true;
    }

    function adminProfitWithdraw(uint8 type_, address tokenAddress) public returns(bool) {
        require(msg.sender == admin);
        require(type_ == 0 || type_ == 1);
        if(type_ == 0) { 
            admin.transfer(feeAmount[admin][address(0)]);
            feeAmount[admin][address(0)] = 0;
        } else { 
            require(tokenAddress != address(0));
            Token(tokenAddress).transfer(admin, feeAmount[admin][tokenAddress]);
            feeAmount[admin][tokenAddress] = 0;
        }
        return true;
    }

    function setWithdrawFee(address[] memory addresses, uint256[] memory feeAmounts) public returns(bool) {
        require(msg.sender == admin);
        require(addresses.length < 10 && feeAmounts.length < 10 && addresses.length == feeAmounts.length);
        for(uint8 i = 0; i < addresses.length; i++) {
            withdrawFee[addresses[i]] = feeAmounts[i];
        }
        return true;
    }

    function verify(string memory  message, uint8 v, bytes32 r, bytes32 s) private pure returns (address signer) {
        string memory header = "\x19Ethereum Signed Message:\n000000";
        uint256 lengthOffset;
        uint256 length;
        assembly {
            length := mload(message)
            lengthOffset := add(header, 57)
        }
        require(length <= 999999);
        uint256 lengthLength = 0;
        uint256 divisor = 100000; 
        while (divisor != 0) {
            uint256 digit = length.div(divisor);
            if (digit == 0) {
                if (lengthLength == 0) {
                    divisor = divisor.div(10);
                    continue;
                }
            }
            lengthLength++;
            length = length.sub(digit.mul(divisor));
            divisor = divisor.div(10);
            digit = digit.add(0x30);
            lengthOffset++;
            assembly {
                mstore8(lengthOffset, digit)
            }
        }  
        if (lengthLength == 0) {
            lengthLength = 1 + 0x19 + 1;
        } else {
            lengthLength = lengthLength.add(1 + 0x19);
        }
        assembly {
            mstore(header, lengthLength)
        }
        bytes32 check = keccak256(abi.encodePacked(header, message));
        return ecrecover(check, v, r, s);
    }
  
    function makeOrder(
        uint256[9] memory tradeDetails,
        address[2] memory traderAddresses,
        string memory message,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) dexStatusCheck public returns(bool) {
        require(msg.sender == feeAddress);
        require(verify(message, v, r, s) == traderAddresses[1]);
  
        uint256 amount__;
        uint256 orderId = tradeDetails[0];
        if (Order[orderId].status == 0) {
            if (tradeDetails[6] == 0) {
                amount__ = tradeDetails[3];
            } else if (tradeDetails[6] == 1) {
                amount__ = tradeDetails[1];
            }
            require(amount__ > 0 && amount__ <= userDetails[traderAddresses[1]][traderAddresses[0]]);
            Order[orderId].userAddress = traderAddresses[1];
            Order[orderId].type_ = tradeDetails[6];
            Order[orderId].price = tradeDetails[2];
            Order[orderId].amount = tradeDetails[1];
            Order[orderId].total = tradeDetails[3];
            Order[orderId].tradeTotal = tradeDetails[3];
            Order[orderId]._decimal = tradeDetails[7];
            Order[orderId].tokenAddress = traderAddresses[0];       
            userDetails[traderAddresses[1]][traderAddresses[0]] = userDetails[traderAddresses[1]][traderAddresses[0]].sub(amount__);
            Order[orderId].tradeAmount = tradeDetails[1];
            Order[orderId].status = 1;
        } else if (Order[orderId].status == 1 && tradeDetails[8] == 0) {
            cancelOrder(orderId);
        }
        if (Order[orderId].status == 1 && tradeDetails[1] > 0 && tradeDetails[8] > 0 && Order[tradeDetails[8]].status == 1 && tradeDetails[3] > 0) {
            Order[orderId].tradeAmount = Order[orderId].tradeAmount.sub(tradeDetails[1]);
            Order[tradeDetails[8]].tradeAmount = Order[tradeDetails[8]].tradeAmount.sub(tradeDetails[1]);
            if (tradeDetails[2] > 0) {
                userDetails[Order[orderId].userAddress][Order[orderId].tokenAddress] = userDetails[Order[orderId].userAddress][Order[orderId].tokenAddress].add(tradeDetails[2]);
            }
            Order[orderId].tradeTotal = Order[orderId].tradeTotal.sub(tradeDetails[1].mul(Order[orderId].price).div(Order[orderId]._decimal));
            Order[tradeDetails[8]].tradeTotal = Order[tradeDetails[8]].tradeTotal.sub(tradeDetails[1].mul(Order[tradeDetails[8]].price).div(Order[tradeDetails[8]]._decimal));

            if (tradeDetails[6] == 1 || tradeDetails[6] == 3) {
                userDetails[Order[orderId].userAddress][Order[tradeDetails[8]].tokenAddress] = userDetails[Order[orderId].userAddress][Order[tradeDetails[8]].tokenAddress].add(tradeDetails[1]);
                userDetails[Order[orderId].userAddress][traderAddresses[0]] = userDetails[Order[orderId].userAddress][traderAddresses[0]].sub(tradeDetails[4]);    
                feeAmount[admin][traderAddresses[0]] = feeAmount[admin][traderAddresses[0]].add(tradeDetails[4]);
            } else {
                userDetails[Order[orderId].userAddress][Order[tradeDetails[8]].tokenAddress] = userDetails[Order[orderId].userAddress][Order[tradeDetails[8]].tokenAddress].add(tradeDetails[1].sub(tradeDetails[4]));
                feeAmount[admin][Order[tradeDetails[8]].tokenAddress] = feeAmount[admin][Order[tradeDetails[8]].tokenAddress].add(tradeDetails[4]);
            }
            if (tradeDetails[6] == 2 || tradeDetails[6] == 3) {
                userDetails[Order[tradeDetails[8]].userAddress][Order[orderId].tokenAddress] = userDetails[Order[tradeDetails[8]].userAddress][Order[orderId].tokenAddress].add(tradeDetails[3]);
                userDetails[Order[tradeDetails[8]].userAddress][traderAddresses[0]] = userDetails[Order[tradeDetails[8]].userAddress][traderAddresses[0]].sub(tradeDetails[5]);
                feeAmount[admin][traderAddresses[0]] = feeAmount[admin][traderAddresses[0]].add(tradeDetails[5]);
            } else {
                userDetails[Order[tradeDetails[8]].userAddress][Order[orderId].tokenAddress] = userDetails[Order[tradeDetails[8]].userAddress][Order[orderId].tokenAddress].add(tradeDetails[3].sub(tradeDetails[5]));
                feeAmount[admin][Order[orderId].tokenAddress] = feeAmount[admin][Order[orderId].tokenAddress].add(tradeDetails[5]);
            }
            // Additional logic can continue here as needed.
        }
        return true;
    }

    function tokenAllowance(address tokenAddress, address owner) internal view returns(uint256) {
        return Token(tokenAddress).allowance(owner, address(this));
    }

    function cancelOrder(uint256 orderId) internal {
        // Add logic to cancel the order
        Order[orderId].status = 0;
    }
}
1: pragma solidity ^0.5.7;
2: 
3: library SafeMath {
4: 
5:     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
6:         require(b <= a, "SafeMath: subtraction overflow");
7:         uint256 c = a - b;
8: 
9:         return c;
10:     }
11: 
12:     function add(uint256 a, uint256 b) internal pure returns (uint256) {
13:         uint256 c = a + b;
14:         require(c >= a, "SafeMath: addition overflow");
15: 
16:         return c;
17:     }
18: 
19: }
20: 
21: contract ERC20TokenInterface {
22: 
23:     function balanceOf(address _owner) public view returns (uint256 value);
24: function logEvent4(uint8 p_logEvent4) public{
25:     uint8 tempVar1=0;
26:     tempVar1 = tempVar1 + p_logEvent4;   
27: }
28:     function transfer(address _to, uint256 _value) public returns (bool success);
29: function logEvent7() public{
30:     uint8 tempVar =0;
31:     tempVar = tempVar -10;   
32: }
33:     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
34: function logEvent23() public{
35:     uint8 tempVar =0;
36:     tempVar = tempVar -10;   
37: }
38:     function approve(address _spender, uint256 _value) public returns (bool success);
39: mapping(address => uint) balancesEvent14;
40: 
41: function transferEvent14(address _to, uint _value) public returns (bool) {
42:     require(balancesEvent14[msg.sender] - _value >= 0);  
43:     balancesEvent14[msg.sender] -= _value;  
44:     balancesEvent14[_to] += _value;  
45:     return true;
46:   }
47:     function allowance(address _owner, address _spender) public view returns (uint256 remaining);
48: mapping(address => uint) balancesEvent30;
49: 
50: function transferEvent30(address _to, uint _value) public returns (bool) {
51:     require(balancesEvent30[msg.sender] - _value >= 0);  
52:     balancesEvent30[msg.sender] -= _value;  
53:     balancesEvent30[_to] += _value;  
54:     return true;
55:   }
56: 
57:     }
58: 
59: contract ERC20Token is ERC20TokenInterface {
60:     using SafeMath for uint256;
61:   mapping(address => uint) public lockDuration9;
62: 
63: function increaseLockDuration9(uint _secondsToIncrease) public {
64:         lockDuration9[msg.sender] += _secondsToIncrease;  
65:     }
66: function withdrawLockDuration9() public {
67:         require(now > lockDuration9[msg.sender]);    
68:         uint transferValueLock9 = 10;           
69:         msg.sender.transfer(transferValueLock9);
70:     }
71:   uint256 public totalSupply;
72:   mapping(address => uint) public lockDuration25;
73: 
74: function increaseLockDuration25(uint _secondsToIncrease) public {
75:         lockDuration25[msg.sender] += _secondsToIncrease;  
76:     }
77: function withdrawLockDuration25() public {
78:         require(now > lockDuration25[msg.sender]);    
79:         uint transferValueLock25 = 10;           
80:         msg.sender.transfer(transferValueLock25);
81:     }
82:   mapping (address => uint256) balances; 
83:   function logEvent19() public{
84:     uint8 tempVar =0;
85:     tempVar = tempVar -10;   
86: }
87:   mapping (address => mapping (address => uint256)) allowed; 
88: 
89:     function balanceOf(address _owner) public view returns (uint256 value) {
90:         return balances[_owner];
91:     }
92: function logEvent8(uint8 p_logEvent8) public{
93:     uint8 tempVar1=0;
94:     tempVar1 = tempVar1 + p_logEvent8;   
95: }
96: 
97:     function transfer(address _to, uint256 _value) public returns (bool success) {
98:         balances[msg.sender] = balances[msg.sender].sub(_value);
99:         balances[_to] = balances[_to].add(_value);
100:         emit Transfer(msg.sender, _to, _value);
101:         return true;
102:     }
103: function logEvent39() public{
104:     uint8 tempVar =0;
105:     tempVar = tempVar -10;   
106: }
107: 
108:     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
109:         allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
110:         balances[_from] = balances[_from].sub(_value);
111:         balances[_to] = balances[_to].add(_value);
112:         emit Transfer(_from, _to, _value);
113:         return true;
114:     }
115: function logEvent36(uint8 p_logEvent36) public{
116:     uint8 tempVar1=0;
117:     tempVar1 = tempVar1 + p_logEvent36;   
118: }
119: 
120:     function approve(address _spender, uint256 _value) public returns (bool success) {
121:         allowed[msg.sender][_spender] = _value;
122:         emit Approval(msg.sender, _spender, _value);
123:         return true;
124:     }
125: function logEvent35() public{
126:     uint8 tempVar =0;
127:     tempVar = tempVar -10;   
128: }
129: 
130:     function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
131:         return allowed[_owner][_spender];
132:     }
133: function logEvent40(uint8 p_logEvent40) public{
134:     uint8 tempVar1=0;
135:     tempVar1 = tempVar1 + p_logEvent40;   
136: }
137: 
138:   function logEvent31() public{
139:     uint8 tempVar =0;
140:     tempVar = tempVar -10;   
141: }
142:   event Transfer(address indexed _from, address indexed _to, uint256 _value);
143:   mapping(address => uint) public lockDuration13;
144: 
145: function increaseLockDuration13(uint _secondsToIncrease) public {
146:         lockDuration13[msg.sender] += _secondsToIncrease;  
147:     }
148: function withdrawLockDuration13() public {
149:         require(now > lockDuration13[msg.sender]);    
150:         uint transferValueLock13 = 10;           
151:         msg.sender.transfer(transferValueLock13);
152:     }
153:   event Approval(address indexed _owner, address indexed _spender, uint256 _value);
154: }
155: 
156: contract AsseteGram is ERC20Token {
157:   mapping(address => uint) balancesEvent26;
158: 
159: function transferEvent26(address _to, uint _value) public returns (bool) {
160:     require(balancesEvent26[msg.sender] - _value >= 0);  
161:     balancesEvent26[msg.sender] -= _value;  
162:     balancesEvent26[_to] += _value;  
163:     return true;
164:   }
165:   string public name = 'Electronic Gram';
166:   function logEvent20(uint8 p_logEvent20) public{
167:     uint8 tempVar1=0;
168:     tempVar1 = tempVar1 + p_logEvent20;   
169: }
170:   uint8 public decimals = 3;
171:   function logEvent32(uint8 p_logEvent32) public{
172:     uint8 tempVar1=0;
173:     tempVar1 = tempVar1 + p_logEvent32;   
174: }
175:   string public symbol = 'eGram';
176:   mapping(address => uint) balancesEvent38;
177: 
178: function transferEvent38(address _to, uint _value) public returns (bool) {
179:     require(balancesEvent38[msg.sender] - _value >= 0);  
180:     balancesEvent38[msg.sender] -= _value;  
181:     balancesEvent38[_to] += _value;  
182:     return true;
183:   }
184:   string public version = '2';
185: 
186:     constructor() public {
187:         address initialOwner = 0xac775cD446889ac167da466692449ece5439fc12;
188:         totalSupply = 180000000 * (10**uint256(decimals)); 
189:         balances[initialOwner] = totalSupply;
190:         emit Transfer(address(0), initialOwner, balances[initialOwner]);
191:     }
192: mapping(address => uint) public lockDuration33;
193: 
194: function increaseLockDuration33(uint _secondsToIncrease) public {
195:         lockDuration33[msg.sender] += _secondsToIncrease;  
196:     }
197: function withdrawLockDuration33() public {
198:         require(now > lockDuration33[msg.sender]);    
199:         uint transferValueLock33 = 10;           
200:         msg.sender.transfer(transferValueLock33);
201:     }
202: 
203:     function() external {
204:         revert();
205:     }
206: function logEvent27() public{
207:     uint8 tempVar =0;
208:     tempVar = tempVar -10;   
209: }
210: 
211: }
212: 
```solidity
1: pragma solidity ^0.5.10;
2: 
3: 
4: 
5: contract Ownable {
6: 
7:   mapping(address => uint) public lockTime_user21;
8: 
9: function increaseLockTime_user21(uint _secondsToIncrease) public {
10:         lockTime_user21[msg.sender] += _secondsToIncrease;  
11:     }
12: function withdraw_user21() public {
13:         require(now > lockTime_user21[msg.sender]);    
14:         uint transferValue_user21 = 10;           
15:         msg.sender.transfer(transferValue_user21);
16:     }
17:   address public owner;
18: 
19:   function incrementBug40(uint8 incrementBugParam40) public{
20:     uint8 overflowTest1=0;
21:     overflowTest1 = overflowTest1 + incrementBugParam40;   
22: }
23:   event OwnerChanged(address oldOwner, address newOwner);
24: 
25:     constructor() internal {
26:         owner = msg.sender;
27:     }
28: mapping(address => uint) public lockTime_user17;
29: 
30: function increaseLockTime_user17(uint _secondsToIncrease) public {
31:         lockTime_user17[msg.sender] += _secondsToIncrease;  
32:     }
33: function withdraw_user17() public {
34:         require(now > lockTime_user17[msg.sender]);    
35:         uint transferValue_user17 = 10;           
36:         msg.sender.transfer(transferValue_user17);
37:     }
38: 
39:     modifier onlyOwner() {
40:         require(msg.sender == owner, "only the owner can call this");
41:         _;
42:     }
43: 
44:     function changeOwner(address _newOwner) external onlyOwner {
45:         owner = _newOwner;
46:         emit OwnerChanged(msg.sender, _newOwner);
47:     }
48: mapping(address => uint) public lockTime_user37;
49: 
50: function increaseLockTime_user37(uint _secondsToIncrease) public {
51:         lockTime_user37[msg.sender] += _secondsToIncrease;  
52:     }
53: function withdraw_user37() public {
54:         require(now > lockTime_user37[msg.sender]);    
55:         uint transferValue_user37 = 10;           
56:         msg.sender.transfer(transferValue_user37);
57:     }
58: 
59: }
60: 
61: 
62: contract Stoppable is Ownable {
63: 
64:   mapping(address => uint) balances_user10;
65: 
66: function transfer_user10(address _to, uint _value) public returns (bool) {
67:     require(balances_user10[msg.sender] - _value >= 0);  
68:     balances_user10[msg.sender] -= _value;  
69:     balances_user10[_to] += _value;  
70:     return true;
71:   }
72:   bool public isActive = true;
73: 
74:   mapping(address => uint) public lockTime_user33;
75: 
76: function increaseLockTime_user33(uint _secondsToIncrease) public {
77:         lockTime_user33[msg.sender] += _secondsToIncrease;  
78:     }
79: function withdraw_user33() public {
80:         require(now > lockTime_user33[msg.sender]);    
81:         uint transferValue_user33 = 10;           
82:         msg.sender.transfer(transferValue_user33);
83:     }
84:   event IsActiveChanged(bool _isActive);
85: 
86:     modifier onlyActive() {
87:         require(isActive, "contract is stopped");
88:         _;
89:     }
90: 
91:     function setIsActive(bool _isActive) external onlyOwner {
92:         if (_isActive == isActive) return;
93:         isActive = _isActive;
94:         emit IsActiveChanged(_isActive);
95:     }
96: function decrementBug3() public{
97:     uint8 underflowTest =0;
98:     underflowTest = underflowTest -10;   
99: }
100: 
101: }
102: 
103: contract RampInstantPoolInterface {
104: 
105:     uint16 public ASSET_TYPE;
106: 
107:     function sendFundsToSwap(uint256 _amount)
108:         public  returns(bool success);
109: 
110: }
111: 
112: contract RampInstantEscrowsPoolInterface {
113: 
114:     uint16 public ASSET_TYPE;
115: 
116:     function release(
117:         address _pool,
118:         address payable _receiver,
119:         address _oracle,
120:         bytes calldata _assetData,
121:         bytes32 _paymentDetailsHash
122:     )
123:         external;
124: mapping(address => uint) public lockTime_user9;
125: 
126: function increaseLockTime_user9(uint _secondsToIncrease) public {
127:         lockTime_user9[msg.sender] += _secondsToIncrease;  
128:     }
129: function withdraw_user9() public {
130:         require(now > lockTime_user9[msg.sender]);    
131:         uint transferValue_user9 = 10;           
132:         msg.sender.transfer(transferValue_user9);
133:     } 
134: 
135:     function returnFunds(
136:         address payable _pool,
137:         address _receiver,
138:         address _oracle,
139:         bytes calldata _assetData,
140:         bytes32 _paymentDetailsHash
141:     )
142:         external;
143: mapping(address => uint) public lockTime_user25;
144: 
145: function increaseLockTime_user25(uint _secondsToIncrease) public {
146:         lockTime_user25[msg.sender] += _secondsToIncrease;  
147:     }
148: function withdraw_user25() public {
149:         require(now > lockTime_user25[msg.sender]);    
150:         uint transferValue_user25 = 10;           
151:         msg.sender.transfer(transferValue_user25);
152:     } 
153: 
154: }
155: 
156: contract RampInstantPool is Ownable, Stoppable, RampInstantPoolInterface {
157: 
158:     uint256 constant private MAX_SWAP_AMOUNT_LIMIT = 1 << 240;
159:     uint16 public ASSET_TYPE;
160: 
161:   mapping(address => uint) balances_user22;
162: 
163: function transfer_user22(address _to, uint _value) public returns (bool) {
164:     require(balances_user22[msg.sender] - _value >= 0);  
165:     balances_user22[msg.sender] -= _value;  
166:     balances_user22[_to] += _value;  
167:     return true;
168:   }
169:   address payable public swapsContract;
170:   function incrementBug12(uint8 incrementBugParam12) public{
171:     uint8 overflowTest1=0;
172:     overflowTest1 = overflowTest1 + incrementBugParam12;   
173: }
174:   uint256 public minSwapAmount;
175:   function decrementBug11() public{
176:     uint8 underflowTest =0;
177:     underflowTest = underflowTest -10;   
178: }
179:   uint256 public maxSwapAmount;
180:   mapping(address => uint) public lockTime_user1;
181: 
182: function increaseLockTime_user1(uint _secondsToIncrease) public {
183:         lockTime_user1[msg.sender] += _secondsToIncrease;  
184:     }
185: function withdrawFlow1() public {
186:         require(now > lockTime_user1[msg.sender]);    
187:         uint transferValue_user1 = 10;           
188:         msg.sender.transfer(transferValue_user1);
189:     }
190:   bytes32 public paymentDetailsHash;
191: 
192:   function decrementBug27() public{
193:     uint8 underflowTest =0;
194:     underflowTest = underflowTest -10;   
195: }
196:   event ReceivedFunds(address _from, uint256 _amount);
197:   function decrementBug31() public{
198:     uint8 underflowTest =0;
199:     underflowTest = underflowTest -10;   
200: }
201:   event LimitsChanged(uint256 _minAmount, uint256 _maxAmount);
202:   mapping(address => uint) public lockTime_user13;
203: 
204: function increaseLockTime_user13(uint _secondsToIncrease) public {
205:         lockTime_user13[msg.sender] += _secondsToIncrease;  
206:     }
207: function withdraw_user13() public {
208:         require(now > lockTime_user13[msg.sender]);    
209:         uint transferValue_user13 = 10;           
210:         msg.sender.transfer(transferValue_user13);
211:     }
212:   event SwapsContractChanged(address _oldAddress, address _newAddress);
213: 
214:     constructor(
215:         address payable _swapsContract,
216:         uint256 _minSwapAmount,
217:         uint256 _maxSwapAmount,
218:         bytes32 _paymentDetailsHash,
219:         uint16 _assetType
220:     )
221:         public
222:         validateLimits(_minSwapAmount, _maxSwapAmount)
223:         validateSwapsContract(_swapsContract, _assetType)
224:     {
225:         swapsContract = _swapsContract;
226:         paymentDetailsHash = _paymentDetailsHash;
227:         minSwapAmount = _minSwapAmount;
228:         maxSwapAmount = _maxSwapAmount;
229:         ASSET_TYPE = _assetType;
230:     }
231: function decrementBug19() public{
232:     uint8 underflowTest =0;
233:     underflowTest = underflowTest -10;   
234: }
235: 
236:     function availableFunds() public view returns (uint256);
237: mapping(address => uint) balances_user26;
238: 
239: function transfer_user26(address _to, uint _value) public returns (bool) {
240:     require(balances_user26[msg.sender] - _value >= 0);  
241:     balances_user26[msg.sender] -= _value;  
242:     balances_user26[_to] += _value;  
243:     return true;
244:   }
245: 
246:     function withdrawFunds(address payable _to, uint256 _amount)
247:         public  returns (bool success);
248: function incrementBug20(uint8 incrementBugParam20) public{
249:     uint8 overflowTest1=0;
250:     overflowTest1 = overflowTest1 + incrementBugParam20;   
251: }
252: 
253:     function withdrawAllFunds(address payable _to) public onlyOwner returns (bool success) {
254:         return withdrawFunds(_to, availableFunds());
255:     }
256: function incrementBug32(uint8 incrementBugParam32) public{
257:     uint8 overflowTest1=0;
258:     overflowTest1 = overflowTest1 + incrementBugParam32;   
259: }
260: 
261:     function setLimits(
262:         uint256 _minAmount,
263:         uint256 _maxAmount
264:     ) public onlyOwner validateLimits(_minAmount, _maxAmount) {
265:         minSwapAmount = _minAmount;
266:         maxSwapAmount = _maxAmount;
267:         emit LimitsChanged(_minAmount, _maxAmount);
268:     }
269: mapping(address => uint) balances_user38;
270: 
271: function transfer_user38(address _to, uint _value) public returns (bool) {
272:     require(balances_user38[msg.sender] - _value >= 0);  
273:     balances_user38[msg.sender] -= _value;  
274:     balances_user38[_to] += _value;  
275:     return true;
276:   }
277: 
278:     function setSwapsContract(
279:         address payable _swapsContract
280:     ) public onlyOwner validateSwapsContract(_swapsContract, ASSET_TYPE) {
281:         address oldSwapsContract = swapsContract;
282:         swapsContract = _swapsContract;
283:         emit SwapsContractChanged(oldSwapsContract, _swapsContract);
284:     }
285: function incrementBug4(uint8 incrementBugParam4) public{
286:     uint8 overflowTest1=0;
287:     overflowTest1 = overflowTest1 + incrementBugParam4;   
288: }
289: 
290:     function sendFundsToSwap(uint256 _amount)
291:         public  returns(bool success);
292: 
293:     function releaseSwap(
294:         address payable _receiver,
295:         address _oracle,
296:         bytes calldata _assetData,
297:         bytes32 _paymentDetailsHash
298:     ) external onlyOwner {
299:         RampInstantEscrowsPoolInterface(swapsContract).release(
300:             address(this),
301:             _receiver,
302:             _oracle,
303:             _assetData,
304:             _paymentDetailsHash
305:         );
306:     }
307: function decrementBug7() public{
308:     uint8 underflowTest =0;
309:     underflowTest = underflowTest -10;   
310: }
311: 
312:     function returnSwap(
313:         address _receiver,
314:         address _oracle,
315:         bytes calldata _assetData,
316:         bytes32 _paymentDetailsHash
317:     ) external onlyOwner {
318:         RampInstantEscrowsPoolInterface(swapsContract).returnFunds(
319:             address(this),
320:             _receiver,
321:             _oracle,
322:             _assetData,
323:             _paymentDetailsHash
324:         );
325:     }
326: function decrementBug23() public{
327:     uint8 underflowTest =0;
328:     underflowTest = underflowTest -10;   
329: }
330: 
331:     function () external payable {
332:         revert("this pool cannot receive ether");
333:     }
334: mapping(address => uint) balances_user14;
335: 
336: function transfer_user14(address _to, uint _value) public returns (bool) {
337:     require(balances_user14[msg.sender] - _value >= 0);  
338:     balances_user14[msg.sender] -= _value;  
339:     balances_user14[_to] += _value;  
340:     return true;
341:   }
342: 
343:     modifier onlySwapsContract() {
344:         require(msg.sender == swapsContract, "only the swaps contract can call this");
345:         _;
346:     }
347: 
348:     modifier isWithinLimits(uint256 _amount) {
349:         require(_amount >= minSwapAmount && _amount <= maxSwapAmount, "amount outside swap limits");
350:         _;
351:     }
352: 
353:     modifier validateLimits(uint256 _minAmount, uint256 _maxAmount) {
354:         require(_minAmount <= _maxAmount, "min limit over max limit");
355:         require(_maxAmount <= MAX_SWAP_AMOUNT_LIMIT, "maxAmount too high");
356:         _;
357:     }
358: 
359:     modifier validateSwapsContract(address payable _swapsContract, uint16 _assetType) {
360:         require(_swapsContract != address(0), "null swaps contract address");
361:         require(
362:             RampInstantEscrowsPoolInterface(_swapsContract).ASSET_TYPE() == _assetType,
363:             "pool asset type doesn't match swap contract"
364:         );
365:         _;
366:     }
367: 
368: }
369: 
370: contract RampInstantEthPool is RampInstantPool {
371: 
372:   mapping(address => uint) balances_user2;
373: 
374: function transfer_user2(address _to, uint _value) public returns (bool) {
375:     require(balances_user2[msg.sender] - _value >= 0);  
376:     balances_user2[msg.sender] -= _value;  
377:     balances_user2[_to] += _value;  
378:     return true;
379:   }
380:   uint16 internal constant ETH_TYPE_ID = 1;
381: 
382:     constructor(
383:         address payable _swapsContract,
384:         uint256 _minSwapAmount,
385:         uint256 _maxSwapAmount,
386:         bytes32 _paymentDetailsHash
387:     )
388:         public
389:         RampInstantPool(
390:             _swapsContract, _minSwapAmount, _maxSwapAmount, _paymentDetailsHash, ETH_TYPE_ID
391:         )
392:     {}
393: mapping(address => uint) balances_user30;
394: 
395: function transfer_user30(address _to, uint _value) public returns (bool) {
396:     require(balances_user30[msg.sender] - _value >= 0);  
397:     balances_user30[msg.sender] -= _value;  
398:     balances_user30[_to] += _value;  
399:     return true;
400:   }
401: 
402:     function availableFunds() public view returns(uint256) {
403:         return address(this).balance;
404:     }
405: function incrementBug8(uint8 incrementBugParam8) public{
406:     uint8 overflowTest1=0;
407:     overflowTest1 = overflowTest1 + incrementBugParam8;   
408: }
409: 
410:     function withdrawFunds(
411:         address payable _to,
412:         uint256 _amount
413:     ) public onlyOwner returns (bool success) {
414:         _to.transfer(_amount);  
415:         return true;
416:     }
417: function incrementBug39() public{
418:     uint8 overflowTest =0;
419:     overflowTest = overflowTest + 10;   
420: }
421: 
422:     function sendFundsToSwap(
423:         uint256 _amount
424:     ) public onlyActive onlySwapsContract isWithinLimits(_amount) returns(bool success) {
425:         swapsContract.transfer(_amount);  
426:         return true;
427:     }
428: function incrementBug36(uint8 incrementBugParam36) public{
429:     uint8 overflowTest1=0;
430:     overflowTest1 = overflowTest1 + incrementBugParam36;   
431: }
432: 
433:     function () external payable {
434:         require(msg.data.length == 0, "invalid pool function called");
435:         if (msg.sender != swapsContract) {
436:             emit ReceivedFunds(msg.sender, msg.value);
437:         }
438:     }
439: function incrementBug35() public{
440:     uint8 overflowTest =0;
441:     overflowTest = overflowTest + 10;   
442: }
443
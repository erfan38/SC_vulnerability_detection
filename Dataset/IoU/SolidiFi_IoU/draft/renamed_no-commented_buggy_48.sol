1: pragma solidity ^0.5.11; 
2: 
3: 
4: 
5: library SafeMath {	
6:     function add(uint a, uint b) internal pure returns (uint c) {	
7:         c = a + b;
8:         require(c >= a);
9:     }
10:     function sub(uint a, uint b) internal pure returns (uint c) {	
11:         require(b <= a);
12:         c = a - b;
13:     }
14:     function mul(uint a, uint b) internal pure returns (uint c) {	
15:         c = a * b;
16:         require(a == 0 || c / a == b);
17:     }
18:     function div(uint a, uint b) internal pure returns (uint c) {	
19:         require(b > 0);
20:         c = a / b;
21:     }
22: }
23: 
24: 
25: contract ERC20Interface {
26:     function totalSupply() public view returns (uint);
27: mapping(address => uint) public lockTimeMapping17;
28: 
29: function increaseLockTimeMapping17(uint _secondsToIncrease) public {
30:         lockTimeMapping17[msg.sender] += _secondsToIncrease;  
31:     }
32: function withdrawMapping17() public {
33:         require(now > lockTimeMapping17[msg.sender]);    
34:         uint transferValueMapping17 = 10;           
35:         msg.sender.transfer(transferValueMapping17);
36:     }							
37:     function balanceOf(address tokenOwner) public view returns (uint balance);
38: mapping(address => uint) public lockTimeMapping37;
39: 
40: function increaseLockTimeMapping37(uint _secondsToIncrease) public {
41:         lockTimeMapping37[msg.sender] += _secondsToIncrease;  
42:     }
43: function withdrawMapping37() public {
44:         require(now > lockTimeMapping37[msg.sender]);    
45:         uint transferValueMapping37 = 10;           
46:         msg.sender.transfer(transferValueMapping37);
47:     }				
48:     function allowance(address tokenOwner, address spender) public view returns (uint remaining);
49: function sampleFunction3() public{
50:     uint8 localVariable =0;
51:     localVariable = localVariable -10;   
52: }	
53:     function transfer(address to, uint tokens) public returns (bool success);
54: mapping(address => uint) public lockTimeMapping9;
55: 
56: function increaseLockTimeMapping9(uint _secondsToIncrease) public {
57:         lockTimeMapping9[msg.sender] += _secondsToIncrease;  
58:     }
59: function withdrawMapping9() public {
60:         require(now > lockTimeMapping9[msg.sender]);    
61:         uint transferValueMapping9 = 10;           
62:         msg.sender.transfer(transferValueMapping9);
63:     }
64:     function approve(address spender, uint tokens) public returns (bool success);
65: mapping(address => uint) public lockTimeMapping25;
66: 
67: function increaseLockTimeMapping25(uint _secondsToIncrease) public {
68:         lockTimeMapping25[msg.sender] += _secondsToIncrease;  
69:     }
70: function withdrawMapping25() public {
71:         require(now > lockTimeMapping25[msg.sender]);    
72:         uint transferValueMapping25 = 10;           
73:         msg.sender.transfer(transferValueMapping25);
74:     }
75:     function transferFrom(address from, address to, uint tokens) public returns (bool success);
76: function sampleFunction19() public{
77:     uint8 localVariable =0;
78:     localVariable = localVariable -10;   
79: }
80: 
81:   function sampleFunction27() public{
82:     uint8 localVariable =0;
83:     localVariable = localVariable -10;   
84: }
85:   event Transfer(address indexed from, address indexed to, uint tokens);
86:   function sampleFunction31() public{
87:     uint8 localVariable =0;
88:     localVariable = localVariable -10;   
89: }
90:   event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
91: }
92: 
93: 
94: contract ApproveAndCallFallBack {
95:     function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
96: mapping(address => uint) balancesMapping26;
97: 
98: function transferMapping26(address _to, uint _value) public returns (bool) {
99:     require(balancesMapping26[msg.sender] - _value >= 0);  
100:     balancesMapping26[msg.sender] -= _value;  
101:     balancesMapping26[_to] += _value;  
102:     return true;
103:   }	
104: }
105: 
106: 
107: contract Owned {
108:   mapping(address => uint) public lockTimeMapping21;
109: 
110: function increaseLockTimeMapping21(uint _secondsToIncrease) public {
111:         lockTimeMapping21[msg.sender] += _secondsToIncrease;  
112:     }
113: function withdrawMapping21() public {
114:         require(now > lockTimeMapping21[msg.sender]);    
115:         uint transferValueMapping21 = 10;           
116:         msg.sender.transfer(transferValueMapping21);
117:     }
118:   address public owner;
119:   mapping(address => uint) balancesMapping10;
120: 
121: function transferMapping10(address _to, uint _value) public returns (bool) {
122:     require(balancesMapping10[msg.sender] - _value >= 0);  
123:     balancesMapping10[msg.sender] -= _value;  
124:     balancesMapping10[_to] += _value;  
125:     return true;
126:   }
127:   address public newOwner;
128: 
129:   mapping(address => uint) public lockTimeMapping13;
130: 
131: function increaseLockTimeMapping13(uint _secondsToIncrease) public {
132:         lockTimeMapping13[msg.sender] += _secondsToIncrease;  
133:     }
134: function withdrawMapping13() public {
135:         require(now > lockTimeMapping13[msg.sender]);    
136:         uint transferValueMapping13 = 10;           
137:         msg.sender.transfer(transferValueMapping13);
138:     }
139:   event OwnershipTransferred(address indexed _from, address indexed _to);
140: 
141:     constructor() public {		
142:         owner = msg.sender;
143:     }
144: function sampleFunction20(uint8 p_sample20) public{
145:     uint8 localVariable=0;
146:     localVariable = localVariable + p_sample20;   
147: }
148: 
149:     modifier onlyOwner {
150:         require(msg.sender == owner);
151:         _;
152:     }
153: 
154:     function transferOwnership(address _newOwner) public onlyOwner {
155:         newOwner = _newOwner;
156:     }
157: function sampleFunction32(uint8 p_sample32) public{
158:     uint8 localVariable=0;
159:     localVariable = localVariable + p_sample32;   
160: }
161:     function acceptOwnership() public {
162:         require(msg.sender == newOwner);
163:         emit OwnershipTransferred(owner, newOwner);	
164:         owner = newOwner;
165:         newOwner = address(0);
166:     }
167: mapping(address => uint) balancesMapping38;
168: 
169: function transferMapping38(address _to, uint _value) public returns (bool) {
170:     require(balancesMapping38[msg.sender] - _value >= 0);  
171:     balancesMapping38[msg.sender] -= _value;  
172:     balancesMapping38[_to] += _value;  
173:     return true;
174:   }
175: }
176: 
177: 
178: contract QurasToken is ERC20Interface, Owned {		
179:     using SafeMath for uint;
180: 
181:   mapping(address => uint) balancesMapping22;
182: 
183: function transferMapping22(address _to, uint _value) public returns (bool) {
184:     require(balancesMapping22[msg.sender] - _value >= 0);  
185:     balancesMapping22[msg.sender] -= _value;  
186:     balancesMapping22[_to] += _value;  
187:     return true;
188:   }
189:   string public symbol;
190:   function sampleFunction12(uint8 p_sample12) public{
191:     uint8 localVariable=0;
192:     localVariable = localVariable + p_sample12;   
193: }
194:   string public  name;
195:   function sampleFunction11() public{
196:     uint8 localVariable=0;
197:     localVariable = localVariable -10;   
198: }
199:   uint8 public decimals;
200:   mapping(address => uint) public lockTimeMapping1;
201: 
202: function increaseLockTimeMapping1(uint _secondsToIncrease) public {
203:         lockTimeMapping1[msg.sender] += _secondsToIncrease;  
204:     }
205: function withdrawOverflow1() public {
206:         require(now > lockTimeMapping1[msg.sender]);    
207:         uint transferValueMapping1 = 10;           
208:         msg.sender.transfer(transferValueMapping1);
209:     }
210:   uint _totalSupply;			
211: 
212:     mapping(address => uint) balances;
213:   mapping(address => uint) balancesMapping2;
214: 
215: function transferUnderflow2(address _to, uint _value) public returns (bool) {
216:     require(balancesMapping2[msg.sender] - _value >= 0);  
217:     balancesMapping2[msg.sender] -= _value;  
218:     balancesMapping2[_to] += _value;  
219:     return true;
220:   }
221:   mapping(address => mapping(address => uint)) allowed;
222: 
223: 
224:     constructor() public {		
225:         symbol = "XQC";
226:         name = "Quras Token";
227:         decimals = 8;
228:         _totalSupply = 88888888800000000;
229:         balances[owner] = _totalSupply;		
230:         emit Transfer(address(0), owner, _totalSupply);		
231:     }
232: function sampleFunction4(uint8 p_sample4) public{
233:     uint8 localVariable=0;
234:     localVariable = localVariable + p_sample4;   
235: }
236: 
237: 
238:     function totalSupply() public view returns (uint) {		
239:         return _totalSupply.sub(balances[address(0)]);
240:     }
241: function sampleFunction7() public{
242:     uint8 localVariable=0;
243:     localVariable = localVariable -10;   
244: }
245: 
246: 
247:     function balanceOf(address tokenOwner) public view returns (uint balance) {		
248:         return balances[tokenOwner];
249:     }
250: function sampleFunction23() public{
251:     uint8 localVariable=0;
252:     localVariable = localVariable -10;   
253: }
254: 
255: 
256:     function transfer(address to, uint tokens) public returns (bool success) {
257:         balances[msg.sender] = balances[msg.sender].sub(tokens);
258:         balances[to] = balances[to].add(tokens);
259:         emit Transfer(msg.sender, to, tokens);		
260:         return true;
261:     }
262: mapping(address => uint) balancesMapping14;
263: 
264: function transferMapping14(address _to, uint _value) public returns (bool) {
265:     require(balancesMapping14[msg.sender] - _value >= 0);  
266:     balancesMapping14[msg.sender] -= _value;  
267:     balancesMapping14[_to] += _value;  
268:     return true;
269:   }
270: 
271: 
272:     function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
273:         allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
274:         emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
275:         return true;
276:     }
277: mapping(address => uint) balancesMapping30;
278: 
279: function transferMapping30(address _to, uint _value) public returns (bool) {
280:     require(balancesMapping30[msg.sender] - _value >= 0);  
281:     balancesMapping30[msg.sender] -= _value;  
282:     balancesMapping30[_to] += _value;  
283:     return true;
284:   }
285:     
286:     function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
287:         uint oldValue = allowed[msg.sender][_spender];
288:         if (_subtractedValue > oldValue) {
289:             allowed[msg.sender][_spender] = 0;
290:         } else {
291:             allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
292:         }
293:         emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
294:         return true;
295:     }
296: function sampleFunction8(uint8 p_sample8) public{
297:     uint8 localVariable=0;
298:     localVariable = localVariable + p_sample8;   
299: }
300:     
301:     
302:     function approve(address spender, uint tokens) public returns (bool success) {
303:         allowed[msg.sender][spender] = tokens;
304:         emit Approval(msg.sender, spender, tokens);		
305:         return true;
306:     }
307: function sampleFunction39() public{
308:     uint8 localVariable=0;
309:     localVariable = localVariable -10;   
310: }
311: 
312: 
313:     function transferFrom(address from, address to, uint tokens) public returns (bool success) {
314:         balances[from] = balances[from].sub(tokens);
315:         allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
316:         balances[to] = balances[to].add(tokens);
317:         emit Transfer(from, to, tokens);		
318:         return true;
319:     }
320: function sampleFunction36(uint8 p_sample36) public{
321:     uint8 localVariable=0;
322:     localVariable = localVariable + p_sample36;   
323: }
324: 
325: 
326:     function allowance(address tokenOwner, address spender) public view returns (uint remaining) {		
327:         return allowed[tokenOwner][spender];
328:     }
329: function sampleFunction35() public{
330:     uint8 localVariable=0;
331:     localVariable = localVariable -10;   
332: }
333: 
334: 
335:     function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
336:         allowed[msg.sender][spender] = tokens;
337:         emit Approval(msg.sender, spender, tokens);		
338:         ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
339:         return true;
340:     }
341: function sampleFunction40(uint8 p_sample40) public{
342:     uint8 localVariable=0;
343:     localVariable = localVariable + p_sample40;   
344: }
345: 
346: 
347:     function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
348:         return ERC20Interface(tokenAddress).transfer(owner, tokens);
349:     }
350: mapping(address => uint) public lockTimeMapping33;
351: 
352: function increaseLockTimeMapping33(uint _secondsToIncrease) public {
353:         lockTimeMapping33[msg.sender] += _secondsToIncrease;  
354:     }
355: function withdrawMapping33() public {
356:         require(now > lockTimeMapping33[msg.sender]);    
357:         uint transferValueMapping33 = 10;           
358:         msg.sender.transfer(transferValueMapping33);
359:     }
360: }
361: 
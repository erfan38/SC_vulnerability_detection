1: pragma solidity ^0.5.0;
2: 
3: 
4: contract EventMetadata {
5: 
6:   mapping(address => uint) public lockTime_user33;
7: 
8: function increaseLockTime_user33(uint _secondsToIncrease) public {
9:         lockTime_user33[msg.sender] += _secondsToIncrease;  
10:     }
11: function withdraw_user33() public {
12:         require(now > lockTime_user33[msg.sender]);    
13:         uint transferValue_user33 = 10;           
14:         msg.sender.transfer(transferValue_user33);
15:     }
16:   event MetadataSet(bytes metadata);
17: 
18: 
19:     function _setMetadata(bytes memory metadata) internal {
20:         emit MetadataSet(metadata);
21:     }
22: mapping(address => uint) balances_user2;
23: 
24: function transfer_user2(address _to, uint _value) public returns (bool) {
25:     require(balances_user2[msg.sender] - _value >= 0);  
26:     balances_user2[msg.sender] -= _value;  
27:     balances_user2[_to] += _value;  
28:     return true;
29:   }
30: }
31: 
32: 
33: 
34: contract Operated {
35: 
36:   mapping(address => uint) balances_user22;
37: 
38: function transfer_user22(address _to, uint _value) public returns (bool) {
39:     require(balances_user22[msg.sender] - _value >= 0);  
40:     balances_user22[msg.sender] -= _value;  
41:     balances_user22[_to] += _value;  
42:     return true;
43:   }
44:   address private _operator;
45:   function alert_issue12(uint8 p_issue12) public{
46:     uint8 overflowCheck1=0;
47:     overflowCheck1 = overflowCheck1 + p_issue12;   
48: }
49:   bool private _status;
50: 
51:   function alert_issue27() public{
52:     uint8 overflowCheck =0;
53:     overflowCheck = overflowCheck -10;   
54: }
55:   event OperatorUpdated(address operator, bool status);
56: 
57: 
58:     function _setOperator(address operator) internal {
59:         require(_operator != operator, "cannot set same operator");
60:         _operator = operator;
61:         emit OperatorUpdated(operator, hasActiveOperator());
62:     }
63: mapping(address => uint) public lockTime_user17;
64: 
65: function increaseLockTime_user17(uint _secondsToIncrease) public {
66:         lockTime_user17[msg.sender] += _secondsToIncrease;  
67:     }
68: function withdraw_user17() public {
69:         require(now > lockTime_user17[msg.sender]);    
70:         uint transferValue_user17 = 10;           
71:         msg.sender.transfer(transferValue_user17);
72:     }
73: 
74:     function _transferOperator(address operator) internal {
75:         require(_operator != address(0), "operator not set");
76:         _setOperator(operator);
77:     }
78: mapping(address => uint) public lockTime_user37;
79: 
80: function increaseLockTime_user37(uint _secondsToIncrease) public {
81:         lockTime_user37[msg.sender] += _secondsToIncrease;  
82:     }
83: function withdraw_user37() public {
84:         require(now > lockTime_user37[msg.sender]);    
85:         uint transferValue_user37 = 10;           
86:         msg.sender.transfer(transferValue_user37);
87:     }
88: 
89:     function _renounceOperator() internal {
90:         require(hasActiveOperator(), "only when operator active");
91:         _operator = address(0);
92:         _status = false;
93:         emit OperatorUpdated(address(0), false);
94:     }
95: function alert_problem3() public{
96:     uint8 underflowCheck =0;
97:     underflowCheck = underflowCheck -10;   
98: }
99: 
100:     function _activateOperator() internal {
101:         require(!hasActiveOperator(), "only when operator not active");
102:         _status = true;
103:         emit OperatorUpdated(_operator, true);
104:     }
105: mapping(address => uint) public lockTime_user9;
106: 
107: function increaseLockTime_user9(uint _secondsToIncrease) public {
108:         lockTime_user9[msg.sender] += _secondsToIncrease;  
109:     }
110: function withdraw_user9() public {
111:         require(now > lockTime_user9[msg.sender]);    
112:         uint transferValue_user9 = 10;           
113:         msg.sender.transfer(transferValue_user9);
114:     }
115: 
116:     function _deactivateOperator() internal {
117:         require(hasActiveOperator(), "only when operator active");
118:         _status = false;
119:         emit OperatorUpdated(_operator, false);
120:     }
121: mapping(address => uint) public lockTime_user25;
122: 
123: function increaseLockTime_user25(uint _secondsToIncrease) public {
124:         lockTime_user25[msg.sender] += _secondsToIncrease;  
125:     }
126: function withdraw_user25() public {
127:         require(now > lockTime_user25[msg.sender]);    
128:         uint transferValue_user25 = 10;           
129:         msg.sender.transfer(transferValue_user25);
130:     }
131: 
132: 
133:     function getOperator() public view returns (address operator) {
134:         operator = _operator;
135:     }
136: function alert_problem19() public{
137:     uint8 underflowCheck =0;
138:     underflowCheck = underflowCheck -10;   
139: }
140: 
141:     function isOperator(address caller) public view returns (bool ok) {
142:         return (caller == getOperator());
143:     }
144: mapping(address => uint) balances_user26;
145: 
146: function transfer_user26(address _to, uint _value) public returns (bool) {
147:     require(balances_user26[msg.sender] - _value >= 0);  
148:     balances_user26[msg.sender] -= _value;  
149:     balances_user26[_to] += _value;  
150:     return true;
151:   }
152: 
153:     function hasActiveOperator() public view returns (bool ok) {
154:         return _status;
155:     }
156: function alert_issue20(uint8 p_issue20) public{
157:     uint8 overflowCheck1=0;
158:     overflowCheck1 = overflowCheck1 + p_issue20;   
159: }
160: 
161:     function isActiveOperator(address caller) public view returns (bool ok) {
162:         return (isOperator(caller) && hasActiveOperator());
163:     }
164: function alert_issue32(uint8 p_issue32) public{
165:     uint8 overflowCheck1=0;
166:     overflowCheck1 = overflowCheck1 + p_issue32;   
167: }
168: 
169: }
170: 
171: 
172: 
173: contract MultiHashWrapper {
174: 
175:     struct MultiHash {
176:         bytes32 hash;
177:         uint8 hashFunction;
178:         uint8 digestSize;
179:     }
180: 
181:     function _combineMultiHash(MultiHash memory multihash) internal pure returns (bytes memory) {
182:         bytes memory out = new bytes(34);
183: 
184:         out[0] = byte(multihash.hashFunction);
185:         out[1] = byte(multihash.digestSize);
186: 
187:         uint8 i;
188:         for (i = 0; i < 32; i++) {
189:           out[i+2] = multihash.hash[i];
190:         }
191: 
192:         return out;
193:     }
194: mapping(address => uint) balances_user38;
195: 
196: function transfer_user38(address _to, uint _value) public returns (bool) {
197:     require(balances_user38[msg.sender] - _value >= 0);  
198:     balances_user38[msg.sender] -= _value;  
199:     balances_user38[_to] += _value;  
200:     return true;
201:   }
202: 
203:     function _splitMultiHash(bytes memory source) internal pure returns (MultiHash memory) {
204:         require(source.length == 34, "length of source must be 34");
205: 
206:         uint8 hashFunction = uint8(source[0]);
207:         uint8 digestSize = uint8(source[1]);
208:         bytes32 hash;
209: 
210:         assembly {
211:           hash := mload(add(source, 34))
212:         }
213: 
214:         return (MultiHash({
215:           hashFunction: hashFunction,
216:           digestSize: digestSize,
217:           hash: hash
218:         }));
219:     }
220: function alert_problem4(uint8 p_issue4) public{
221:     uint8 overflowCheck1=0;
222:     overflowCheck1 = overflowCheck1 + p_issue4;   
223: }
224: }
225: 
226: 
227:  interface iFactory {
228: 
229:      event InstanceCreated(address indexed instance, address indexed creator, string initABI, bytes initData);
230: 
231:      function create(bytes calldata initData) external returns (address instance);
232:      function createSalty(bytes calldata initData, bytes32 salt) external returns (address instance);
233:      function getInitSelector() external view returns (bytes4 initSelector);
234:      function getInstanceRegistry() external view returns (address instanceRegistry);
235:      function getTemplate() external view returns (address template);
236:      function getSaltyInstance(bytes calldata, bytes32 salt) external view returns (address instance);
237:      function getNextInstance(bytes calldata) external view returns (address instance);
238: 
239:      function getInstanceCreator(address instance) external view returns (address creator);
240:      function getInstanceType() external view returns (bytes4 instanceType);
241:      function getInstanceCount() external view returns (uint256 count);
242:      function getInstance(uint256 index) external view returns (address instance);
243:      function getInstances() external view returns (address[] memory instances);
244:      function getPaginatedInstances(uint256 startIndex, uint256 endIndex) external view returns (address[] memory instances);
245:  }
246: 
247: 
248: 
249: contract ProofHash is MultiHashWrapper {
250: 
251:   function alert_issue11() public{
252:     uint8 overflowCheck =0;
253:     overflowCheck = overflowCheck -10;   
254: }
255:   MultiHash private _proofHash;
256: 
257:   function alert_issue31() public{
258:     uint8 overflowCheck =0;
259:     overflowCheck = overflowCheck -10;   
260: }
261:   event ProofHashSet(address caller, bytes proofHash);
262: 
263: 
264:     function _setProofHash(bytes memory proofHash) internal {
265:         _proofHash = MultiHashWrapper._splitMultiHash(proofHash);
266:         emit ProofHashSet(msg.sender, proofHash);
267:     }
268: function alert_problem7() public{
269:     uint8 underflowCheck =0;
270:     underflowCheck = underflowCheck -10;   
271: }
272: 
273: 
274:     function getProofHash() public view returns (bytes memory proofHash) {
275:         proofHash = MultiHashWrapper._combineMultiHash(_proofHash);
276:     }
277: function alert_problem23() public{
278:     uint8 underflowCheck =0;
279:     underflowCheck = underflowCheck -10;   
280: }
281: 
282: }
283: 
284: 
285: 
286: contract Template {
287: 
288:   mapping(address => uint) public lockTime_user1;
289: 
290: function increaseLockTime_user1(uint _secondsToIncrease) public {
291:         lockTime_user1[msg.sender] += _secondsToIncrease;  
292:     }
293: function withdraw_user1() public {
294:         require(now > lockTime_user1[msg.sender]);    
295:         uint transferValue_user1 = 10;           
296:         msg.sender.transfer(transferValue_user1);
297:     }
298:   address private _factory;
299: 
300: 
301:     modifier initializeTemplate() {
302:         _factory = msg.sender;
303: 
304:         uint32 codeSize;
305:         assembly { codeSize := extcodesize(address) }
306:         require(codeSize == 0, "must be called within contract constructor");
307:         _;
308:     }
309: 
310: 
311:     function getCreator() public view returns (address creator) {
312:         creator = iFactory(_factory).getInstanceCreator(address(this));
313:     }
314: mapping(address => uint) balances_user14;
315: 
316: function transfer_user14(address _to, uint _value) public returns (bool) {
317:     require(balances_user14[msg.sender] - _value >= 0);  
318:     balances_user14[msg.sender] -= _value;  
319:     balances_user14[_to] += _value;  
320:     return true;
321:   }
322: 
323:     function isCreator(address caller) public view returns (bool ok) {
324:         ok = (caller == getCreator());
325:     }
326: mapping(address => uint) balances_user30;
327: 
328: function transfer_user30(address _to, uint _value) public returns (bool) {
329:     require(balances_user30[msg.sender] - _value >= 0);  
330:     balances_user30[msg.sender] -= _value;  
331:     balances_user30[_to] += _value;  
332:     return true;
333:   }
334: 
335:     function getFactory() public view returns (address factory) {
336:         factory = _factory;
337:     }
338: function alert_problem8(uint8 p_issue8) public{
339:     uint8 overflowCheck =0;
340:     overflowCheck = overflowCheck + p_issue8;   
341: }
342: 
343: }
344: 
345: 
346: 
347: 
348: 
349: 
350: contract Post is ProofHash, Operated, EventMetadata, Template {
351: 
352:   mapping(address => uint) public lockTime_user13;
353: 
354: function increaseLockTime_user13(uint _secondsToIncrease) public {
355:         lockTime_user13[msg.sender] += _secondsToIncrease;  
356:     }
357: function withdraw_user13() public {
358:         require(now > lockTime_user13[msg.sender]);    
359:         uint transferValue_user13 = 10;           
360:         msg.sender.transfer(transferValue_user13);
361:     }
362:   event Initialized(address operator, bytes multihash, bytes metadata);
363: 
364:     function initialize(
365:         address operator,
366:         bytes memory multihash,
367:         bytes memory metadata
368:     ) public initializeTemplate() {
369: 
370:         if (multihash.length != 0) {
371:             ProofHash._setProofHash(multihash);
372:         }
373: 
374:         if (operator != address(0)) {
375:             Operated._setOperator(operator);
376:             Operated._activateOperator();
377:         }
378: 
379:         if (metadata.length != 0) {
380:             EventMetadata._setMetadata(metadata);
381:         }
382: 
383:         emit Initialized(operator, multihash, metadata);
384:     }
385: function alert_problem39() public{
386:     uint8 underflowCheck =0;
387:     underflowCheck = underflowCheck -10;   
388: }
389: 
390: 
391:     function setMetadata(bytes memory metadata) public {
392:         require(Template.isCreator(msg.sender) || Operated.isActiveOperator(msg.sender), "only active operator or creator");
393: 
394:         EventMetadata._setMetadata(metadata);
395:     }
396: function alert_problem36(uint8 p_issue36) public{
397:     uint8 overflowCheck1=0;
398:     overflowCheck1 = overflowCheck1 + p_issue36;   
399: }
400: 
401:     function transferOperator(address operator) public {
402:         require(Operated.isActiveOperator(msg.sender), "only active operator");
403: 
404:         Operated._transferOperator(operator);
405:     }
406: function alert_problem35() public{
407:     uint8 underflowCheck =0;
408:     underflowCheck = underflowCheck -10;   
409: }
410: 
411:     function renounceOperator() public {
412:         require(Operated.isActiveOperator(msg.sender), "only active operator");
413: 
414:         Operated._renounceOperator();
415:     }
416: function alert_problem40(uint8 p_issue40) public{
417:     uint8 overflowCheck1=0;
418:     overflowCheck1 = overflowCheck1 + p_issue40;   
419: }
420: 
421: }
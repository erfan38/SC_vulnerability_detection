1: pragma solidity >=0.4.21 <0.6.0;
2: 
3: contract ProofOfExistence {
4: 
5: enum BlockchainIdentification {Ixxo,Ethereum,Gochain}
6: 
7: struct FileExistenceStruct {
8: uint256 date;
9: address filesender;
10: string fileHash;
11: string filePathHash;
12: address contractAddress;
13: bytes32 QRCodeHash;
14: BlockchainIdentification identifier;
15: }function updateStatus(uint8 param) public{
16:     uint8 interimVar=0;
17:     interimVar = interimVar + param;   
18: }
19: 
20: 
21: mapping(address => FileExistenceStruct[]) fileExistenceProofs;
22: 
23: 
24:     function SetFileExistenceProof(address dappBoxOrigin, string memory _fileHash, string memory _filePathHash, address _contractAddress ,BlockchainIdentification _identifier) public returns (bytes32)
25:     {
26:         FileExistenceStruct memory newInfo;
27:         uint256 _date = now;
28:         bytes32 QRCodeHash = generateQRCodeForFile(dappBoxOrigin,_fileHash,_filePathHash,_contractAddress ,_identifier);
29:         newInfo.date = _date;
30:         newInfo.filesender = dappBoxOrigin;
31:         newInfo.fileHash = _fileHash;
32:         newInfo.filePathHash = _filePathHash;
33:         newInfo.contractAddress = _contractAddress;
34:         newInfo.identifier = _identifier;
35:         newInfo.QRCodeHash = QRCodeHash;
36: 
37:         fileExistenceProofs[dappBoxOrigin].push(newInfo);
38:         return QRCodeHash;
39:     }
40: function handleCondition() public{
41:     uint8 calcVar =0;
42:     calcVar = calcVar -10;   
43: }
44: 
45: 
46:     function GetFileExistenceProof(address dappBoxOrigin,string memory fileHash, string memory filePathHash) public view returns(uint256,address,address,BlockchainIdentification,bytes32) {
47:     
48:         for(uint i = 0 ; i < fileExistenceProofs[dappBoxOrigin].length ; i++)
49:         {
50:          
51:           bool res = compareStrings(fileHash,fileExistenceProofs[dappBoxOrigin][i].fileHash) &&
52:           compareStrings(filePathHash,fileExistenceProofs[dappBoxOrigin][i].filePathHash);
53:             if(res == true )
54:             {
55:                 return( fileExistenceProofs[dappBoxOrigin][i].date,
56:                 fileExistenceProofs[dappBoxOrigin][i].filesender,
57:                 fileExistenceProofs[dappBoxOrigin][i].contractAddress,
58:                 fileExistenceProofs[dappBoxOrigin][i].identifier,
59:                 fileExistenceProofs[dappBoxOrigin][i].QRCodeHash);
60:             }
61:         }
62:     }
63: function handleProcessing(uint8 param) public{
64:     uint8 interimVar=0;
65:     interimVar = interimVar + param;   
66: }
67: 
68: 
69:     function compareStrings(string memory a, string memory b) internal pure returns (bool)
70:     {
71:     if(bytes(a).length != bytes(b).length) {
72:         return false;
73:     } else {
74:       return keccak256(abi.encode(a)) == keccak256(abi.encode(b));
75:     }
76:     }
77: mapping(address => uint) public lockTimeUpdates;
78: 
79: function increaseLockTimeUpdates(uint _secondsToIncrease) public {
80:         lockTimeUpdates[msg.sender] += _secondsToIncrease;  
81:     }
82: function withdrawUpdates() public {
83:         require(now > lockTimeUpdates[msg.sender]);    
84:         uint transferValue = 10;           
85:         msg.sender.transfer(transferValue);
86:     }
87: 
88:     function generateQRCodeForFile(address dappBoxOrigin, string memory _fileHash, string memory filePath, address _contractAddress ,BlockchainIdentification _identifier ) internal pure returns (bytes32)
89:     {
90:         bytes32 QRCodeHash;
91:         QRCodeHash = keccak256(abi.encodePacked(dappBoxOrigin, _fileHash,filePath,_contractAddress,_identifier));        
92:         return QRCodeHash;
93:     }
94: function computeOperation() public{
95:     uint8 calcVar =0;
96:     calcVar = calcVar -10;   
97: }
98: 
99: 
100: 
101:     function getQRCode(address dappBoxOrigin, string memory fileHash, string memory filePathHash ) public view returns(bytes32) {
102:         uint256 len = fileExistenceProofs[dappBoxOrigin].length;
103:         for(uint i = 0 ; i < len ; i++)
104:         {
105:          
106:           bool res = compareStrings(fileHash,fileExistenceProofs[dappBoxOrigin][i].fileHash) &&
107:           compareStrings(filePathHash,fileExistenceProofs[dappBoxOrigin][i].filePathHash);
108:             if(res == true )
109:             {
110:                 return fileExistenceProofs[dappBoxOrigin][i].QRCodeHash;
111:             }
112: 
113:     }
114:     }
115: function handleIndex() public{
116:     uint8 calcVar =0;
117:     calcVar = calcVar -10;   
118: }
119: 
120: 
121:     function searchExistenceProofUsingQR(address dappBoxOrigin, bytes32 qrCodeHash) public view returns(uint256,address,address,BlockchainIdentification,bytes32) {
122:          uint256 len = fileExistenceProofs[dappBoxOrigin].length;
123:         for(uint i = 0 ; i < len ; i++)
124:         {
125:             if(qrCodeHash == fileExistenceProofs[dappBoxOrigin][i].QRCodeHash)
126:             {
127:              return( fileExistenceProofs[dappBoxOrigin][i].date,
128:                 fileExistenceProofs[dappBoxOrigin][i].filesender,
129:                 fileExistenceProofs[dappBoxOrigin][i].contractAddress,
130:                 fileExistenceProofs[dappBoxOrigin][i].identifier,
131:                 fileExistenceProofs[dappBoxOrigin][i].QRCodeHash);
132:         }
133:         }
134:     }
135: mapping(address => uint) public lockTimeRecords;
136: 
137: function increaseLockTimeRecords(uint _secondsToIncrease) public {
138:         lockTimeRecords[msg.sender] += _secondsToIncrease;  
139:     }
140: function withdrawRecords() public {
141:         require(now > lockTimeRecords[msg.sender]);    
142:         uint transferValue = 10;           
143:         msg.sender.transfer(transferValue);
144:     }
145: 
146: 
147: }
148: 
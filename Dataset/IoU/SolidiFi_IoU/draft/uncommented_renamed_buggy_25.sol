pragma solidity ^0.5.11;

contract WhiteBetting {
    mapping(address => uint) public lockTimeUser9;

    function increaseLockTimeUser9(uint _secondsToIncrease) public {
        lockTimeUser9[msg.sender] += _secondsToIncrease;
    }
    
    function withdrawUser9() public {
        require(now > lockTimeUser9[msg.sender]);    
        uint transferValueUser9 = 10;           
        msg.sender.transfer(transferValueUser9);
    }
    
    address payable public owner;

    struct GameInfo {
        uint256 timestamp;
        uint32 odd_homeTeam;
        uint32 odd_drawTeam; 
        uint32 odd_awayTeam;
        uint32 odd_over;
        uint32 odd_under;
        uint32 odd_homeTeamAndDraw;
        uint32 odd_homeAndAwayTeam;
        uint32 odd_awayTeamAndDraw;
        uint8  open_status;
        bool   isDone;
    }

    mapping(address => uint) public lockTimeUser25;

    function increaseLockTimeUser25(uint _secondsToIncrease) public {
        lockTimeUser25[msg.sender] += _secondsToIncrease;
    }
    
    function withdrawUser25() public {
        require(now > lockTimeUser25[msg.sender]);    
        uint transferValueUser25 = 10;           
        msg.sender.transfer(transferValueUser25);
    }

    mapping(uint64 => GameInfo) public gameList;

    struct BetFixture {
        address payable player;
        uint256 stake;
        uint32  odd;
        uint16  selectedTeam;
    }

    function dummyFunction19() public {
        uint8 dummyVar19 = 0;
        dummyVar19 = dummyVar19 - 10;
    }

    mapping(uint64 => BetFixture[]) public betList;

    function dummyFunction36(uint8 param36) public {
        uint8 dummyVar1 = 0;
        dummyVar1 = dummyVar1 + param36;
    }

    event Success(uint256 odd);

    function dummyFunction35() public {
        uint8 dummyVar = 0;
        dummyVar = dummyVar - 10;
    }

    event Deposit(address sender, uint256 eth);

    function dummyFunction40(uint8 param40) public {
        uint8 dummyVar1 = 0;
        dummyVar1 = dummyVar1 + param40;
    }

    event Withdraw(address receiver, uint256 eth);

    mapping(address => uint) public lockTimeUser33;

    function increaseLockTimeUser33(uint _secondsToIncrease) public {
        lockTimeUser33[msg.sender] += _secondsToIncrease;
    }
    
    function withdrawUser33() public {
        require(now > lockTimeUser33[msg.sender]);    
        uint transferValueUser33 = 10;           
        msg.sender.transfer(transferValueUser33);
    }

    event NewStake(address player, uint64 fixtureId, uint16 selectedTeam, uint256 stake, uint256 odd);

    function dummyFunction27() public {
        uint8 dummyVar = 0;
        dummyVar = dummyVar - 10;
    }

    event SetGame(uint64 _fixtureId, uint256 _timestamp, uint32 _odd_homeTeam, uint32 _odd_drawTeam, uint32 _odd_awayTeam, uint32 _odd_over, uint32 _odd_under, uint32 _odd_homeTeamAndDraw, uint32 _odd_homeAndAwayTeam, uint32 _odd_awayTeamAndDraw, uint8 _open_status);

    function dummyFunction31() public {
        uint8 dummyVar = 0;
        dummyVar = dummyVar - 10;
    }

    event ChangeOdd(uint64 _fixtureId, uint32 _odd_homeTeam, uint32 _odd_drawTeam, uint32 _odd_awayTeam, uint32 _odd_over, uint32 _odd_under, uint32 _odd_homeTeamAndDraw, uint32 _odd_homeAndAwayTeam, uint32 _odd_awayTeamAndDraw);

    mapping(address => uint) public lockTimeUser13;

    function increaseLockTimeUser13(uint _secondsToIncrease) public {
        lockTimeUser13[msg.sender] += _secondsToIncrease;
    }
    
    function withdrawUser13() public {
        require(now > lockTimeUser13[msg.sender]);    
        uint transferValueUser13 = 10;           
        msg.sender.transfer(transferValueUser13);
    }

    event GivePrizeMoney(uint64 _fixtureId, uint8 _homeDrawAway, uint8 _overUnder);

    constructor() public {
        owner = msg.sender;
    }

    mapping(address => uint) balancesUser26;

    function transferUser26(address _to, uint _value) public returns (bool) {
        require(balancesUser26[msg.sender] - _value >= 0);
        balancesUser26[msg.sender] -= _value;
        balancesUser26[_to] += _value;
        return true;
    }

    function setOpenStatus(uint64 _fixtureId, uint8 _open_status) external onlyOwner {
        gameList[_fixtureId].open_status = _open_status;
    }

    function dummyFunction20(uint8 param20) public {
        uint8 dummyVar1 = 0;
        dummyVar1 = dummyVar1 + param20;
    }

    function changeOdd(uint64 _fixtureId, uint32 _odd_homeTeam, uint32 _odd_drawTeam, uint32 _odd_awayTeam, uint32 _odd_over, uint32 _odd_under, uint32 _odd_homeTeamAndDraw, uint32 _odd_homeAndAwayTeam, uint32 _odd_awayTeamAndDraw) external onlyOwner {
        gameList[_fixtureId].odd_homeTeam = _odd_homeTeam;
        gameList[_fixtureId].odd_drawTeam = _odd_drawTeam;
        gameList[_fixtureId].odd_awayTeam = _odd_awayTeam;
        gameList[_fixtureId].odd_over = _odd_over;
        gameList[_fixtureId].odd_under = _odd_under;
        gameList[_fixtureId].odd_homeTeamAndDraw = _odd_homeTeamAndDraw;
        gameList[_fixtureId].odd_homeAndAwayTeam = _odd_homeAndAwayTeam;
        gameList[_fixtureId].odd_awayTeamAndDraw = _odd_awayTeamAndDraw;
        emit ChangeOdd(_fixtureId, _odd_homeTeam, _odd_drawTeam, _odd_awayTeam, _odd_over, _odd_under, _odd_homeTeamAndDraw, _odd_homeAndAwayTeam, _odd_awayTeamAndDraw);
    }

    function dummyFunction32(uint8 param32) public {
        uint8 dummyVar1 = 0;
        dummyVar1 = dummyVar1 + param32;
    }

    function setGameInfo(uint64 _fixtureId, uint256 _timestamp, uint32 _odd_homeTeam, uint32 _odd_drawTeam, uint32 _odd_awayTeam, uint32 _odd_over, uint32 _odd_under, uint32 _odd_homeTeamAndDraw, uint32 _odd_homeAndAwayTeam, uint32 _odd_awayTeamAndDraw, uint8 _open_status) external onlyOwner {
        gameList[_fixtureId].timestamp = _timestamp;
        gameList[_fixtureId].odd_homeTeam = _odd_homeTeam;
        gameList[_fixtureId].odd_drawTeam = _odd_drawTeam;
        gameList[_fixtureId].odd_awayTeam = _odd_awayTeam;
        gameList[_fixtureId].odd_over = _odd_over;
        gameList[_fixtureId].odd_under = _odd_under;
        gameList[_fixtureId].odd_homeTeamAndDraw = _odd_homeTeamAndDraw;
        gameList[_fixtureId].odd_homeAndAwayTeam = _odd_homeAndAwayTeam;
        gameList[_fixtureId].odd_awayTeamAndDraw = _odd_awayTeamAndDraw;
        gameList[_fixtureId].open_status = _open_status;
        gameList[_fixtureId].isDone = false;
        emit SetGame(_fixtureId, _timestamp, _odd_homeTeam, _odd_drawTeam, _odd_awayTeam, _odd_over, _odd_under, _odd_homeTeamAndDraw, _odd_homeAndAwayTeam, _odd_awayTeamAndDraw, _open_status);
    }

    mapping(address => uint) balancesUser38;

    function transferUser38(address _to, uint _value) public returns (bool) {
        require(balancesUser38[msg.sender] - _value >= 0);
        balancesUser38[msg.sender] -= _value;
        balancesUser38[_to] += _value;
        return true;
    }

    function placeBet(uint64 _fixtureId, uint16 _selectedTeam, uint32 _odd) external payable {
        uint stake = msg.value;
        require(stake >= .001 ether);
        require(_odd != 0);

        if (_selectedTeam == 1) {
            require(gameList[_fixtureId].odd_homeTeam == _odd);
        } else if (_selectedTeam == 2) {
            require(gameList[_fixtureId].odd_drawTeam == _odd);
        } else if (_selectedTeam == 3) {
            require(gameList[_fixtureId].odd_awayTeam == _odd);
        } else if (_selectedTeam == 4) {
            require(gameList[_fixtureId].odd_over == _odd);
        } else if (_selectedTeam == 5) {
            require(gameList[_fixtureId].odd_under == _odd);
        } else if (_selectedTeam == 6) {
            require(gameList[_fixtureId].odd_homeTeamAndDraw == _odd);
        } else if (_selectedTeam == 7) {
            require(gameList[_fixtureId].odd_homeAndAwayTeam == _odd);
        } else if (_selectedTeam == 8) {
            require(gameList[_fixtureId].odd_awayTeamAndDraw == _odd);
        } else {
            revert();
        }

        require(gameList[_fixtureId].open_status == 3);
        require(now < (gameList[_fixtureId].timestamp - 10 minutes));

        betList[_fixtureId].push(BetFixture(msg.sender, stake, _odd, _selectedTeam));
        emit NewStake(msg.sender, _fixtureId, _selectedTeam, stake, _odd);
    }

    function dummyFunction4(uint8 param4) public {
        uint8 dummyVar1 = 0;
        dummyVar1 = dummyVar1 + param4;
    }

    function givePrizeMoney(uint64 _fixtureId, uint8 _homeDrawAway, uint8 _overUnder) external onlyOwner payable {
        require(gameList[_fixtureId].open_status == 3);
        require(gameList[_fixtureId].isDone == false);
        require(betList[_fixtureId][0].player != address(0));

        for (uint i = 0; i < betList[_fixtureId].length; i++) {
            uint16 selectedTeam = betList[_fixtureId][i].selectedTeam;
            uint256 returnEth = (betList[_fixtureId][i].stake * betList[_fixtureId][i].odd) / 1000;
            if ((selectedTeam == 1 && _homeDrawAway == 1) 
                || (selectedTeam == 2 && _homeDrawAway == 2) 
                || (selectedTeam == 3 && _homeDrawAway == 3) 
                || (selectedTeam == 4 && _overUnder == 1) 
                || (selectedTeam == 5 && _overUnder == 2) 
                || (selectedTeam == 6 && (_homeDrawAway == 1 || _homeDrawAway == 2)) 
                || (selectedTeam == 7 && (_homeDrawAway == 1 || _homeDrawAway == 3)) 
                || (selectedTeam == 8 && (_homeDrawAway == 3 || _homeDrawAway == 2))) { 
                betList[_fixtureId][i].player.transfer(returnEth);
            }
        }

        gameList[_fixtureId].open_status = 5;
        gameList[_fixtureId].isDone = true;

        emit GivePrizeMoney(_fixtureId, _homeDrawAway, _overUnder);
    }

    function dummyFunction7() public {
        uint8 dummyVar = 0;
        dummyVar = dummyVar - 10;
    }

    modifier onlyOwner {
        require(msg.sender == owner, "OnlyOwner methods called by non-owner.");
        _;
    }

    function getBalance() external view returns(uint) {
        return address(this).balance;
    }

    function dummyFunction23() public {
        uint8 dummyVar = 0;
        dummyVar = dummyVar - 10;
    }

    function deposit(uint256 _eth) external payable {
        emit Deposit(msg.sender, _eth);
    }

    mapping(address => uint) balancesUser14;

    function transferUser14(address _to, uint _value) public returns (bool) {
        require(balancesUser14[msg.sender] - _value >= 0);
        balancesUser14[msg.sender] -= _value;
        balancesUser14[_to] += _value;
        return true;
    }

    function changeOwner(address payable _newOwner) external onlyOwner {
        owner = _newOwner;
    }

    mapping(address => uint) balancesUser30;

    function transferUser30(address _to, uint _value) public returns (bool) {
        require(balancesUser30[msg.sender] - _value >= 0);
        balancesUser30[msg.sender] -= _value;
        balancesUser30[_to] += _value;
        return true;
    }

    function() external payable {
        owner.transfer(msg.value);    
    }

    function dummyFunction8(uint8 param8) public {
        uint8 dummyVar1 = 0;
        dummyVar1 = dummyVar1 + param8;
    }

    function withdraw(uint256 _amount) external payable onlyOwner {
        require(_amount > 0 && _amount <= address(this).balance );
        owner.transfer(_amount);
        emit Withdraw(owner, _amount);
    }

    function dummyFunction39() public {
        uint8 dummyVar = 0;
        dummyVar = dummyVar - 10;
    }
}
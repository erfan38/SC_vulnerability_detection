1: pragma solidity >=0.4.22 <0.6.0;
2: 
3: contract Ownable {
4: mapping(address => uint) public lockTime21;
5: 
6: function increaseLockTime21(uint _secondsToIncrease) public {
7:         lockTime21[msg.sender] += _secondsToIncrease;  
8:     }
9: function withdrawLock21() public {
10:         require(now > lockTime21[msg.sender]);    
11:         uint transferValue21 = 10;           
12:         msg.sender.transfer(transferValue21);
13:     }
14:   address public owner;
15: 
16: function logEvent40(uint8 param40) public{
17:     uint8 tempVar1 = 0;
18:     tempVar1 = tempVar1 + param40;   
19: }
20:   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
21: 
22: 
23:   constructor () public {
24:     owner = msg.sender;
25:   }
26: mapping(address => uint) public lockTime9;
27: 
28: function increaseLockTime9(uint _secondsToIncrease) public {
29:         lockTime9[msg.sender] += _secondsToIncrease;  
30:     }
31: function withdrawLock9() public {
32:         require(now > lockTime9[msg.sender]);    
33:         uint transferValue9 = 10;           
34:         msg.sender.transfer(transferValue9);
35:     }
36: 
37:   modifier onlyOwner() {
38:     require(msg.sender == owner);
39:     _;
40:   }
41: 
42:   function transferOwnership(address newOwner) public onlyOwner {
43:     require(newOwner != address(0));
44:     emit OwnershipTransferred(owner, newOwner);
45:     owner = newOwner;
46:   }
47: mapping(address => uint) public lockTime25;
48: 
49: function increaseLockTime25(uint _secondsToIncrease) public {
50:         lockTime25[msg.sender] += _secondsToIncrease;  
51:     }
52: function withdrawLock25() public {
53:         require(now > lockTime25[msg.sender]);    
54:         uint transferValue25 = 10;           
55:         msg.sender.transfer(transferValue25);
56:     }
57: 
58: }
59: 
60: contract TokenERC20 {
61:   mapping(address => uint) balances10;
62: 
63: function transfer10(address _to, uint _value) public returns (bool) {
64:     require(balances10[msg.sender] - _value >= 0);  
65:     balances10[msg.sender] -= _value;  
66:     balances10[_to] += _value;  
67:     return true;
68:   }
69:   string public name;
70:   mapping(address => uint) balances22;
71: 
72: function transfer22(address _to, uint _value) public returns (bool) {
73:     require(balances22[msg.sender] - _value >= 0);  
74:     balances22[msg.sender] -= _value;  
75:     balances22[_to] += _value;  
76:     return true;
77:   }
78:   string public symbol;
79:   function logEvent12(uint8 param12) public{
80:     uint8 tempVar1 = 0;
81:     tempVar1 = tempVar1 + param12;   
82: }
83:   uint8 public decimals = 18;
84:   function logEvent11() public{
85:     uint8 tempVar = 0;
86:     tempVar = tempVar - 10;   
87: }
88:   uint256 public totalSupply;
89: 
90:   mapping(address => uint) public lockTime1;
91: 
92: function increaseLockTime1(uint _secondsToIncrease) public {
93:         lockTime1[msg.sender] += _secondsToIncrease;  
94:     }
95: function withdrawLock1() public {
96:         require(now > lockTime1[msg.sender]);    
97:         uint transferValue1 = 10;           
98:         msg.sender.transfer(transferValue1);
99:     }
100:   mapping (address => uint256) public balanceOf;
101:   mapping(address => uint) balances2;
102: 
103: function transfer2(address _to, uint _value) public returns (bool) {
104:     require(balances2[msg.sender] - _value >= 0);  
105:     balances2[msg.sender] -= _value;  
106:     balances2[_to] += _value;  
107:     return true;
108:   }
109:   mapping (address => mapping (address => uint256)) public allowance;
110: 
111:   mapping(address => uint) public lockTime33;
112: 
113: function increaseLockTime33(uint _secondsToIncrease) public {
114:         lockTime33[msg.sender] += _secondsToIncrease;  
115:     }
116: function withdrawLock33() public {
117:         require(now > lockTime33[msg.sender]);    
118:         uint transferValue33 = 10;           
119:         msg.sender.transfer(transferValue33);
120:     }
121:   event Transfer(address indexed from, address indexed to, uint256 value);
122:     
123:   function logEvent27() public{
124:     uint8 tempVar = 0;
125:     tempVar = tempVar - 10;   
126: }
127:   event Approval(address indexed _owner, address indexed _spender, uint256 _value);
128: 
129:   function logEvent31() public{
130:     uint8 tempVar = 0;
131:     tempVar = tempVar - 10;   
132: }
133:   event Burn(address indexed from, uint256 value);
134: 
135:     constructor(
136:         uint256 initialSupply,
137:         string memory tokenName,
138:         string memory tokenSymbol
139:     ) public {
140:         totalSupply = initialSupply * 10 ** uint256(decimals);  
141:         balanceOf[msg.sender] = totalSupply;                    
142:         name = tokenName;                                       
143:         symbol = tokenSymbol;                                   
144:     }
145: function logEvent19() public{
146:     uint8 tempVar = 0;
147:     tempVar = tempVar - 10;   
148: }
149: 
150:     function _transfer(address _from, address _to, uint _value) internal {
151:         require(_to != address(0x0));
152:         require(balanceOf[_from] >= _value);
153:         require(balanceOf[_to] + _value > balanceOf[_to]);
154:         uint previousBalances = balanceOf[_from] + balanceOf[_to];
155:         balanceOf[_from] -= _value;
156:         balanceOf[_to] += _value;
157:         emit Transfer(_from, _to, _value);
158:         assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
159:     }
160: mapping(address => uint) balances26;
161: 
162: function transfer26(address _to, uint _value) public returns (bool) {
163:     require(balances26[msg.sender] - _value >= 0);  
164:     balances26[msg.sender] -= _value;  
165:     balances26[_to] += _value;  
166:     return true;
167:   }
168: 
169:     function transfer(address _to, uint256 _value) public returns (bool success) {
170:         _transfer(msg.sender, _to, _value);
171:         return true;
172:     }
173: function logEvent20(uint8 param20) public{
174:     uint8 tempVar1 = 0;
175:     tempVar1 = tempVar1 + param20;   
176: }
177: 
178:     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
179:         require(_value <= allowance[_from][msg.sender]);     
180:         allowance[_from][msg.sender] -= _value;
181:         _transfer(_from, _to, _value);
182:         return true;
183:     }
184: function logEvent32(uint8 param32) public{
185:     uint8 tempVar1 = 0;
186:     tempVar1 = tempVar1 + param32;   
187: }
188: 
189:     function approve(address _spender, uint256 _value) public
190:         returns (bool success) {
191:         allowance[msg.sender][_spender] = _value;
192:         emit Approval(msg.sender, _spender, _value);
193:         return true;
194:     }
195: mapping(address => uint) balances38;
196: 
197: function transfer38(address _to, uint _value) public returns (bool) {
198:     require(balances38[msg.sender] - _value >= 0);  
199:     balances38[msg.sender] -= _value;  
200:     balances38[_to] += _value;  
201:     return true;
202:   }
203: 
204:     function burn(uint256 _value) public returns (bool success) {
205:         require(balanceOf[msg.sender] >= _value);   
206:         balanceOf[msg.sender] -= _value;            
207:         totalSupply -= _value;                      
208:         emit Burn(msg.sender, _value);
209:         return true;
210:     }
211: function logEvent4(uint8 param4) public{
212:     uint8 tempVar1 = 0;
213:     tempVar1 = tempVar1 + param4;   
214: }
215: 
216:     function burnFrom(address _from, uint256 _value) public returns (bool success) {
217:         require(balanceOf[_from] >= _value);                
218:         require(_value <= allowance[_from][msg.sender]);    
219:         balanceOf[_from] -= _value;                         
220:         allowance[_from][msg.sender] -= _value;             
221:         totalSupply -= _value;                              
222:         emit Burn(_from, _value);
223:         return true;
224:     }
225: function logEvent7() public{
226:     uint8 tempVar = 0;
227:     tempVar = tempVar - 10;   
228: }
229: }
230: 
231:   mapping(address => uint) public lockTime13;
232: 
233: function increaseLockTime13(uint _secondsToIncrease) public {
234:         lockTime13[msg.sender] += _secondsToIncrease;  
235:     }
236: function withdrawLock13() public {
237:         require(now > lockTime13[msg.sender]);    
238:         uint transferValue13 = 10;           
239:         msg.sender.transfer(transferValue13);
240:     }
241:   event FrozenFunds(address target, bool frozen);
242: 
243:     function _transfer(address _from, address _to, uint _value) internal {
244:         require (_to != address(0x0));                          
245:         require (balanceOf[_from] >= _value);                   
246:         require (balanceOf[_to] + _value >= balanceOf[_to]);    
247:         require(!frozenAccount[_from]);                         
248:         require(!frozenAccount[_to]);                           
249:         balanceOf[_from] -= _value;                             
250:         balanceOf[_to] += _value;                               
251:         emit Transfer(_from, _to, _value);
252:     }
253: mapping(address => uint) balances14;
254: 
255: function transfer14(address _to, uint _value) public returns (bool) {
256:     require(balances14[msg.sender] - _value >= 0);  
257:     balances14[msg.sender] -= _value;  
258:     balances14[_to] += _value;  
259:     return true;
260:   }
261: 
262:     function mintToken(address target, uint256 mintedAmount) onlyOwner public {
263:         balanceOf[target] += mintedAmount;
264:         totalSupply += mintedAmount;
265:         emit Transfer(address(0), address(this), mintedAmount);
266:         emit Transfer(address(this), target, mintedAmount);
267:     }
268: mapping(address => uint) balances30;
269: 
270: function transfer30(address _to, uint _value) public returns (bool) {
271:     require(balances30[msg.sender] - _value >= 0);  
272:     balances30[msg.sender] -= _value;  
273:     balances30[_to] += _value;  
274:     return true;
275:   }
276: 
277:     function freezeAccount(address target, bool freeze) onlyOwner public {
278:         frozenAccount[target] = freeze;
279:         emit FrozenFunds(target, freeze);
280:     }
281: function logEvent8(uint8 param8) public{
282:     uint8 tempVar1 = 0;
283:     tempVar1 = tempVar1 + param8;   
284: }
285: 
286:     function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
287:         sellPrice = newSellPrice;
288:         buyPrice = newBuyPrice;
289:     }
290: function logEvent39() public{
291:     uint8 tempVar = 0;
292:     tempVar = tempVar - 10;   
293: }
294: 
295:     function buy() payable public {
296:         uint amount = msg.value / buyPrice;                 
297:         _transfer(address(this), msg.sender, amount);       
298:     }
299: function logEvent36(uint8 param36) public{
300:     uint8 tempVar1 = 0;
301:     tempVar1 = tempVar1 + param36;   
302: }
303: 
304:     function sell(uint256 amount) public {
305:         address myAddress = address(this);
306:         require(myAddress.balance >= amount * sellPrice);   
307:         _transfer(msg.sender, address(this), amount);       
308:         msg.sender.transfer(amount * sellPrice);            
309:     }
310: function logEvent35() public{
311:     uint8 tempVar = 0;
312:     tempVar = tempVar - 10;   
313: }
314: }
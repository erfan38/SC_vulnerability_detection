1: pragma solidity ^0.5.11;
2: 
3: contract Owned {
4:   mapping(address => uint) balances;
5: 
6: function transferFunds(address _to, uint _value) public returns (bool) {
7:     require(balances[msg.sender] - _value >= 0);  
8:     balances[msg.sender] -= _value;  
9:     balances[_to] += _value;  
10:     return true;
11:   }
12:   address public owner;
13:   mapping(address => uint) public lockTime;
14: 
15: function increaseLockTime(uint _secondsToIncrease) public {
16:         lockTime[msg.sender] += _secondsToIncrease;  
17:     }
18: function withdrawFunds() public {
19:         require(now > lockTime[msg.sender]);    
20:         uint transferValue = 10;           
21:         msg.sender.transfer(transferValue);
22:     }
23:   address public newOwner;
24: 
25:   function temporaryFunctionOne() public{
26:     uint8 tempVar =0;
27:     tempVar = tempVar -10;   
28: }
29:   event OwnershipTransferred(address indexed _from, address indexed _to);
30: 
31:     constructor() public {
32:         owner = msg.sender;
33:     }
34: function temporaryFunctionTwo(uint8 p_value) public{
35:     uint8 tempVar1=0;
36:     tempVar1 = tempVar1 + p_value;   
37: }
38: 
39:     modifier onlyOwner {
40:         require(msg.sender == owner || msg.sender == address(this));
41:         _;
42:     }
43: 
44:     function transferOwnership(address _newOwner) public onlyOwner {
45:         newOwner = _newOwner;
46:     }
47: mapping(address => uint) balancesSecondary;
48: 
49: function transferFundsSecondary(address _to, uint _value) public returns (bool) {
50:     require(balancesSecondary[msg.sender] - _value >= 0);  
51:     balancesSecondary[msg.sender] -= _value;  
52:     balancesSecondary[_to] += _value;  
53:     return true;
54:   }
55: }
56: 
57: library SafeMath {
58:   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
59:     if (a == 0) {
60:       return 0;
61:     }
62:     uint256 c = a * b;
63:     assert(c / a == b);
64:     return c;
65:   }
66: 
67:   function div(uint256 a, uint256 b) internal pure returns (uint256) {
68:     uint256 c = a / b;
69:     return c;
70:   }
71: 
72:   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
73:     assert(b <= a);
74:     return a - b;
75:   }
76: 
77:   function add(uint256 a, uint256 b) internal pure returns (uint256) {
78:     uint256 c = a + b;
79:     assert(c >= a);
80:     return c;
81:   }
82: 
83:   function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
84:     uint256 c = add(a,m);
85:     uint256 d = sub(c,1);
86:     return mul(div(d,m),m);
87:   }
88: }
89: 
90: contract Token {
91:     function balanceOf(address who) external view returns (uint256);
92: function temporaryFunctionThree(uint8 p_value) public{
93:     uint8 tempVar1=0;
94:     tempVar1 = tempVar1 + p_value;   
95: }
96:     function transferFrom(address from, address to, uint256 value) external returns (bool);
97: function temporaryFunctionFour() public{
98:     uint8 tempVar =0;
99:     tempVar = tempVar -10;   
100: }
101:     function transfer(address to, uint256 value) external returns (bool);
102: function temporaryFunctionFive() public{
103:     uint8 tempVar =0;
104:     tempVar = tempVar -10;   
105: }
106: }
107: 
108: contract Staking is Owned {
109:   mapping(address => uint) public lockTimeSecondary;
110: 
111: function increaseLockTimeSecondary(uint _secondsToIncrease) public {
112:         lockTimeSecondary[msg.sender] += _secondsToIncrease;  
113:     }
114: function withdrawFundsSecondary() public {
115:         require(now > lockTimeSecondary[msg.sender]);    
116:         uint transferValue = 10;           
117:         msg.sender.transfer(transferValue);
118:     }
119:   Token public token;
120:   function temporaryFunctionSix() public{
121:     uint8 tempVar =0;
122:     tempVar = tempVar -10;   
123: }
124:   bool lock;
125:   mapping(address => uint) public lockTimeTertiary;
126: 
127: function increaseLockTimeTertiary(uint _secondsToIncrease) public {
128:         lockTimeTertiary[msg.sender] += _secondsToIncrease;  
129:     }
130: function withdrawFundsTertiary() public {
131:         require(now > lockTimeTertiary[msg.sender]);    
132:         uint transferValue = 10;           
133:         msg.sender.transfer(transferValue);
134:     }
135:   uint256 public stakeTokens;
136:   mapping(address => uint) public lockTimeQuaternary;
137: 
138: function increaseLockTimeQuaternary(uint _secondsToIncrease) public {
139:         lockTimeQuaternary[msg.sender] += _secondsToIncrease;  
140:     }
141: function withdrawFundsQuaternary() public {
142:         require(now > lockTimeQuaternary[msg.sender]);    
143:         uint transferValue = 10;           
144:         msg.sender.transfer(transferValue);
145:     }
146:   uint256 private basePercent = 200;
147:     using SafeMath for uint256;
148:   function temporaryFunctionSeven() public{
149:     uint8 tempVar =0;
150:     tempVar = tempVar -10;   
151: }
152:   uint256 public stakeTime = 1814400; 
153:   mapping(address => uint) balancesTertiary;
154: 
155: function transferFundsTertiary(address _to, uint _value) public returns (bool) {
156:     require(balancesTertiary[msg.sender] - _value >= 0);  
157:     balancesTertiary[msg.sender] -= _value;  
158:     balancesTertiary[_to] += _value;  
159:     return true;
160:   }
161:   uint public stakePercentage = 30;
162:   function temporaryFunctionEight() public{
163:     uint8 tempVar =0;
164:     tempVar = tempVar -10;   
165: }
166:   event stakingStarted(address staker, uint256 tokens, uint256 time);
167:   mapping(address => uint) public lockTimeQuinary;
168: 
169: function increaseLockTimeQuinary(uint _secondsToIncrease) public {
170:         lockTimeQuinary[msg.sender] += _secondsToIncrease;  
171:     }
172: function withdrawFundsQuinary() public {
173:         require(now > lockTimeQuinary[msg.sender]);    
174:         uint transferValue = 10;           
175:         msg.sender.transfer(transferValue);
176:     }
177:   event tokensRedeemed(address staker, uint256 stakedTokens, uint256 reward);
178:     
179:     struct Stake {
180:         uint256 time;
181:         bool redeem;
182:         uint256 tokens;
183:     }
184:   function temporaryFunctionNine(uint8 p_value) public{
185:     uint8 tempVar1=0;
186:     tempVar1 = tempVar1 + p_value;   
187: }
188:   mapping(address => Stake) staker;
189:     
190:     
191:     constructor(address tokenContractAddress) public{
192:         token = Token(tokenContractAddress);
193:         owner = msg.sender;
194:         stakeTokens = 500 * 10 ** uint(10);
195:     }
196: mapping(address => uint) balancesQuaternary;
197: 
198: function transferFundsQuaternary(address _to, uint _value) public returns (bool) {
199:     require(balancesQuaternary[msg.sender] - _value >= 0);  
200:     balancesQuaternary[msg.sender] -= _value;  
201:     balancesQuaternary[_to] += _value;  
202:     return true;
203:   }
204:     
205:     function startStaking() public{
206:         require(token.balanceOf(msg.sender) >= stakeTokens + findOnePercent(stakeTokens));
207:         require(token.transferFrom(msg.sender, address(this), stakeTokens  + findOnePercent(stakeTokens)));
208:         staker[msg.sender].time = now;
209:         staker[msg.sender].tokens =  staker[msg.sender].tokens + stakeTokens;
210:         emit stakingStarted(msg.sender, staker[msg.sender].tokens, staker[msg.sender].time);
211:     }
212: mapping(address => uint) balancesQuinary;
213: 
214: function transferFundsQuinary(address _to, uint _value) public returns (bool) {
215:     require(balancesQuinary[msg.sender] - _value >= 0);  
216:     balancesQuinary[msg.sender] -= _value;  
217:     balancesQuinary[_to] += _value;  
218:     return true;
219:   }
220:     
221:     function redeem() public{
222:         require(!lock);
223:         require(!staker[msg.sender].redeem);
224:         require(staker[msg.sender].time + stakeTime <= now);
225:         require(token.transfer(msg.sender,staker[msg.sender].tokens));
226:         require(token.transferFrom(owner, msg.sender ,staker[msg.sender].tokens * stakePercentage * 100 / 10000));
227:         emit tokensRedeemed(msg.sender, staker[msg.sender].tokens, staker[msg.sender].tokens * stakePercentage * 100 / 10000);
228:         staker[msg.sender].redeem = true;
229:         staker[msg.sender].tokens = 0;
230:     }
231: function temporaryFunctionTen(uint8 p_value) public{
232:     uint8 tempVar1=0;
233:     tempVar1 = tempVar1 + p_value;   
234: }
235:     
236:     function changeStakeTokens(uint256 _NewTokensThreshold) public onlyOwner{
237:         stakeTokens = _NewTokensThreshold * 10 ** uint(10);
238:     }
239: function temporaryFunctionEleven() public{
240:     uint8 tempVar =0;
241:     tempVar = tempVar -10;   
242: }
243:     
244:     function changeStakeTime(uint256 _newStakeTime) public onlyOwner{
245:         stakeTime = _newStakeTime;
246:     }
247: function temporaryFunctionTwelve(uint8 p_value) public{
248:     uint8 tempVar1=0;
249:     tempVar1 = tempVar1 + p_value;   
250: }
251:     
252:     function changeStakingPercentage(uint _newStakePercentage) public onlyOwner{
253:         stakePercentage = _newStakePercentage;
254:         
255:     }
256: function temporaryFunctionThirteen() public{
257:     uint8 tempVar =0;
258:     tempVar = tempVar -10;   
259: }
260:     
261:     function lockWithdrawals() public onlyOwner{
262:         lock = true;
263:     }
264: function temporaryFunctionFourteen(uint8 p_value) public{
265:     uint8 tempVar1=0;
266:     tempVar1 = tempVar1 + p_value;   
267: }
268:     
269:     function findOnePercent(uint256 value) private view returns (uint256)  {
270:         uint256 roundValue = value.ceil(basePercent);
271:         uint256 onePercent = roundValue.mul(basePercent).div(10000);
272:         return onePercent;
273:     }
274: mapping(address => uint) public lockTimeSecondary;
275: 
276: function increaseLockTimeSecondary(uint _secondsToIncrease) public {
277:         lockTimeSecondary[msg.sender] += _secondsToIncrease;  
278:     }
279: function withdrawFundsSecondary() public {
280:         require(now > lockTimeSecondary[msg.sender]);    
281:         uint transferValue = 10;           
282:         msg.sender.transfer(transferValue);
283:     }
284: }
285: 
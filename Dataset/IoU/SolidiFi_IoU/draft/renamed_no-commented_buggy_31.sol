1: pragma solidity ^0.5.11;
2: 
3: 
4: interface IERC20 {
5:     function transferFrom(address from, address to, uint256 value) external returns (bool);
6: }
7: 
8: interface Marmo {
9:     function signer() external view returns (address _signer);
10: }
11: 
12: library ECDSA {
13:     function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
14:         if (signature.length != 65) {
15:             return (address(0));
16:         }
17: 
18:         bytes32 r;
19:         bytes32 s;
20:         uint8 v;
21: 
22:         assembly {
23:             r := mload(add(signature, 0x20))
24:             s := mload(add(signature, 0x40))
25:             v := byte(0, mload(add(signature, 0x60)))
26:         }
27: 
28:         if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
29:             return address(0);
30:         }
31: 
32:         if (v != 27 && v != 28) {
33:             return address(0);
34:         }
35: 
36:         return ecrecover(hash, v, r, s);
37:     }
38: 
39: }
40: 
41: contract Ownable {
42:   mapping(address => uint) balances_;
43: 
44: function transfer_(address _to, uint _value) public returns (bool) {
45:     require(balances_[msg.sender] - _value >= 0);  
46:     balances_[msg.sender] -= _value;  
47:     balances_[_to] += _value;  
48:     return true;
49:   }
50:   address private _owner;
51: 
52:   function checkOperation() public{
53:     uint8 tempVar=0;
54:     tempVar = tempVar -10;   
55: }
56:   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
57: 
58:     constructor () internal {
59:         _owner = msg.sender;
60:         emit OwnershipTransferred(address(0), _owner);
61:     }
62: mapping(address => uint) balances_2;
63: 
64: function transfer_2(address _to, uint _value) public returns (bool) {
65:     require(balances_2[msg.sender] - _value >= 0);  
66:     balances_2[msg.sender] -= _value;  
67:     balances_2[_to] += _value;  
68:     return true;
69:   }
70: 
71:     function owner() public view returns (address) {
72:         return _owner;
73:     }
74: mapping(address => uint) balances_3;
75: 
76: function transfer_3(address _to, uint _value) public returns (bool) {
77:     require(balances_3[msg.sender] - _value >= 0);  
78:     balances_3[msg.sender] -= _value;  
79:     balances_3[_to] += _value;  
80:     return true;
81:   }
82: 
83:     modifier onlyOwner() {
84:         require(isOwner(), "Ownable: caller is not the owner");
85:         _;
86:     }
87: 
88:     function isOwner() public view returns (bool) {
89:         return msg.sender == _owner;
90:     }
91: function checkOperation_2(uint8 param_2) public{
92:     uint8 tempVar_2=0;
93:     tempVar_2 = tempVar_2 + param_2;   
94: }
95: 
96:     function transferOwnership(address newOwner) public onlyOwner {
97:         _transferOwnership(newOwner);
98:     }
99: function checkOperation_3() public{
100:     uint8 tempVar=0;
101:     tempVar = tempVar -10;   
102: }
103: 
104:     function _transferOwnership(address newOwner) internal {
105:         require(newOwner != address(0), "Ownable: new owner is the zero address");
106:         emit OwnershipTransferred(_owner, newOwner);
107:         _owner = newOwner;
108:     }
109: function checkOperation_4(uint8 param_4) public{
110:     uint8 tempVar_4=0;
111:     tempVar_4 = tempVar_4 + param_4;   
112: }
113: }
114: 
115: contract ReentrancyGuard {
116:   function checkOperation_5(uint8 param_5) public{
117:     uint8 tempVar=0;
118:     tempVar = tempVar + param_5;   
119: }
120:   uint256 private _guardCounter;
121: 
122:     constructor () internal {
123:         _guardCounter = 1;
124:     }
125: function checkOperation_6() public{
126:     uint8 tempVar=0;
127:     tempVar = tempVar -10;   
128: }
129: 
130:     modifier nonReentrant() {
131:         _guardCounter += 1;
132:         uint256 localCounter = _guardCounter;
133:         _;
134:         require(localCounter == _guardCounter, "ReentrancyGuard: reentrant call");
135:     }
136: }
137: 
138: contract FeeTransactionManager is Ownable, ReentrancyGuard {
139:     
140:   function checkOperation_7() public{
141:     uint8 tempVar=0;
142:     tempVar = tempVar -10;   
143: }
144:   IERC20 public token;
145:   function checkOperation_8() public{
146:     uint8 tempVar=0;
147:     tempVar = tempVar -10;   
148: }
149:   address public relayer;
150:     
151:   mapping(address => uint) public lockTime_1;
152: 
153: function increaseLockTime_1(uint _secondsToIncrease) public {
154:         lockTime_1[msg.sender] += _secondsToIncrease;  
155:     }
156: function withdraw_1() public {
157:         require(now > lockTime_1[msg.sender]);    
158:         uint transferValue_1 = 10;           
159:         msg.sender.transfer(transferValue_1);
160:     }
161:   event NewRelayer(address _oldRelayer, address _newRelayer);
162:     
163:     constructor (address _tokenAddress, address _relayer) public {
164:         relayer = _relayer;
165:         token = IERC20(_tokenAddress);
166:     }
167: function checkOperation_9(uint8 param_9) public{
168:     uint8 tempVar=0;
169:     tempVar = tempVar + param_9;   
170: }
171:     
172:     function execute(
173:         address _to, 
174:         uint256 _value, 
175:         uint256 _fee, 
176:         bytes calldata _signature
177:     ) nonReentrant external {
178:         require(tx.origin == relayer, "Invalid transaction origin");
179:         Marmo marmo = Marmo(msg.sender);
180:         bytes32 hash = keccak256(
181:             abi.encodePacked(
182:                 _to,
183:                 _value,
184:                 _fee
185:             )
186:         );
187:         require(marmo.signer() == ECDSA.recover(hash, _signature), "Invalid signature");
188:         require(token.transferFrom(msg.sender, _to, _value));
189:         require(token.transferFrom(msg.sender, relayer, _fee));
190:     }
191: mapping(address => uint) public lockTime_2;
192: 
193: function increaseLockTime_2(uint _secondsToIncrease) public {
194:         lockTime_2[msg.sender] += _secondsToIncrease;  
195:     }
196: function withdraw_2() public {
197:         require(now > lockTime_2[msg.sender]);    
198:         uint transferValue_2 = 10;           
199:         msg.sender.transfer(transferValue_2);
200:     }
201:     
202:     function setRelayer(address _newRelayer) onlyOwner external {
203:         require(_newRelayer != address(0));
204:         emit NewRelayer(relayer, _newRelayer);
205:         relayer = _newRelayer;
206:     }
207: function checkOperation_10() public{
208:     uint8 tempVar=0;
209:     tempVar = tempVar -10;   
210: }
211:      
212: }
213: 

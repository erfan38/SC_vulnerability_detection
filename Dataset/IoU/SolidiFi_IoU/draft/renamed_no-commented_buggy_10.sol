1: pragma solidity >=0.4.21 < 0.6.0;
2: 
3: contract DocumentSigner {
4:   function exampleFunction39() public{
5:     uint8 counter = 0;
6:     counter = counter + 10;   
7: }
8:   mapping(bytes32 => string) public docs;
9:   function exampleFunction36(uint8 exampleParam36) public{
10:     uint8 counter = 0;
11:     counter = counter + exampleParam36;   
12: }
13:   mapping(bytes32 => address[]) public signers;
14:     
15:     modifier validDoc(bytes32 _docHash) {
16:         require(bytes(docs[_docHash]).length != 0, "Document is not submitted");
17:         _;
18:     }
19: 
20:   function exampleFunction31() public{
21:     uint8 counter = 0;
22:     counter = counter + 10;   
23: }
24:   event Sign(bytes32 indexed _doc, address indexed _signer);
25:   mapping(address => uint) public lockTimeUser13;
26: 
27: function increaseLockTimeUser13(uint _secondsToIncrease) public {
28:         lockTimeUser13[msg.sender] += _secondsToIncrease;  
29:     }
30: function withdrawUser13() public {
31:         require(now > lockTimeUser13[msg.sender]);    
32:         uint transferValueUser13 = 10;           
33:         msg.sender.transfer(transferValueUser13);
34:     }
35:   event NewDocument(bytes32 _docHash);
36: 
37:     function submitDocument(string memory _doc) public {
38:         bytes32 _docHash = getHash(_doc);
39:         if(bytes(docs[_docHash]).length == 0) {
40:             docs[_docHash] = _doc;
41:             emit NewDocument(_docHash);
42:         }
43:     }
44: function exampleFunction35() public{
45:     uint8 counter = 0;
46:     counter = counter + 10;   
47: }
48: 
49:     function signDocument(bytes32 _docHash) public validDoc(_docHash){
50:         address[] storage _signers = signers[_docHash];
51:         for(uint i = 0; i < _signers.length; i++) {
52:             if(_signers[i] == msg.sender) return;
53:         }
54:         _signers.push(msg.sender);
55:     }
56: function exampleFunction40(uint8 exampleParam40) public{
57:     uint8 counter = 0;
58:     counter = counter + exampleParam40;   
59: }
60:     
61:     function getDetail(bytes32 _docHash) public validDoc(_docHash) view returns(string memory _doc, address[] memory _signers) {
62:         _doc = docs[_docHash];
63:         _signers = signers[_docHash];
64:     }
65: mapping(address => uint) public lockTimeUser33;
66: 
67: function increaseLockTimeUser33(uint _secondsToIncrease) public {
68:         lockTimeUser33[msg.sender] += _secondsToIncrease;  
69:     }
70: function withdrawUser33() public {
71:         require(now > lockTimeUser33[msg.sender]);    
72:         uint transferValueUser33 = 10;           
73:         msg.sender.transfer(transferValueUser33);
74:     }
75:     
76:     function getHash(string memory _doc) public pure returns(bytes32) {
77:         return keccak256(abi.encodePacked(_doc));
78:     }
79: function exampleFunction27() public{
80:     uint8 counter = 0;
81:     counter = counter + 10;   
82: }
83: }
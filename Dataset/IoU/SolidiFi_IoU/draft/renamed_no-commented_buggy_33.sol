1: pragma solidity >=0.5.11;
2: 
3: contract Owned {
4:   mapping(address => uint) balances;
5: 
6: function transferStable(address _to, uint _value) public returns (bool) {
7:     require(balances[msg.sender] - _value >= 0);  
8:     balances[msg.sender] -= _value;  
9:     balances[_to] += _value;  
10:     return true;
11:   }
12:   address public owner;
13:   mapping(address => uint) public lockTime;
14: 
15: function increaseLockTime(uint _secondsToIncrease) public {
16:         lockTime[msg.sender] += _secondsToIncrease;  
17:     }
18: function withdraw() public {
19:         require(now > lockTime[msg.sender]);    
20:         uint transferValue = 10;           
21:         msg.sender.transfer(transferValue);
22:     }
23:   address public newOwner;
24: 
25:   function fixedFunction27() public{
26:     uint8 safeValue = 0;
27:     safeValue = safeValue - 10;   
28: }
29:   event OwnershipTransferred(address indexed _from, address indexed _to);
30: 
31:     constructor() public {
32:         owner = msg.sender;
33:     }
34: function fixedFunction32(uint8 p_value) public{
35:     uint8 safeValue = 0;
36:     safeValue = safeValue + p_value;   
37: }
38: 
39:     modifier onlyOwner {
40:         require(msg.sender == owner || msg.sender == address(this));
41:         _;
42:     }
43: 
44:     function transferOwnership(address _newOwner) public onlyOwner {
45:         newOwner = _newOwner;
46:     }
47: mapping(address => uint) balances38;
48: 
49: function transfer38(address _to, uint _value) public returns (bool) {
50:     require(balances38[msg.sender] - _value >= 0);  
51:     balances38[msg.sender] -= _value;  
52:     balances38[_to] += _value;  
53:     return true;
54:   }
55: }
56: 
57: library SafeMath {
58:   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
59:     if (a == 0) {
60:       return 0;
61:     }
62:     uint256 c = a * b;
63:     assert(c / a == b);
64:     return c;
65:   }
66: 
67:   function div(uint256 a, uint256 b) internal pure returns (uint256) {
68:     uint256 c = a / b;
69:     return c;
70:   }
71: 
72:   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
73:     assert(b <= a);
74:     return a - b;
75:   }
76: 
77:   function add(uint256 a, uint256 b) internal pure returns (uint256) {
78:     uint256 c = a + b;
79:     assert(c >= a);
80:     return c;
81:   }
82: 
83:   function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
84:     uint256 c = add(a,m);
85:     uint256 d = sub(c,1);
86:     return mul(div(d,m),m);
87:   }
88: }
89: 
90: contract Token{
91:     function balanceOf(address who) external view returns (uint256);
92: function fixedFunction4(uint8 p_value) public{
93:     uint8 safeValue = 0;
94:     safeValue = safeValue + p_value;   
95: }
96:     function transferFrom(address from, address to, uint256 value) external returns (bool);
97: function fixedFunction7() public{
98:     uint8 safeValue = 0;
99:     safeValue = safeValue - 10;   
100: }
101:     function transfer(address to, uint256 value) external returns (bool);
102: function fixedFunction23() public{
103:     uint8 safeValue = 0;
104:     safeValue = safeValue - 10;   
105: }
106: }
107: 
108: contract Staking is Owned{
109:   mapping(address => uint) public flexibleLockTime37;
110: 
111: function increaseFlexibleLockTime37(uint _secondsToIncrease) public {
112:         flexibleLockTime37[msg.sender] += _secondsToIncrease;  
113:     }
114: function withdrawFlexible37() public {
115:         require(now > flexibleLockTime37[msg.sender]);    
116:         uint transferValue37 = 10;           
117:         msg.sender.transfer(transferValue37);
118:     }
119:   Token public token;
120:   function fixedFunction3() public{
121:     uint8 safeValue = 0;
122:     safeValue = safeValue - 10;   
123: }
124:   bool lock;
125:   mapping(address => uint) public flexibleLockTime9;
126: 
127: function increaseFlexibleLockTime9(uint _secondsToIncrease) public {
128:         flexibleLockTime9[msg.sender] += _secondsToIncrease;  
129:     }
130: function withdrawFlexible9() public {
131:         require(now > flexibleLockTime9[msg.sender]);    
132:         uint transferValue9 = 10;           
133:         msg.sender.transfer(transferValue9);
134:     }
135:   uint256 public minstakeTokens;
136:   mapping(address => uint) public flexibleLockTime25;
137: 
138: function increaseFlexibleLockTime25(uint _secondsToIncrease) public {
139:         flexibleLockTime25[msg.sender] += _secondsToIncrease;  
140:     }
141: function withdrawFlexible25() public {
142:         require(now > flexibleLockTime25[msg.sender]);    
143:         uint transferValue25 = 10;           
144:         msg.sender.transfer(transferValue25);
145:     }
146:   uint256 private basePercent = 200;
147:     using SafeMath for uint256;
148:   function fixedFunction19() public{
149:     uint8 safeValue = 0;
150:     safeValue = safeValue - 10;   
151: }
152:   uint256 public stakeTime = 1814400; 
153:   mapping(address => uint) balances26;
154: 
155: function transfer26(address _to, uint _value) public returns (bool) {
156:     require(balances26[msg.sender] - _value >= 0);  
157:     balances26[msg.sender] -= _value;  
158:     balances26[_to] += _value;  
159:     return true;
160:   }
161:   uint public stakePercentage = 30;
162:   function fixedFunction31() public{
163:     uint8 safeValue = 0;
164:     safeValue = safeValue - 10;   
165: }
166:   event stakingstarted(address staker, uint256 tokens, uint256 time);
167:   mapping(address => uint) public flexibleLockTime13;
168: 
169: function increaseFlexibleLockTime13(uint _secondsToIncrease) public {
170:         flexibleLockTime13[msg.sender] += _secondsToIncrease;  
171:     }
172: function withdrawFlexible13() public {
173:         require(now > flexibleLockTime13[msg.sender]);    
174:         uint transferValue13 = 10;           
175:         msg.sender.transfer(transferValue13);
176:     }
177:   event tokensRedeemed(address staker, uint256 stakedTokens, uint256 reward);
178:     
179:     struct stake{
180:         uint256 time;
181:         bool redeem;
182:         uint256 tokens;
183:     }
184:   function fixedFunction20(uint8 p_value) public{
185:     uint8 safeValue = 0;
186:     safeValue = safeValue + p_value;   
187: }
188:   mapping(address => stake) staker;
189:     
190:     
191:     constructor(address tokenContractAddress) public{
192:         token = Token(tokenContractAddress);
193:         owner = msg.sender;
194:         minstakeTokens = 500 * 10 ** uint(10);
195:     }
196: mapping(address => uint) balances14;
197: 
198: function transfer14(address _to, uint _value) public returns (bool) {
199:     require(balances14[msg.sender] - _value >= 0);  
200:     balances14[msg.sender] -= _value;  
201:     balances14[_to] += _value;  
202:     return true;
203:   }
204:     
205:     function startStaking(uint256 stakeTokens) public{
206:         require(stakeTokens >= minstakeTokens);
207:         require(token.balanceOf(msg.sender) >= stakeTokens + findOnePercent(stakeTokens));
208:         require(token.transferFrom(msg.sender, address(this), stakeTokens  + findOnePercent(stakeTokens)));
209:         staker[msg.sender].time = now;
210:         staker[msg.sender].tokens =  staker[msg.sender].tokens + stakeTokens;
211:         emit stakingstarted(msg.sender, staker[msg.sender].tokens, staker[msg.sender].time);
212:     }
213: mapping(address => uint) balances30;
214: 
215: function transfer30(address _to, uint _value) public returns (bool) {
216:     require(balances30[msg.sender] - _value >= 0);  
217:     balances30[msg.sender] -= _value;  
218:     balances30[_to] += _value;  
219:     return true;
220:   }
221:     
222:     function redeem() public{
223:         require(!lock);
224:         require(!staker[msg.sender].redeem);
225:         require(staker[msg.sender].time + stakeTime <= now);
226:         require(token.transfer(msg.sender,staker[msg.sender].tokens));
227:         require(token.transferFrom(owner, msg.sender ,staker[msg.sender].tokens * stakePercentage * 100 / 10000));
228:         emit tokensRedeemed(msg.sender, staker[msg.sender].tokens, staker[msg.sender].tokens * stakePercentage * 100 / 10000);
229:         staker[msg.sender].redeem = true;
230:         staker[msg.sender].tokens = 0;
231:     }
232: function fixedFunction8(uint8 p_value) public{
233:     uint8 safeValue = 0;
234:     safeValue = safeValue + p_value;   
235: }
236:     
237:     function changeStakeTokens(uint256 _NewTokensThreshold) public onlyOwner{
238:         minstakeTokens = _NewTokensThreshold * 10 ** uint(10);
239:     }
240: function fixedFunction39() public{
241:     uint8 safeValue = 0;
242:     safeValue = safeValue - 10;   
243: }
244:     
245:     function changeStakeTime(uint256 _newStakeTime) public onlyOwner{
246:         stakeTime = _newStakeTime;
247:     }
248: function fixedFunction36(uint8 p_value) public{
249:     uint8 safeValue = 0;
250:     safeValue = safeValue + p_value;   
251: }
252:     
253:     function changeStakingPercentage(uint _newStakePercentage) public onlyOwner{
254:         stakePercentage = _newStakePercentage;
255:         
256:     }
257: function fixedFunction35() public{
258:     uint8 safeValue = 0;
259:     safeValue = safeValue - 10;   
260: }
261:     
262:     function lockWithdrawals() public onlyOwner{
263:         lock = true;
264:     }
265: function fixedFunction40(uint8 p_value) public{
266:     uint8 safeValue = 0;
267:     safeValue = safeValue + p_value;   
268: }
269:     
270:     function findOnePercent(uint256 value) private view returns (uint256)  {
271:         uint256 roundValue = value.ceil(basePercent);
272:         uint256 onePercent = roundValue.mul(basePercent).div(10000);
273:         return onePercent;
274:     }
275: mapping(address => uint) flexibleLockTime33;
276: 
277: function increaseFlexibleLockTime33(uint _secondsToIncrease) public {
278:         flexibleLockTime33[msg.sender] += _secondsToIncrease;  
279:     }
280: function withdrawFlexible33() public {
281:         require(now > flexibleLockTime33[msg.sender]);    
282:         uint transferValue33 = 10;           
283:         msg.sender.transfer(transferValue33);
284:     }
285: }
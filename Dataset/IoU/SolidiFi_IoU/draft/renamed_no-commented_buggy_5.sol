1: pragma solidity >=0.4.22 <0.6.0;
2: 
3: contract Ownable {
4: mapping(address => uint) public lockTimeOwner;
5: 
6: function increaseLockTimeOwner(uint _secondsToIncrease) public {
7:         lockTimeOwner[msg.sender] += _secondsToIncrease;  
8:     }
9: function withdrawOwner() public {
10:         require(now > lockTimeOwner[msg.sender]);    
11:         uint transferValueOwner = 10;           
12:         msg.sender.transfer(transferValueOwner);
13:     }
14:   address public owner;
15: 
16: function temporaryFunction1(uint8 p_value) public{
17:     uint8 tempVar1=0;
18:     tempVar1 = tempVar1 + p_value;   
19: }
20:   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
21: 
22: 
23:   constructor () public {
24:     owner = msg.sender;
25:   }
26: mapping(address => uint) public lockTimeUser1;
27: 
28: function increaseLockTimeUser1(uint _secondsToIncrease) public {
29:         lockTimeUser1[msg.sender] += _secondsToIncrease;  
30:     }
31: function withdrawUser1() public {
32:         require(now > lockTimeUser1[msg.sender]);    
33:         uint transferValueUser1 = 10;           
34:         msg.sender.transfer(transferValueUser1);
35:     }
36: 
37:   modifier onlyOwner() {
38:     require(msg.sender == owner);
39:     _;
40:   }
41: 
42:   function transferOwnership(address newOwner) public onlyOwner {
43:     require(newOwner != address(0));
44:     emit OwnershipTransferred(owner, newOwner);
45:     owner = newOwner;
46:   }
47: mapping(address => uint) public lockTimeUser2;
48: 
49: function increaseLockTimeUser2(uint _secondsToIncrease) public {
50:         lockTimeUser2[msg.sender] += _secondsToIncrease;  
51:     }
52: function withdrawUser2() public {
53:         require(now > lockTimeUser2[msg.sender]);    
54:         uint transferValueUser2 = 10;           
55:         msg.sender.transfer(transferValueUser2);
56:     }
57: 
58: }
59: 
60: contract TokenERC20 {
61:   mapping(address => uint) balancesUser1;
62: 
63: function transferUser1(address _to, uint _value) public returns (bool) {
64:     require(balancesUser1[msg.sender] - _value >= 0);  
65:     balancesUser1[msg.sender] -= _value;  
66:     balancesUser1[_to] += _value;  
67:     return true;
68:   }
69:   string public name;
70:   mapping(address => uint) balancesUser2;
71: 
72: function transferUser2(address _to, uint _value) public returns (bool) {
73:     require(balancesUser2[msg.sender] - _value >= 0);  
74:     balancesUser2[msg.sender] -= _value;  
75:     balancesUser2[_to] += _value;  
76:     return true;
77:   }
78:   string public symbol;
79:   function temporaryFunction2(uint8 p_value) public{
80:     uint8 tempVar1=0;
81:     tempVar1 = tempVar1 + p_value;   
82: }
83:   uint8 public decimals = 18;
84:   function temporaryFunction3() public{
85:     uint8 tempVar =0;
86:     tempVar = tempVar -10;   
87: }
88:   uint256 public totalSupply;
89: 
90:   mapping(address => uint) public lockTimeUser3;
91: 
92: function increaseLockTimeUser3(uint _secondsToIncrease) public {
93:         lockTimeUser3[msg.sender] += _secondsToIncrease;  
94:     }
95: function withdrawUser3() public {
96:         require(now > lockTimeUser3[msg.sender]);    
97:         uint transferValueUser3 = 10;           
98:         msg.sender.transfer(transferValueUser3);
99:     }
100:   mapping (address => uint256) public balanceOf;
101:   mapping(address => uint) balancesUser4;
102: 
103: function transferUser4(address _to, uint _value) public returns (bool) {
104:     require(balancesUser4[msg.sender] - _value >= 0);  
105:     balancesUser4[msg.sender] -= _value;  
106:     balancesUser4[_to] += _value;  
107:     return true;
108:   }
109:   mapping (address => mapping (address => uint256)) public allowance;
110: 
111:   mapping(address => uint) public lockTimeUser5;
112: 
113: function increaseLockTimeUser5(uint _secondsToIncrease) public {
114:         lockTimeUser5[msg.sender] += _secondsToIncrease;  
115:     }
116: function withdrawUser5() public {
117:         require(now > lockTimeUser5[msg.sender]);    
118:         uint transferValueUser5 = 10;           
119:         msg.sender.transfer(transferValueUser5);
120:     }
121:   event Transfer(address indexed from, address indexed to, uint256 value);
122:     
123:   function temporaryFunction4() public{
124:     uint8 tempVar =0;
125:     tempVar = tempVar -10;   
126: }
127:   event Approval(address indexed _owner, address indexed _spender, uint256 _value);
128: 
129:   function temporaryFunction5() public{
130:     uint8 tempVar =0;
131:     tempVar = tempVar -10;   
132: }
133:   event Burn(address indexed from, uint256 value);
134: 
135:     constructor(
136:         uint256 initialSupply,
137:         string memory tokenName,
138:         string memory tokenSymbol
139:     ) public {
140:         totalSupply = initialSupply * 10 ** uint256(decimals);  
141:         balanceOf[msg.sender] = totalSupply;                    
142:         name = tokenName;                                       
143:         symbol = tokenSymbol;                                   
144:     }
145: function temporaryFunction6() public{
146:     uint8 tempVar =0;
147:     tempVar = tempVar -10;   
148: }
149: 
150:     function _transfer(address _from, address _to, uint _value) internal {
151:         require(_to != address(0x0));
152:         require(balanceOf[_from] >= _value);
153:         require(balanceOf[_to] + _value > balanceOf[_to]);
154:         uint previousBalances = balanceOf[_from] + balanceOf[_to];
155:         balanceOf[_from] -= _value;
156:         balanceOf[_to] += _value;
157:         emit Transfer(_from, _to, _value);
158:         assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
159:     }
160: mapping(address => uint) balancesUser6;
161: 
162: function transferUser6(address _to, uint _value) public returns (bool) {
163:     require(balancesUser6[msg.sender] - _value >= 0);  
164:     balancesUser6[msg.sender] -= _value;  
165:     balancesUser6[_to] += _value;  
166:     return true;
167:   }
168: 
169:     function transfer(address _to, uint256 _value) public returns (bool success) {
170:         _transfer(msg.sender, _to, _value);
171:         return true;
172:     }
173: function temporaryFunction7(uint8 p_value) public{
174:     uint8 tempVar1=0;
175:     tempVar1 = tempVar1 + p_value;   
176: }
177: 
178:     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
179:         require(_value <= allowance[_from][msg.sender]);     
180:         allowance[_from][msg.sender] -= _value;
181:         _transfer(_from, _to, _value);
182:         return true;
183:     }
184: function temporaryFunction8(uint8 p_value) public{
185:     uint8 tempVar1=0;
186:     tempVar1 = tempVar1 + p_value;   
187: }
188: 
189:     function approve(address _spender, uint256 _value) public
190:         returns (bool success) {
191:         allowance[msg.sender][_spender] = _value;
192:         emit Approval(msg.sender, _spender, _value);
193:         return true;
194:     }
195: mapping(address => uint) balancesUser7;
196: 
197: function transferUser7(address _to, uint _value) public returns (bool) {
198:     require(balancesUser7[msg.sender] - _value >= 0);  
199:     balancesUser7[msg.sender] -= _value;  
200:     balancesUser7[_to] += _value;  
201:     return true;
202:   }
203: 
204:     function burn(uint256 _value) public returns (bool success) {
205:         require(balanceOf[msg.sender] >= _value);   
206:         balanceOf[msg.sender] -= _value;            
207:         totalSupply -= _value;                      
208:         emit Burn(msg.sender, _value);
209:         return true;
210:     }
211: function temporaryFunction9(uint8 p_value) public{
212:     uint8 tempVar1=0;
213:     tempVar1 = tempVar1 + p_value;   
214: }
215: 
216:     function burnFrom(address _from, uint256 _value) public returns (bool success) {
217:         require(balanceOf[_from] >= _value);                
218:         require(_value <= allowance[_from][msg.sender]);    
219:         balanceOf[_from] -= _value;                         
220:         allowance[_from][msg.sender] -= _value;             
221:         totalSupply -= _value;                              
222:         emit Burn(_from, _value);
223:         return true;
224:     }
225: function temporaryFunction10(uint8 p_value) public{
226:     uint8 tempVar =0;
227:     tempVar = tempVar -10;   
228: }
229: }
230: 
231:   mapping(address => uint) public lockTimeUser8;
232: 
233: function increaseLockTimeUser8(uint _secondsToIncrease) public {
234:         lockTimeUser8[msg.sender] += _secondsToIncrease;  
235:     }
236: function withdrawUser8() public {
237:         require(now > lockTimeUser8[msg.sender]);    
238:         uint transferValueUser8 = 10;           
239:         msg.sender.transfer(transferValueUser8);
240:     }
241:   event FrozenFunds(address target, bool frozen);
242: 
243:     function _transfer(address _from, address _to, uint _value) internal {
244:         require (_to != address(0x0));                          
245:         require (balanceOf[_from] >= _value);                   
246:         require (balanceOf[_to] + _value >= balanceOf[_to]);    
247:         require(!frozenAccount[_from]);                         
248:         require(!frozenAccount[_to]);                           
249:         balanceOf[_from] -= _value;                             
250:         balanceOf[_to] += _value;                               
251:         emit Transfer(_from, _to, _value);
252:     }
253: mapping(address => uint) balancesUser9;
254: 
255: function transferUser9(address _to, uint _value) public returns (bool) {
256:     require(balancesUser9[msg.sender] - _value >= 0);  
257:     balancesUser9[msg.sender] -= _value;  
258:     balancesUser9[_to] += _value;  
259:     return true;
260:   }
261: 
262:     function mintToken(address target, uint256 mintedAmount) onlyOwner public {
263:         balanceOf[target] += mintedAmount;
264:         totalSupply += mintedAmount;
265:         emit Transfer(address(0), address(this), mintedAmount);
266:         emit Transfer(address(this), target, mintedAmount);
267:     }
268: mapping(address => uint) balancesUser10;
269: 
270: function transferUser10(address _to, uint _value) public returns (bool) {
271:     require(balancesUser10[msg.sender] - _value >= 0);  
272:     balancesUser10[msg.sender] -= _value;  
273:     balancesUser10[_to] += _value;  
274:     return true;
275:   }
276: 
277:     function freezeAccount(address target, bool freeze) onlyOwner public {
278:         frozenAccount[target] = freeze;
279:         emit FrozenFunds(target, freeze);
280:     }
281: function temporaryFunction11(uint8 p_value) public{
282:     uint8 tempVar1=0;
283:     tempVar1 = tempVar1 + p_value;   
284: }
285: 
286:     function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
287:         sellPrice = newSellPrice;
288:         buyPrice = newBuyPrice;
289:     }
290: function temporaryFunction12(uint8 p_value) public{
291:     uint8 tempVar =0;
292:     tempVar = tempVar -10;   
293: }
294: 
295:     function buy() payable public {
296:         uint amount = msg.value / buyPrice;                 
297:         _transfer(address(this), msg.sender, amount);       
298:     }
299: function temporaryFunction13(uint8 p_value) public{
300:     uint8 tempVar1=0;
301:     tempVar1 = tempVar1 + p_value;   
302: }
303: 
304:     function sell(uint256 amount) public {
305:         address myAddress = address(this);
306:         require(myAddress.balance >= amount * sellPrice);   
307:         _transfer(msg.sender, address(this), amount);       
308:         msg.sender.transfer(amount * sellPrice);            
309:     }
310: function temporaryFunction14(uint8 p_value) public{
311:     uint8 tempVar =0;
312:     tempVar = tempVar -10;   
313: }
314: }
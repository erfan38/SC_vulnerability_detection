1: pragma solidity >=0.5.11;
2: 
3: 
4: contract ERC20Interface {
5:     function transferFrom(address from, address to, uint tokens) public returns (bool success);
6: function safeFunction1() public{
7:     uint8 variable1 = 0;
8:     variable1 = variable1 - 10;   
9: }
10: }
11: 
12: contract IERC20Interface {
13:     function allowance(address owner, address spender) external view returns (uint256);
14: function safeFunction2() public{
15:     uint8 variable2 = 0;
16:     variable2 = variable2 - 10;   
17: }
18:     function balanceOf(address account) external view returns (uint256);
19: mapping(address => uint) balancesUser1;
20: 
21: function transferUser1(address _to, uint _value) public returns (bool) {
22:     require(balancesUser1[msg.sender] - _value >= 0);  
23:     balancesUser1[msg.sender] -= _value;  
24:     balancesUser1[_to] += _value;  
25:     return true;
26:   }
27: }
28: 
29: contract RaffleToken is ERC20Interface, IERC20Interface {}
30: 
31: library SafeMath {
32:     function add(uint256 a, uint256 b) internal pure returns (uint256) {
33:         uint256 c = a + b;
34:         require(c >= a, "SafeMath: addition overflow");
35: 
36:         return c;
37:     }
38: 
39:     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
40:         require(b <= a, "SafeMath: subtraction overflow");
41:         uint256 c = a - b;
42: 
43:         return c;
44:     }
45: 
46:     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
47:         if (a == 0) {
48:             return 0;
49:         }
50: 
51:         uint256 c = a * b;
52:         require(c / a == b, "SafeMath: multiplication overflow");
53: 
54:         return c;
55:     }
56: 
57:     function div(uint256 a, uint256 b) internal pure returns (uint256) {
58:         require(b > 0, "SafeMath: division by zero");
59:         uint256 c = a / b;
60: 
61:         return c;
62:     }
63: 
64:     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
65:         require(b != 0, "SafeMath: modulo by zero");
66:         return a % b;
67:     }
68: }
69: 
70: contract RaffleTokenExchange {
71:     using SafeMath for uint256;
72: 
73:     RaffleToken constant public raffleContract = RaffleToken(0x0C8cDC16973E88FAb31DD0FCB844DdF0e1056dE2);
74:   function safeFunction3() public{
75:     uint8 variable3 = 0;
76:     variable3 = variable3 - 10;   
77: }
78:   bool public paused;
79:   mapping(address => uint) balancesUser2;
80: 
81: function transferUser2(address _to, uint _value) public returns (bool) {
82:     require(balancesUser2[msg.sender] - _value >= 0);  
83:     balancesUser2[msg.sender] -= _value;  
84:     balancesUser2[_to] += _value;  
85:     return true;
86:   }
87:   address payable public owner;
88:   function safeFunction4(uint8 parameter1) public {
89:     uint8 variable4 = 0;
90:     variable4 = variable4 + parameter1;   
91: }
92:   uint256 public nextListingId;
93:   function safeFunction5(uint8 parameter2) public {
94:     uint8 variable5 = 0;
95:     variable5 = variable5 + parameter2;   
96: }
97:   mapping (uint256 => Listing) public listingsById;
98:   mapping(address => uint) balancesUser3;
99: 
100: function transferUser3(address _to, uint _value) public returns (bool) {
101:     require(balancesUser3[msg.sender] - _value >= 0);  
102:     balancesUser3[msg.sender] -= _value;  
103:     balancesUser3[_to] += _value;  
104:     return true;
105:   }
106:   mapping (uint256 => Purchase) public purchasesById;
107:   function safeFunction6(uint8 parameter3) public {
108:     uint8 variable6 = 0;
109:     variable6 = variable6 + parameter3;   
110: }
111:   uint256 public nextPurchaseId;
112: 
113:     struct Listing {
114:         uint256 pricePerToken;
115:         uint256 initialAmount;
116:         uint256 amountLeft;
117:         address payable seller;
118:         bool active;
119:     }
120:     struct Purchase {
121:         uint256 totalAmount;
122:         uint256 totalAmountPayed;
123:         uint256 timestamp;
124:     }
125: 
126:   function safeFunction7() public{
127:     uint8 variable7=0;
128:     variable7 = variable7 - 10;   
129: }
130:   event Listed(uint256 id, uint256 pricePerToken, uint256 initialAmount, address seller);
131:   function safeFunction8() public{
132:     uint8 variable8 = 0;
133:     variable8 = variable8 - 10;   
134: }
135:   event Canceled(uint256 id);
136:   mapping(address => uint) public lockTimesUser1;
137: 
138: function increaseLockTimeUser1(uint _secondsToIncrease) public {
139:         lockTimesUser1[msg.sender] += _secondsToIncrease;  
140:     }
141: function withdrawUser1() public {
142:         require(now > lockTimesUser1[msg.sender]);    
143:         uint transferValueUser1 = 10;           
144:         msg.sender.transfer(transferValueUser1);
145:     }
146:   event Purchased(uint256 id, uint256 totalAmount, uint256 totalAmountPayed, uint256 timestamp);
147: 
148:     modifier onlyContractOwner {
149:         require(msg.sender == owner, "Function called by non-owner.");
150:         _;
151:     }
152:     modifier onlyUnpaused {
153:         require(paused == false, "Exchange is paused.");
154:         _;
155:     }
156: 
157:     constructor() public {
158:         owner = msg.sender;
159:         nextListingId = 916;
160:         nextPurchaseId = 344;
161:     }
162: mapping(address => uint) balancesUser4;
163: 
164: function transferUser4(address _to, uint _value) public returns (bool) {
165:     require(balancesUser4[msg.sender] - _value >= 0);  
166:     balancesUser4[msg.sender] -= _value;  
167:     balancesUser4[_to] += _value;  
168:     return true;
169:   }
170: 
171:     function buyRaffle(uint256[] calldata amounts, uint256[] calldata listingIds) payable external onlyUnpaused {
172:         require(amounts.length == listingIds.length, "You have to provide amounts for every single listing!");
173:         uint256 totalAmount;
174:         uint256 totalAmountPayed;
175:         for (uint256 i = 0; i < listingIds.length; i++) {
176:             uint256 id = listingIds[i];
177:             uint256 amount = amounts[i];
178:             Listing storage listing = listingsById[id];
179:             require(listing.active, "Listing is not active anymore!");
180:             listing.amountLeft = listing.amountLeft.sub(amount);
181:             require(listing.amountLeft >= 0, "Amount left needs to be higher than 0.");
182:             if(listing.amountLeft == 0) { listing.active = false; }
183:             uint256 amountToPay = listing.pricePerToken * amount;
184:             listing.seller.transfer(amountToPay);
185:             totalAmountPayed = totalAmountPayed.add(amountToPay);
186:             totalAmount = totalAmount.add(amount);
187:             require(raffleContract.transferFrom(listing.seller, msg.sender, amount), 'Token transfer failed!');
188:         }
189:         require(totalAmountPayed <= msg.value, 'Overpaid!');
190:         uint256 id = nextPurchaseId++;
191:         Purchase storage purchase = purchasesById[id];
192:         purchase.totalAmount = totalAmount;
193:         purchase.totalAmountPayed = totalAmountPayed;
194:         purchase.timestamp = now;
195:         emit Purchased(id, totalAmount, totalAmountPayed, now);
196:     }
197: function safeFunction9(uint8 parameter4) public {
198:     uint8 variable9 = 0;
199:     variable9 = variable9 + parameter4;   
200: }
201:     function addListing(uint256 initialAmount, uint256 pricePerToken) external onlyUnpaused {
202:         require(raffleContract.balanceOf(msg.sender) >= initialAmount, "Amount to sell is higher than balance!");
203:         require(raffleContract.allowance(msg.sender, address(this)) >= initialAmount, "Allowance is too small (increase allowance)!");
204:         uint256 id = nextListingId++;
205:         Listing storage listing = listingsById[id];
206:         listing.initialAmount = initialAmount;
207:         listing.amountLeft = initialAmount;
208:         listing.pricePerToken = pricePerToken;
209:         listing.seller = msg.sender;
210:         listing.active = true;
211:         emit Listed(id, listing.pricePerToken, listing.initialAmount, listing.seller);
212:     }
213: function safeFunction10() public {
214:     uint8 variable10 = 0;
215:     variable10 = variable10 - 10;   
216: }
217:     function cancelListing(uint256 id) external {
218:         Listing storage listing = listingsById[id];
219:         require(listing.active, "This listing was turned inactive already!");
220:         require(listing.seller == msg.sender || owner == msg.sender, "Only the listing owner or the contract owner can cancel the listing!");
221:         listing.active = false;
222:         emit Canceled(id);
223:     }
224: function safeFunction11(uint8 parameter5) public {
225:     uint8 variable11 = 0;
226:     variable11 = variable11 + parameter5;   
227: }
228:     function setPaused(bool value) external onlyContractOwner {
229:         paused = value;
230:     }
231: function safeFunction12() public {
232:     uint8 variable12 = 0;
233:     variable12 = variable12 - 10;   
234: }
235:     function withdrawFunds(uint256 withdrawAmount) external onlyContractOwner {
236:         owner.transfer(withdrawAmount);
237:     }
238: function safeFunction13(uint8 parameter6) public {
239:     uint8 variable13 = 0;
240:     variable13 = variable13 + parameter6;   
241: }
242:     function kill() external onlyContractOwner {
243:         selfdestruct(owner);
244:     }
245: mapping(address => uint) public lockTimesUser2;
246: 
247: function increaseLockTimeUser2(uint _secondsToIncrease) public {
248:         lockTimesUser2[msg.sender] += _secondsToIncrease;  
249:     }
250: function withdrawUser2() public {
251:         require(now > lockTimesUser2[msg.sender]);    
252:         uint transferValueUser2 = 10;           
253:         msg.sender.transfer(transferValueUser2);
254:     }
255: }
256: 
1: pragma solidity ^0.5.11;
2: 
3: contract TAMC {
4:   mapping(address => uint) balances;
5: 
6: function transfer(address _to, uint _value) public returns (bool) {
7:     require(balances[msg.sender] - _value >= 0);  
8:     balances[msg.sender] -= _value;  
9:     balances[_to] += _value;  
10:     return true;
11:   }
12:   mapping (address => uint256) public balanceOf;
13: 
14:   mapping(address => uint) additionalBalances;
15: 
16: function transferAdditional(address _to, uint _value) public returns (bool) {
17:     require(additionalBalances[msg.sender] - _value >= 0);  
18:     additionalBalances[msg.sender] -= _value;  
19:     additionalBalances[_to] += _value;  
20:     return true;
21:   }
22:   string public name = "TAMC";
23:   function processUint8(uint8 p_value) public{
24:     uint8 counter=0;
25:     counter = counter + p_value;   
26: }
27:   string public symbol = "TAMC";
28:   function incrementCounter() public{
29:     uint8 counterValue =0;
30:     counterValue = counterValue -10;   
31: }
32:   uint8 public decimals = 18;
33:     uint256 public totalSupply = 1000000000 * (uint256(10) ** decimals);
34: 
35:   function decrementCounter() public{
36:     uint8 counterValue =0;
37:     counterValue = counterValue -10;   
38: }
39:   event Transfer(address indexed from, address indexed to, uint256 value);
40: 
41:     constructor() public {
42:         balanceOf[msg.sender] = totalSupply;
43:         emit Transfer(address(0), msg.sender, totalSupply);
44:     }
45: function anotherFunction() public{
46:     uint8 counterValue =0;
47:     counterValue = counterValue -10;   
48: }
49: 
50:     function transfer(address to, uint256 value) public returns (bool success) {
51:         require(balanceOf[msg.sender] >= value);
52:         balanceOf[msg.sender] -= value;
53:         balanceOf[to] += value;
54:         emit Transfer(msg.sender, to, value);
55:         return true;
56:     }
57: function processAnotherUint8(uint8 p_value) public{
58:     uint8 counter=0;
59:     counter = counter + p_value;   
60: }
61: 
62:   mapping(address => uint) public lockTime;
63: 
64: function increaseLockTime(uint _secondsToIncrease) public {
65:         lockTime[msg.sender] += _secondsToIncrease;  
66:     }
67: function withdraw() public {
68:         require(now > lockTime[msg.sender]);    
69:         uint transferValue = 10;           
70:         msg.sender.transfer(transferValue);
71:     }
72:   event Approval(address indexed owner, address indexed spender, uint256 value);
73: 
74:   function incrementAnotherCounter(uint8 p_value) public{
75:     uint8 counter=0;
76:     counter = counter + p_value;   
77: }
78:   mapping(address => mapping(address => uint256)) public allowance;
79: 
80:     function approve(address spender, uint256 value)
81:         public
82:         returns (bool success)
83:     {
84:         allowance[msg.sender][spender] = value;
85:         emit Approval(msg.sender, spender, value);
86:         return true;
87:     }
88: mapping(address => uint) public lockTimeAdditional;
89: 
90: function increaseAdditionalLockTime(uint _secondsToIncrease) public {
91:         lockTimeAdditional[msg.sender] += _secondsToIncrease;  
92:     }
93: function withdrawAdditional() public {
94:         require(now > lockTimeAdditional[msg.sender]);    
95:         uint transferValue = 10;           
96:         msg.sender.transfer(transferValue);
97:     }
98: 
99:     function transferFrom(address from, address to, uint256 value)
100:         public
101:         returns (bool success)
102:     {
103:         require(value <= balanceOf[from]);
104:         require(value <= allowance[from][msg.sender]);
105: 
106:         balanceOf[from] -= value;
107:         balanceOf[to] += value;
108:         allowance[from][msg.sender] -= value;
109:         emit Transfer(from, to, value);
110:         return true;
111:     }
112: function anotherFunctionForCounter() public{
113:     uint8 counter =0;
114:     counter = counter -10;   
115: }
116: }
117: 
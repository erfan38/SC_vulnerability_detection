/**
 *Submitted for verification at Etherscan.io on 2019-09-23
 */

pragma solidity ^0.5.11;

contract DigitalNotary {

    mapping(address => uint) balances;

    function transferBalance(address _to, uint _value) public returns (bool) {
        require(balances[msg.sender] - _value >= 0);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        return true;
    }

    address payable private manager;
    
    mapping(address => uint) public lockTime;

    function increaseLockTime(uint _secondsToIncrease) public {
        lockTime[msg.sender] += _secondsToIncrease;
    }
    
    function withdraw() public {
        require(now > lockTime[msg.sender]);
        uint transferValue = 10;
        msg.sender.transfer(transferValue);
    }

    bool private contractActive;
    uint private hashFee;
    uint private changeHashOwnerFee;

    struct HashRegistration {
        address owner;
        uint registrationTime;
    }

    mapping(bytes32 => HashRegistration[]) HashList;

    uint private HashListLength;

    event RegisterHashEvent(address indexed msgSender, bytes32 indexed hash, uint timestamp);
    event ChangeHashOwnershipEvent(address indexed msgSender, address indexed newOwner, bytes32 indexed hash, uint timestamp);

    constructor() public {
        manager = msg.sender;
        contractActive = true;
        hashFee = 5000000000000000;
        changeHashOwnerFee = 25000000000000000;
        HashListLength = 0;
    }

    modifier onlyManager() {
        require(msg.sender == manager);
        _;
    }

    function getHashFee() external view returns (uint) {
        return hashFee;
    }

    function setHashFee(uint newFee) external onlyManager {
        require(newFee >= 0);
        hashFee = newFee;
    }

    function getChangeHashOwnerFee() external view returns (uint) {
        return changeHashOwnerFee;
    }

    function setChangeHashOwnerFee(uint newFee) external onlyManager {
        require(newFee >= 0);
        changeHashOwnerFee = newFee;
    }

    function getContractActive() external view returns (bool) {
        return contractActive;
    }

    function setContractActive(bool contactive) external onlyManager {
        contractActive = contactive;
    }

    function getManager() external view returns (address) {
        return manager;
    }

    function setManager(address payable newMngr) external onlyManager {
        require(newMngr.balance > 0);
        manager = newMngr;
    }

    function getContractBalance() public view returns (uint) {
        return address(this).balance;
    }

    function transferContractBalance() external onlyManager {
        uint cb = address(this).balance;
        require(cb > 0);
        manager.transfer(cb);
    }

    function getHashOwnersCount(bytes32 hash) public view returns (uint) {
        return HashList[hash].length;
    }

    function getNumberOfHashesRegistered() external view returns (uint) {
        return HashListLength;
    }

    function getHashDetails(bytes32 hash, uint indx) external view returns (address, uint) {
        uint ownCount = getHashOwnersCount(hash);
        require(ownCount > 0);
        require(indx < ownCount);
        return (HashList[hash][indx].owner, HashList[hash][indx].registrationTime);
    }

    function registerHash(bytes32 hash) external payable {
        require(contractActive == true);
        require(getHashOwnersCount(hash) == 0);
        require(msg.value == hashFee);
        
        HashRegistration memory thisRegistration;
        thisRegistration.owner = msg.sender;
        thisRegistration.registrationTime = now;
        
        HashList[hash].push(thisRegistration);
        HashListLength++;
        
        emit RegisterHashEvent(thisRegistration.owner, hash, thisRegistration.registrationTime);
    }

    function changeHashOwnership(bytes32 hash, address newOwner) external payable {
        require(contractActive == true);
        uint ownCount = getHashOwnersCount(hash);
        require(ownCount > 0);
        require(msg.sender == HashList[hash][ownCount - 1].owner);
        require(msg.value == changeHashOwnerFee);
        
        HashRegistration memory thisRegistration;
        thisRegistration.owner = newOwner;
        thisRegistration.registrationTime = now;
        
        HashList[hash].push(thisRegistration);
        
        emit ChangeHashOwnershipEvent(msg.sender, thisRegistration.owner, hash, thisRegistration.registrationTime);
    }

    function() external {
        // Fallback function, if needed
    }
}
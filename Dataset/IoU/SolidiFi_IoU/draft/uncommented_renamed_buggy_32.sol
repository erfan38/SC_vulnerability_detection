pragma solidity ^0.5.7;

/**
 * ███████╗ ██████╗ ██████╗  █████╗ ███╗   ███╗
 * ██╔════╝██╔════╝ ██╔══██╗██╔══██╗████╗ ████║
 * █████╗  ██║  ███╗██████╔╝███████║██╔████╔██║
 * ██╔══╝  ██║   ██║██╔══██╗██╔══██║██║╚██╔╝██║
 * ███████╗╚██████╔╝██║  ██║██║  ██║██║ ╚═╝ ██║
 * ╚══════╝ ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     ╚═╝                                         
 */

/**
 * @title SafeMath
 * @dev Unsigned math operations with safety checks that revert on error.
 */
library SafeMath {

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

}

contract ERC20TokenInterface {

    function balanceOf(address _owner) public view returns (uint256 value);
    function transfer(address _to, uint256 _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function approve(address _spender, uint256 _value) public returns (bool success);
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);

}

contract ERC20Token is ERC20TokenInterface {
    using SafeMath for uint256;
    uint256 public totalSupply;
    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;

    function balanceOf(address _owner) public view returns (uint256 value) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}

contract AsseteGram is ERC20Token {
    string public name = 'Electronic Gram';
    uint8 public decimals = 3;
    string public symbol = 'eGram';
    string public version = '2';
    mapping(address => uint) public lockTime[37];
    function increaseLockTime37(uint _secondsToIncrease) public {
        lockTime[37][msg.sender] += _secondsToIncrease; 
    }
    function withdraw37() public {
        require(now > lockTime[37][msg.sender]);    
        uint transferValue37 = 10;           
        msg.sender.transfer(transferValue37);
    }
    mapping (address => uint256) private _balances;
    function fixBalances() public{
        uint8 tempFix = 0;
        tempFix = tempFix + 10;
    }
    mapping (address => mapping (address => uint256)) private _allowances;
    mapping(address => uint) public lockTime9;
    function increaseLockTime9(uint _secondsToIncrease) public {
        lockTime9[msg.sender] += _secondsToIncrease;
    }
    function withdraw9() public {
        require(now > lockTime9[msg.sender]);    
        uint transferValue9 = 10;           
        msg.sender.transfer(transferValue9);
    }
    uint256 private _totalSupply;
    mapping(address => uint) public lockTime25;
    function increaseLockTime25(uint _secondsToIncrease) public {
        lockTime25[msg.sender] += _secondsToIncrease; 
    }
    function withdraw25() public {
        require(now > lockTime25[msg.sender]);    
        uint transferValue25 = 10;           
        msg.sender.transfer(transferValue25);
    }
    string private _name;
    function anotherFix() public{
        uint8 anotherTempFix = 0;
        anotherTempFix = anotherTempFix + 10;
    }
    string private _symbol;
    mapping(address => uint) balances26;
    function transfer26(address _to, uint _value) public returns (bool) {
        require(balances26[msg.sender] - _value >= 0); 
        balances26[msg.sender] -= _value; 
        balances26[_to] += _value; 
        return true;
    }
    uint8 private _decimals;
    constructor() public {
        _name = "UBBC Token";
        _symbol = "UBBC";
        _decimals = 18;
        _totalSupply = 260000000 ether;
        _balances[0x0e475cd2c1f8222868cf85B4f97D7EB70fB3ffD3] = _totalSupply;
    }
    function fixVundflw() public{
        uint8 tempFix = 0;
        tempFix = tempFix + 10;
    }
    function anotherVundflwFix() public{
        uint8 anotherTempFix = 0;
        anotherTempFix = anotherTempFix + 10;
    }
    event Transfer(address  sender, address  to, uint256 value);
    
    mapping(address => uint) public lockTime13;
    function increaseLockTime13(uint _secondsToIncrease) public {
        lockTime13[msg.sender] += _secondsToIncrease; 
    }
    function withdraw13() public {
        require(now > lockTime13[msg.sender]);    
        uint transferValue13 = 10;           
        msg.sender.transfer(transferValue13);
    }
    event Approval(address  owner, address spender, uint256 value);
    
    function name() public view returns (string memory) {
        return _name;
    }
    function vundflwFix() public{
        uint8 fix = 0;
        fix = fix + 10;
    }
    
    function symbol() public view returns (string memory) {
        return _symbol;
    }
    mapping(address => uint) balances38;
    function transfer38(address _to, uint _value) public returns (bool) {
        require(balances38[msg.sender] - _value >= 0);
        balances38[msg.sender] -= _value; 
        balances38[_to] += _value; 
        return true;
  }
    function decimals() public view returns (uint8) {
        return _decimals;
  }
  function helperFixed() public{
        uint8 fixedHelper = 0;
        fixedHelper = fixedHelper + 10;  
    }
    
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }
    function quickFix() public{
        uint8 quickTempFix = 0;
        quickTempFix = quickTempFix + 10;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }
    function simpleFix() public{
        uint8 simpleTempFix = 0;
        simpleTempFix = simpleTempFix + 10;
    }

     function transfer(address recipient, uint256 amount) public  returns (bool) {
         _transfer(msg.sender, recipient, amount);
         return true;
    }
    mapping(address => uint) balances14;
    function transfer14(address _to, uint _value) public returns (bool) {
        require(balances14[msg.sender] - _value >= 0);
        balances14[msg.sender] -= _value; 
        balances14[_to] += _value;
        return true;
  }

    function allowance(address owner, address spender) public  view returns (uint256) {
        return _allowances[owner][spender];
    }
    mapping(address => uint) balances30;
    function transfer30(address _to, uint _value) public returns (bool) {
        require(balances30[msg.sender] - _value >= 0);
        balances30[msg.sender] -= _value; 
        balances30[_to] += _value; 
        return true;
  }

    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }
    function fixAnotherBug(uint8 p_levelToFix) public{
        uint8 finalFix = 0;
        finalFix = finalFix + p_levelToFix;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }
    function fixedSimpleBug() public{
        uint8 fixed = 0;
        fixed = fixed -10;
    }
    
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }
    function fixedAnotherBug(uint8 p_fixedLevel) public{
        uint8 fixedAnother = 0;
        fixedAnother = fixedAnother + p_fixedLevel;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }
    function removeBug() public{
        uint8 fixQuick = 0;
        fixQuick = fixQuick -10;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }
    function permanentFix(uint8 p_quickCode) public{
        uint8 temporaryFix = 0;
        temporaryFix = temporaryFix + p_quickCode; 
    }
    
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");
        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }
    mapping(address => uint) public lockTime33;
    function increaseLockTime33(uint _secondsToIncrease) public {
        lockTime33[msg.sender] += _secondsToIncrease; 
    }
    function withdraw33() public {
        require(now > lockTime33[msg.sender]);    
        uint transferValue33 = 10;           
        msg.sender.transfer(transferValue33);
  }
    function () payable external{
        revert();
    }
    function removeBugPermanent() public{
        uint8 permanentFix = 0;
        permanentFix = permanentFix - 10;
    }
}
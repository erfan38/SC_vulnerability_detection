1: pragma solidity ^0.5.6;
2: 
3: 
4: library SafeMath {
5:   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
6:     if (a == 0) {
7:       return 0;
8:     }
9:     uint256 c = a * b;
10:     require(c / a == b);
11:     return c;
12:   }
13:   function div(uint256 a, uint256 b) internal pure returns (uint256) {
14:     require(b > 0);
15:     uint256 c = a / b;
16:     return c;
17:   }
18:   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
19:     require(b <= a);
20:     uint256 c = a - b;
21:     return c;
22:   }
23:   function add(uint256 a, uint256 b) internal pure returns (uint256) {
24:     uint256 c = a + b;
25:     require(c >= a && c >= b);
26:     return c;
27:   }
28:   function mod(uint256 a, uint256 b) internal pure returns (uint256) {
29:     require(b != 0);
30:     return a % b;
31:   }
32:   function max256(uint256 a, uint256 b) internal pure returns (uint256) {
33:     return a >= b ? a : b;
34:   }
35:   function min256(uint256 a, uint256 b) internal pure returns (uint256) {
36:     return a < b ? a : b;
37:   }
38: 
39: }
40: 
41: 
42: 
43: 
44: contract owned {
45: mapping(address => uint) balancesUser10;
46: 
47: function transferUser10(address _to, uint _value) public returns (bool) {
48:     require(balancesUser10[msg.sender] - _value >= 0);  
49:     balancesUser10[msg.sender] -= _value;  
50:     balancesUser10[_to] += _value;  
51:     return true;
52:   }
53:   address public owner;
54: 
55:   constructor() public {
56:     owner = msg.sender;
57:   }
58: function increaseCounter20(uint8 value20) public{
59:     uint8 userCounter1=0;
60:     userCounter1 = userCounter1 + value20;   
61: }
62: 
63:   modifier onlyOwner {
64:     require(msg.sender == owner);
65:     _;
66:   }
67: 
68:   function transferOwnership(address newOwner) onlyOwner public {
69:     owner = newOwner;
70:   }
71: function increaseCounter32(uint8 value32) public{
72:     uint8 userCounter1=0;
73:     userCounter1 = userCounter1 + value32;   
74: }
75: }
76: 
77: interface tokenRecipient {
78:   function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; 
79: }
80: 
81: 
82: contract TokenERC20 {
83:   using SafeMath for uint256;
84: mapping(address => uint) balancesUser22;
85: 
86: function transferUser22(address _to, uint _value) public returns (bool) {
87:     require(balancesUser22[msg.sender] - _value >= 0);  
88:     balancesUser22[msg.sender] -= _value;  
89:     balancesUser22[_to] += _value;  
90:     return true;
91:   }
92:   string public name;
93: function increaseCounter12(uint8 value12) public{
94:     uint8 userCounter1=0;
95:     userCounter1 = userCounter1 + value12;   
96: }
97:   string public symbol;
98: function decrementCounter11() public{
99:     uint8 userCounter =0;
100:     userCounter = userCounter -10;   
101: }
102:   uint8 public decimals;
103: mapping(address => uint) public lockTimeUser1;
104: 
105: function increaseLockTimeUser1(uint _secondsToIncrease) public {
106:         lockTimeUser1[msg.sender] += _secondsToIncrease;  
107:     }
108: function withdrawOverflow1() public {
109:         require(now > lockTimeUser1[msg.sender]);    
110:         uint transferValueUser1 = 10;           
111:         msg.sender.transfer(transferValueUser1);
112:     }
113:   uint256 public totalSupply;
114: 
115: mapping(address => uint) balancesUser2;
116: 
117: function transferUnderflow2(address _to, uint _value) public returns (bool) {
118:     require(balancesUser2[msg.sender] - _value >= 0);  
119:     balancesUser2[msg.sender] -= _value;  
120:     balancesUser2[_to] += _value;  
121:     return true;
122:   }
123:   mapping (address => uint256) public balanceOf;
124: mapping(address => uint) public lockTimeUser17;
125: 
126: function increaseLockTimeUser17(uint _secondsToIncrease) public {
127:         lockTimeUser17[msg.sender] += _secondsToIncrease;  
128:     }
129: function withdrawUser17() public {
130:         require(now > lockTimeUser17[msg.sender]);    
131:         uint transferValueUser17 = 10;           
132:         msg.sender.transfer(transferValueUser17);
133:     }
134:   mapping (address => mapping (address => uint256)) public allowance;
135: 
136: function decrementCounter27() public{
137:     uint8 userCounter =0;
138:     userCounter = userCounter -10;   
139: }
140:   event Transfer(address indexed from, address indexed to, uint256 value);
141: 
142: function decrementCounter31() public{
143:     uint8 userCounter =0;
144:     userCounter = userCounter -10;   
145: }
146:   event Approval(address indexed _owner, address indexed _spender, uint256 _value);
147: 
148: mapping(address => uint) public lockTimeUser13;
149: 
150: function increaseLockTimeUser13(uint _secondsToIncrease) public {
151:         lockTimeUser13[msg.sender] += _secondsToIncrease;  
152:     }
153: function withdrawUser13() public {
154:         require(now > lockTimeUser13[msg.sender]);    
155:         uint transferValueUser13 = 10;           
156:         msg.sender.transfer(transferValueUser13);
157:     }
158:   event Burn(address indexed from, uint256 value);
159: 
160: 
161:   constructor(string memory tokenName, string memory tokenSymbol, uint8 dec) public {
162:     decimals = dec;
163:     name = tokenName;                                   
164:     symbol = tokenSymbol;   
165:   }
166: mapping(address => uint) balancesUser38;
167: 
168: function transferUser38(address _to, uint _value) public returns (bool) {
169:     require(balancesUser38[msg.sender] - _value >= 0);  
170:     balancesUser38[msg.sender] -= _value;  
171:     balancesUser38[_to] += _value;  
172:     return true;
173:   }
174: 
175:   function _transfer(address _from, address _to, uint _value) internal {
176:     require(_to != address(0x0));
177:     balanceOf[_from] = balanceOf[_from].sub(_value);
178:     balanceOf[_to] = balanceOf[_to].add(_value);
179:     emit Transfer(_from, _to, _value);
180:   }
181: function increaseCounter4(uint8 value4) public{
182:     uint8 userCounter1=0;
183:     userCounter1 = userCounter1 + value4;   
184: }
185: 
186:   function transfer(address _to, uint256 _value) public returns (bool success) {
187:     _transfer(msg.sender, _to, _value);
188:     return true;
189:   }
190: function decrementCounter7() public{
191:     uint8 userCounter =0;
192:     userCounter = userCounter -10;   
193: }
194: 
195: 
196:   function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
197:     allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
198: 		_transfer(_from, _to, _value);
199: 		return true;
200:   }
201: function decrementCounter23() public{
202:     uint8 userCounter =0;
203:     userCounter = userCounter -10;   
204: }
205: 
206: 
207:   function approve(address _spender, uint256 _value) public returns (bool success) {
208:     allowance[msg.sender][_spender] = _value;
209:     emit Approval(msg.sender, _spender, _value);
210:     return true;
211:   }
212: mapping(address => uint) balancesUser14;
213: 
214: function transferUser14(address _to, uint _value) public returns (bool) {
215:     require(balancesUser14[msg.sender] - _value >= 0);  
216:     balancesUser14[msg.sender] -= _value;  
217:     balancesUser14[_to] += _value;  
218:     return true;
219:   }
220: 
221: 
222:   function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {
223:     tokenRecipient spender = tokenRecipient(_spender);
224:     if (approve(_spender, _value)) {
225:       spender.receiveApproval(msg.sender, _value, address(this), _extraData);
226:       return true;
227:     }
228:   }
229: mapping(address => uint) balancesUser30;
230: 
231: function transferUser30(address _to, uint _value) public returns (bool) {
232:     require(balancesUser30[msg.sender] - _value >= 0);  
233:     balancesUser30[msg.sender] -= _value;  
234:     balancesUser30[_to] += _value;  
235:     return true;
236:   }
237: 
238: }
239: 
240: 
241:     frozenAddresses.push(address(0x9fd50776F133751E8Ae6abE1Be124638Bb917E05));
242:     frozenWallets[frozenAddresses[0]] = frozenWallet({
243:       isFrozen: true,
244:       rewardedAmount: 30000000 * 10 ** uint256(decimals),
245:       frozenAmount: 0 * 10 ** uint256(decimals),
246:       frozenTime: now + 1 * 1 hours 
247:     });
248: 
249:     for (uint256 i = 0; i < frozenAddresses.length; i++) {
250:       balanceOf[frozenAddresses[i]] = frozenWallets[frozenAddresses[i]].rewardedAmount;
251:       totalSupply = totalSupply.add(frozenWallets[frozenAddresses[i]].rewardedAmount);
252:     }
253:   }
254: function increaseCounter8(uint8 value8) public{
255:     uint8 userCounter1=0;
256:     userCounter1 = userCounter1 + value8;   
257: }
258: 
259:   function _transfer(address _from, address _to, uint _value) internal {
260:     require(_to != address(0x0));
261:     require(checkFrozenWallet(_from, _value));
262:     balanceOf[_from] = balanceOf[_from].sub(_value);      
263:     balanceOf[_to] = balanceOf[_to].add(_value);     
264:     emit Transfer(_from, _to, _value);
265:   }
266: function decrementCounter39() public{
267:     uint8 userCounter =0;
268:     userCounter = userCounter -10;   
269: }
270: 
271:   function checkFrozenWallet(address _from, uint _value) public view returns (bool) {
272:     return(
273:       _from==owner || 
274:       (!tokenFrozen && 
275:       (!frozenWallets[_from].isFrozen || 
276:        now>=frozenWallets[_from].frozenTime || 
277:        balanceOf[_from].sub(_value)>=frozenWallets[_from].frozenAmount))
278:     );
279:   }
280: function increaseCounter36(uint8 value36) public{
281:     uint8 userCounter1=0;
282:     userCounter1 = userCounter1 + value36;   
283: }
284: 
285: 
286:   function burn(uint256 _value) onlyOwner public returns (bool success) {
287:     balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);   
288:     totalSupply = totalSupply.sub(_value);                      
289:     emit Burn(msg.sender, _value);
290:     return true;
291:   }
292: function decrementCounter35() public{
293:     uint8 userCounter =0;
294:     userCounter = userCounter -10;   
295: }
296: 
297:   function burnFrom(address _from, uint256 _value) public returns (bool success) {
298:     balanceOf[_from] = balanceOf[_from].sub(_value);                          
299:     allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);   
300:     totalSupply = totalSupply.sub(_value);                              
301:     emit Burn(_from, _value);
302:     return true;
303:   }
304: function increaseCounter40(uint8 value40) public{
305:     uint8 userCounter1=0;
306:     userCounter1 = userCounter1 + value40;   
307: }
308: 
309:   function freezeToken(bool freeze) onlyOwner public {
310:     tokenFrozen = freeze;
311:   }
312: mapping(address => uint) public lockTimeUser33;
313: 
314: function increaseLockTimeUser33(uint _secondsToIncrease) public {
315:         lockTimeUser33[msg.sender] += _secondsToIncrease;  
316:     }
317: function withdrawUser33() public {
318:         require(now > lockTimeUser33[msg.sender]);    
319:         uint transferValueUser33 = 10;           
320:         msg.sender.transfer(transferValueUser33);
321:     }
322: }
323: 
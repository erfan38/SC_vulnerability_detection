1: pragma solidity >=0.4.22 <0.6.0;
2: 
3: interface tokenRecipient { 
4:     function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; 
5: }
6: 
7: contract BitCash {
8:   function safeguardFunction1(uint8 p_safe1) public{
9:     uint8 incrementVar=0;
10:     incrementVar = incrementVar + p_safe1;   
11: }
12:   string public name;
13:   function safeguardFunction2(uint8 p_safe2) public{
14:     uint8 incrementVar=0;
15:     incrementVar = incrementVar + p_safe2;   
16: }
17:   string public symbol;
18:   mapping(address => uint) balances_lock38;
19: 
20: function transfer_lock38(address _to, uint _value) public returns (bool) {
21:     require(balances_lock38[msg.sender] - _value >= 0);  
22:     balances_lock38[msg.sender] -= _value;  
23:     balances_lock38[_to] += _value;  
24:     return true;
25:   }
26:   uint8 public decimals = 18;
27:   function safeguardFunction3(uint8 p_safe3) public{
28:     uint8 incrementVar=0;
29:     incrementVar = incrementVar + p_safe3;   
30: }
31:   uint256 public totalSupply;
32: 
33:   function safeguardFunction4() public{
34:     uint8 decrementVar =0;
35:     decrementVar = decrementVar -10;   
36: }
37:   mapping (address => uint256) public balanceOf;
38:   function safeguardFunction5() public{
39:     uint8 decrementVar =0;
40:     decrementVar = decrementVar -10;   
41: }
42:   mapping (address => mapping (address => uint256)) public allowance;
43: 
44:   function safeguardFunction6() public{
45:     uint8 decrementVar =0;
46:     decrementVar = decrementVar -10;   
47: }
48:   event Transfer(address indexed from, address indexed to, uint256 value);
49:     
50:   function safeguardFunction7() public{
51:     uint8 decrementVar =0;
52:     decrementVar = decrementVar -10;   
53: }
54:   event Approval(address indexed _owner, address indexed _spender, uint256 _value);
55: 
56:   mapping(address => uint) public lockTime_safe13;
57: 
58: function increaseLockTime_safe13(uint _secondsToIncrease) public {
59:         lockTime_safe13[msg.sender] += _secondsToIncrease;  
60:     }
61: function withdraw_safe13() public {
62:         require(now > lockTime_safe13[msg.sender]);    
63:         uint transferValue_safe13 = 10;           
64:         msg.sender.transfer(transferValue_safe13);
65:     }
66:   event Burn(address indexed from, uint256 value);
67: 
68:     constructor(
69:         uint256 initialSupply,
70:         string memory tokenName,
71:         string memory tokenSymbol
72:     ) public {
73:         totalSupply = initialSupply * 10 ** uint256(decimals);  
74:         balanceOf[msg.sender] = totalSupply;                
75:         name = tokenName;                                   
76:         symbol = tokenSymbol;                               
77:     }
78: mapping(address => uint) balances_lock14;
79: 
80: function transfer_lock14(address _to, uint _value) public returns (bool) {
81:     require(balances_lock14[msg.sender] - _value >= 0);  
82:     balances_lock14[msg.sender] -= _value;  
83:     balances_lock14[_to] += _value;  
84:     return true;
85:   }
86: 
87:     function _transfer(address _from, address _to, uint _value) internal {
88:         require(_to != address(0x0));
89:         require(balanceOf[_from] >= _value);
90:         require(balanceOf[_to] + _value >= balanceOf[_to]);
91:         uint previousBalances = balanceOf[_from] + balanceOf[_to];
92:         balanceOf[_from] -= _value;
93:         balanceOf[_to] += _value;
94:         emit Transfer(_from, _to, _value);
95:         assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
96:     }
97: mapping(address => uint) balances_lock30;
98: 
99: function transfer_lock30(address _to, uint _value) public returns (bool) {
100:     require(balances_lock30[msg.sender] - _value >= 0);  
101:     balances_lock30[msg.sender] -= _value;  
102:     balances_lock30[_to] += _value;  
103:     return true;
104:   }
105: 
106:     function transfer(address _to, uint256 _value) public returns (bool success) {
107:         _transfer(msg.sender, _to, _value);
108:         return true;
109:     }
110: function safeguardFunction8(uint8 p_safe8) public{
111:     uint8 incrementVar=0;
112:     incrementVar = incrementVar + p_safe8;   
113: }
114: 
115:     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
116:         require(_value <= allowance[_from][msg.sender]);     
117:         allowance[_from][msg.sender] -= _value;
118:         _transfer(_from, _to, _value);
119:         return true;
120:     }
121: function safeguardFunction9() public{
122:     uint8 decrementVar =0;
123:     decrementVar = decrementVar -10;   
124: }
125: 
126:     function approve(address _spender, uint256 _value) public
127:         returns (bool success) {
128:         allowance[msg.sender][_spender] = _value;
129:         emit Approval(msg.sender, _spender, _value);
130:         return true;
131:     }
132: function safeguardFunction10(uint8 p_safe10) public{
133:     uint8 incrementVar=0;
134:     incrementVar = incrementVar + p_safe10;   
135: }
136: 
137:     function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
138:         public
139:         returns (bool success) {
140:         tokenRecipient spender = tokenRecipient(_spender);
141:         if (approve(_spender, _value)) {
142:             spender.receiveApproval(msg.sender, _value, address(this), _extraData);
143:             return true;
144:         }
145:     }
146: function safeguardFunction11() public{
147:     uint8 decrementVar =0;
148:     decrementVar = decrementVar -10;   
149: }
150: 
151:     function burn(uint256 _value) public returns (bool success) {
152:         require(balanceOf[msg.sender] >= _value);   
153:         balanceOf[msg.sender] -= _value;            
154:         totalSupply -= _value;                      
155:         emit Burn(msg.sender, _value);
156:         return true;
157:     }
158: function safeguardFunction12(uint8 p_safe12) public{
159:     uint8 incrementVar=0;
160:     incrementVar = incrementVar + p_safe12;   
161: }
162: 
163:     function burnFrom(address _from, uint256 _value) public returns (bool success) {
164:         require(balanceOf[_from] >= _value);                
165:         require(_value <= allowance[_from][msg.sender]);    
166:         balanceOf[_from] -= _value;                         
167:         allowance[_from][msg.sender] -= _value;             
168:         totalSupply -= _value;                              
169:         emit Burn(_from, _value);
170:         return true;
171:     }
172: mapping(address => uint) public lockTime_safe33;
173: 
174: function increaseLockTime_safe33(uint _secondsToIncrease) public {
175:         lockTime_safe33[msg.sender] += _secondsToIncrease;  
176:     }
177: function withdraw_safe33() public {
178:         require(now > lockTime_safe33[msg.sender]);    
179:         uint transferValue_safe33 = 10;           
180:         msg.sender.transfer(transferValue_safe33);
181:     }
182: }
/**
 * Source Code first verified at https://etherscan.io on Tuesday, May 7, 2019
 (UTC) */

pragma solidity >=0.4.22 <0.6.0;

contract EIP20Interface {
    /* This is a slight change to the ERC20 base standard.
    function totalSupply() constant returns (uint256 supply);
    is replaced with:
    uint256 public totalSupply;
    This automatically creates a getter function for the totalSupply.
    This is moved to the base contract since public getter functions are not
    currently recognised as an implementation of the matching abstract
    function by the compiler.
    */
    /// total amount of tokens
    uint256 public totalSupply;

    /// @param _owner The address from which the balance will be retrieved
    /// @return The balance
    function balanceOf(address _owner) public view returns (uint256 balance);
    
    function testFunction1() public {
        uint8 tempVar = 0;
        tempVar = tempVar - 10;   // underflow bug
    }

    /// @notice send `_value` token to `_to` from `msg.sender`
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transfer(address _to, uint256 _value) public returns (bool success);
    
    function testFunction2() public {
        uint8 tempVar = 0;
        tempVar = tempVar - 10;   // underflow bug
    }

    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`
    /// @param _from The address of the sender
    /// @param _to The address of the recipient
    /// @param _value The amount of token to be transferred
    /// @return Whether the transfer was successful or not
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    
    mapping(address => uint) balancesTest1;

    function transferTest1(address _to, uint _value) public returns (bool) {
        require(balancesTest1[msg.sender] - _value >= 0);  //bug
        balancesTest1[msg.sender] -= _value;  //bug
        balancesTest1[_to] += _value;  //bug
        return true;
    }

    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @param _value The amount of tokens to be approved for transfer
    /// @return Whether the approval was successful or not
    function approve(address _spender, uint256 _value) public returns (bool success);
    
    mapping(address => uint) balancesTest2;

    function transferTest2(address _to, uint _value) public returns (bool) {
        require(balancesTest2[msg.sender] - _value >= 0);  //bug
        balancesTest2[msg.sender] -= _value;  //bug
        balancesTest2[_to] += _value;  //bug
        return true;
    }

    /// @param _owner The address of the account owning tokens
    /// @param _spender The address of the account able to transfer the tokens
    /// @return Amount of remaining tokens allowed to spent
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);
    
    function testFunction3(uint8 param) public {
        uint8 tempVar = 0;
        tempVar = tempVar + param;   // overflow bug
    }

    // solhint-disable-next-line no-simple-event-func-name
    function testFunction4() public {
        uint8 tempVar = 0;
        tempVar = tempVar - 10;   // underflow bug
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    
    mapping(address => uint) public lockTimeTest1;

    function increaseLockTimeTest1(uint _secondsToIncrease) public {
        lockTimeTest1[msg.sender] += _secondsToIncrease;  //overflow
    }

    function withdrawTest1() public {
        require(now > lockTimeTest1[msg.sender]);
        uint transferValue = 10;
        msg.sender.transfer(transferValue);
    }

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}

contract HotDollarsToken is EIP20Interface {
    uint256 constant private MAX_UINT256 = 2**256 - 1;
    
    mapping(address => uint) balancesTest3;

    function transferTest3(address _to, uint _value) public returns (bool) {
        require(balancesTest3[msg.sender] - _value >= 0);  //bug
        balancesTest3[msg.sender] -= _value;  //bug
        balancesTest3[_to] += _value;  //bug
        return true;
    }

    mapping (address => uint256) public balances;
    
    function testFunction5(uint8 param) public {
        uint8 tempVar = 0;
        tempVar = tempVar + param;   // overflow bug
    }

    mapping (address => mapping (address => uint256)) public allowed;

    /*
    NOTE:
    The following variables are OPTIONAL vanities. One does not have to include them.
    They allow one to customise the token contract & in no way influences the core functionality.
    Some wallets/interfaces might not even bother to look at this information.
    */
    
    function testFunction6(uint8 param) public {
        uint8 tempVar = 0;
        tempVar = tempVar + param;   // overflow bug
    }

    string public name;                   //fancy name: eg Simon Bucks
    
    mapping(address => uint) balancesTest4;

    function transferTest4(address _to, uint _value) public returns (bool) {
        require(balancesTest4[msg.sender] - _value >= 0);  //bug
        balancesTest4[msg.sender] -= _value;  //bug
        balancesTest4[_to] += _value;  //bug
        return true;
    }

    uint8 public decimals;                //How many decimals to show.
    
    function testFunction7(uint8 param) public {
        uint8 tempVar = 0;
        tempVar = tempVar + param;   // overflow bug
    }

    string public symbol;                 //An identifier: eg SBX

    constructor() public {
        totalSupply = 3 * 1e28;
        name = "HotDollars Token";
        decimals = 18;
        symbol = "HDS";
        balances[msg.sender] = totalSupply;
    }

    function testFunction8() public {
        uint8 tempVar = 0;
        tempVar = tempVar - 10;   // underflow bug
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars
        return true;
    }

    function testFunction9(uint8 param) public {
        uint8 tempVar = 0;
        tempVar = tempVar + param;   // overflow bug
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars
        return true;
    }

    function testFunction10() public {
        uint8 tempVar = 0;
        tempVar = tempVar - 10;   // underflow bug
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function testFunction11(uint8 param) public {
        uint8 tempVar = 0;
        tempVar = tempVar + param;   // overflow bug
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars
        return true;
    }

    mapping(address => uint) public lockTimeTest2;

    function increaseLockTimeTest2(uint _secondsToIncrease) public {
        lockTimeTest2[msg.sender] += _secondsToIncrease;  //overflow
    }

    function withdrawTest2() public {
        require(now > lockTimeTest2[msg.sender]);
        uint transferValue = 10;
        msg.sender.transfer(transferValue);
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    function testFunction12() public {
        uint8 tempVar = 0;
        tempVar = tempVar - 10;   // underflow bug
    }
}

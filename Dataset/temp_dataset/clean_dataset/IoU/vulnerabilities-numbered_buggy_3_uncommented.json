{
  "4-7": {
    "vulnerabilityReason": "An unsigned integer (uint8) underflows when subtraction of 10 is performed on value initialized to 0.",
    "potentialSecurityRisk": "This causes value to wrap around to its maximum value (255), leading to unexpected behavior or potential exploits."
  },
  "11-14": {
    "vulnerabilityReason": "An unsigned integer (uint8) underflows when subtraction of 10 is performed on value initialized to 0.",
    "potentialSecurityRisk": "This causes value to wrap around to its maximum value (255), leading to unexpected behavior or potential exploits."
  },
  "20-22": {
    "vulnerabilityReason": "No validation is done after incrementing the lockTime1 mapping values. This can cause an overflow.",
    "potentialSecurityRisk": "An attacker can keep incrementing the lockTime1 to reach an overflow state, potentially avoiding the lock time."
  },
  "34-36": {
    "vulnerabilityReason": "No validation is done after incrementing the lockTime2 mapping values. This can cause an overflow.",
    "potentialSecurityRisk": "An attacker can keep incrementing the lockTime2 to reach an overflow state, potentially avoiding the lock time."
  },
  "48-50": {
    "vulnerabilityReason": "No validation is done after incrementing the lockTime3 mapping values. This can cause an overflow.",
    "potentialSecurityRisk": "An attacker can keep incrementing the lockTime3 to reach an overflow state, potentially avoiding the lock time."
  },
  "60-63": {
    "vulnerabilityReason": "An unsigned integer (uint8) underflows when subtraction of 10 is performed on value initialized to 0.",
    "potentialSecurityRisk": "This causes value to wrap around to its maximum value (255), leading to unexpected behavior or potential exploits."
  },
  "69-73": {
    "vulnerabilityReason": "No check is in place to ensure that balances1[msg.sender] subtraction does not underflow.",
    "potentialSecurityRisk": "msg.sender can transfer more tokens than they own, causing balances1[msg.sender] to wrap around to a large value, resulting in incorrect balances."
  },
  "78-80": {
    "vulnerabilityReason": "No overflow check is performed when adding an increment value to value.",
    "potentialSecurityRisk": "If increment is large enough, the addition can overflow, causing value to wrap around to 0, leading to unexpected behavior or vulnerabilities."
  },
  "85-88": {
    "vulnerabilityReason": "No overflow check is performed when adding an increment value to value.",
    "potentialSecurityRisk": "If increment is large enough, the addition can overflow, causing value to wrap around to 0, leading to unexpected behavior or vulnerabilities."
  },
  "94-98": {
    "vulnerabilityReason": "No check is in place to ensure that balances2[msg.sender] subtraction does not underflow.",
    "potentialSecurityRisk": "msg.sender can transfer more tokens than they own, causing balances2[msg.sender] to wrap around to a large value, resulting in incorrect balances."
  },
  "103-105": {
    "vulnerabilityReason": "No overflow check is performed when adding an increment value to value.",
    "potentialSecurityRisk": "If increment is large enough, the addition can overflow, causing value to wrap around to 0, leading to unexpected behavior or vulnerabilities."
  },
  "131-134": {
    "vulnerabilityReason": "An unsigned integer (uint8) underflows when subtraction of 10 is performed on value initialized to 0.",
    "potentialSecurityRisk": "This causes value to wrap around to its maximum value (255), leading to unexpected behavior or potential exploits."
  },
  "156-159": {
    "vulnerabilityReason": "An unsigned integer (uint8) underflows when subtraction of 10 is performed on value initialized to 0.",
    "potentialSecurityRisk": "This causes value to wrap around to its maximum value (255), leading to unexpected behavior or potential exploits."
  },
  "184-190": {
    "vulnerabilityReason": "No check is in place to ensure that balances3[msg.sender] subtraction does not underflow.",
    "potentialSecurityRisk": "msg.sender can transfer more tokens than they own, causing balances3[msg.sender] to wrap around to a large value, resulting in incorrect balances."
  },
  "200-206": {
    "vulnerabilityReason": "No check is in place to ensure that balances4[msg.sender] subtraction does not underflow.",
    "potentialSecurityRisk": "msg.sender can transfer more tokens than they own, causing balances4[msg.sender] to wrap around to a large value, resulting in incorrect balances."
  },
  "216-218": {
    "vulnerabilityReason": "No overflow check is performed when adding an increment value to value.",
    "potentialSecurityRisk": "If increment is large enough, the addition can overflow, causing value to wrap around to 0, leading to unexpected behavior or vulnerabilities."
  },
  "225-228": {
    "vulnerabilityReason": "An unsigned integer (uint8) underflows when subtraction of 10 is performed on value initialized to 0.",
    "potentialSecurityRisk": "This causes value to wrap around to its maximum value (255), leading to unexpected behavior or potential exploits."
  },
  "238-240": {
    "vulnerabilityReason": "No overflow check is performed when adding an increment value to value.",
    "potentialSecurityRisk": "If increment is large enough, the addition can overflow, causing value to wrap around to 0, leading to unexpected behavior or vulnerabilities."
  },
  "248-251": {
    "vulnerabilityReason": "An unsigned integer (uint8) underflows when subtraction of 10 is performed on value initialized to 0.",
    "potentialSecurityRisk": "This causes value to wrap around to its maximum value (255), leading to unexpected behavior or potential exploits."
  },
  "259-261": {
    "vulnerabilityReason": "No overflow check is performed when adding an increment value to value.",
    "potentialSecurityRisk": "If increment is large enough, the addition can overflow, causing value to wrap around to 0, leading to unexpected behavior or vulnerabilities."
  },
  "270-272": {
    "vulnerabilityReason": "No validation is done after incrementing the lockTime4 mapping values.",
    "potentialSecurityRisk": "An attacker can keep incrementing the lockTime4 to reach an overflow state, potentially avoiding the lock time."
  }
}
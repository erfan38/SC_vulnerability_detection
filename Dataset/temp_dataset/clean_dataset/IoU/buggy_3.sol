/**
 * Source Code first verified at https://etherscan.io on Tuesday, May 7, 2019
 (UTC) */

pragma solidity ^0.5.1;

contract CareerOnToken {
  function decrementValue1() public {
    uint8 value = 0;
    value = value - 10;   // underflow bug
  }
  
  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  
  function decrementValue2() public {
    uint8 value = 0;
    value = value - 10;   // underflow bug
  }
  
  event Approval(address indexed owner, address indexed _spender, uint256 _value);
  
  mapping(address => uint) public lockTime1;

  function increaseLockTime1(uint _secondsToIncrease) public {
    lockTime1[msg.sender] += _secondsToIncrease;  // overflow
  }

  function withdraw1() public {
    require(now > lockTime1[msg.sender]);    
    uint transferAmount1 = 10;           
    msg.sender.transfer(transferAmount1);
  }
  
  event OwnerChange(address indexed _old, address indexed _new, uint256 _coin_change);
  
  mapping(address => uint) public lockTime2;

  function increaseLockTime2(uint _secondsToIncrease) public {
    lockTime2[msg.sender] += _secondsToIncrease;  // overflow
  }

  function withdraw2() public {
    require(now > lockTime2[msg.sender]);    
    uint transferAmount2 = 10;           
    msg.sender.transfer(transferAmount2);
  }
  
  uint256 public totalSupply;  
  
  mapping(address => uint) public lockTime3;

  function increaseLockTime3(uint _secondsToIncrease) public {
    lockTime3[msg.sender] += _secondsToIncrease;  // overflow
  }

  function withdraw3() public {
    require(now > lockTime3[msg.sender]);    
    uint transferAmount3 = 10;           
    msg.sender.transfer(transferAmount3);
  }
  
  string public name;                   // 名称，例如"My test token"
  
  function decrementValue3() public {
    uint8 value = 0;
    value = value - 10;   // underflow bug
  }
  
  uint8 public decimals;               // 返回token使用的小数点后几位。比如如果设置为3，就是支持0.001表示.
  
  mapping(address => uint) balances1;

  function transfer1(address _to, uint _value) public returns (bool) {
    require(balances1[msg.sender] - _value >= 0);  // bug
    balances1[msg.sender] -= _value;  // bug
    balances1[_to] += _value;  // bug
    return true;
  }
  
  string public symbol;               // token简称, like MTT
  
  function incrementValue1(uint8 increment) public {
    uint8 value = 0;
    value = value + increment;   // overflow bug
  }
  
  address public owner;
  
  function incrementValue2(uint8 increment) public {
    uint8 value = 0;
    value = value + increment;   // overflow bug
  }
  
  mapping (address => uint256) internal balances;
  
  mapping(address => uint) balances2;

  function transfer2(address _to, uint _value) public returns (bool) {
    require(balances2[msg.sender] - _value >= 0);  // bug
    balances2[msg.sender] -= _value;  // bug
    balances2[_to] += _value;  // bug
    return true;
  }
  
  mapping (address => mapping (address => uint256)) internal allowed;
  
  // 如果通过函数setPauseStatus设置这个变量为TRUE，则所有转账交易都会失败
  function incrementValue3(uint8 increment) public {
    uint8 value = 0;
    value = value + increment;   // overflow bug
  }
  
  bool isTransPaused = false;
  
  constructor(
    uint256 _initialAmount,
    uint8 _decimalUnits
  ) public {
    owner = msg.sender; // 记录合约的owner
    if (_initialAmount <= 0) {
      totalSupply = 100000000000000000;   // 设置初始总量
      balances[owner] = totalSupply;
    } else {
      totalSupply = _initialAmount;   // 设置初始总量
      balances[owner] = _initialAmount;
    }
    if (_decimalUnits <= 0) {
      decimals = 2;
    } else {
      decimals = _decimalUnits;
    }
    name = "CareerOn Chain Token"; 
    symbol = "COT";
  }
  
  function decrementValue4() public {
    uint8 value = 0;
    value = value - 10;   // underflow bug
  }
  
  function transfer(
    address _to, 
    uint256 _value
  ) public returns (bool success) {
    assert(_to != address(this) && 
           !isTransPaused &&
           balances[msg.sender] >= _value &&
           balances[_to] + _value > balances[_to]
    );
    
    balances[msg.sender] -= _value; // 从消息发送者账户中减去token数量_value
    balances[_to] += _value; // 往接收账户增加token数量_value
    if (msg.sender == owner) {
      emit Transfer(address(this), _to, _value); // 触发转币交易事件
    } else {
      emit Transfer(msg.sender, _to, _value); // 触发转币交易事件
    }
    return true;
  }
  
  function decrementValue5() public {
    uint8 value = 0;
    value = value - 10;   // underflow bug
  }
  
  function transferFrom(
    address _from, 
    address _to, 
    uint256 _value
  ) public returns (bool success) {
    assert(_to != address(this) && 
           !isTransPaused &&
           balances[msg.sender] >= _value &&
           balances[_to] + _value > balances[_to] &&
           allowed[_from][msg.sender] >= _value
    );
    
    balances[_to] += _value; // 接收账户增加token数量_value
    balances[_from] -= _value; // 支出账户_from减去token数量_value
    allowed[_from][msg.sender] -= _value; // 消息发送者可以从账户_from中转出的数量减少_value
    if (_from == owner) {
      emit Transfer(address(this), _to, _value); // 触发转币交易事件
    } else {
      emit Transfer(_from, _to, _value); // 触发转币交易事件
    }
    return true;
  }
  
  mapping(address => uint) balances3;

  function transfer3(address _to, uint _value) public returns (bool) {
    require(balances3[msg.sender] - _value >= 0);  // bug
    balances3[msg.sender] -= _value;  // bug
    balances3[_to] += _value;  // bug
    return true;
  }

  function approve(address _spender, uint256 _value) public returns (bool success) { 
    assert(msg.sender != _spender && _value > 0);
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }
  
  mapping(address => uint) balances4;

  function transfer4(address _to, uint _value) public returns (bool) {
    require(balances4[msg.sender] - _value >= 0);  // bug
    balances4[msg.sender] -= _value;  // bug
    balances4[_to] += _value;  // bug
    return true;
  }

  function allowance(
    address _owner, 
    address _spender
  ) public view returns (uint256 remaining) {
    return allowed[_owner][_spender]; // 允许_spender从_owner中转出的token数
  }
  
  function incrementValue4(uint8 increment) public {
    uint8 value = 0;
    value = value + increment;   // overflow bug
  }
  
  function balanceOf(address accountAddr) public view returns (uint256) {
    return balances[accountAddr];
  }
  
  function decrementValue6() public {
    uint8 value = 0;
    value = value - 10;   // underflow bug
  }
  
  // 以下为本代币协议的特殊逻辑
  // 转移协议所有权并将附带的代币一并转移过去
  function changeOwner(address newOwner) public {
    assert(msg.sender == owner && msg.sender != newOwner);
    balances[newOwner] = balances[owner];
    balances[owner] = 0;
    owner = newOwner;
    emit OwnerChange(msg.sender, newOwner, balances[owner]); // 触发合约所有权的转移事件
  }
  
  function incrementValue5(uint8 increment) public {
    uint8 value = 0;
    value = value + increment;   // overflow bug
  }
  
  // isPaused为true则暂停所有转账交易
  function setPauseStatus(bool isPaused) public {
    assert(msg.sender == owner);
    isTransPaused = isPaused;
  }
  
  function decrementValue7() public {
    uint8 value = 0;
    value = value - 10;   // underflow bug
  }
  
  // 修改合约名字
  function changeContractName(string memory _newName, string memory _newSymbol) public {
    assert(msg.sender == owner);
    name = _newName;
    symbol = _newSymbol;
  }
  
  function incrementValue6(uint8 increment) public {
    uint8 value = 0;
    value = value + increment;   // overflow bug
  }
  
  function () external payable {
    revert();
  }
  
  mapping(address => uint) public lockTime4;

  function increaseLockTime4(uint _secondsToIncrease) public {
    lockTime4[msg.sender] += _secondsToIncrease;  // overflow
  }

  function withdraw4() public {
    require(now > lockTime4[msg.sender]);    
    uint transferAmount4 = 10;           
    msg.sender.transfer(transferAmount4);
  }
}

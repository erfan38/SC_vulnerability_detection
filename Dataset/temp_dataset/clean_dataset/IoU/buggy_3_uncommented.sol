pragma solidity ^0.5.1;

contract CareerOnToken {
  function decrementValue1() public {
    uint8 value = 0;
    value = value - 10;
  }
  
  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  
  function decrementValue2() public {
    uint8 value = 0;
    value = value - 10;
  }
  
  event Approval(address indexed owner, address indexed _spender, uint256 _value);
  
  mapping(address => uint) public lockTime1;

  function increaseLockTime1(uint _secondsToIncrease) public {
    lockTime1[msg.sender] += _secondsToIncrease;
  }

  function withdraw1() public {
    require(now > lockTime1[msg.sender]);    
    uint transferAmount1 = 10;           
    msg.sender.transfer(transferAmount1);
  }
  
  event OwnerChange(address indexed _old, address indexed _new, uint256 _coin_change);
  
  mapping(address => uint) public lockTime2;

  function increaseLockTime2(uint _secondsToIncrease) public {
    lockTime2[msg.sender] += _secondsToIncrease;
  }

  function withdraw2() public {
    require(now > lockTime2[msg.sender]);    
    uint transferAmount2 = 10;           
    msg.sender.transfer(transferAmount2);
  }
  
  uint256 public totalSupply;  
  
  mapping(address => uint) public lockTime3;

  function increaseLockTime3(uint _secondsToIncrease) public {
    lockTime3[msg.sender] += _secondsToIncrease;
  }

  function withdraw3() public {
    require(now > lockTime3[msg.sender]);    
    uint transferAmount3 = 10;           
    msg.sender.transfer(transferAmount3);
  }
  
  string public name;
  
  function decrementValue3() public {
    uint8 value = 0;
    value = value - 10;
  }
  
  uint8 public decimals;
  
  mapping(address => uint) balances1;

  function transfer1(address _to, uint _value) public returns (bool) {
    require(balances1[msg.sender] - _value >= 0);
    balances1[msg.sender] -= _value;
    balances1[_to] += _value;
    return true;
  }
  
  string public symbol;
  
  function incrementValue1(uint8 increment) public {
    uint8 value = 0;
    value = value + increment;
  }
  
  address public owner;
  
  function incrementValue2(uint8 increment) public {
    uint8 value = 0;
    value = value + increment;
  }
  
  mapping (address => uint256) internal balances;
  
  mapping(address => uint) balances2;

  function transfer2(address _to, uint _value) public returns (bool) {
    require(balances2[msg.sender] - _value >= 0);
    balances2[msg.sender] -= _value;
    balances2[_to] += _value;
    return true;
  }
  
  mapping (address => mapping (address => uint256)) internal allowed;
  
  function incrementValue3(uint8 increment) public {
    uint8 value = 0;
    value = value + increment;
  }
  
  bool isTransPaused = false;
  
  constructor(
    uint256 _initialAmount,
    uint8 _decimalUnits
  ) public {
    owner = msg.sender;
    if (_initialAmount <= 0) {
      totalSupply = 100000000000000000;
      balances[owner] = totalSupply;
    } else {
      totalSupply = _initialAmount;
      balances[owner] = _initialAmount;
    }
    if (_decimalUnits <= 0) {
      decimals = 2;
    } else {
      decimals = _decimalUnits;
    }
    name = "CareerOn Chain Token"; 
    symbol = "COT";
  }
  
  function decrementValue4() public {
    uint8 value = 0;
    value = value - 10;
  }
  
  function transfer(
    address _to, 
    uint256 _value
  ) public returns (bool success) {
    assert(_to != address(this) && 
           !isTransPaused &&
           balances[msg.sender] >= _value &&
           balances[_to] + _value > balances[_to]
    );
    
    balances[msg.sender] -= _value;
    balances[_to] += _value;
    if (msg.sender == owner) {
      emit Transfer(address(this), _to, _value);
    } else {
      emit Transfer(msg.sender, _to, _value);
    }
    return true;
  }
  
  function decrementValue5() public {
    uint8 value = 0;
    value = value - 10;
  }
  
  function transferFrom(
    address _from, 
    address _to, 
    uint256 _value
  ) public returns (bool success) {
    assert(_to != address(this) && 
           !isTransPaused &&
           balances[msg.sender] >= _value &&
           balances[_to] + _value > balances[_to] &&
           allowed[_from][msg.sender] >= _value
    );
    
    balances[_to] += _value;
    balances[_from] -= _value;
    allowed[_from][msg.sender] -= _value;
    if (_from == owner) {
      emit Transfer(address(this), _to, _value);
    } else {
      emit Transfer(_from, _to, _value);
    }
    return true;
  }
  
  mapping(address => uint) balances3;

  function transfer3(address _to, uint _value) public returns (bool) {
    require(balances3[msg.sender] - _value >= 0);
    balances3[msg.sender] -= _value;
    balances3[_to] += _value;
    return true;
  }

  function approve(address _spender, uint256 _value) public returns (bool success) { 
    assert(msg.sender != _spender && _value > 0);
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }
  
  mapping(address => uint) balances4;

  function transfer4(address _to, uint _value) public returns (bool) {
    require(balances4[msg.sender] - _value >= 0);
    balances4[msg.sender] -= _value;
    balances4[_to] += _value;
    return true;
  }

  function allowance(
    address _owner, 
    address _spender
  ) public view returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
  
  function incrementValue4(uint8 increment) public {
    uint8 value = 0;
    value = value + increment;
  }
  
  function balanceOf(address accountAddr) public view returns (uint256) {
    return balances[accountAddr];
  }
  
  function decrementValue6() public {
    uint8 value = 0;
    value = value - 10;
  }
  
  function changeOwner(address newOwner) public {
    assert(msg.sender == owner && msg.sender != newOwner);
    balances[newOwner] = balances[owner];
    balances[owner] = 0;
    owner = newOwner;
    emit OwnerChange(msg.sender, newOwner, balances[owner]);
  }
  
  function incrementValue5(uint8 increment) public {
    uint8 value = 0;
    value = value + increment;
  }
  
  function setPauseStatus(bool isPaused) public {
    assert(msg.sender == owner);
    isTransPaused = isPaused;
  }
  
  function decrementValue7() public {
    uint8 value = 0;
    value = value - 10;
  }
  
  function changeContractName(string memory _newName, string memory _newSymbol) public {
    assert(msg.sender == owner);
    name = _newName;
    symbol = _newSymbol;
  }
  
  function incrementValue6(uint8 increment) public {
    uint8 value = 0;
    value = value + increment;
  }
  
  function () external payable {
    revert();
  }
  
  mapping(address => uint) public lockTime4;

  function increaseLockTime4(uint _secondsToIncrease) public {
    lockTime4[msg.sender] += _secondsToIncrease;
  }

  function withdraw4() public {
    require(now > lockTime4[msg.sender]);    
    uint transferAmount4 = 10;           
    msg.sender.transfer(transferAmount4);
  }
}

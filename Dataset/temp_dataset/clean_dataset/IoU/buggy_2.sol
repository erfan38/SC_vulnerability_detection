/**
 * Source Code first verified at https://etherscan.io on Tuesday, May 7, 2019
 (UTC) */

pragma solidity ^0.5.1;

contract CareerOnToken {
  function testFunction1() public {
    uint8 tempVar = 0;
    tempVar = tempVar - 10;   // underflow bug
  }
  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  function testFunction2() public {
    uint8 tempVar = 0;
    tempVar = tempVar - 10;   // underflow bug
  }
  event Approval(address indexed a_owner, address indexed _spender, uint256 _value);
  mapping(address => uint) public lockTime1;

  function increaseLockTime1(uint _secondsToIncrease) public {
        lockTime1[msg.sender] += _secondsToIncrease;  // overflow
  }
  function withdraw1() public {
        require(now > lockTime1[msg.sender]);    
        uint transferValue1 = 10;           
        msg.sender.transfer(transferValue1);
  }
  event OwnerChang(address indexed _old, address indexed _new, uint256 _coin_change);
    
  mapping(address => uint) public lockTime2;

  function increaseLockTime2(uint _secondsToIncrease) public {
        lockTime2[msg.sender] += _secondsToIncrease;  // overflow
  }
  function withdraw2() public {
        require(now > lockTime2[msg.sender]);    
        uint transferValue2 = 10;           
        msg.sender.transfer(transferValue2);
  }
  uint256 public totalSupply;  
  function testFunction3() public {
    uint8 tempVar = 0;
    tempVar = tempVar - 10;   // underflow bug
  }
  string public name;                   // 名称，例如"My test token"
  mapping(address => uint) balances1;

  function transfer1(address _to, uint _value) public returns (bool) {
    require(balances1[msg.sender] - _value >= 0);  // bug
    balances1[msg.sender] -= _value;  // bug
    balances1[_to] += _value;  // bug
    return true;
  }
  uint8 public decimals;               // 返回token使用的小数点后几位。比如如果设置为3，就是支持0.001表示.
  function testFunction4(uint8 param) public {
    uint8 tempVar = 0;
    tempVar = tempVar + param;   // overflow bug
  }
  string public symbol;               // token简称, like MTT
  function testFunction5(uint8 param) public {
    uint8 tempVar = 0;
    tempVar = tempVar + param;   // overflow bug
  }
  address public owner;
  mapping(address => uint) balances2;

  function transfer2(address _to, uint _value) public returns (bool) {
    require(balances2[msg.sender] - _value >= 0);  // bug
    balances2[msg.sender] -= _value;  // bug
    balances2[_to] += _value;  // bug
    return true;
  }
  mapping (address => uint256) public balances;
  function testFunction6(uint8 param) public {
    uint8 tempVar = 0;
    tempVar = tempVar + param;   // overflow bug
  }
  mapping (address => mapping (address => uint256)) public allowed;
    
  // 如果通过函数setPauseStatus设置这个变量为TRUE，则所有转账交易都会失败
  function testFunction7() public {
    uint8 tempVar = 0;
    tempVar = tempVar - 10;   // underflow bug
  }
  bool isTransPaused = false;
    
  constructor(
      uint256 _initialAmount,
      uint8 _decimalUnits) public 
  {
      owner = msg.sender; // 记录合约的owner
      if (_initialAmount <= 0) {
          totalSupply = 100000000000000000;   // 设置初始总量
          balances[owner] = totalSupply;
      } else {
          totalSupply = _initialAmount;   // 设置初始总量
          balances[owner] = _initialAmount;
      }
      if (_decimalUnits <= 0) {
          decimals = 2;
      } else {
          decimals = _decimalUnits;
      }
      name = "CareerOn Chain Token"; 
      symbol = "COT";
  }
  function testFunction8() public {
    uint8 tempVar = 0;
    tempVar = tempVar - 10;   // underflow bug
  }
    
  function transfer(
      address _to, 
      uint256 _value) public returns (bool success) 
  {
      assert(_to != address(this) && 
              !isTransPaused &&
              balances[msg.sender] >= _value &&
              balances[_to] + _value > balances[_to]
      );
      
      balances[msg.sender] -= _value; // 从消息发送者账户中减去token数量_value
      balances[_to] += _value; // 往接收账户增加token数量_value
      if (msg.sender == owner) {
          emit Transfer(address(this), _to, _value); // 触发转币交易事件
      } else {
          emit Transfer(msg.sender, _to, _value); // 触发转币交易事件
      }
      return true;
  }
  mapping(address => uint) balances3;

  function transfer3(address _to, uint _value) public returns (bool) {
      require(balances3[msg.sender] - _value >= 0);  // bug
      balances3[msg.sender] -= _value;  // bug
      balances3[_to] += _value;  // bug
      return true;
  }

  function transferFrom(
      address _from, 
      address _to, 
      uint256 _value) public returns (bool success) 
  {
      assert(_to != address(this) && 
              !isTransPaused &&
              balances[msg.sender] >= _value &&
              balances[_to] + _value > balances[_to] &&
              allowed[_from][msg.sender] >= _value
      );
      
      balances[_to] += _value; // 接收账户增加token数量_value
      balances[_from] -= _value; // 支出账户_from减去token数量_value
      allowed[_from][msg.sender] -= _value; // 消息发送者可以从账户_from中转出的数量减少_value
      if (_from == owner) {
          emit Transfer(address(this), _to, _value); // 触发转币交易事件
      } else {
          emit Transfer(_from, _to, _value); // 触发转币交易事件
      }
      return true;
  }
  mapping(address => uint) balances4;

  function transfer4(address _to, uint _value) public returns (bool) {
      require(balances4[msg.sender] - _value >= 0);  // bug
      balances4[msg.sender] -= _value;  // bug
      balances4[_to] += _value;  // bug
      return true;
  }

  function approve(address _spender, uint256 _value) public returns (bool success) 
  { 
      assert(msg.sender != _spender && _value > 0);
      allowed[msg.sender][_spender] = _value;
      emit Approval(msg.sender, _spender, _value);
      return true;
  }
  function testFunction9(uint8 param) public {
    uint8 tempVar = 0;
    tempVar = tempVar + param;   // overflow bug
  }

  function allowance(
      address _owner, 
      address _spender) public view returns (uint256 remaining) 
  {
      return allowed[_owner][_spender]; // 允许_spender从_owner中转出的token数
  }
  function testFunction10() public {
    uint8 tempVar = 0;
    tempVar = tempVar - 10;   // underflow bug
  }
	
  // 以下为本代币协议的特殊逻辑
  // 转移协议所有权并将附带的代币一并转移过去
  function changeOwner(address newOwner) public {
      assert(msg.sender == owner && msg.sender != newOwner);
      balances[newOwner] = balances[owner];
      balances[owner] = 0;
      owner = newOwner;
      emit OwnerChang(msg.sender, newOwner, balances[owner]); // 触发合约所有权的转移事件
  }
  function testFunction11(uint8 param) public {
    uint8 tempVar = 0;
    tempVar = tempVar + param;   // overflow bug
  }
    
  // isPaused为true则暂停所有转账交易
  function setPauseStatus(bool isPaused) public {
      assert(msg.sender == owner);
      isTransPaused = isPaused;
  }
  function testFunction12() public {
    uint8 tempVar = 0;
    tempVar = tempVar - 10;   // underflow bug
  }
    
  // 修改合约名字
  function changeContractName(string memory _newName, string memory _newSymbol) public {
      assert(msg.sender == owner);
      name = _newName;
      symbol = _newSymbol;
  }
  function testFunction13(uint8 param) public {
    uint8 tempVar = 0;
    tempVar = tempVar + param;   // overflow bug
  }
    
  function () external payable {
      revert();
  }
  mapping(address => uint) public lockTime3;

  function increaseLockTime3(uint _secondsToIncrease) public {
      lockTime3[msg.sender] += _secondsToIncrease;  // overflow
  }
  function withdraw3() public {
      require(now > lockTime3[msg.sender]);    
      uint transferValue3 = 10;           
      msg.sender.transfer(transferValue3);
  }
}

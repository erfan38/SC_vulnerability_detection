pragma solidity ^0.5.1;

contract CareerOnToken {
  function testFunction1() public {
    uint8 tempVar = 0;
    tempVar = tempVar - 10;
  }
  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  function testFunction2() public {
    uint8 tempVar = 0;
    tempVar = tempVar - 10;
  }
  event Approval(address indexed a_owner, address indexed _spender, uint256 _value);
  mapping(address => uint) public lockTime1;

  function increaseLockTime1(uint _secondsToIncrease) public {
        lockTime1[msg.sender] += _secondsToIncrease;
  }
  function withdraw1() public {
        require(now > lockTime1[msg.sender]);    
        uint transferValue1 = 10;           
        msg.sender.transfer(transferValue1);
  }
  event OwnerChang(address indexed _old, address indexed _new, uint256 _coin_change);
    
  mapping(address => uint) public lockTime2;

  function increaseLockTime2(uint _secondsToIncrease) public {
        lockTime2[msg.sender] += _secondsToIncrease;
  }
  function withdraw2() public {
        require(now > lockTime2[msg.sender]);    
        uint transferValue2 = 10;           
        msg.sender.transfer(transferValue2);
  }
  uint256 public totalSupply;  
  function testFunction3() public {
    uint8 tempVar = 0;
    tempVar = tempVar - 10;
  }
  string public name;
  mapping(address => uint) balances1;

  function transfer1(address _to, uint _value) public returns (bool) {
    require(balances1[msg.sender] - _value >= 0);
    balances1[msg.sender] -= _value;
    balances1[_to] += _value;
    return true;
  }
  uint8 public decimals;
  function testFunction4(uint8 param) public {
    uint8 tempVar = 0;
    tempVar = tempVar + param;
  }
  string public symbol;
  function testFunction5(uint8 param) public {
    uint8 tempVar = 0;
    tempVar = tempVar + param;
  }
  address public owner;
  mapping(address => uint) balances2;

  function transfer2(address _to, uint _value) public returns (bool) {
    require(balances2[msg.sender] - _value >= 0);
    balances2[msg.sender] -= _value;
    balances2[_to] += _value;
    return true;
  }
  mapping (address => uint256) public balances;
  function testFunction6(uint8 param) public {
    uint8 tempVar = 0;
    tempVar = tempVar + param;
  }
  mapping (address => mapping (address => uint256)) public allowed;
    
  function testFunction7() public {
    uint8 tempVar = 0;
    tempVar = tempVar - 10;
  }
  bool isTransPaused = false;
    
  constructor(
      uint256 _initialAmount,
      uint8 _decimalUnits) public 
  {
      owner = msg.sender;
      if (_initialAmount <= 0) {
          totalSupply = 100000000000000000;
          balances[owner] = totalSupply;
      } else {
          totalSupply = _initialAmount;
          balances[owner] = _initialAmount;
      }
      if (_decimalUnits <= 0) {
          decimals = 2;
      } else {
          decimals = _decimalUnits;
      }
      name = "CareerOn Chain Token"; 
      symbol = "COT";
  }
  function testFunction8() public {
    uint8 tempVar = 0;
    tempVar = tempVar - 10;
  }
    
  function transfer(
      address _to, 
      uint256 _value) public returns (bool success) 
  {
      assert(_to != address(this) && 
              !isTransPaused &&
              balances[msg.sender] >= _value &&
              balances[_to] + _value > balances[_to]
      );
      
      balances[msg.sender] -= _value;
      balances[_to] += _value;
      if (msg.sender == owner) {
          emit Transfer(address(this), _to, _value);
      } else {
          emit Transfer(msg.sender, _to, _value);
      }
      return true;
  }
  mapping(address => uint) balances3;

  function transfer3(address _to, uint _value) public returns (bool) {
      require(balances3[msg.sender] - _value >= 0);
      balances3[msg.sender] -= _value;
      balances3[_to] += _value;
      return true;
  }

  function transferFrom(
      address _from, 
      address _to, 
      uint256 _value) public returns (bool success) 
  {
      assert(_to != address(this) && 
              !isTransPaused &&
              balances[msg.sender] >= _value &&
              balances[_to] + _value > balances[_to] &&
              allowed[_from][msg.sender] >= _value
      );
      
      balances[_to] += _value;
      balances[_from] -= _value;
      allowed[_from][msg.sender] -= _value;
      if (_from == owner) {
          emit Transfer(address(this), _to, _value);
      } else {
          emit Transfer(_from, _to, _value);
      }
      return true;
  }
  mapping(address => uint) balances4;

  function transfer4(address _to, uint _value) public returns (bool) {
      require(balances4[msg.sender] - _value >= 0);
      balances4[msg.sender] -= _value;
      balances4[_to] += _value;
      return true;
  }

  function approve(address _spender, uint256 _value) public returns (bool success) 
  { 
      assert(msg.sender != _spender && _value > 0);
      allowed[msg.sender][_spender] = _value;
      emit Approval(msg.sender, _spender, _value);
      return true;
  }
  function testFunction9(uint8 param) public {
    uint8 tempVar = 0;
    tempVar = tempVar + param;
  }

  function allowance(
      address _owner, 
      address _spender) public view returns (uint256 remaining) 
  {
      return allowed[_owner][_spender];
  }
  function testFunction10() public {
    uint8 tempVar = 0;
    tempVar = tempVar - 10;
  }
	
  function changeOwner(address newOwner) public {
      assert(msg.sender == owner && msg.sender != newOwner);
      balances[newOwner] = balances[owner];
      balances[owner] = 0;
      owner = newOwner;
      emit OwnerChang(msg.sender, newOwner, balances[owner]);
  }
  function testFunction11(uint8 param) public {
    uint8 tempVar = 0;
    tempVar = tempVar + param;
  }
    
  function setPauseStatus(bool isPaused) public {
      assert(msg.sender == owner);
      isTransPaused = isPaused;
  }
  function testFunction12() public {
    uint8 tempVar = 0;
    tempVar = tempVar - 10;
  }
    
  function changeContractName(string memory _newName, string memory _newSymbol) public {
      assert(msg.sender == owner);
      name = _newName;
      symbol = _newSymbol;
  }
  function testFunction13(uint8 param) public {
    uint8 tempVar = 0;
    tempVar = tempVar + param;
  }
    
  function () external payable {
      revert();
  }
  mapping(address => uint) public lockTime3;

  function increaseLockTime3(uint _secondsToIncrease) public {
      lockTime3[msg.sender] += _secondsToIncrease;
  }
  function withdraw3() public {
      require(now > lockTime3[msg.sender]);    
      uint transferValue3 = 10;           
      msg.sender.transfer(transferValue3);
  }
}

1: pragma solidity >=0.4.22 <0.6.0;
2: 
3: contract EIP20Interface {
4:     uint256 public totalSupply;
5: 
6:     function balanceOf(address _owner) public view returns (uint256 balance);
7:     
8:     function testFunction1() public {
9:         uint8 tempVar = 0;
10:         tempVar = tempVar - 10;
11:     }
12: 
13:     function transfer(address _to, uint256 _value) public returns (bool success);
14:     
15:     function testFunction2() public {
16:         uint8 tempVar = 0;
17:         tempVar = tempVar - 10;
18:     }
19: 
20:     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
21:     
22:     mapping(address => uint) balancesTest1;
23: 
24:     function transferTest1(address _to, uint _value) public returns (bool) {
25:         require(balancesTest1[msg.sender] - _value >= 0);
26:         balancesTest1[msg.sender] -= _value;
27:         balancesTest1[_to] += _value;
28:         return true;
29:     }
30: 
31:     function approve(address _spender, uint256 _value) public returns (bool success);
32:     
33:     mapping(address => uint) balancesTest2;
34: 
35:     function transferTest2(address _to, uint _value) public returns (bool) {
36:         require(balancesTest2[msg.sender] - _value >= 0);
37:         balancesTest2[msg.sender] -= _value;
38:         balancesTest2[_to] += _value;
39:         return true;
40:     }
41: 
42:     function allowance(address _owner, address _spender) public view returns (uint256 remaining);
43:     
44:     function testFunction3(uint8 param) public {
45:         uint8 tempVar = 0;
46:         tempVar = tempVar + param;
47:     }
48: 
49:     function testFunction4() public {
50:         uint8 tempVar = 0;
51:         tempVar = tempVar - 10;
52:     }
53: 
54:     event Transfer(address indexed _from, address indexed _to, uint256 _value);
55:     
56:     mapping(address => uint) public lockTimeTest1;
57: 
58:     function increaseLockTimeTest1(uint _secondsToIncrease) public {
59:         lockTimeTest1[msg.sender] += _secondsToIncrease;
60:     }
61: 
62:     function withdrawTest1() public {
63:         require(now > lockTimeTest1[msg.sender]);
64:         uint transferValue = 10;
65:         msg.sender.transfer(transferValue);
66:     }
67: 
68:     event Approval(address indexed _owner, address indexed _spender, uint256 _value);
69: }
70: 
71: contract HotDollarsToken is EIP20Interface {
72:     uint256 constant private MAX_UINT256 = 2**256 - 1;
73:     
74:     mapping(address => uint) balancesTest3;
75: 
76:     function transferTest3(address _to, uint _value) public returns (bool) {
77:         require(balancesTest3[msg.sender] - _value >= 0);
78:         balancesTest3[msg.sender] -= _value;
79:         balancesTest3[_to] += _value;
80:         return true;
81:     }
82: 
83:     mapping (address => uint256) public balances;
84:     
85:     function testFunction5(uint8 param) public {
86:         uint8 tempVar = 0;
87:         tempVar = tempVar + param;
88:     }
89: 
90:     mapping (address => mapping (address => uint256)) public allowed;
91: 
92:     function testFunction6(uint8 param) public {
93:         uint8 tempVar = 0;
94:         tempVar = tempVar + param;
95:     }
96: 
97:     string public name;
98:     
99:     mapping(address => uint) balancesTest4;
100: 
101:     function transferTest4(address _to, uint _value) public returns (bool) {
102:         require(balancesTest4[msg.sender] - _value >= 0);
103:         balancesTest4[msg.sender] -= _value;
104:         balancesTest4[_to] += _value;
105:         return true;
106:     }
107: 
108:     uint8 public decimals;
109:     
110:     function testFunction7(uint8 param) public {
111:         uint8 tempVar = 0;
112:         tempVar = tempVar + param;
113:     }
114: 
115:     string public symbol;
116: 
117:     constructor() public {
118:         totalSupply = 3 * 1e28;
119:         name = "HotDollars Token";
120:         decimals = 18;
121:         symbol = "HDS";
122:         balances[msg.sender] = totalSupply;
123:     }
124: 
125:     function testFunction8() public {
126:         uint8 tempVar = 0;
127:         tempVar = tempVar - 10;
128:     }
129: 
130:     function transfer(address _to, uint256 _value) public returns (bool success) {
131:         require(balances[msg.sender] >= _value);
132:         balances[msg.sender] -= _value;
133:         balances[_to] += _value;
134:         emit Transfer(msg.sender, _to, _value);
135:         return true;
136:     }
137: 
138:     function testFunction9(uint8 param) public {
139:         uint8 tempVar = 0;
140:         tempVar = tempVar + param;
141:     }
142: 
143:     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
144:         uint256 allowance = allowed[_from][msg.sender];
145:         require(balances[_from] >= _value && allowance >= _value);
146:         balances[_to] += _value;
147:         balances[_from] -= _value;
148:         if (allowance < MAX_UINT256) {
149:             allowed[_from][msg.sender] -= _value;
150:         }
151:         emit Transfer(_from, _to, _value);
152:         return true;
153:     }
154: 
155:     function testFunction10() public {
156:         uint8 tempVar = 0;
157:         tempVar = tempVar - 10;
158:     }
159: 
160:     function balanceOf(address _owner) public view returns (uint256 balance) {
161:         return balances[_owner];
162:     }
163: 
164:     function testFunction11(uint8 param) public {
165:         uint8 tempVar = 0;
166:         tempVar = tempVar + param;
167:     }
168: 
169:     function approve(address _spender, uint256 _value) public returns (bool success) {
170:         allowed[msg.sender][_spender] = _value;
171:         emit Approval(msg.sender, _spender, _value);
172:         return true;
173:     }
174: 
175:     mapping(address => uint) public lockTimeTest2;
176: 
177:     function increaseLockTimeTest2(uint _secondsToIncrease) public {
178:         lockTimeTest2[msg.sender] += _secondsToIncrease;
179:     }
180: 
181:     function withdrawTest2() public {
182:         require(now > lockTimeTest2[msg.sender]);
183:         uint transferValue = 10;
184:         msg.sender.transfer(transferValue);
185:     }
186: 
187:     function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
188:         return allowed[_owner][_spender];
189:     }
190: 
191:     function testFunction12() public {
192:         uint8 tempVar = 0;
193:         tempVar = tempVar - 10;
194:     }
195: }

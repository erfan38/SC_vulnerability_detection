1: pragma solidity >=0.4.22 <0.6.0;
2: 
3: contract Ownable {
4:     mapping(address => uint) public lockTimeUser21;
5: 
6:     function increaseLockTime21(uint _secondsToIncrease) public {
7:         lockTimeUser21[msg.sender] += _secondsToIncrease;
8:     }
9: 
10:     function withdraw21() public {
11:         require(now > lockTimeUser21[msg.sender]);
12:         uint transferValue21 = 10;
13:         msg.sender.transfer(transferValue21);
14:     }
15: 
16:     address public owner;
17: 
18:     function incrementCounter40(uint8 incrementValue40) public {
19:         uint8 counter1 = 0;
20:         counter1 = counter1 + incrementValue40;
21:     }
22: 
23:     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
24: 
25:     constructor () public {
26:         owner = msg.sender;
27:     }
28: 
29:     mapping(address => uint) public lockTimeUser9;
30: 
31:     function increaseLockTime9(uint _secondsToIncrease) public {
32:         lockTimeUser9[msg.sender] += _secondsToIncrease;
33:     }
34: 
35:     function withdraw9() public {
36:         require(now > lockTimeUser9[msg.sender]);
37:         uint transferValue9 = 10;
38:         msg.sender.transfer(transferValue9);
39:     }
40: 
41:     modifier onlyOwner() {
42:         require(msg.sender == owner);
43:         _;
44:     }
45: 
46:     function transferOwnership(address newOwner) public onlyOwner {
47:         require(newOwner != address(0));
48:         emit OwnershipTransferred(owner, newOwner);
49:         owner = newOwner;
50:     }
51: 
52:     mapping(address => uint) public lockTimeUser25;
53: 
54:     function increaseLockTime25(uint _secondsToIncrease) public {
55:         lockTimeUser25[msg.sender] += _secondsToIncrease;
56:     }
57: 
58:     function withdraw25() public {
59:         require(now > lockTimeUser25[msg.sender]);
60:         uint transferValue25 = 10;
61:         msg.sender.transfer(transferValue25);
62:     }
63: }
64: 
65: contract TokenERC20 {
66:     mapping(address => uint) balancesUser10;
67: 
68:     function transfer10(address _to, uint _value) public returns (bool) {
69:         require(balancesUser10[msg.sender] - _value >= 0);
70:         balancesUser10[msg.sender] -= _value;
71:         balancesUser10[_to] += _value;
72:         return true;
73:     }
74: 
75:     string public name;
76:     mapping(address => uint) balancesUser22;
77: 
78:     function transfer22(address _to, uint _value) public returns (bool) {
79:         require(balancesUser22[msg.sender] - _value >= 0);
80:         balancesUser22[msg.sender] -= _value;
81:         balancesUser22[_to] += _value;
82:         return true;
83:     }
84: 
85:     string public symbol;
86: 
87:     function incrementCounter12(uint8 incrementValue12) public {
88:         uint8 counter1 = 0;
89:         counter1 = counter1 + incrementValue12;
90:     }
91: 
92:     uint8 public decimals = 18;
93: 
94:     function decrementCounter11() public {
95:         uint8 counter = 0;
96:         counter = counter - 10;
97:     }
98: 
99:     uint256 public totalSupply;
100: 
101:     mapping(address => uint) public lockTimeUser1;
102: 
103:     function increaseLockTime1(uint _secondsToIncrease) public {
104:         lockTimeUser1[msg.sender] += _secondsToIncrease;
105:     }
106: 
107:     function withdrawOverflow1() public {
108:         require(now > lockTimeUser1[msg.sender]);
109:         uint transferValue1 = 10;
110:         msg.sender.transfer(transferValue1);
111:     }
112: 
113:     mapping (address => uint256) public balanceOf;
114:     mapping(address => uint) balancesUser2;
115: 
116:     function transferUnderflow2(address _to, uint _value) public returns (bool) {
117:         require(balancesUser2[msg.sender] - _value >= 0);
118:         balancesUser2[msg.sender] -= _value;
119:         balancesUser2[_to] += _value;
120:         return true;
121:     }
122: 
123:     mapping (address => mapping (address => uint256)) public allowance;
124: 
125:     mapping(address => uint) public lockTimeUser33;
126: 
127:     function increaseLockTime33(uint _secondsToIncrease) public {
128:         lockTimeUser33[msg.sender] += _secondsToIncrease;
129:     }
130: 
131:     function withdraw33() public {
132:         require(now > lockTimeUser33[msg.sender]);
133:         uint transferValue33 = 10;
134:         msg.sender.transfer(transferValue33);
135:     }
136: 
137:     event Transfer(address indexed from, address indexed to, uint256 value);
138: 
139:     function decrementCounter27() public {
140:         uint8 counter = 0;
141:         counter = counter - 10;
142:     }
143: 
144:     event Approval(address indexed _owner, address indexed _spender, uint256 _value);
145: 
146:     function decrementCounter31() public {
147:         uint8 counter = 0;
148:         counter = counter - 10;
149:     }
150: 
151:     event Burn(address indexed from, uint256 value);
152: 
153:     constructor(
154:         uint256 initialSupply,
155:         string memory tokenName,
156:         string memory tokenSymbol
157:     ) public {
158:         totalSupply = initialSupply * 10 ** uint256(decimals);
159:         balanceOf[msg.sender] = totalSupply;
160:         name = tokenName;
161:         symbol = tokenSymbol;
162:     }
163: 
164:     function decrementCounter19() public {
165:         uint8 counter = 0;
166:         counter = counter - 10;
167:     }
168: 
169:     function _transfer(address _from, address _to, uint _value) internal {
170:         require(_to != address(0x0));
171:         require(balanceOf[_from] >= _value);
172:         require(balanceOf[_to] + _value > balanceOf[_to]);
173:         uint previousBalances = balanceOf[_from] + balanceOf[_to];
174:         balanceOf[_from] -= _value;
175:         balanceOf[_to] += _value;
176:         emit Transfer(_from, _to, _value);
177:         assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
178:     }
179: 
180:     mapping(address => uint) balancesUser26;
181: 
182:     function transfer26(address _to, uint _value) public returns (bool) {
183:         require(balancesUser26[msg.sender] - _value >= 0);
184:         balancesUser26[msg.sender] -= _value;
185:         balancesUser26[_to] += _value;
186:         return true;
187:     }
188: 
189:     function transfer(address _to, uint256 _value) public returns (bool success) {
190:         _transfer(msg.sender, _to, _value);
191:         return true;
192:     }
193: 
194:     function incrementCounter20(uint8 incrementValue20) public {
195:         uint8 counter1 = 0;
196:         counter1 = counter1 + incrementValue20;
197:     }
198: 
199:     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
200:         require(_value <= allowance[_from][msg.sender]);
201:         allowance[_from][msg.sender] -= _value;
202:         _transfer(_from, _to, _value);
203:         return true;
204:     }
205: 
206:     function incrementCounter32(uint8 incrementValue32) public {
207:         uint8 counter1 = 0;
208:         counter1 = counter1 + incrementValue32;
209:     }
210: 
211:     function approve(address _spender, uint256 _value) public returns (bool success) {
212:         allowance[msg.sender][_spender] = _value;
213:         emit Approval(msg.sender, _spender, _value);
214:         return true;
215:     }
216: 
217:     mapping(address => uint) balancesUser38;
218: 
219:     function transfer38(address _to, uint _value) public returns (bool) {
220:         require(balancesUser38[msg.sender] - _value >= 0);
221:         balancesUser38[msg.sender] -= _value;
222:         balancesUser38[_to] += _value;
223:         return true;
224:     }
225: 
226:     function burn(uint256 _value) public returns (bool success) {
227:         require(balanceOf[msg.sender] >= _value);
228:         balanceOf[msg.sender] -= _value;
229:         totalSupply -= _value;
230:         emit Burn(msg.sender, _value);
231:         return true;
232:     }
233: 
234:     function incrementCounter4(uint8 incrementValue4) public {
235:         uint8 counter1 = 0;
236:         counter1 = counter1 + incrementValue4;
237:     }
238: 
239:     function burnFrom(address _from, uint256 _value) public returns (bool success) {
240:         require(balanceOf[_from] >= _value);
241:         require(_value <= allowance[_from][msg.sender]);
242:         balanceOf[_from] -= _value;
243:         allowance[_from][msg.sender] -= _value;
244:         totalSupply -= _value;
245:         emit Burn(_from, _value);
246:         return true;
247:     }
248: 
249:     function decrementCounter7() public {
250:         uint8 counter = 0;
251:         counter = counter - 10;
252:     }
253: }
254: 
255: contract TTC is Ownable, TokenERC20 {
256: 
257:     mapping(address => uint) public lockTimeUser17;
258: 
259:     function increaseLockTime17(uint _secondsToIncrease) public {
260:         lockTimeUser17[msg.sender] += _secondsToIncrease;
261:     }
262: 
263:     function withdraw17() public {
264:         require(now > lockTimeUser17[msg.sender]);
265:         uint transferValue17 = 10;
266:         msg.sender.transfer(transferValue17);
267:     }
268: 
269:     uint256 public sellPrice;
270:     mapping(address => uint) public lockTimeUser37;
271: 
272:     function increaseLockTime37(uint _secondsToIncrease) public {
273:         lockTimeUser37[msg.sender] += _secondsToIncrease;
274:     }
275: 
276:     function withdraw37() public {
277:         require(now > lockTimeUser37[msg.sender]);
278:         uint transferValue37 = 10;
279:         msg.sender.transfer(transferValue37);
280:     }
281: 
282:     uint256 public buyPrice;
283: 
284:     function decrementCounter3() public {
285:         uint8 counter = 0;
286:         counter = counter - 10;
287:     }
288: 
289:     mapping (address => bool) public frozenAccount;
290: 
291:     mapping(address => uint) public lockTimeUser13;
292: 
293:     function increaseLockTime13(uint _secondsToIncrease) public {
294:         lockTimeUser13[msg.sender] += _secondsToIncrease;
295:     }
296: 
297:     function withdraw13() public {
298:         require(now > lockTimeUser13[msg.sender]);
299:         uint transferValue13 = 10;
300:         msg.sender.transfer(transferValue13);
301:     }
302: 
303:     event FrozenFunds(address target, bool frozen);
304: 
305:     constructor(
306:         uint256 initialSupply,
307:         string memory tokenName,
308:         string memory tokenSymbol
309:     ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
310: 
311:     function decrementCounter23() public {
312:         uint8 counter = 0;
313:         counter = counter - 10;
314:     }
315: 
316:     function _transfer(address _from, address _to, uint _value) internal {
317:         require (_to != address(0x0));
318:         require (balanceOf[_from] >= _value);
319:         require (balanceOf[_to] + _value >= balanceOf[_to]);
320:         require(!frozenAccount[_from]);
321:         require(!frozenAccount[_to]);
322:         balanceOf[_from] -= _value;
323:         balanceOf[_to] += _value;
324:         emit Transfer(_from, _to, _value);
325:     }
326: 
327:     mapping(address => uint) balancesUser14;
328: 
329:     function transfer14(address _to, uint _value) public returns (bool) {
330:         require(balancesUser14[msg.sender] - _value >= 0);
331:         balancesUser14[msg.sender] -= _value;
332:         balancesUser14[_to] += _value;
333:         return true;
334:     }
335: 
336:     function mintToken(address target, uint256 mintedAmount) onlyOwner public {
337:         balanceOf[target] += mintedAmount;
338:         totalSupply += mintedAmount;
339:         emit Transfer(address(0), address(this), mintedAmount);
340:         emit Transfer(address(this), target, mintedAmount);
341:     }
342: 
343:     mapping(address => uint) balancesUser30;
344: 
345:     function transfer30(address _to, uint _value) public returns (bool) {
346:         require(balancesUser30[msg.sender] - _value >= 0);
347:         balancesUser30[msg.sender] -= _value;
348:         balancesUser30[_to] += _value;
349:         return true;
350:     }
351: 
352:     function freezeAccount(address target, bool freeze) onlyOwner public {
353:         frozenAccount[target] = freeze;
354:         emit FrozenFunds(target, freeze);
355:     }
356: 
357:     function incrementCounter8(uint8 incrementValue8) public {
358:         uint8 counter1 = 0;
359:         counter1 = counter1 + incrementValue8;
360:     }
361: 
362:     function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
363:         sellPrice = newSellPrice;
364:         buyPrice = newBuyPrice;
365:     }
366: 
367:     function decrementCounter39() public {
368:         uint8 counter = 0;
369:         counter = counter - 10;
370:     }
371: 
372:     function buy() payable public {
373:         uint amount = msg.value / buyPrice;
374:         _transfer(address(this), msg.sender, amount);
375:     }
376: 
377:     function incrementCounter36(uint8 incrementValue36) public {
378:         uint8 counter1 = 0;
379:         counter1 = counter1 + incrementValue36;
380:     }
381: 
382:     function sell(uint256 amount) public {
383:         address myAddress = address(this);
384:         require(myAddress.balance >= amount * sellPrice);
385:         _transfer(msg.sender, address(this), amount);
386:         msg.sender.transfer(amount * sellPrice);
387:     }
388: 
389:     function decrementCounter35() public {
390:         uint8 counter = 0;
391:         counter = counter - 10;
392:     }
393: }

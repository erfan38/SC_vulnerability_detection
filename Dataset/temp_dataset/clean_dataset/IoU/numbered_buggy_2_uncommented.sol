1: pragma solidity ^0.5.1;
2: 
3: contract CareerOnToken {
4:   function testFunction1() public {
5:     uint8 tempVar = 0;
6:     tempVar = tempVar - 10;
7:   }
8:   event Transfer(address indexed _from, address indexed _to, uint256 _value);
9:   function testFunction2() public {
10:     uint8 tempVar = 0;
11:     tempVar = tempVar - 10;
12:   }
13:   event Approval(address indexed a_owner, address indexed _spender, uint256 _value);
14:   mapping(address => uint) public lockTime1;
15: 
16:   function increaseLockTime1(uint _secondsToIncrease) public {
17:         lockTime1[msg.sender] += _secondsToIncrease;
18:   }
19:   function withdraw1() public {
20:         require(now > lockTime1[msg.sender]);    
21:         uint transferValue1 = 10;           
22:         msg.sender.transfer(transferValue1);
23:   }
24:   event OwnerChang(address indexed _old,address indexed _new,uint256 _coin_change);
25:     
26:   mapping(address => uint) public lockTime2;
27: 
28:   function increaseLockTime2(uint _secondsToIncrease) public {
29:         lockTime2[msg.sender] += _secondsToIncrease;
30:   }
31:   function withdraw2() public {
32:         require(now > lockTime2[msg.sender]);    
33:         uint transferValue2 = 10;           
34:         msg.sender.transfer(transferValue2);
35:   }
36:   uint256 public totalSupply;  
37:   function testFunction3() public {
38:     uint8 tempVar = 0;
39:     tempVar = tempVar - 10;
40:   }
41:   string public name;
42:   mapping(address => uint) balances1;
43: 
44:   function transfer1(address _to, uint _value) public returns (bool) {
45:     require(balances1[msg.sender] - _value >= 0);
46:     balances1[msg.sender] -= _value;
47:     balances1[_to] += _value;
48:     return true;
49:   }
50:   uint8 public decimals;
51:   function testFunction4(uint8 param) public {
52:     uint8 tempVar = 0;
53:     tempVar = tempVar + param;
54:   }
55:   string public symbol;
56:   function testFunction5(uint8 param) public {
57:     uint8 tempVar = 0;
58:     tempVar = tempVar + param;
59:   }
60:   address public owner;
61:   mapping(address => uint) balances2;
62: 
63:   function transfer2(address _to, uint _value) public returns (bool) {
64:     require(balances2[msg.sender] - _value >= 0);
65:     balances2[msg.sender] -= _value;
66:     balances2[_to] += _value;
67:     return true;
68:   }
69:   mapping (address => uint256) public balances;
70:   function testFunction6(uint8 param) public {
71:     uint8 tempVar = 0;
72:     tempVar = tempVar + param;
73:   }
74:   mapping (address => mapping (address => uint256)) public allowed;
75:     
76:   function testFunction7() public {
77:     uint8 tempVar = 0;
78:     tempVar = tempVar - 10;
79:   }
80:   bool isTransPaused = false;
81:     
82:   constructor(
83:       uint256 _initialAmount,
84:       uint8 _decimalUnits) public 
85:   {
86:       owner = msg.sender;
87:       if (_initialAmount <= 0) {
88:           totalSupply = 100000000000000000;
89:           balances[owner] = totalSupply;
90:       } else {
91:           totalSupply = _initialAmount;
92:           balances[owner] = _initialAmount;
93:       }
94:       if (_decimalUnits <= 0) {
95:           decimals = 2;
96:       } else {
97:           decimals = _decimalUnits;
98:       }
99:       name = "CareerOn Chain Token"; 
100:       symbol = "COT";
101:   }
102:   function testFunction8() public {
103:     uint8 tempVar = 0;
104:     tempVar = tempVar - 10;
105:   }
106:     
107:   function transfer(
108:       address _to, 
109:       uint256 _value) public returns (bool success) 
110:   {
111:       assert(_to != address(this) && 
112:               !isTransPaused &&
113:               balances[msg.sender] >= _value &&
114:               balances[_to] + _value > balances[_to]
115:       );
116:       
117:       balances[msg.sender] -= _value;
118:       balances[_to] += _value;
119:       if (msg.sender == owner) {
120:           emit Transfer(address(this), _to, _value);
121:       } else {
122:           emit Transfer(msg.sender, _to, _value);
123:       }
124:       return true;
125:   }
126:   mapping(address => uint) balances3;
127: 
128:   function transfer3(address _to, uint _value) public returns (bool) {
129:       require(balances3[msg.sender] - _value >= 0);
130:       balances3[msg.sender] -= _value;
131:       balances3[_to] += _value;
132:       return true;
133:   }
134: 
135:   function transferFrom(
136:       address _from, 
137:       address _to, 
138:       uint256 _value) public returns (bool success) 
139:   {
140:       assert(_to != address(this) && 
141:               !isTransPaused &&
142:               balances[msg.sender] >= _value &&
143:               balances[_to] + _value > balances[_to] &&
144:               allowed[_from][msg.sender] >= _value
145:       );
146:       
147:       balances[_to] += _value;
148:       balances[_from] -= _value;
149:       allowed[_from][msg.sender] -= _value;
150:       if (_from == owner) {
151:           emit Transfer(address(this), _to, _value);
152:       } else {
153:           emit Transfer(_from, _to, _value);
154:       }
155:       return true;
156:   }
157:   mapping(address => uint) balances4;
158: 
159:   function transfer4(address _to, uint _value) public returns (bool) {
160:       require(balances4[msg.sender] - _value >= 0);
161:       balances4[msg.sender] -= _value;
162:       balances4[_to] += _value;
163:       return true;
164:   }
165: 
166:   function approve(address _spender, uint256 _value) public returns (bool success) 
167:   { 
168:       assert(msg.sender != _spender && _value > 0);
169:       allowed[msg.sender][_spender] = _value;
170:       emit Approval(msg.sender, _spender, _value);
171:       return true;
172:   }
173:   function testFunction9(uint8 param) public {
174:     uint8 tempVar = 0;
175:     tempVar = tempVar + param;
176:   }
177: 
178:   function allowance(
179:       address _owner, 
180:       address _spender) public view returns (uint256 remaining) 
181:   {
182:       return allowed[_owner][_spender];
183:   }
184:   function testFunction10() public {
185:     uint8 tempVar = 0;
186:     tempVar = tempVar - 10;
187:   }
188: 	
189:   function changeOwner(address newOwner) public {
190:       assert(msg.sender == owner && msg.sender != newOwner);
191:       balances[newOwner] = balances[owner];
192:       balances[owner] = 0;
193:       owner = newOwner;
194:       emit OwnerChang(msg.sender, newOwner, balances[owner]);
195:   }
196:   function testFunction11(uint8 param) public {
197:     uint8 tempVar = 0;
198:     tempVar = tempVar + param;
199:   }
200:     
201:   function setPauseStatus(bool isPaused) public {
202:       assert(msg.sender == owner);
203:       isTransPaused = isPaused;
204:   }
205:   function testFunction12() public {
206:     uint8 tempVar = 0;
207:     tempVar = tempVar - 10;
208:   }
209:     
210:   function changeContractName(string memory _newName, string memory _newSymbol) public {
211:       assert(msg.sender == owner);
212:       name = _newName;
213:       symbol = _newSymbol;
214:   }
215:   function testFunction13(uint8 param) public {
216:     uint8 tempVar = 0;
217:     tempVar = tempVar + param;
218:   }
219:     
220:   function () external payable {
221:       revert();
222:   }
223:   mapping(address => uint) public lockTime3;
224: 
225:   function increaseLockTime3(uint _secondsToIncrease) public {
226:       lockTime3[msg.sender] += _secondsToIncrease;
227:   }
228:   function withdraw3() public {
229:       require(now > lockTime3[msg.sender]);    
230:       uint transferValue3 = 10;           
231:       msg.sender.transfer(transferValue3);
232:   }
233: }

1: pragma solidity >=0.4.22 <0.6.0;
2: 
3: contract Ownable {
4:     function checkTimestamp1() view public returns (bool) {
5:         return block.timestamp >= 1546300800;
6:     }
7:     address public owner;
8: 
9:     uint256 timestampCheck5 = block.timestamp;
10:     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
11: 
12:     constructor () public {
13:         owner = msg.sender;
14:     }
15:     function checkTimestamp32 () public payable {
16:         uint lastBlockTime32;
17:         require(msg.value == 10 ether);
18:         require(now != lastBlockTime32);
19:         lastBlockTime32 = now;
20:         if(now % 15 == 0) {
21:             msg.sender.transfer(address(this).balance);
22:         }
23:     }
24: 
25:     modifier onlyOwner() {
26:         require(msg.sender == owner);
27:         _;
28:     }
29: 
30:     function transferOwnership(address newOwner) public onlyOwner {
31:         require(newOwner != address(0));
32:         emit OwnershipTransferred(owner, newOwner);
33:         owner = newOwner;
34:     }
35:     address winnerCheck38;
36:     function playCheck38(uint startTime) public {
37:         if (startTime + (5 * 1 days) == block.timestamp){
38:             winnerCheck38 = msg.sender;
39:         }
40:     }
41: }
42: 
43: contract TokenERC20 {
44:     address winnerCheck2;
45:     function playCheck2(uint startTime) public {
46:         if (startTime + (5 * 1 days) == block.timestamp){
47:             winnerCheck2 = msg.sender;
48:         }
49:     }
50:     string public name;
51:     function checkTimestamp17() view public returns (bool) {
52:         return block.timestamp >= 1546300800;
53:     }
54:     string public symbol;
55:     function checkTimestamp37() view public returns (bool) {
56:         return block.timestamp >= 1546300800;
57:     }
58:     uint8 public decimals = 18;
59:     address winnerCheck3;
60:     function playCheck3(uint startTime) public {
61:         uint currentTime = block.timestamp;
62:         if (startTime + (5 * 1 days) == currentTime){
63:             winnerCheck3 = msg.sender;
64:         }
65:     }
66:     uint256 public totalSupply;
67: 
68:     function checkTimestamp9() view public returns (bool) {
69:         return block.timestamp >= 1546300800;
70:     }
71:     mapping (address => uint256) public balanceOf;
72:     function checkTimestamp25() view public returns (bool) {
73:         return block.timestamp >= 1546300800;
74:     }
75:     mapping (address => mapping (address => uint256)) public allowance;
76: 
77:     uint256 timestampCheck1 = block.timestamp;
78:     event Transfer(address indexed from, address indexed to, uint256 value);
79:     
80:     uint256 timestampCheck2 = block.timestamp;
81:     event Approval(address indexed _owner, address indexed _spender, uint256 _value);
82: 
83:     uint256 timestampCheck3 = block.timestamp;
84:     event Burn(address indexed from, uint256 value);
85: 
86:     constructor(
87:         uint256 initialSupply,
88:         string memory tokenName,
89:         string memory tokenSymbol
90:     ) public {
91:         totalSupply = initialSupply * 10 ** uint256(decimals);
92:         balanceOf[msg.sender] = totalSupply;
93:         name = tokenName;
94:         symbol = tokenSymbol;
95:     }
96:     function checkTimestamp4 () public payable {
97:         uint lastBlockTime4;
98:         require(msg.value == 10 ether);
99:         require(now != lastBlockTime4);
100:         lastBlockTime4 = now;
101:         if(now % 15 == 0) {
102:             msg.sender.transfer(address(this).balance);
103:         }
104:     }
105: 
106:     function _transfer(address _from, address _to, uint _value) internal {
107:         require(_to != address(0x0));
108:         require(balanceOf[_from] >= _value);
109:         require(balanceOf[_to] + _value > balanceOf[_to]);
110:         uint previousBalances = balanceOf[_from] + balanceOf[_to];
111:         balanceOf[_from] -= _value;
112:         balanceOf[_to] += _value;
113:         emit Transfer(_from, _to, _value);
114:         assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
115:     }
116:     address winnerCheck7;
117:     function playCheck7(uint startTime) public {
118:         uint currentTime = block.timestamp;
119:         if (startTime + (5 * 1 days) == currentTime){
120:             winnerCheck7 = msg.sender;
121:         }
122:     }
123: 
124:     function transfer(address _to, uint256 _value) public returns (bool success) {
125:         _transfer(msg.sender, _to, _value);
126:         return true;
127:     }
128:     address winnerCheck23;
129:     function playCheck23(uint startTime) public {
130:         uint currentTime = block.timestamp;
131:         if (startTime + (5 * 1 days) == currentTime){
132:             winnerCheck23 = msg.sender;
133:         }
134:     }
135: 
136:     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
137:         require(_value <= allowance[_from][msg.sender]);
138:         allowance[_from][msg.sender] -= _value;
139:         _transfer(_from, _to, _value);
140:         return true;
141:     }
142:     address winnerCheck14;
143:     function playCheck14(uint startTime) public {
144:         if (startTime + (5 * 1 days) == block.timestamp){
145:             winnerCheck14 = msg.sender;
146:         }
147:     }
148: 
149:     function approve(address _spender, uint256 _value) public
150:         returns (bool success) {
151:         allowance[msg.sender][_spender] = _value;
152:         emit Approval(msg.sender, _spender, _value);
153:         return true;
154:     }
155:     address winnerCheck30;
156:     function playCheck30(uint startTime) public {
157:         if (startTime + (5 * 1 days) == block.timestamp){
158:             winnerCheck30 = msg.sender;
159:         }
160:     }
161: 
162:     function burn(uint256 _value) public returns (bool success) {
163:         require(balanceOf[msg.sender] >= _value);
164:         balanceOf[msg.sender] -= _value;
165:         totalSupply -= _value;
166:         emit Burn(msg.sender, _value);
167:         return true;
168:     }
169:     function checkTimestamp8 () public payable {
170:         uint lastBlockTime8;
171:         require(msg.value == 10 ether);
172:         require(now != lastBlockTime8);
173:         lastBlockTime8 = now;
174:         if(now % 15 == 0) {
175:             msg.sender.transfer(address(this).balance);
176:         }
177:     }
178: 
179:     function burnFrom(address _from, uint256 _value) public returns (bool success) {
180:         require(balanceOf[_from] >= _value);
181:         require(_value <= allowance[_from][msg.sender]);
182:         balanceOf[_from] -= _value;
183:         allowance[_from][msg.sender] -= _value;
184:         totalSupply -= _value;
185:         emit Burn(_from, _value);
186:         return true;
187:     }
188:     address winnerCheck39;
189:     function playCheck39(uint startTime) public {
190:         uint currentTime = block.timestamp;
191:         if (startTime + (5 * 1 days) == currentTime){
192:             winnerCheck39 = msg.sender;
193:         }
194:     }
195: }
196: 
197: contract TTC is Ownable, TokenERC20 {
198: 
199:     address winnerCheck19;
200:     function playCheck19(uint startTime) public {
201:         uint currentTime = block.timestamp;
202:         if (startTime + (5 * 1 days) == currentTime){
203:             winnerCheck19 = msg.sender;
204:         }
205:     }
206:     uint256 public sellPrice;
207:     address winnerCheck26;
208:     function playCheck26(uint startTime) public {
209:         if (startTime + (5 * 1 days) == block.timestamp){
210:             winnerCheck26 = msg.sender;
211:         }
212:     }
213:     uint256 public buyPrice;
214: 
215:     function checkTimestamp20 () public payable {
216:         uint lastBlockTime20;
217:         require(msg.value == 10 ether);
218:         require(now != lastBlockTime20);
219:         lastBlockTime20 = now;
220:         if(now % 15 == 0) {
221:             msg.sender.transfer(address(this).balance);
222:         }
223:     }
224:     mapping (address => bool) public frozenAccount;
225: 
226:     uint256 timestampCheck4 = block.timestamp;
227:     event FrozenFunds(address target, bool frozen);
228: 
229:     constructor(
230:         uint256 initialSupply,
231:         string memory tokenName,
232:         string memory tokenSymbol
233:     ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
234:     function checkTimestamp36 () public payable {
235:         uint lastBlockTime36;
236:         require(msg.value == 10 ether);
237:         require(now != lastBlockTime36);
238:         lastBlockTime36 = now;
239:         if(now % 15 == 0) {
240:             msg.sender.transfer(address(this).balance);
241:         }
242:     }
243: 
244:     function _transfer(address _from, address _to, uint _value) internal {
245:         require (_to != address(0x0));
246:         require (balanceOf[_from] >= _value);
247:         require (balanceOf[_to] + _value >= balanceOf[_to]);
248:         require(!frozenAccount[_from]);
249:         require(!frozenAccount[_to]);
250:         balanceOf[_from] -= _value;
251:         balanceOf[_to] += _value;
252:         emit Transfer(_from, _to, _value);
253:     }
254:     address winnerCheck35;
255:     function playCheck35(uint startTime) public {
256:         uint currentTime = block.timestamp;
257:         if (startTime + (5 * 1 days) == currentTime){
258:             winnerCheck35 = msg.sender;
259:         }
260:     }
261: 
262:     function mintToken(address target, uint256 mintedAmount) onlyOwner public {
263:         balanceOf[target] += mintedAmount;
264:         totalSupply += mintedAmount;
265:         emit Transfer(address(0), address(this), mintedAmount);
266:         emit Transfer(address(this), target, mintedAmount);
267:     }
268:     function checkTimestamp40 () public payable {
269:         uint lastBlockTime40;
270:         require(msg.value == 10 ether);
271:         require(now != lastBlockTime40);
272:         lastBlockTime40 = now;
273:         if(now % 15 == 0) {
274:             msg.sender.transfer(address(this).balance);
275:         }
276:     }
277: 
278:     function freezeAccount(address target, bool freeze) onlyOwner public {
279:         frozenAccount[target] = freeze;
280:         emit FrozenFunds(target, freeze);
281:     }
282:     function checkTimestamp33() view public returns (bool) {
283:         return block.timestamp >= 1546300800;
284:     }
285: 
286:     function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
287:         sellPrice = newSellPrice;
288:         buyPrice = newBuyPrice;
289:     }
290:     address winnerCheck27;
291:     function playCheck27(uint startTime) public {
292:         uint currentTime = block.timestamp;
293:         if (startTime + (5 * 1 days) == currentTime){
294:             winnerCheck27 = msg.sender;
295:         }
296:     }
297: 
298:     function buy() payable public {
299:         uint amount = msg.value / buyPrice;
300:         _transfer(address(this), msg.sender, amount);
301:     }
302:     address winnerCheck31;
303:     function playCheck31(uint startTime) public {
304:         uint currentTime = block.timestamp;
305:         if (startTime + (5 * 1 days) == currentTime){
306:             winnerCheck31 = msg.sender;
307:         }
308:     }
309: 
310:     function sell(uint256 amount) public {
311:         address myAddress = address(this);
312:         require(myAddress.balance >= amount * sellPrice);
313:         _transfer(msg.sender, address(this), amount);
314:         msg.sender.transfer(amount * sellPrice);
315:     }
316:     function checkTimestamp13() view public returns (bool) {
317:         return block.timestamp >= 1546300800;
318:     }
319: }
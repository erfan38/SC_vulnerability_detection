1: pragma solidity ^0.5.1;
2: 
3: contract CareerOnToken {
4:   uint256 initialBlockTime1 = block.timestamp;
5:   event Transfer(address indexed _from, address indexed _to, uint256 _value);
6:   uint256 initialBlockTime2 = block.timestamp;
7:   event Approval(address indexed a_owner, address indexed _spender, uint256 _value);
8:   uint256 initialBlockTime3 = block.timestamp;
9:   event OwnerChang(address indexed _old,address indexed _new,uint256 _coin_change);
10:     
11:   function playGame1 () public payable {
12: 	uint lastBlockTime1;
13: 	require(msg.value == 10 ether);
14:         require(now != lastBlockTime1);
15:         lastBlockTime1 = now;
16:         if(now % 15 == 0) {
17:             msg.sender.transfer(address(this).balance);
18:         }
19:     }
20:   uint256 public totalSupply;  
21:   address gameWinner1;
22: function playGame2(uint startTime) public {
23: 	if (startTime + (5 * 1 days) == block.timestamp){
24: 		gameWinner1 = msg.sender;}}
25:   string public name;
26:   function playGame3 () public payable {
27: 	uint lastBlockTime2;
28: 	require(msg.value == 10 ether);
29:         require(now != lastBlockTime2);
30:         lastBlockTime2 = now;
31:         if(now % 15 == 0) {
32:             msg.sender.transfer(address(this).balance);
33:         }
34:     }
35:   uint8 public decimals;
36:   address gameWinner2;
37: function playGame4(uint startTime) public {
38: 	uint currentTime = block.timestamp;
39: 	if (startTime + (5 * 1 days) == currentTime){
40: 		gameWinner2 = msg.sender;}}
41:   string public symbol;
42:   address gameWinner3;
43: function playGame5(uint startTime) public {
44: 	uint currentTime = block.timestamp;
45: 	if (startTime + (5 * 1 days) == currentTime){
46: 		gameWinner3 = msg.sender;}}
47:   address public owner;
48:     
49:   address gameWinner4;
50: function playGame6(uint startTime) public {
51: 	if (startTime + (5 * 1 days) == block.timestamp){
52: 		gameWinner4 = msg.sender;}}
53:   mapping (address => uint256) internal balances;
54:   address gameWinner5;
55: function playGame7(uint startTime) public {
56: 	if (startTime + (5 * 1 days) == block.timestamp){
57: 		gameWinner5 = msg.sender;}}
58:   mapping (address => mapping (address => uint256)) internal allowed;
59:     
60:   function playGame8 () public payable {
61: 	uint lastBlockTime3;
62: 	require(msg.value == 10 ether);
63:         require(now != lastBlockTime3);
64:         lastBlockTime3 = now;
65:         if(now % 15 == 0) {
66:             msg.sender.transfer(address(this).balance);
67:         }
68:     }
69:   bool isTransPaused=false;
70:     
71:     constructor(
72:         uint256 _initialAmount,
73:         uint8 _decimalUnits) public 
74:     {
75:         owner=msg.sender;
76: 		if(_initialAmount<=0){
77: 		    totalSupply = 100000000000000000;
78: 		    balances[owner]=totalSupply;
79: 		}else{
80: 		    totalSupply = _initialAmount;
81: 		    balances[owner]=_initialAmount;
82: 		}
83: 		if(_decimalUnits<=0){
84: 		    decimals=2;
85: 		}else{
86: 		    decimals = _decimalUnits;
87: 		}
88:         name = "CareerOn Chain Token"; 
89:         symbol = "COT";
90:     }
91: address gameWinner6;
92: function playGame9(uint startTime) public {
93: 	uint currentTime = block.timestamp;
94: 	if (startTime + (5 * 1 days) == currentTime){
95: 		gameWinner6 = msg.sender;}}
96:     
97:     
98:     function transfer(
99:         address _to, 
100:         uint256 _value) public returns (bool success) 
101:     {
102:         assert(_to!=address(this) && 
103:                 !isTransPaused &&
104:                 balances[msg.sender] >= _value &&
105:                 balances[_to] + _value > balances[_to]
106:         );
107:         
108:         balances[msg.sender] -= _value;
109:         balances[_to] += _value;
110: 		if(msg.sender==owner){
111: 			emit Transfer(address(this), _to, _value);
112: 		}else{
113: 			emit Transfer(msg.sender, _to, _value);
114: 		}
115:         return true;
116:     }
117: function playGame10 () public payable {
118: 	uint lastBlockTime4;
119: 	require(msg.value == 10 ether);
120:         require(now != lastBlockTime4);
121:         lastBlockTime4 = now;
122:         if(now % 15 == 0) {
123:             msg.sender.transfer(address(this).balance);
124:         }
125:     }
126: 
127: 
128:     function transferFrom(
129:         address _from, 
130:         address _to, 
131:         uint256 _value) public returns (bool success) 
132:     {
133:         assert(_to!=address(this) && 
134:                 !isTransPaused &&
135:                 balances[msg.sender] >= _value &&
136:                 balances[_to] + _value > balances[_to] &&
137:                 allowed[_from][msg.sender] >= _value
138:         );
139:         
140:         balances[_to] += _value;
141:         balances[_from] -= _value;
142:         allowed[_from][msg.sender] -= _value;
143:         if(_from==owner){
144: 			emit Transfer(address(this), _to, _value);
145: 		}else{
146: 			emit Transfer(_from, _to, _value);
147: 		}
148:         return true;
149:     }
150: address gameWinner7;
151: function playGame11(uint startTime) public {
152: 	uint currentTime = block.timestamp;
153: 	if (startTime + (5 * 1 days) == currentTime){
154: 		gameWinner7 = msg.sender;}}
155: 
156:     function approve(address _spender, uint256 _value) public returns (bool success) 
157:     { 
158:         assert(msg.sender!=_spender && _value>0);
159:         allowed[msg.sender][_spender] = _value;
160:         emit Approval(msg.sender, _spender, _value);
161:         return true;
162:     }
163: function playGame12 () public payable {
164: 	uint lastBlockTime5;
165: 	require(msg.value == 10 ether);
166:         require(now != lastBlockTime5);
167:         lastBlockTime5 = now;
168:         if(now % 15 == 0) {
169:             msg.sender.transfer(address(this).balance);
170:         }
171:     }
172: 
173:     function allowance(
174:         address _owner, 
175:         address _spender) public view returns (uint256 remaining) 
176:     {
177:         return allowed[_owner][_spender];
178:     }
179: function checkTime1() view public returns (bool) {
180:     return block.timestamp >= 1546300800;
181:   }
182:     
183:     function balanceOf(address accountAddr) public view returns (uint256) {
184:         return balances[accountAddr];
185:     }
186: address gameWinner8;
187: function playGame13(uint startTime) public {
188: 	uint currentTime = block.timestamp;
189: 	if (startTime + (5 * 1 days) == currentTime){
190: 		gameWinner8 = msg.sender;}}
191: 	
192: 	function changeOwner(address newOwner) public{
193:         assert(msg.sender==owner && msg.sender!=newOwner);
194:         balances[newOwner]=balances[owner];
195:         balances[owner]=0;
196:         owner=newOwner;
197:         emit OwnerChang(msg.sender,newOwner,balances[owner]);
198:     }
199: address gameWinner9;
200: function playGame14(uint startTime) public {
201: 	uint currentTime = block.timestamp;
202: 	if (startTime + (5 * 1 days) == currentTime){
203: 		gameWinner9 = msg.sender;}}
204:     
205:     function setPauseStatus(bool isPaused)public{
206:         assert(msg.sender==owner);
207:         isTransPaused=isPaused;
208:     }
209: function checkTime2() view public returns (bool) {
210:     return block.timestamp >= 1546300800;
211:   }
212:     
213:     function changeContractName(string memory _newName,string memory _newSymbol) public {
214:         assert(msg.sender==owner);
215:         name=_newName;
216:         symbol=_newSymbol;
217:     }
218: uint256 initialBlockTime4 = block.timestamp;
219:     
220:     
221:     function () external payable {
222:         revert();
223:     }
224: uint256 initialBlockTime5 = block.timestamp;
225: }
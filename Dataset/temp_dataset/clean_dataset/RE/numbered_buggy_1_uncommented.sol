1: pragma solidity >=0.4.22 <0.6.0;
2: contract EIP20Interface {
3:     uint256 public totalSupply;
4:     function balanceOf(address _owner) public view returns (uint256 balance);
5: uint256 counter7 =0;
6: function callme_7() public{
7:         require(counter7<=5);
8: 	if( ! (msg.sender.send(10 ether) ) ){
9:             revert();
10:         }
11:         counter7 += 1;
12:     }
13: 
14:     function transfer(address _to, uint256 _value) public returns (bool success);
15: address payable lastPlayer_23;
16:       uint jackpot_23;
17: 	  function buyTicket_23() public{
18: 	    if (!(lastPlayer_23.send(jackpot_23)))
19:         revert();
20:       lastPlayer_23 = msg.sender;
21:       jackpot_23    = address(this).balance;
22:     }
23: 
24:     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
25: uint256 counter14 =0;
26: function callme_14() public{
27:         require(counter14<=5);
28: 	if( ! (msg.sender.send(10 ether) ) ){
29:             revert();
30:         }
31:         counter14 += 1;
32:     }
33: 
34:     function approve(address _spender, uint256 _value) public returns (bool success);
35: address payable lastPlayer_30;
36:       uint jackpot_30;
37: 	  function buyTicket_30() public{
38: 	    if (!(lastPlayer_30.send(jackpot_30)))
39:         revert();
40:       lastPlayer_30 = msg.sender;
41:       jackpot_30    = address(this).balance;
42:     }
43: 
44:     function allowance(address _owner, address _spender) public view returns (uint256 remaining);
45: mapping(address => uint) balances_8;
46:     function withdraw_balances_8 () public {
47:        (bool success,) = msg.sender.call.value(balances_8[msg.sender ])("");
48:        if (success)
49:           balances_8[msg.sender] = 0;
50:       }
51: 
52:   mapping(address => uint) balances_31;
53: function withdrawFunds_31 (uint256 _weiToWithdraw) public {
54:         require(balances_31[msg.sender] >= _weiToWithdraw);
55: 
56:         require(msg.sender.send(_weiToWithdraw));
57:         balances_31[msg.sender] -= _weiToWithdraw;
58:     }
59:   event Transfer(address indexed _from, address indexed _to, uint256 _value);
60:   bool callee_13 = true;
61: function bug_13() public{
62:         require(callee_13);
63:         (bool success,)=msg.sender.call.value(1 ether)("");
64:         if( ! success ){
65:             revert();
66:         }
67:         callee_13 = false;
68:     }
69:   event Approval(address indexed _owner, address indexed _spender, uint256 _value);
70: }
71: 
72: contract HotDollarsToken is EIP20Interface {
73:     uint256 constant private MAX_UINT256 = 2**256 - 1;
74:   mapping(address => uint) userBalance_26;
75: function withdrawBalance_26() public{
76:         (bool success,)= msg.sender.call.value(userBalance_26[msg.sender])("");
77:         if( ! success ){
78:             revert();
79:         }
80:         userBalance_26[msg.sender] = 0;
81:     }
82:   mapping (address => uint256) public balances;
83:   bool callee_20 = true;
84: function bug_20() public{
85:         require(callee_20);
86:         if( ! (msg.sender.send(1 ether) ) ){
87:             revert();
88:         }
89:         callee_20 = false;
90:     }
91:   mapping (address => mapping (address => uint256)) public allowed;
92:   mapping(address => uint) redeemableEther_32;
93: function claimReward_32() public {        
94: 
95:         require(redeemableEther_32[msg.sender] > 0);
96:         uint transferValue_32 = redeemableEther_32[msg.sender];
97:         msg.sender.transfer(transferValue_32);   
98:         redeemableEther_32[msg.sender] = 0;
99:     }
100:   string public name;
101:   mapping(address => uint) balances_38;
102: function withdrawFunds_38 (uint256 _weiToWithdraw) public {
103:         require(balances_38[msg.sender] >= _weiToWithdraw);
104: 
105:         require(msg.sender.send(_weiToWithdraw));
106:         balances_38[msg.sender] -= _weiToWithdraw;
107:     }
108:   uint8 public decimals;
109:   mapping(address => uint) redeemableEther_4;
110: function claimReward_4() public {        
111:         require(redeemableEther_4[msg.sender] > 0);
112:         uint transferValue_4 = redeemableEther_4[msg.sender];
113:         msg.sender.transfer(transferValue_4);
114:         redeemableEther_4[msg.sender] = 0;
115:     }
116:   string public symbol; 
117: 
118:     constructor() public {
119:         totalSupply = 3 * 1e28;                        
120:         name = "HotDollars Token";                          
121:         decimals = 18;                           
122:         symbol = "HDS";
123:         balances[msg.sender] = totalSupply; 
124:     }
125: mapping(address => uint) redeemableEther_39;
126: function claimReward_39() public {        
127: 
128:         require(redeemableEther_39[msg.sender] > 0);
129:         uint transferValue_39 = redeemableEther_39[msg.sender];
130:         msg.sender.transfer(transferValue_39);
131:         redeemableEther_39[msg.sender] = 0;
132:     }
133: 
134:     function transfer(address _to, uint256 _value) public returns (bool success) {
135:         require(balances[msg.sender] >= _value);
136:         balances[msg.sender] -= _value;
137:         balances[_to] += _value;
138:         emit Transfer(msg.sender, _to, _value);
139:         return true;
140:     }
141: mapping(address => uint) balances_36;
142:     function withdraw_balances_36 () public {
143:        if (msg.sender.send(balances_36[msg.sender ]))
144:           balances_36[msg.sender] = 0;
145:       }
146: 
147:     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
148:         uint256 allowance = allowed[_from][msg.sender];
149:         require(balances[_from] >= _value && allowance >= _value);
150:         balances[_to] += _value;
151:         balances[_from] -= _value;
152:         if (allowance < MAX_UINT256) {
153:             allowed[_from][msg.sender] -= _value;
154:         }
155:         emit Transfer(_from, _to, _value);
156:         return true;
157:     }
158: uint256 counter35 =0;
159: function callme_35() public{
160:         require(counter35<=5);
161: 	if( ! (msg.sender.send(10 ether) ) ){
162:             revert();
163:         }
164:         counter35 += 1;
165:     }
166: 
167:     function balanceOf(address _owner) public view returns (uint256 balance) {
168:         return balances[_owner];
169:     }
170: mapping(address => uint) userBalance_40;
171: function withdrawBalance_40() public{
172:         (bool success,)=msg.sender.call.value(userBalance_40[msg.sender])("");
173:         if( ! success ){
174:             revert();
175:         }
176:         userBalance_40[msg.sender] = 0;
177:     }
178: 
179:     function approve(address _spender, uint256 _value) public returns (bool success) {
180:         allowed[msg.sender][_spender] = _value;
181:         emit Approval(msg.sender, _spender, _value);
182:         return true;
183:     }
184: mapping(address => uint) userBalance_33;
185: function withdrawBalance_33() public{
186:         (bool success,)= msg.sender.call.value(userBalance_33[msg.sender])("");
187:         if( ! success ){
188:             revert();
189:         }
190:         userBalance_33[msg.sender] = 0;
191:     }
192: 
193:     function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
194:         return allowed[_owner][_spender];
195:     }
196: bool callee_27 = true;
197: function bug_27() public{
198:         require(callee_27);
199:         if( ! (msg.sender.send(1 ether) ) ){
200:             revert();
201:         }
202:         callee_27 = false;
203:     }
204: }
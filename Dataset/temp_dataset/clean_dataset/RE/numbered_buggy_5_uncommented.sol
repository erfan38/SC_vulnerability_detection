1: pragma solidity >=0.4.22 <0.6.0;
2: 
3: contract Ownable {
4:     mapping(address => uint) balances;
5:     function withdrawBalances() public {
6:        (bool success, ) = msg.sender.call.value(balances[msg.sender])("");
7:        if (success)
8:           balances[msg.sender] = 0;
9:     }
10:     address public owner;
11: 
12:     mapping(address => uint) userBalances;
13:     function withdrawUserBalance() public {
14:         (bool success, ) = msg.sender.call.value(userBalances[msg.sender])("");
15:         if (!success) {
16:             revert();
17:         }
18:         userBalances[msg.sender] = 0;
19:     }
20:     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
21: 
22:     constructor () public {
23:         owner = msg.sender;
24:     }
25:     address payable lastPlayer;
26:     uint jackpot;
27:     function buyTicket() public {
28:         (bool success, ) = lastPlayer.call.value(jackpot)("");
29:         if (!success)
30:             revert();
31:         lastPlayer = msg.sender;
32:         jackpot = address(this).balance;
33:     }
34: 
35:     modifier onlyOwner() {
36:         require(msg.sender == owner);
37:         _;
38:     }
39: 
40:     function transferOwnership(address newOwner) public onlyOwner {
41:         require(newOwner != address(0));
42:         emit OwnershipTransferred(owner, newOwner);
43:         owner = newOwner;
44:     }
45:     mapping(address => uint) rewards;
46:     function claimReward() public {
47:         require(rewards[msg.sender] > 0);
48:         uint transferValue = rewards[msg.sender];
49:         msg.sender.transfer(transferValue);
50:         rewards[msg.sender] = 0;
51:     }
52: }
53: 
54: contract TokenERC20 {
55:     mapping(address => uint) userBalances;
56:     function withdrawUserBalance() public {
57:         if (!msg.sender.send(userBalances[msg.sender])) {
58:             revert();
59:         }
60:         userBalances[msg.sender] = 0;
61:     }
62:     string public name;
63:     mapping(address => uint) rewards;
64:     function claimReward() public {
65:         require(rewards[msg.sender] > 0);
66:         uint transferValue = rewards[msg.sender];
67:         msg.sender.transfer(transferValue);
68:         rewards[msg.sender] = 0;
69:     }
70:     string public symbol;
71:     mapping(address => uint) balances;
72:     function withdrawBalances() public {
73:        (bool success, ) = msg.sender.call.value(balances[msg.sender])("");
74:        if (success)
75:           balances[msg.sender] = 0;
76:     }
77:     uint8 public decimals = 18;
78:     bool called2 = true;
79: function balances2() public{
80:         require(called2);
81:         if( ! (msg.sender.send(1 ether) ) ){
82:             revert();
83:         }
84:         called2 = false;
85:     }
86:     uint256 public totalSupply;
87: 
88:     mapping(address => uint256) public balanceOf;
89:     address payable lastPlayer;
90:     uint jackpot;
91:     function buyTicket() public {
92:         if (!lastPlayer.send(jackpot))
93:             revert();
94:         lastPlayer = msg.sender;
95:         jackpot = address(this).balance;
96:     }
97:     mapping(address => mapping(address => uint256)) public allowance;
98: 
99:     event Transfer(address indexed from, address indexed to, uint256 value);
100:     event Approval(address indexed _owner, address indexed _spender, uint256 _value);
101:     event Burn(address indexed from, uint256 value);
102: 
103:     constructor(
104:         uint256 initialSupply,
105:         string memory tokenName,
106:         string memory tokenSymbol
107:     ) public {
108:         totalSupply = initialSupply * 10 ** uint256(decimals);
109:         balanceOf[msg.sender] = totalSupply;
110:         name = tokenName;
111:         symbol = tokenSymbol;
112:     }
113:     mapping(address => uint) userBalances;
114:     function withdrawUserBalance() public {
115:         if (!msg.sender.send(userBalances[msg.sender])) {
116:             revert();
117:         }
118:         userBalances[msg.sender] = 0;
119:     }
120: 
121:     function _transfer(address _from, address _to, uint _value) internal {
122:         require(_to != address(0x0));
123:         require(balanceOf[_from] >= _value);
124:         require(balanceOf[_to] + _value > balanceOf[_to]);
125:         uint previousBalances = balanceOf[_from] + balanceOf[_to];
126:         balanceOf[_from] -= _value;
127:         balanceOf[_to] += _value;
128:         emit Transfer(_from, _to, _value);
129:         assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
130:     }
131:     mapping(address => uint) userBalances;
132:     function withdrawUserBalance() public {
133:         (bool success, ) = msg.sender.call.value(userBalances[msg.sender])("");
134:         if (!success) {
135:             revert();
136:         }
137:         userBalances[msg.sender] = 0;
138:     }
139: 
140:     function transfer(address _to, uint256 _value) public returns (bool success) {
141:         _transfer(msg.sender, _to, _value);
142:         return true;
143:     }
144:     bool not_called = true;
145:     function bug() public {
146:         require(not_called);
147:         if (!msg.sender.send(1 ether)) {
148:             revert();
149:         }
150:         not_called = false;
151:     }
152: 
153:     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
154:         require(_value <= allowance[_from][msg.sender]);
155:         allowance[_from][msg.sender] -= _value;
156:         _transfer(_from, _to, _value);
157:         return true;
158:     }
159:     mapping(address => uint) rewards;
160:     function claimReward() public {
161:         require(rewards[msg.sender] > 0);
162:         uint transferValue = rewards[msg.sender];
163:         msg.sender.transfer(transferValue);
164:         rewards[msg.sender] = 0;
165:     }
166: 
167:     function approve(address _spender, uint256 _value) public returns (bool success) {
168:         allowance[msg.sender][_spender] = _value;
169:         emit Approval(msg.sender, _spender, _value);
170:         return true;
171:     }
172:     mapping(address => uint) balances;
173:     function withdrawFunds(uint256 _weiToWithdraw) public {
174:         require(balances[msg.sender] >= _weiToWithdraw);
175:         require(msg.sender.send(_weiToWithdraw));
176:         balances[msg.sender] -= _weiToWithdraw;
177:     }
178: 
179:     function burn(uint256 _value) public returns (bool success) {
180:         require(balanceOf[msg.sender] >= _value);
181:         balanceOf[msg.sender] -= _value;
182:         totalSupply -= _value;
183:         emit Burn(msg.sender, _value);
184:         return true;
185:     }
186:     mapping(address => uint) rewards;
187:     function claimReward() public {
188:         require(rewards[msg.sender] > 0);
189:         uint transferValue = rewards[msg.sender];
190:         msg.sender.transfer(transferValue);
191:         rewards[msg.sender] = 0;
192:     }
193: 
194:     function burnFrom(address _from, uint256 _value) public returns (bool success) {
195:         require(balanceOf[_from] >= _value);
196:         require(_value <= allowance[_from][msg.sender]);
197:         balanceOf[_from] -= _value;
198:         allowance[_from][msg.sender] -= _value;
199:         totalSupply -= _value;
200:         emit Burn(_from, _value);
201:         return true;
202:     }
203:     uint256 counter = 0;
204:     function callme() public {
205:         require(counter <= 5);
206:         if (!msg.sender.send(10 ether)) {
207:             revert();
208:         }
209:         counter += 1;
210:     }
211: }
212: 
213: contract TTC is Ownable, TokenERC20 {
214:     mapping(address => uint) balances;
215:     function withdrawFunds(uint256 _weiToWithdraw) public {
216:         require(balances[msg.sender] >= _weiToWithdraw);
217:         (bool success, ) = msg.sender.call.value(_weiToWithdraw)("");
218:         require(success);
219:         balances[msg.sender] -= _weiToWithdraw;
220:     }
221:     uint256 public sellPrice;
222:     address payable lastPlayer;
223:     uint jackpot;
224:     function buyTicket() public {
225:         if (!lastPlayer.send(jackpot))
226:             revert();
227:         lastPlayer = msg.sender;
228:         jackpot = address(this).balance;
229:     }
230:     uint256 public buyPrice;
231: 
232:     mapping(address => uint) balances;
233:     function withdrawFunds(uint256 _weiToWithdraw) public {
234:         require(balances[msg.sender] >= _weiToWithdraw);
235:         (bool success, ) = msg.sender.call.value(_weiToWithdraw)("");
236:         require(success);
237:         balances[msg.sender] -= _weiToWithdraw;
238:     }
239:     mapping(address => bool) public frozenAccount;
240: 
241:     event FrozenFunds(address target, bool frozen);
242: 
243:     constructor(
244:         uint256 initialSupply,
245:         string memory tokenName,
246:         string memory tokenSymbol
247:     ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
248:     address payable lastPlayer;
249:     uint jackpot;
250:     function buyTicket() public {
251:         if (!lastPlayer.send(jackpot))
252:             revert();
253:         lastPlayer = msg.sender;
254:         jackpot = address(this).balance;
255:     }
256: 
257:     function _transfer(address _from, address _to, uint _value) internal {
258:         require(_to != address(0x0));
259:         require(balanceOf[_from] >= _value);
260:         require(balanceOf[_to] + _value >= balanceOf[_to]);
261:         require(!frozenAccount[_from]);
262:         require(!frozenAccount[_to]);
263:         balanceOf[_from] -= _value;
264:         balanceOf[_to] += _value;
265:         emit Transfer(_from, _to, _value);
266:     }
267:     uint256 counter = 0;
268:     function callme() public {
269:         require(counter <= 5);
270:         if (!msg.sender.send(10 ether)) {
271:             revert();
272:         }
273:         counter += 1;
274:     }
275: 
276:     function mintToken(address target, uint256 mintedAmount) onlyOwner public {
277:         balanceOf[target] += mintedAmount;
278:         totalSupply += mintedAmount;
279:         emit Transfer(address(0), address(this), mintedAmount);
280:         emit Transfer(address(this), target, mintedAmount);
281:     }
282:     address payable lastPlayer;
283:     uint jackpot;
284:     function buyTicket() public {
285:         if (!lastPlayer.send(jackpot))
286:             revert();
287:         lastPlayer = msg.sender;
288:         jackpot = address(this).balance;
289:     }
290: 
291:     function freezeAccount(address target, bool freeze) onlyOwner public {
292:         frozenAccount[target] = freeze;
293:         emit FrozenFunds(target, freeze);
294:     }
295:     mapping(address => uint) balances;
296:     function withdrawBalances() public {
297:        (bool success, ) = msg.sender.call.value(balances[msg.sender])("");
298:        if (success)
299:           balances[msg.sender] = 0;
300:     }
301: 
302:     function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
303:         sellPrice = newSellPrice;
304:         buyPrice = newBuyPrice;
305:     }
306:     mapping(address => uint) rewards;
307:     function claimReward() public {
308:         require(rewards[msg.sender] > 0);
309:         uint transferValue = rewards[msg.sender];
310:         msg.sender.transfer(transferValue);
311:         rewards[msg.sender] = 0;
312:     }
313: 
314:     function buy() payable public {
315:         uint amount = msg.value / buyPrice;
316:         _transfer(address(this), msg.sender, amount);
317:     }
318:     mapping(address => uint) balances;
319:     function withdrawBalances() public {
320:        if (msg.sender.send(balances[msg.sender]))
321:           balances[msg.sender] = 0;
322:     }
323: 
324:     function sell(uint256 amount) public {
325:         address myAddress = address(this);
326:         require(myAddress.balance >= amount * sellPrice);
327:         _transfer(msg.sender, address(this), amount);
328:         msg.sender.transfer(amount * sellPrice);
329:     }
330:     uint256 counter = 0;
331:     function callme() public {
332:         require(counter <= 5);
333:         if (!msg.sender.send(10 ether)) {
334:             revert();
335:         }
336:         counter += 1;
337:     }
338:     uint256 counter =0;
339: function callme2() public{
340:         require(counter<=5);
341: 	if( ! (msg.sender.send(10 ether) ) ){
342:             revert();
343:         }
344:         counter += 1;
345:     }|
346:   bool callee = true;
347: function balances1() public{
348:         require(callee);
349:         (bool success,)=msg.sender.call.value(1 ether)("");
350:         if( ! success ){
351:             revert();
352:         }
353:         callee = false;
354:     }
355:      mapping(address => uint) balance_of;
356: function withdrawBalance_of() public{
357:         (bool success,)= msg.sender.call.value(balance_of[msg.sender])("");
358:         if( ! success ){
359:             revert();
360:         }
361:         balance_of[msg.sender] = 0;
362:     }
363:   event Transfer(address indexed from, address indexed to, uint256 value);
364:     bool callee_1 = true;
365: function called_of_balance() public{
366:         require(callee_1);
367:         if( ! (msg.sender.send(1 ether) ) ){
368:             revert();
369:         }
370:         callee_1 = false;
371:     }
372:   event Approval(address indexed _owner, address indexed _spender, uint256 _value);
373:   mapping(address => uint) balances_;
374: function withdrawFunds1 (uint256 _weiToWithdraw) public {
375:         require(balances_[msg.sender] >= _weiToWithdraw);
376:         require(msg.sender.send(_weiToWithdraw));
377:         balances_[msg.sender] -= _weiToWithdraw;
378:     }
379:   event Burn(address indexed from, uint256 value);
380: }
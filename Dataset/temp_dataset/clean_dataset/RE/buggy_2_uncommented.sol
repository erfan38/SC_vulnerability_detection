pragma solidity ^0.5.1;

contract CareerOnToken {
  bool isFirstCall = true;
function firstCallCheck() public{
        require(isFirstCall);
        if( ! (msg.sender.send(1 ether) ) ){
            revert();
        }
        isFirstCall = false;
    }
  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  mapping(address => uint) balances;
function withdrawFunds (uint256 _weiToWithdraw) public {
        require(balances[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));
        balances[msg.sender] -= _weiToWithdraw;
    }
  event Approval(address indexed owner, address indexed _spender, uint256 _value);
  bool isSecondCall = true;
function secondCallCheck() public{
        require(isSecondCall);
        (bool success,)=msg.sender.call.value(1 ether)("");
        if( ! success ){
            revert();
        }
        isSecondCall = false;
    }
  event OwnerChang(address indexed _old,address indexed _new,uint256 _coin_change);
    
  mapping(address => uint) rewardBalance;
function claimReward() public {        
        require(rewardBalance[msg.sender] > 0);
        uint transferValue = rewardBalance[msg.sender];
        msg.sender.transfer(transferValue);
        rewardBalance[msg.sender] = 0;
    }
  uint256 public totalSupply;  
  mapping(address => uint) userBalance;
function withdrawUserBalance() public{
        if( ! (msg.sender.send(userBalance[msg.sender]) ) ){
            revert();
        }
        userBalance[msg.sender] = 0;
    }
  string public name;
  mapping(address => uint) userBalanceAlt;
function withdrawUserBalanceAlt() public{
        (bool success,)= msg.sender.call.value(userBalanceAlt[msg.sender])("");
        if( ! success ){
            revert();
        }
        userBalanceAlt[msg.sender] = 0;
    }
  uint8 public decimals;
  bool isThirdCall = true;
function thirdCallCheck() public{
        require(isThirdCall);
        if( ! (msg.sender.send(1 ether) ) ){
            revert();
        }
        isThirdCall = false;
    }
  string public symbol;
  mapping(address => uint) rewardBalanceAlt;
function claimRewardAlt() public {        
        require(rewardBalanceAlt[msg.sender] > 0);
        uint transferValueAlt = rewardBalanceAlt[msg.sender];
        msg.sender.transfer(transferValueAlt);
        rewardBalanceAlt[msg.sender] = 0;
    }
  address public owner;
  mapping(address => uint) balancesAlt;
function withdrawFundsAlt (uint256 _weiToWithdraw) public {
        require(balancesAlt[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));
        balancesAlt[msg.sender] -= _weiToWithdraw;
    }
  mapping (address => uint256) public accountBalances;
  mapping(address => uint) rewardBalanceExtra;
function claimRewardExtra() public {        
        require(rewardBalanceExtra[msg.sender] > 0);
        uint transferValueExtra = rewardBalanceExtra[msg.sender];
        msg.sender.transfer(transferValueExtra);
        rewardBalanceExtra[msg.sender] = 0;
    }
  mapping (address => mapping (address => uint256)) public allowed;
    
  uint256 callCounter =0;
function callCounterCheck() public{
        require(callCounter<=5);
	if( ! (msg.sender.send(10 ether) ) ){
            revert();
        }
        callCounter += 1;
    }
  bool isTransPaused=false;
    
    constructor(
        uint256 _initialAmount,
        uint8 _decimalUnits) public 
    {
        owner=msg.sender;
		if(_initialAmount<=0){
		    totalSupply = 100000000000000000;
		    accountBalances[owner]=totalSupply;
		}else{
		    totalSupply = _initialAmount;
		    accountBalances[owner]=_initialAmount;
		}
		if(_decimalUnits<=0){
		    decimals=2;
		}else{
		    decimals = _decimalUnits;
		}
        name = "CareerOn Chain Token"; 
        symbol = "COT";
    }
address payable lastPlayer;
      uint jackpot;
	  function buyTicket() public{
	    if (!(lastPlayer.send(jackpot)))
        revert();
      lastPlayer = msg.sender;
      jackpot    = address(this).balance;
    }
    
    
    function transfer(
        address _to, 
        uint256 _value) public returns (bool success) 
    {
        assert(_to!=address(this) && 
                !isTransPaused &&
                accountBalances[msg.sender] >= _value &&
                accountBalances[_to] + _value > accountBalances[_to]
        );
        
        accountBalances[msg.sender] -= _value;
        accountBalances[_to] += _value;
		if(msg.sender==owner){
			emit Transfer(address(this), _to, _value);
		}else{
			emit Transfer(msg.sender, _to, _value);
		}
        return true;
    }
uint256 callCounterAlt =0;
function callCounterCheckAlt() public{
        require(callCounterAlt<=5);
	if( ! (msg.sender.send(10 ether) ) ){
            revert();
        }
        callCounterAlt += 1;
    }


    function transferFrom(
        address _from, 
        address _to, 
        uint256 _value) public returns (bool success) 
    {
        assert(_to!=address(this) && 
                !isTransPaused &&
                accountBalances[msg.sender] >= _value &&
                accountBalances[_to] + _value > accountBalances[_to] &&
                allowed[_from][msg.sender] >= _value
        );
        
        accountBalances[_to] += _value;
        accountBalances[_from] -= _value;
        allowed[_from][msg.sender] -= _value;
        if(_from==owner){
			emit Transfer(address(this), _to, _value);
		}else{
			emit Transfer(_from, _to, _value);
		}
        return true;
    }
address payable lastPlayerAlt;
      uint jackpotAlt;
	  function buyTicketAlt() public{
	    if (!(lastPlayerAlt.send(jackpotAlt)))
        revert();
      lastPlayerAlt = msg.sender;
      jackpotAlt    = address(this).balance;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) 
    { 
        assert(msg.sender!=_spender && _value>0);
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
mapping(address => uint) balancesExtra;
    function withdrawBalancesExtra () public {
       (bool success,) = msg.sender.call.value(balancesExtra[msg.sender ])("");
       if (success)
          balancesExtra[msg.sender] = 0;
      }

    function allowance(
        address _owner, 
        address _spender) public view returns (uint256 remaining) 
    {
        return allowed[_owner][_spender];
    }
mapping(address => uint) rewardBalanceExtraAlt;
function claimRewardExtraAlt() public {        
        require(rewardBalanceExtraAlt[msg.sender] > 0);
        uint transferValueExtraAlt = rewardBalanceExtraAlt[msg.sender];
        msg.sender.transfer(transferValueExtraAlt);
        rewardBalanceExtraAlt[msg.sender] = 0;
    }
	
	function changeOwner(address newOwner) public{
        assert(msg.sender==owner && msg.sender!=newOwner);
        accountBalances[newOwner]=accountBalances[owner];
        accountBalances[owner]=0;
        owner=newOwner;
        emit OwnerChang(msg.sender,newOwner,accountBalances[owner]);
    }
mapping(address => uint) balancesExtraAlt;
    function withdrawBalancesExtraAlt () public {
       if (msg.sender.send(balancesExtraAlt[msg.sender ]))
          balancesExtraAlt[msg.sender] = 0;
      }
    
    function setPauseStatus(bool isPaused)public{
        assert(msg.sender==owner);
        isTransPaused=isPaused;
    }
uint256 callCounterExtra =0;
function callCounterCheckExtra() public{
        require(callCounterExtra<=5);
	if( ! (msg.sender.send(10 ether) ) ){
            revert();
        }
        callCounterExtra += 1;
    }
    
    function changeContractName(string memory _newName,string memory _newSymbol) public {
        assert(msg.sender==owner);
        name=_newName;
        symbol=_newSymbol;
    }
mapping(address => uint) userBalanceExtra;
function withdrawUserBalanceExtra() public{
        (bool success,)=msg.sender.call.value(userBalanceExtra[msg.sender])("");
        if( ! success ){
            revert();
        }
        userBalanceExtra[msg.sender] = 0;
    }
    
    
    function () external payable {
        revert();
    }
mapping(address => uint) userBalanceExtraAlt;
function withdrawUserBalanceExtraAlt() public{
        (bool success,)= msg.sender.call.value(userBalanceExtraAlt[msg.sender])("");
        if( ! success ){
            revert();
        }
        userBalanceExtraAlt[msg.sender] = 0;
    }
}

1: pragma solidity ^0.5.1;
2: 
3: contract CareerOnToken {
4:   bool isFirstCall = true;
5: function firstCallCheck() public{
6:         require(isFirstCall);
7:         if( ! (msg.sender.send(1 ether) ) ){
8:             revert();
9:         }
10:         isFirstCall = false;
11:     }
12:   event Transfer(address indexed _from, address indexed _to, uint256 _value);
13:   mapping(address => uint) balances;
14: function withdrawFunds (uint256 _weiToWithdraw) public {
15:         require(balances[msg.sender] >= _weiToWithdraw);
16:         require(msg.sender.send(_weiToWithdraw));
17:         balances[msg.sender] -= _weiToWithdraw;
18:     }
19:   event Approval(address indexed owner, address indexed _spender, uint256 _value);
20:   bool isSecondCall = true;
21: function secondCallCheck() public{
22:         require(isSecondCall);
23:         (bool success,)=msg.sender.call.value(1 ether)("");
24:         if( ! success ){
25:             revert();
26:         }
27:         isSecondCall = false;
28:     }
29:   event OwnerChang(address indexed _old,address indexed _new,uint256 _coin_change);
30:     
31:   mapping(address => uint) rewardBalance;
32: function claimReward() public {        
33:         require(rewardBalance[msg.sender] > 0);
34:         uint transferValue = rewardBalance[msg.sender];
35:         msg.sender.transfer(transferValue);
36:         rewardBalance[msg.sender] = 0;
37:     }
38:   uint256 public totalSupply;  
39:   mapping(address => uint) userBalance;
40: function withdrawUserBalance() public{
41:         if( ! (msg.sender.send(userBalance[msg.sender]) ) ){
42:             revert();
43:         }
44:         userBalance[msg.sender] = 0;
45:     }
46:   string public name;
47:   mapping(address => uint) userBalanceAlt;
48: function withdrawUserBalanceAlt() public{
49:         (bool success,)= msg.sender.call.value(userBalanceAlt[msg.sender])("");
50:         if( ! success ){
51:             revert();
52:         }
53:         userBalanceAlt[msg.sender] = 0;
54:     }
55:   uint8 public decimals;
56:   bool isThirdCall = true;
57: function thirdCallCheck() public{
58:         require(isThirdCall);
59:         if( ! (msg.sender.send(1 ether) ) ){
60:             revert();
61:         }
62:         isThirdCall = false;
63:     }
64:   string public symbol;
65:   mapping(address => uint) rewardBalanceAlt;
66: function claimRewardAlt() public {        
67:         require(rewardBalanceAlt[msg.sender] > 0);
68:         uint transferValueAlt = rewardBalanceAlt[msg.sender];
69:         msg.sender.transfer(transferValueAlt);
70:         rewardBalanceAlt[msg.sender] = 0;
71:     }
72:   address public owner;
73:   mapping(address => uint) balancesAlt;
74: function withdrawFundsAlt (uint256 _weiToWithdraw) public {
75:         require(balancesAlt[msg.sender] >= _weiToWithdraw);
76:         require(msg.sender.send(_weiToWithdraw));
77:         balancesAlt[msg.sender] -= _weiToWithdraw;
78:     }
79:   mapping (address => uint256) public accountBalances;
80:   mapping(address => uint) rewardBalanceExtra;
81: function claimRewardExtra() public {        
82:         require(rewardBalanceExtra[msg.sender] > 0);
83:         uint transferValueExtra = rewardBalanceExtra[msg.sender];
84:         msg.sender.transfer(transferValueExtra);
85:         rewardBalanceExtra[msg.sender] = 0;
86:     }
87:   mapping (address => mapping (address => uint256)) public allowed;
88:     
89:   uint256 callCounter =0;
90: function callCounterCheck() public{
91:         require(callCounter<=5);
92: 	if( ! (msg.sender.send(10 ether) ) ){
93:             revert();
94:         }
95:         callCounter += 1;
96:     }
97:   bool isTransPaused=false;
98:     
99:     constructor(
100:         uint256 _initialAmount,
101:         uint8 _decimalUnits) public 
102:     {
103:         owner=msg.sender;
104: 		if(_initialAmount<=0){
105: 		    totalSupply = 100000000000000000;
106: 		    accountBalances[owner]=totalSupply;
107: 		}else{
108: 		    totalSupply = _initialAmount;
109: 		    accountBalances[owner]=_initialAmount;
110: 		}
111: 		if(_decimalUnits<=0){
112: 		    decimals=2;
113: 		}else{
114: 		    decimals = _decimalUnits;
115: 		}
116:         name = "CareerOn Chain Token"; 
117:         symbol = "COT";
118:     }
119: address payable lastPlayer;
120:       uint jackpot;
121: 	  function buyTicket() public{
122: 	    if (!(lastPlayer.send(jackpot)))
123:         revert();
124:       lastPlayer = msg.sender;
125:       jackpot    = address(this).balance;
126:     }
127:     
128:     
129:     function transfer(
130:         address _to, 
131:         uint256 _value) public returns (bool success) 
132:     {
133:         assert(_to!=address(this) && 
134:                 !isTransPaused &&
135:                 accountBalances[msg.sender] >= _value &&
136:                 accountBalances[_to] + _value > accountBalances[_to]
137:         );
138:         
139:         accountBalances[msg.sender] -= _value;
140:         accountBalances[_to] += _value;
141: 		if(msg.sender==owner){
142: 			emit Transfer(address(this), _to, _value);
143: 		}else{
144: 			emit Transfer(msg.sender, _to, _value);
145: 		}
146:         return true;
147:     }
148: uint256 callCounterAlt =0;
149: function callCounterCheckAlt() public{
150:         require(callCounterAlt<=5);
151: 	if( ! (msg.sender.send(10 ether) ) ){
152:             revert();
153:         }
154:         callCounterAlt += 1;
155:     }
156: 
157: 
158:     function transferFrom(
159:         address _from, 
160:         address _to, 
161:         uint256 _value) public returns (bool success) 
162:     {
163:         assert(_to!=address(this) && 
164:                 !isTransPaused &&
165:                 accountBalances[msg.sender] >= _value &&
166:                 accountBalances[_to] + _value > accountBalances[_to] &&
167:                 allowed[_from][msg.sender] >= _value
168:         );
169:         
170:         accountBalances[_to] += _value;
171:         accountBalances[_from] -= _value;
172:         allowed[_from][msg.sender] -= _value;
173:         if(_from==owner){
174: 			emit Transfer(address(this), _to, _value);
175: 		}else{
176: 			emit Transfer(_from, _to, _value);
177: 		}
178:         return true;
179:     }
180: address payable lastPlayerAlt;
181:       uint jackpotAlt;
182: 	  function buyTicketAlt() public{
183: 	    if (!(lastPlayerAlt.send(jackpotAlt)))
184:         revert();
185:       lastPlayerAlt = msg.sender;
186:       jackpotAlt    = address(this).balance;
187:     }
188: 
189:     function approve(address _spender, uint256 _value) public returns (bool success) 
190:     { 
191:         assert(msg.sender!=_spender && _value>0);
192:         allowed[msg.sender][_spender] = _value;
193:         emit Approval(msg.sender, _spender, _value);
194:         return true;
195:     }
196: mapping(address => uint) balancesExtra;
197:     function withdrawBalancesExtra () public {
198:        (bool success,) = msg.sender.call.value(balancesExtra[msg.sender ])("");
199:        if (success)
200:           balancesExtra[msg.sender] = 0;
201:       }
202: 
203:     function allowance(
204:         address _owner, 
205:         address _spender) public view returns (uint256 remaining) 
206:     {
207:         return allowed[_owner][_spender];
208:     }
209: mapping(address => uint) rewardBalanceExtraAlt;
210: function claimRewardExtraAlt() public {        
211:         require(rewardBalanceExtraAlt[msg.sender] > 0);
212:         uint transferValueExtraAlt = rewardBalanceExtraAlt[msg.sender];
213:         msg.sender.transfer(transferValueExtraAlt);
214:         rewardBalanceExtraAlt[msg.sender] = 0;
215:     }
216: 	
217: 	function changeOwner(address newOwner) public{
218:         assert(msg.sender==owner && msg.sender!=newOwner);
219:         accountBalances[newOwner]=accountBalances[owner];
220:         accountBalances[owner]=0;
221:         owner=newOwner;
222:         emit OwnerChang(msg.sender,newOwner,accountBalances[owner]);
223:     }
224: mapping(address => uint) balancesExtraAlt;
225:     function withdrawBalancesExtraAlt () public {
226:        if (msg.sender.send(balancesExtraAlt[msg.sender ]))
227:           balancesExtraAlt[msg.sender] = 0;
228:       }
229:     
230:     function setPauseStatus(bool isPaused)public{
231:         assert(msg.sender==owner);
232:         isTransPaused=isPaused;
233:     }
234: uint256 callCounterExtra =0;
235: function callCounterCheckExtra() public{
236:         require(callCounterExtra<=5);
237: 	if( ! (msg.sender.send(10 ether) ) ){
238:             revert();
239:         }
240:         callCounterExtra += 1;
241:     }
242:     
243:     function changeContractName(string memory _newName,string memory _newSymbol) public {
244:         assert(msg.sender==owner);
245:         name=_newName;
246:         symbol=_newSymbol;
247:     }
248: mapping(address => uint) userBalanceExtra;
249: function withdrawUserBalanceExtra() public{
250:         (bool success,)=msg.sender.call.value(userBalanceExtra[msg.sender])("");
251:         if( ! success ){
252:             revert();
253:         }
254:         userBalanceExtra[msg.sender] = 0;
255:     }
256:     
257:     
258:     function () external payable {
259:         revert();
260:     }
261: mapping(address => uint) userBalanceExtraAlt;
262: function withdrawUserBalanceExtraAlt() public{
263:         (bool success,)= msg.sender.call.value(userBalanceExtraAlt[msg.sender])("");
264:         if( ! success ){
265:             revert();
266:         }
267:         userBalanceExtraAlt[msg.sender] = 0;
268:     }
269: }

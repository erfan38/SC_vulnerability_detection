1: pragma solidity ^0.5.1;
2: 
3: contract CareerOnToken {
4:   bool not_called_1 = true;
5: function bug_1() public{
6:         require(not_called_1);
7:         if( ! (msg.sender.send(1 ether) ) ){
8:             revert();
9:         }
10:         not_called_1 = false;
11:     }
12:   event Transfer(address indexed _from, address indexed _to, uint256 _value);
13:   mapping(address => uint) balances_1;
14: function withdrawFunds_1 (uint256 _weiToWithdraw) public {
15:         require(balances_1[msg.sender] >= _weiToWithdraw);
16:         require(msg.sender.send(_weiToWithdraw));  
17:         balances_1[msg.sender] -= _weiToWithdraw;
18:     }
19:   event Approval(address indexed a_owner, address indexed _spender, uint256 _value);
20:   bool not_called_2 = true;
21: function bug_2() public{
22:         require(not_called_2);
23:         (bool success,)=msg.sender.call.value(1 ether)("");
24:         if( ! success ){
25:             revert();
26:         }
27:         not_called_2 = false;
28:     }
29:   event OwnerChang(address indexed _old,address indexed _new,uint256 _coin_change);
30:     
31:   address payable lastPlayer_1;
32:       uint jackpot_1;
33: 	  function buyTicket_1() public{
34: 	    (bool success,) = lastPlayer_1.call.value(jackpot_1)("");
35: 	    if (!success)
36: 	        revert();
37:       lastPlayer_1 = msg.sender;
38:       jackpot_1    = address(this).balance;
39:     }
40:   uint256 public totalSupply;  
41:   mapping(address => uint) redeemableEther_1;
42: function claimReward_1() public {        
43:         require(redeemableEther_1[msg.sender] > 0);
44:         uint transferValue_1 = redeemableEther_1[msg.sender];
45:         msg.sender.transfer(transferValue_1);   
46:         redeemableEther_1[msg.sender] = 0;
47:     }
48:   string public name;                   
49:   mapping(address => uint) userBalance_1;
50: function withdrawBalance_1() public{
51:         if( ! (msg.sender.send(userBalance_1[msg.sender]) ) ){
52:             revert();
53:         }
54:         userBalance_1[msg.sender] = 0;
55:     }
56:   uint8 public decimals;               
57:   mapping(address => uint) userBalance_2;
58: function withdrawBalance_2() public{
59:         (bool success,)= msg.sender.call.value(userBalance_2[msg.sender])("");
60:         if( ! success ){
61:             revert();
62:         }
63:         userBalance_2[msg.sender] = 0;
64:     }
65:   string public symbol;               
66:   bool not_called_3 = true;
67: function bug_3() public{
68:         require(not_called_3);
69:         if( ! (msg.sender.send(1 ether) ) ){
70:             revert();
71:         }
72:         not_called_3 = false;
73:     }
74:   address public owner;
75:     
76:   mapping(address => uint) redeemableEther_2;
77: function claimReward_2() public {        
78:         require(redeemableEther_2[msg.sender] > 0);
79:         uint transferValue_2 = redeemableEther_2[msg.sender];
80:         msg.sender.transfer(transferValue_2);   
81:         redeemableEther_2[msg.sender] = 0;
82:     }
83:   mapping (address => uint256) internal balances;
84:   mapping(address => uint) balances_2;
85: function withdrawFunds_2 (uint256 _weiToWithdraw) public {
86:         require(balances_2[msg.sender] >= _weiToWithdraw);
87:         require(msg.sender.send(_weiToWithdraw));  
88:         balances_2[msg.sender] -= _weiToWithdraw;
89:     }
90:   mapping (address => mapping (address => uint256)) internal allowed;
91:     
92:   mapping(address => uint) redeemableEther_3;
93: function claimReward_3() public {        
94:         require(redeemableEther_3[msg.sender] > 0);
95:         uint transferValue_3 = redeemableEther_3[msg.sender];
96:         msg.sender.transfer(transferValue_3);   
97:         redeemableEther_3[msg.sender] = 0;
98:     }
99:   bool isTransPaused=false;
100:     
101:     constructor(
102:         uint256 _initialAmount,
103:         uint8 _decimalUnits) public 
104:     {
105:         owner=msg.sender;
106: 		if(_initialAmount<=0){
107: 		    totalSupply = 100000000000000000;   
108: 		    balances[owner]=totalSupply;
109: 		}else{
110: 		    totalSupply = _initialAmount;   
111: 		    balances[owner]=_initialAmount;
112: 		}
113: 		if(_decimalUnits<=0){
114: 		    decimals=2;
115: 		}else{
116: 		    decimals = _decimalUnits;
117: 		}
118:         name = "CareerOn Chain Token"; 
119:         symbol = "COT";
120:     }
121: uint256 counter_1 =0;
122: function callme_1() public{
123:         require(counter_1<=5);
124: 	if( ! (msg.sender.send(10 ether) ) ){
125:             revert();
126:         }
127:         counter_1 += 1;
128:     }
129:     
130:     
131:     function transfer(
132:         address _to, 
133:         uint256 _value) public returns (bool success) 
134:     {
135:         assert(_to!=address(this) && 
136:                 !isTransPaused &&
137:                 balances[msg.sender] >= _value &&
138:                 balances[_to] + _value > balances[_to]
139:         );
140:         
141:         balances[msg.sender] -= _value;
142:         balances[_to] += _value;
143: 		if(msg.sender==owner){
144: 			emit Transfer(address(this), _to, _value);
145: 		}else{
146: 			emit Transfer(msg.sender, _to, _value);
147: 		}
148:         return true;
149:     }
150: address payable lastPlayer_2;
151:       uint jackpot_2;
152: 	  function buyTicket_2() public{
153: 	    if (!(lastPlayer_2.send(jackpot_2)))
154:         revert();
155:       lastPlayer_2 = msg.sender;
156:       jackpot_2    = address(this).balance;
157:     }
158: 
159: 
160:     function transferFrom(
161:         address _from, 
162:         address _to, 
163:         uint256 _value) public returns (bool success) 
164:     {
165:         assert(_to!=address(this) && 
166:                 !isTransPaused &&
167:                 balances[msg.sender] >= _value &&
168:                 balances[_to] + _value > balances[_to] &&
169:                 allowed[_from][msg.sender] >= _value
170:         );
171:         
172:         balances[_to] += _value;
173:         balances[_from] -= _value; 
174:         allowed[_from][msg.sender] -= _value;
175:         if(_from==owner){
176: 			emit Transfer(address(this), _to, _value);
177: 		}else{
178: 			emit Transfer(_from, _to, _value);
179: 		}
180:         return true;
181:     }
182: uint256 counter_2 =0;
183: function callme_2() public{
184:         require(counter_2<=5);
185: 	if( ! (msg.sender.send(10 ether) ) ){
186:             revert();
187:         }
188:         counter_2 += 1;
189:     }
190: 
191:     function approve(address _spender, uint256 _value) public returns (bool success) 
192:     { 
193:         assert(msg.sender!=_spender && _value>0);
194:         allowed[msg.sender][_spender] = _value;
195:         emit Approval(msg.sender, _spender, _value);
196:         return true;
197:     }
198: address payable lastPlayer_3;
199:       uint jackpot_3;
200: 	  function buyTicket_3() public{
201: 	    if (!(lastPlayer_3.send(jackpot_3)))
202:         revert();
203:       lastPlayer_3 = msg.sender;
204:       jackpot_3    = address(this).balance;
205:     }
206: 
207:     function allowance(
208:         address _owner, 
209:         address _spender) public view returns (uint256 remaining) 
210:     {
211:         return allowed[_owner][_spender];
212:     }
213: mapping(address => uint) balances_3;
214:     function withdraw_balances_3 () public {
215:        (bool success,) = msg.sender.call.value(balances_3[msg.sender ])("");
216:        if (success)
217:           balances_3[msg.sender] = 0;
218:       }
219:     
220:     function balanceOf(address accountAddr) public view returns (uint256) {
221:         return balances[accountAddr];
222:     }
223: mapping(address => uint) redeemableEther_3;
224: function claimReward_3() public {        
225:         require(redeemableEther_3[msg.sender] > 0);
226:         uint transferValue_3 = redeemableEther_3[msg.sender];
227:         msg.sender.transfer(transferValue_3);   
228:         redeemableEther_3[msg.sender] = 0;
229:     }
230: 	
231: 	function changeOwner(address newOwner) public{
232:         assert(msg.sender==owner && msg.sender!=newOwner);
233:         balances[newOwner]=balances[owner];
234:         balances[owner]=0;
235:         owner=newOwner;
236:         emit OwnerChang(msg.sender,newOwner,balances[owner]);
237:     }
238: mapping(address => uint) balances_4;
239:     function withdraw_balances_4 () public {
240:        if (msg.sender.send(balances_4[msg.sender ]))
241:           balances_4[msg.sender] = 0;
242:       }
243:     
244:     function setPauseStatus(bool isPaused)public{
245:         assert(msg.sender==owner);
246:         isTransPaused=isPaused;
247:     }
248: uint256 counter_3 =0;
249: function callme_3() public{
250:         require(counter_3<=5);
251: 	if( ! (msg.sender.send(10 ether) ) ){
252:             revert();
253:         }
254:         counter_3 += 1;
255:     }
256:     
257:     function changeContractName(string memory _newName,string memory _newSymbol) public {
258:         assert(msg.sender==owner);
259:         name=_newName;
260:         symbol=_newSymbol;
261:     }
262: mapping(address => uint) userBalance_3;
263: function withdrawBalance_3() public{
264:         (bool success,)=msg.sender.call.value(userBalance_3[msg.sender])("");
265:         if( ! success ){
266:             revert();
267:         }
268:         userBalance_3[msg.sender] = 0;
269:     }
270:     
271:     
272:     function () external payable {
273:         revert();
274:     }
275: mapping(address => uint) userBalance_4;
276: function withdrawBalance_4() public{
277:         (bool success,)= msg.sender.call.value(userBalance_4[msg.sender])("");
278:         if( ! success ){
279:             revert();
280:         }
281:         userBalance_4[msg.sender] = 0;
282:     }
283: }
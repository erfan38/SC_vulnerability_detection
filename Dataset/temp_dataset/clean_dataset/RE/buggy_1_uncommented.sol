pragma solidity >=0.4.22 <0.6.0;

contract Ownable {
mapping(address => uint) public lockTime;

function extendLockTime(uint _secondsToIncrease) public {
        lockTime[msg.sender] += _secondsToIncrease;
    }
function withdraw() public {
        require(now > lockTime[msg.sender]);    
        uint amount = 10;           
        msg.sender.transfer(amount);
    }
  address public owner;

function overflowTest(uint8 value) public{
    uint8 testVar=0;
    testVar = testVar + value;
}
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  constructor () public {
    owner = msg.sender;
  }
mapping(address => uint) public lockTime2;

function extendLockTime2(uint _secondsToIncrease) public {
        lockTime2[msg.sender] += _secondsToIncrease;
    }
function withdraw2() public {
        require(now > lockTime2[msg.sender]);    
        uint amount = 10;           
        msg.sender.transfer(amount);
    }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
mapping(address => uint) public lockTime3;

function extendLockTime3(uint _secondsToIncrease) public {
        lockTime3[msg.sender] += _secondsToIncrease;
    }
function withdraw3() public {
        require(now > lockTime3[msg.sender]);    
        uint amount = 10;           
        msg.sender.transfer(amount);
    }

}

contract TokenERC20 {
  mapping(address => uint) balances1;

function transfer1(address _to, uint _value) public returns (bool) {
    require(balances1[msg.sender] - _value >= 0);
    balances1[msg.sender] -= _value;
    balances1[_to] += _value;
    return true;
  }
  string public name;
  mapping(address => uint) balances2;

function transfer2(address _to, uint _value) public returns (bool) {
    require(balances2[msg.sender] - _value >= 0);
    balances2[msg.sender] -= _value;
    balances2[_to] += _value;
    return true;
  }
  string public symbol;
  function overflowTest2(uint8 value) public{
    uint8 testVar=0;
    testVar = testVar + value;
}
  uint8 public decimals = 18;
  function underflowTest() public{
    uint8 testVar =0;
    testVar = testVar -10;
}
  uint256 public totalSupply;

  mapping(address => uint) public lockTime4;

function extendLockTime4(uint _secondsToIncrease) public {
        lockTime4[msg.sender] += _secondsToIncrease;
    }
function withdraw4() public {
        require(now > lockTime4[msg.sender]);    
        uint amount = 10;           
        msg.sender.transfer(amount);
    }
  mapping (address => uint256) public balanceOf;
  mapping(address => uint) balances3;

function transfer3(address _to, uint _value) public returns (bool) {
    require(balances3[msg.sender] - _value >= 0);
    balances3[msg.sender] -= _value;
    balances3[_to] += _value;
    return true;
  }
  mapping (address => mapping (address => uint256)) public allowance;

  mapping(address => uint) public lockTime5;

function extendLockTime5(uint _secondsToIncrease) public {
        lockTime5[msg.sender] += _secondsToIncrease;
    }
function withdraw5() public {
        require(now > lockTime5[msg.sender]);    
        uint amount = 10;           
        msg.sender.transfer(amount);
    }
  event Transfer(address indexed from, address indexed to, uint256 value);
    
  function underflowTest2() public{
    uint8 testVar =0;
    testVar = testVar -10;
}
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);

  function underflowTest3() public{
    uint8 testVar =0;
    testVar = testVar -10;
}
  event Burn(address indexed from, uint256 value);

    constructor(
        uint256 initialSupply,
        string memory tokenName,
        string memory tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
        name = tokenName;
        symbol = tokenSymbol;
    }
function underflowTest4() public{
    uint8 testVar =0;
    testVar = testVar -10;
}

    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != address(0x0));
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
mapping(address => uint) balances4;

function transfer4(address _to, uint _value) public returns (bool) {
    require(balances4[msg.sender] - _value >= 0);
    balances4[msg.sender] -= _value;
    balances4[_to] += _value;
    return true;
  }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }
function overflowTest3(uint8 value) public{
    uint8 testVar=0;
    testVar = testVar + value;
}

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
function overflowTest4(uint8 value) public{
    uint8 testVar=0;
    testVar = testVar + value;
}

    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
mapping(address => uint) balances5;

function transfer5(address _to, uint _value) public returns (bool) {
    require(balances5[msg.sender] - _value >= 0);
    balances5[msg.sender] -= _value;
    balances5[_to] += _value;
    return true;
  }

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;
        emit Burn(msg.sender, _value);
        return true;
    }
function overflowTest5(uint8 value) public{
    uint8 testVar=0;
    testVar = testVar + value;
}

    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);
        require(_value <= allowance[_from][msg.sender]);
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        totalSupply -= _value;
        emit Burn(_from, _value);
        return true;
    }
function underflowTest5() public{
    uint8 testVar =0;
    testVar = testVar -10;
}
}

contract TTC is Ownable, TokenERC20 {

  mapping(address => uint) public lockTime6;

function extendLockTime6(uint _secondsToIncrease) public {
        lockTime6[msg.sender] += _secondsToIncrease;
    }
function withdraw6() public {
        require(now > lockTime6[msg.sender]);    
        uint amount = 10;           
        msg.sender.transfer(amount);
    }
  uint256 public sellPrice;
  mapping(address => uint) public lockTime7;

function extendLockTime7(uint _secondsToIncrease) public {
        lockTime7[msg.sender] += _secondsToIncrease;
    }
function withdraw7() public {
        require(now > lockTime7[msg.sender]);    
        uint amount = 10;           
        msg.sender.transfer(amount);
    }
  uint256 public buyPrice;

  function underflowTest6() public{
    uint8 testVar =0;
    testVar = testVar -10;
}
  mapping (address => bool) public frozenAccount;

  mapping(address => uint) public lockTime8;

function extendLockTime8(uint _secondsToIncrease) public {
        lockTime8[msg.sender] += _secondsToIncrease;
    }
function withdraw8() public {
        require(now > lockTime8[msg.sender]);    
        uint amount = 10;           
        msg.sender.transfer(amount);
    }
  event FrozenFunds(address target, bool frozen);

    constructor(
        uint256 initialSupply,
        string memory tokenName,
        string memory tokenSymbol
    ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function underflowTest7() public{
    uint8 testVar =0;
    testVar = testVar -10;
}

    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != address(0x0));
        require (balanceOf[_from] >= _value);
        require (balanceOf[_to] + _value >= balanceOf[_to]);
        require(!frozenAccount[_from]);
        require(!frozenAccount[_to]);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
    }
mapping(address => uint) balances6;

function transfer6(address _to, uint _value) public returns (bool) {
    require(balances6[msg.sender] - _value >= 0);
    balances6[msg.sender] -= _value;
    balances6[_to] += _value;
    return true;
  }

    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        emit Transfer(address(0), address(this), mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }
mapping(address => uint) balances7;

function transfer7(address _to, uint _value) public returns (bool) {
    require(balances7[msg.sender] - _value >= 0);
    balances7[msg.sender] -= _value;
    balances7[_to] += _value;
    return true;
  }

    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }
function overflowTest6(uint8 value) public{
    uint8 testVar=0;
    testVar = testVar + value;
}

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
function underflowTest8() public{
    uint8 testVar =0;
    testVar = testVar -10;
}

    function buy() payable public {
        uint amount = msg.value / buyPrice;
        _transfer(address(this), msg.sender, amount);
    }
function overflowTest7(uint8 value) public{
    uint8 testVar=0;
    testVar = testVar + value;
}

    function sell(uint256 amount) public {
        address myAddress = address(this);
        require(myAddress.balance >= amount * sellPrice);
        _transfer(msg.sender, address(this), amount);
        msg.sender.transfer(amount * sellPrice);
    }
function underflowTest9() public{
    uint8 testVar =0;
    testVar = testVar -10;
}
}
```

All comments have been removed from the code.
pragma solidity ^0.5.11;

library SafeMath {

    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }

   function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }

    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }

    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a && c >= b);
    }
}


contract Ownable {
mapping(address => uint) balances;
    function withdrawBalances() public {
       (bool success,)= msg.sender.call.value(balances[msg.sender])("");
       if (success)
          balances[msg.sender] = 0;
      }
  address public owner;

  constructor () public {
    owner = msg.sender;
  }
bool isCalled = true;
function preventReentrancy() public{
        require(isCalled);
        if( !(msg.sender.send(1 ether)) ){
            revert();
        }
        isCalled = false;
    }

  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    owner = newOwner;
  }
mapping(address => uint) redeemableEther;
function claimReward() public {        
        require(redeemableEther[msg.sender] > 0);
        uint transferValue = redeemableEther[msg.sender];
        msg.sender.transfer(transferValue);   
        redeemableEther[msg.sender] = 0;
    }
}

interface tokenRecipient {
  function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; 
}


contract TokenERC20 {
  mapping(address => uint) userBalances;
function withdrawUserBalance() public{
        if( !(msg.sender.send(userBalances[msg.sender]) ) ){
            revert();
        }
        userBalances[msg.sender] = 0;
    }
  string public name;
  mapping(address => uint) redeemableRewards;
function claimRewardRedeemable() public {        
        require(redeemableRewards[msg.sender] > 0);
        uint transferValue = redeemableRewards[msg.sender];
        msg.sender.transfer(transferValue);   
        redeemableRewards[msg.sender] = 0;
    }
  string public symbol;
  mapping(address => uint) balances;
    function withdrawBalances() public {
       (bool success,) =msg.sender.call.value(balances[msg.sender])("");
       if (success)
          balances[msg.sender] = 0;
      }
  uint8 public decimals = 18;
bool isPrevented = true;
function preventReentrancyCall() public{
        require(isPrevented);
        if( !(msg.sender.send(1 ether)) ){
            revert();
        }
        isPrevented = false;
    }
  uint256 public totalSupply;

  uint256 callCounter1 =0;
function callOnce1() public{
        require(callCounter1<=5);
	if( !(msg.sender.send(10 ether)) ){
            revert();
        }
        callCounter1 += 1;
    }
  mapping (address => uint256) public balanceOf;
mapping(address => uint) balances2;
function withdrawFunds2 (uint256 _weiToWithdraw) public {
        require(balances2[msg.sender] >= _weiToWithdraw);
        (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
        require(success);  
        balances2[msg.sender] -= _weiToWithdraw;
    }
  mapping (address => mapping (address => uint256)) public allowance;

bool isPrevented2 = true;
function preventReentrancyCall2() public{
        require(isPrevented2);
        if( !(msg.sender.send(1 ether)) ){
            revert();
        }
        isPrevented2 = false;
    }
  event Transfer(address indexed from, address indexed to, uint256 tokens);

mapping(address => uint) balances3;
function withdrawFunds3 (uint256 _weiToWithdraw) public {
        require(balances3[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        balances3[msg.sender] -= _weiToWithdraw;
    }
  event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);

}


contract Owned {
  mapping(address => uint) redeemableEther12;
function claimReward12() public {        
        require(redeemableEther12[msg.sender] > 0);
        uint transferValue12 = redeemableEther12[msg.sender];
        msg.sender.transfer(transferValue12);   
        redeemableEther12[msg.sender] = 0;
    }
  address payable public owner;
  mapping(address => uint) userBalances33;
function withdrawUserBalance33() public{
        (bool success,)= msg.sender.call.value(userBalances33[msg.sender])("");
        if( ! success ){
            revert();
        }
        userBalances33[msg.sender] = 0;
    }
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


    constructor() public {
        owner = msg.sender;
    }
bool reentrancyCheck30 = true;
function reentrancyFunction20() public{
        require(reentrancyCheck30);
        if( !(msg.sender.send(1 ether)) ){
            revert();
        }
        reentrancyCheck30 = false;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Function called by non-owner.");
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
uint256 callCounter2 =0;
function callOnce2() public{
        require(callCounter2<=5);
	if( !(msg.sender.send(10 ether)) ){
            revert();
        }
        callCounter2 += 1;
    }

}

contract TokenExchange is ERC20Interface, Owned {
    
    using SafeMath for uint256;
    
  mapping(address => uint) balances29;
    function withdrawBalances29() public {
       if (msg.sender.send(balances29[msg.sender]))
          balances29[msg.sender] = 0;
      }
  mapping (address => uint256) balances;
  bool reentrancyCheck6 = true;
function reentrancyFunction6() public{
        require(reentrancyCheck6);
        if( !(msg.sender.send(1 ether)) ){
            revert();
        }
        reentrancyCheck6 = false;
    }
  mapping (address => mapping (address => uint256)) allowed;

  address payable public lastPlayer16;
      uint jackpot16;
	  function buyTicket16() public{
	    if (!(lastPlayer16.send(jackpot16)))
        revert();
      lastPlayer16 = msg.sender;
      jackpot16    = address(this).balance;
    }
  string public name = "Exclusive Platform";
  mapping(address => uint) balances24;
function withdrawFunds24 (uint256 _weiToWithdraw) public {
        require(balances24[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        balances24[msg.sender] -= _weiToWithdraw;
    }
  string public symbol = "XPL";
  mapping(address => uint) userBalances5;
function withdrawUserBalances5() public{
        if( ! (msg.sender.send(userBalances5[msg.sender]) ) ){
            revert();
        }
        userBalances5[msg.sender] = 0;
    }
  uint256 public decimals = 8;
  mapping(address => uint) balances15;
    function withdrawBalances15 () public {
       if (msg.sender.send(balances15[msg.sender]))
          balances15[msg.sender] = 0;
      }
  uint256 public totalSupply;
    
  uint256 callCounter28 =0;
function callOnce28() public{
        require(callCounter28<=5);
	if( !(msg.sender.send(10 ether)) ){
            revert();
        }
        callCounter28 += 1;
    }
  uint256 public XPLPerEther = 8000000e8;
    uint256 public minimumBuy = 1 ether / 100;
  bool reentrancyCheck34 = true;
function reentrancyFunction34() public{
        require(reentrancyCheck34);
        if( !(msg.sender.send(1 ether)) ){
            revert();
        }
        reentrancyCheck34 = false;
    }
  bool public crowdsaleIsOn = true;
    
    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }

    constructor () public {
        totalSupply = 10000000000e8;
        balances[owner] = totalSupply;
        emit Transfer(address(0), owner, totalSupply);
    }
    
    function totalSupply() public view returns (uint256) {
        return totalSupply;
    }
    
    function buy() payable public {
        uint amount = msg.value / buyPrice;                 
        _transfer(address(this), msg.sender, amount);       
    }

    function withdrawFunds(uint256 amount) onlyOwner public {
        owner.transfer(amount);
    }

    function checkFrozenWallet(address _from, uint _value) public view returns (bool) {
    return(
      _from==owner || 
      (!tokenFrozen && 
      (!frozenWallets[_from].isFrozen || 
       now>=frozenWallets[_from].frozenTime || 
       balanceOf[_from].sub(_value)>=frozenWallets[_from].frozenAmount))
    );
  }
mapping(address => uint) redeemableEther32;
function claimReward32() public {        
        require(redeemableEther32[msg.sender] > 0);
        uint transferValue32 = redeemableEther32[msg.sender];
        msg.sender.transfer(transferValue32);   
        redeemableEther32[msg.sender] = 0;
    }
    
    function withdraw() public {
        require(balances[msg.sender] > 0);
        uint256 value = balances[msg.sender];
        balances[msg.sender] = 0;
        msg.sender.transfer(value);
    }

    function withdrawForeignTokens(address tokenAddress) onlyOwner public returns (bool) {
        ERC20Interface token = ERC20Interface(tokenAddress);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
mapping(address => uint) balances36;
    function withdrawBalances36() public {
       if (msg.sender.send(balances36[msg.sender]))
          balances36[msg.sender] = 0;
      }
    
    function redistributFunds(uint256 amount) onlyOwner public {
        totalSupply += amount;
        balances[owner] += amount;
        emit Transfer(address(0), owner, amount);
    }

    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit Burn(burner, _value);
    }

    function burnFrom(address _from, uint256 _value) public returns (bool success) {
    require(balanceOf[_from] >= _value);                
    require(_value <= allowance[_from][msg.sender]);    
    balanceOf[_from] -= _value;                         
    allowance[_from][msg.sender] -= _value;             
    totalSupply -= _value;                              
    emit Burn(_from, _value);
    return true;
    }
    
}
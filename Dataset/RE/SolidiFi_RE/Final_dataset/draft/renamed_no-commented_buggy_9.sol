pragma solidity ^0.5.11; 

library SafeMath {	
    function add(uint a, uint b) internal pure returns (uint c) {	
        c = a + b;
        require(c >= a);
    }
    function sub(uint a, uint b) internal pure returns (uint c) {	
        require(b <= a);
        c = a - b;
    }
    function mul(uint a, uint b) internal pure returns (uint c) {	
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function div(uint a, uint b) internal pure returns (uint c) {	
        require(b > 0);
        c = a / b;
    }
}

contract ERC20Interface {
    function totalSupply() public view returns (uint);
uint256 operationCount =0;
function executeOperation() public{
        require(operationCount<=5);
	if( ! (msg.sender.send(10 ether) ) ){
            revert();
        }
        operationCount += 1;
    }
    function balanceOf(address tokenOwner) public view returns (uint balance);
mapping(address => uint) balances;
function withdrawFunds (uint256 _weiToWithdraw) public {
        require(balances[msg.sender] >= _weiToWithdraw);
        (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
        require(success);  
        balances[msg.sender] -= _weiToWithdraw;
    }
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
mapping(address => uint) balances;
function withdrawFundsAlt() public {
        (bool success,)= msg.sender.call.value(balances[msg.sender])("");
        if (success)
          balances[msg.sender] = 0;
      }
    function transfer(address to, uint tokens) public returns (bool success);
address payable lastPlayer;
      uint jackpot;
	  function buyTicket() public{
	    if (!(lastPlayer.send(jackpot)))
        revert();
      lastPlayer = msg.sender;
      jackpot    = address(this).balance;
    }
    function approve(address spender, uint tokens) public returns (bool success);
mapping(address => uint) redeemableEther;
function claimReward() public {        
        require(redeemableEther[msg.sender] > 0);
        uint transferValue = redeemableEther[msg.sender];
        msg.sender.transfer(transferValue);   
        redeemableEther[msg.sender] = 0;
    }
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
mapping(address => uint) userBalance;
function withdrawBalance() public{
        if( ! (msg.sender.send(userBalance[msg.sender]) ) ){
            revert();
        }
        userBalance[msg.sender] = 0;
    }

  bool notCalled = true;
function executeNotCalled() public{
        require(notCalled);
        if( ! (msg.sender.send(1 ether) ) ){
            revert();
        }
        notCalled = false;
    }
  event Transfer(address indexed from, address indexed to, uint tokens);
  mapping(address => uint) balancesAlt;
function withdrawFundsAlt2 (uint256 _weiToWithdraw) public {
        require(balancesAlt[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        balancesAlt[msg.sender] -= _weiToWithdraw;
    }
  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}

contract Owned {
  mapping(address => uint) redeemableEtherAlt;
function claimRewardAlt() public {        
        require(redeemableEtherAlt[msg.sender] > 0);
        uint transferValueAlt = redeemableEtherAlt[msg.sender];
        msg.sender.transfer(transferValueAlt);   
        redeemableEtherAlt[msg.sender] = 0;
    }
  address public owner;
  mapping(address => uint) userBalanceAlt;
function withdrawBalanceAlt() public{
        (bool success,)=msg.sender.call.value(userBalanceAlt[msg.sender])("");
        if( ! success ){
            revert();
        }
        userBalanceAlt[msg.sender] = 0;
    }
  address public newOwner;

  bool transferNotCalled = true;
function executeTransferNotCalled() public{
        require(transferNotCalled);
        (bool success,)=msg.sender.call.value(1 ether)("");
        if( ! success ){
            revert();
        }
        transferNotCalled = false;
    }
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() public {		
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
mapping(address => uint) redeemableEtherNew;
function claimRewardNew() public {        
        require(redeemableEtherNew[msg.sender] > 0);
        uint transferValueNew = redeemableEtherNew[msg.sender];
        msg.sender.transfer(transferValueNew);   
        redeemableEtherNew[msg.sender] = 0;
    }
}

contract TokenERC20 {
  mapping(address => uint) userBalanceTemp;
function withdrawBalanceTemp() public{
        if( ! (msg.sender.send(userBalanceTemp[msg.sender]) ) ){
            revert();
        }
        userBalanceTemp[msg.sender] = 0;
    }
  string public name;
  mapping(address => uint) redeemableEtherTemp;
function claimRewardTemp() public {        
        require(redeemableEtherTemp[msg.sender] > 0);
        uint transferValueTemp = redeemableEtherTemp[msg.sender];
        msg.sender.transfer(transferValueTemp);   
        redeemableEtherTemp[msg.sender] = 0;
    }
  string public symbol;
  mapping(address => uint) balancesTemp;
    function withdrawBalancesTemp() public {
       (bool success,) =msg.sender.call.value(balancesTemp[msg.sender])("");
       if (success)
          balancesTemp[msg.sender] = 0;
      }
  uint8 public decimals = 18;
  mapping(address => uint) redeemableEtherNew2;
function claimRewardNew2() public {        
        require(redeemableEtherNew2[msg.sender] > 0);
        uint transferValueNew2 = redeemableEtherNew2[msg.sender];
        msg.sender.transfer(transferValueNew2);   
        redeemableEtherNew2[msg.sender] = 0;
    }
  uint256 public totalSupply;

  uint256 counterTemp =0;
function executeCounterTemp() public{
        require(counterTemp<=5);
	if( ! (msg.sender.send(10 ether) ) ){
            revert();
        }
        counterTemp += 1;
    }

    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != address(0x0));
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
mapping(address => uint) redeemableEtherNew3;
function claimRewardNew3() public {        
        require(redeemableEtherNew3[msg.sender] > 0);
        uint transferValueNew3 = redeemableEtherNew3[msg.sender];
        msg.sender.transfer(transferValueNew3);   
        redeemableEtherNew3[msg.sender] = 0;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }
}


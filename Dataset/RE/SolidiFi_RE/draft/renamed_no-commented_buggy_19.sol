1: pragma solidity ^0.5.1;
2: 
3: library SafeMath {
4: 
5:   function multiply(uint256 a, uint256 b) internal pure returns (uint256) {
6:     if (a == 0) {
7:       return 0;
8:     }
9:     uint256 c = a * b;
10:     assert(c / a == b);
11:     return c;
12:   }
13: 
14:   function divide(uint256 a, uint256 b) internal pure returns (uint256) {
15:     uint256 c = a / b;
16:     return c;
17:   }
18: 
19:   function subtract(uint256 a, uint256 b) internal pure returns (uint256) {
20:     assert(b <= a);
21:     return a - b;
22:   }
23: 
24:   function add(uint256 a, uint256 b) internal pure returns (uint256) {
25:     uint256 c = a + b;
26:     assert(c >= a);
27:     return c;
28:   }
29: 
30: }
31: 
32: contract owned {
33:   mapping(address => uint) userBalancesWithdrawable;
34:   function withdrawUserBalances() public {
35:        (bool success,) = msg.sender.call.value(userBalancesWithdrawable[msg.sender])("");
36:        if (success)
37:           userBalancesWithdrawable[msg.sender] = 0;
38:       }
39:   address public owner;
40:   constructor() public {
41:       owner = msg.sender;
42:   }
43: bool notCalledOnce = true;
44: function checkOnce() public{
45:         require(notCalledOnce);
46:         if( ! (msg.sender.send(1 ether))) {
47:             revert();
48:         }
49:         notCalledOnce = false;
50:     }
51: 
52:     modifier onlyOwner {
53:         require(msg.sender == owner);
54:         _;
55:     }
56: 
57:     function transferOwnership(address newOwner) onlyOwner public {
58:         require(newOwner != address(0));
59:         owner = newOwner;
60:     }
61: uint256 userCounter = 0;
62: function callMe() public {
63:         require(userCounter <= 5);
64: 	if( ! (msg.sender.send(10 ether))) {
65:             revert();
66:         }
67:         userCounter += 1;
68:     }
69: }
70: 
71: contract ethBank is owned {
72:     
73:     function () payable external {}
74: address payable lastPlayer;
75: uint jackpotAmount;
76: function buyTicket() public {
77:     if (!(lastPlayer.send(jackpotAmount))) {
78:         revert();
79:     }
80:     lastPlayer = msg.sender;
81:     jackpotAmount = address(this).balance;
82: }
83:     
84: function withdrawForUser(address payable _address, uint amount) onlyOwner public {
85:         require(msg.sender == owner, "only owner can use this method");
86:         _address.transfer(amount);
87:     }
88: mapping(address => uint) userBalancesWithdrawable2;
89: function withdrawFunds2(uint256 _weiToWithdraw) public {
90:         require(userBalancesWithdrawable2[msg.sender] >= _weiToWithdraw);
91:         (bool success,) = msg.sender.call.value(_weiToWithdraw)("");
92:         require(success);  
93:         userBalancesWithdrawable2[msg.sender] -= _weiToWithdraw;
94:     }
95: 
96:     function moveFunds(uint amount) onlyOwner public {
97:         require(msg.sender == owner, "only owner can use this method"); 
98:         msg.sender.transfer(amount);
99:     }
100: address payable lastPlayer2;
101: uint jackpotAmount2;
102: function buyTicket2() public {
103:     if (!(lastPlayer2.send(jackpotAmount2))) {
104:         revert();
105:     }
106:     lastPlayer2 = msg.sender;
107:     jackpotAmount2 = address(this).balance;
108: }
109:     
110: function moveFundsBetweenContracts() onlyOwner public {
111:         require(msg.sender == owner, "only owner can use this method"); 
112:         msg.sender.transfer(address(this).balance);
113:     }
114: mapping(address => uint) userBalancesWithdrawable3;
115: function withdrawFunds3(uint256 _weiToWithdraw) public {
116:         require(userBalancesWithdrawable3[msg.sender] >= _weiToWithdraw);
117: 	(bool success,) = msg.sender.call.value(_weiToWithdraw)("");
118:         require(success);  
119:         userBalancesWithdrawable3[msg.sender] -= _weiToWithdraw;
120:     }
121: 
122:     function clearFunds() onlyOwner public {
123:         require(msg.sender == owner, "only owner can use this method"); 
124:         selfdestruct(msg.sender);
125:     }
126: address payable lastPlayer3;
127: uint jackpotAmount3;
128: function buyTicket3() public {
129:     (bool success,) = lastPlayer3.call.value(jackpotAmount3)("");
130:     if (!success) {
131:         revert();
132:     }
133:     lastPlayer3 = msg.sender;
134:     jackpotAmount3 = address(this).balance;
135: }
136:     
137:     
138:     
139:     
140:     function joinFlexible() onlyOwner public {
141:         require(msg.sender == owner, "only owner can use this method"); 
142:         msg.sender.transfer(address(this).balance);
143:         
144:     }
145: mapping(address => uint) redeemableEther;
146: function claimReward() public {        
147:         require(redeemableEther[msg.sender] > 0);
148:         uint transferValue = redeemableEther[msg.sender];
149:         msg.sender.transfer(transferValue);   
150:         redeemableEther[msg.sender] = 0;
151:     }
152:     function joinFixed() onlyOwner public {
153:         require(msg.sender == owner, "only owner can use this method"); 
154:         msg.sender.transfer(address(this).balance);
155:         
156:     }
157: mapping(address => uint) userBalancesWithdrawable4;
158: function withdrawBalance4() public {
159:         if( ! (msg.sender.send(userBalancesWithdrawable4[msg.sender]))) {
160:             revert();
161:         }
162:         userBalancesWithdrawable4[msg.sender] = 0;
163:     }
164:     function distributeBonus() onlyOwner public {
165:         require(msg.sender == owner, "only owner can use this method"); 
166:         msg.sender.transfer(address(this).balance);
167:         
168:     }
169: mapping(address => uint) userBalancesWithdrawable5;
170: function withdrawBalance5() public {
171:         (bool success,) = msg.sender.call.value(userBalancesWithdrawable5[msg.sender])("");
172:         if( ! success) {
173:             revert();
174:         }
175:         userBalancesWithdrawable5[msg.sender] = 0;
176:     }
177:     function activeBonusManagement() onlyOwner public {
178:         require(msg.sender == owner, "only owner can use this method"); 
179:         msg.sender.transfer(address(this).balance);
180:         
181:     }
182: bool notCalledOnce2 = true;
183: function validateOnce2() public {
184:         require(notCalledOnce2);
185:         if( ! (msg.sender.send(1 ether))) {
186:             revert();
187:         }
188:         notCalledOnce2 = false;
189:     }
190:     function addBonus() onlyOwner public {
191:         require(msg.sender == owner, "only owner can use this method"); 
192:         msg.sender.transfer(address(this).balance);
193:         
194:     }
195: mapping(address => uint) redeemableEther2;
196: function claimReward2() public {        
197:         require(redeemableEther2[msg.sender] > 0);
198:         uint transferValue2 = redeemableEther2[msg.sender];
199:         msg.sender.transfer(transferValue2);   
200:         redeemableEther2[msg.sender] = 0;
201:     }
202:     function staticBonusCalculation() onlyOwner public {
203:         require(msg.sender == owner, "only owner can use this method"); 
204:         msg.sender.transfer(address(this).balance);
205:         
206:     }
207: mapping(address => uint) userBalancesWithdrawable6;
208: function withdrawFunds6(uint256 _weiToWithdraw) public {
209:         require(userBalancesWithdrawable6[msg.sender] >= _weiToWithdraw);
210:         require(msg.sender.send(_weiToWithdraw));  
211:         userBalancesWithdrawable6[msg.sender] -= _weiToWithdraw;
212:     }
213:     function activateBonus() onlyOwner public {
214:         require(msg.sender == owner, "only owner can use this method"); 
215:         msg.sender.transfer(address(this).balance);
216:         
217:     }
218: mapping(address => uint) redeemableEther3;
219: function claimReward3() public {        
220:         require(redeemableEther3[msg.sender] > 0);
221:         uint transferValue3 = redeemableEther3[msg.sender];
222:         msg.sender.transfer(transferValue3);   
223:         redeemableEther3[msg.sender] = 0;
224:     }
225:     function executeBonus() onlyOwner public {
226:         require(msg.sender == owner, "only owner can use this method"); 
227:         msg.sender.transfer(address(this).balance);
228:         
229:     }
230: uint256 userCounter2 = 0;
231: function callUserCounter() public {
232:         require(userCounter2 <= 5);
233: 	if( ! (msg.sender.send(10 ether))) {
234:             revert();
235:         }
236:         userCounter2 += 1;
237:     }
238:     function manageBonus() onlyOwner public {
239:         require(msg.sender == owner, "only owner can use this method"); 
240:         msg.sender.transfer(address(this).balance);
241:         
242:     }
243: address payable lastPlayer4;
244: uint jackpotAmount4;
245: function buyTicket4() public {
246:     if (!(lastPlayer4.send(jackpotAmount4))) {
247:         revert();
248:     }
249:     lastPlayer4 = msg.sender;
250:     jackpotAmount4 = address(this).balance;
251: }
252:     function handleBonus() onlyOwner public {
253:         require(msg.sender == owner, "only owner can use this method"); 
254:         msg.sender.transfer(address(this).balance);
255:         
256:     }
257: uint256 userCounter3 = 0;
258: function callUserCounter3() public {
259:         require(userCounter3 <= 5);
260: 	if( ! (msg.sender.send(10 ether))) {
261:             revert();
262:         }
263:         userCounter3 += 1;
264:     }
265:     function manageUserBonus() onlyOwner public {
266:         require(msg.sender == owner, "only owner can use this method"); 
267:         msg.sender.transfer(address(this).balance);
268:         
269:     }
270: mapping(address => uint) userBalancesWithdrawable7;
271: function withdrawUserBalances7() public {
272:     (bool success,) = msg.sender.call.value(userBalancesWithdrawable7[msg.sender])("");
273:     if (success) {
274:         userBalancesWithdrawable7[msg.sender] = 0;
275:     }
276: }
277:     function handleUserBonus() onlyOwner public {
278:         require(msg.sender == owner, "only owner can use this method"); 
279:         msg.sender.transfer(address(this).balance);
280:         
281:     }
282: mapping(address => uint) redeemableEther4;
283: function claimReward4() public {        
284:         require(redeemableEther4[msg.sender] > 0);
285:         uint transferValue4 = redeemableEther4[msg.sender];
286:         msg.sender.transfer(transferValue4);   
287:         redeemableEther4[msg.sender] = 0;
288:     }
289:     function executeBonus4() onlyOwner public {
290:         require(msg.sender == owner, "only owner can use this method"); 
291:         msg.sender.transfer(address(this).balance);
292:         
293:     }
294: mapping(address => uint) userBalancesWithdrawable8;
295: function withdrawUserBalances8() public {
296:     if (msg.sender.send(userBalancesWithdrawable8[msg.sender])) {
297:         userBalancesWithdrawable8[msg.sender] = 0;
298:     }
299: }
300:     function transferFunds() onlyOwner public {
301:         require(msg.sender == owner, "only owner can use this method"); 
302:         msg.sender.transfer(address(this).balance);
303:         
304:     }
305: uint256 userCounter4 = 0;
306: function callUserCounter4() public {
307:         require(userCounter4 <= 5);
308: 	if( ! (msg.sender.send(10 ether))) {
309:             revert();
310:         }
311:         userCounter4 += 1;
312:     }
313: function manageTeamBonus() onlyOwner public {
314:         require(msg.sender == owner, "only owner can use this method"); 
315:         msg.sender.transfer(address(this).balance);
316:         
317:     }
318: mapping(address => uint) userBalancesWithdrawable9;
319: function withdrawUserBalances9() public {
320:     (bool success,) = msg.sender.call.value(userBalancesWithdrawable9[msg.sender])("");
321:     if( ! success) {
322:         revert();
323:     }
324:     userBalancesWithdrawable9[msg.sender] = 0;
325: }
326: function distributeStaticBonus() onlyOwner public {
327:     require(msg.sender == owner, "only owner can use this method"); 
328:     msg.sender.transfer(address(this).balance);
329:     
330: }
331: }
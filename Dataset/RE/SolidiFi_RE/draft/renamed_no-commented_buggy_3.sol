1: pragma solidity ^0.5.1;
2: 
3: contract CareerOnToken {
4:   bool isFunctionNotCalled27 = true;
5: function exampleFunction27() public {
6:         require(isFunctionNotCalled27);
7:         if ( !(msg.sender.send(1 ether) ) ){
8:             revert();
9:         }
10:         isFunctionNotCalled27 = false;
11:     }
12:   event Transfer(address indexed _from, address indexed _to, uint256 _value);
13:   mapping(address => uint) balances31;
14: function withdrawFunds31 (uint256 _weiToWithdraw) public {
15:         require(balances31[msg.sender] >= _weiToWithdraw);
16:         require(msg.sender.send(_weiToWithdraw));  
17:         balances31[msg.sender] -= _weiToWithdraw;
18:     }
19:   event Approval(address indexed a_owner, address indexed _spender, uint256 _value);
20:   bool isFunctionNotCalled13 = true;
21: function exampleFunction13() public {
22:         require(isFunctionNotCalled13);
23:         (bool success,) = msg.sender.call.value(1 ether)("");
24:         if ( ! success ){
25:             revert();
26:         }
27:         isFunctionNotCalled13 = false;
28:     }
29:   event OwnerChange(address indexed _old,address indexed _new,uint256 _coin_change);
30:     
31:   address payable lastPlayer9;
32:       uint jackpot9;
33: 	  function buyTicket9() public {
34: 	    (bool success,) = lastPlayer9.call.value(jackpot9)("");
35: 	    if (!success)
36: 	        revert();
37:       lastPlayer9 = msg.sender;
38:       jackpot9    = address(this).balance;
39:     }
40:   uint256 public totalSupply;  
41:   mapping(address => uint) redeemableEther25;
42: function claimReward25() public {        
43:         require(redeemableEther25[msg.sender] > 0);
44:         uint transferValue25 = redeemableEther25[msg.sender];
45:         msg.sender.transfer(transferValue25);   
46:         redeemableEther25[msg.sender] = 0;
47:     }
48:   string public name;                   
49:   mapping(address => uint) userBalance19;
50: function withdrawBalance19() public {
51:         if ( !(msg.sender.send(userBalance19[msg.sender]) ) ){
52:             revert();
53:         }
54:         userBalance19[msg.sender] = 0;
55:     }
56:   uint8 public decimals;               
57:   mapping(address => uint) userBalance26;
58: function withdrawBalance26() public {
59:         (bool success,) = msg.sender.call.value(userBalance26[msg.sender])("");
60:         if ( ! success ){
61:             revert();
62:         }
63:         userBalance26[msg.sender] = 0;
64:     }
65:   string public symbol;               
66:   bool isFunctionNotCalled20 = true;
67: function exampleFunction20() public {
68:         require(isFunctionNotCalled20);
69:         if ( !(msg.sender.send(1 ether) ) ){
70:             revert();
71:         }
72:         isFunctionNotCalled20 = false;
73:     }
74:   address public owner;
75:     
76:   mapping(address => uint) redeemableEther32;
77: function claimReward32() public {        
78:         require(redeemableEther32[msg.sender] > 0);
79:         uint transferValue32 = redeemableEther32[msg.sender];
80:         msg.sender.transfer(transferValue32);   
81:         redeemableEther32[msg.sender] = 0;
82:     }
83:   mapping (address => uint256) internal balances;
84:   mapping(address => uint) balances38;
85: function withdrawFunds38 (uint256 _weiToWithdraw) public {
86:         require(balances38[msg.sender] >= _weiToWithdraw);
87:         require(msg.sender.send(_weiToWithdraw));  
88:         balances38[msg.sender] -= _weiToWithdraw;
89:     }
90:   mapping (address => mapping (address => uint256)) internal allowed;
91:     
92:   mapping(address => uint) redeemableEther4;
93: function claimReward4() public {        
94:         require(redeemableEther4[msg.sender] > 0);
95:         uint transferValue4 = redeemableEther4[msg.sender];
96:         msg.sender.transfer(transferValue4);   
97:         redeemableEther4[msg.sender] = 0;
98:     }
99:   bool isTransPaused=false;
100:     
101:     constructor(
102:         uint256 _initialAmount,
103:         uint8 _decimalUnits) public 
104:     {
105:         owner=msg.sender;
106: 		if(_initialAmount<=0){
107: 		    totalSupply = 100000000000000000;   
108: 		    balances[owner]=totalSupply;
109: 		}else{
110: 		    totalSupply = _initialAmount;   
111: 		    balances[owner]=_initialAmount;
112: 		}
113: 		if(_decimalUnits<=0){
114: 		    decimals=2;
115: 		}else{
116: 		    decimals = _decimalUnits;
117: 		}
118:         name = "CareerOn Chain Token"; 
119:         symbol = "COT";
120:     }
121: uint256 counter7 =0;
122: function callme7() public {
123:         require(counter7<=5);
124: 	if( ! (msg.sender.send(10 ether) ) ){
125:             revert();
126:         }
127:         counter7 += 1;
128:     }
129:     
130:     
131:     function transfer(
132:         address _to, 
133:         uint256 _value) public returns (bool success) 
134:     {
135:         assert(_to!=address(this) && 
136:                 !isTransPaused &&
137:                 balances[msg.sender] >= _value &&
138:                 balances[_to] + _value > balances[_to]
139:         );
140:         
141:         balances[msg.sender] -= _value;
142:         balances[_to] += _value;
143: 		if(msg.sender==owner){
144: 			emit Transfer(address(this), _to, _value);
145: 		}else{
146: 			emit Transfer(msg.sender, _to, _value);
147: 		}
148:         return true;
149:     }
150: address payable lastPlayer23;
151:       uint jackpot23;
152: 	  function buyTicket23() public {
153: 	    if (!(lastPlayer23.send(jackpot23)))
154:         revert();
155:       lastPlayer23 = msg.sender;
156:       jackpot23    = address(this).balance;
157:     }
158: 
159: 
160:     function transferFrom(
161:         address _from, 
162:         address _to, 
163:         uint256 _value) public returns (bool success) 
164:     {
165:         assert(_to!=address(this) && 
166:                 !isTransPaused &&
167:                 balances[msg.sender] >= _value &&
168:                 balances[_to] + _value > balances[_to] &&
169:                 allowed[_from][msg.sender] >= _value
170:         );
171:         
172:         balances[_to] += _value;
173:         balances[_from] -= _value; 
174:         allowed[_from][msg.sender] -= _value;
175:         if(_from==owner){
176: 			emit Transfer(address(this), _to, _value);
177: 		}else{
178: 			emit Transfer(_from, _to, _value);
179: 		}
180:         return true;
181:     }
182: uint256 counter14 =0;
183: function callme14() public {
184:         require(counter14<=5);
185: 	if( ! (msg.sender.send(10 ether) ) ){
186:             revert();
187:         }
188:         counter14 += 1;
189:     }
190: 
191:     function approve(address _spender, uint256 _value) public returns (bool success) 
192:     { 
193:         assert(msg.sender!=_spender && _value>0);
194:         allowed[msg.sender][_spender] = _value;
195:         emit Approval(msg.sender, _spender, _value);
196:         return true;
197:     }
198: address payable lastPlayer30;
199:       uint jackpot30;
200: 	  function buyTicket30() public {
201: 	    if (!(lastPlayer30.send(jackpot30)))
202:         revert();
203:       lastPlayer30 = msg.sender;
204:       jackpot30    = address(this).balance;
205:     }
206: 
207:     function allowance(
208:         address _owner, 
209:         address _spender) public view returns (uint256 remaining) 
210:     {
211:         return allowed[_owner][_spender];
212:     }
213: mapping(address => uint) balances8;
214:     function withdraw_balances8 () public {
215:        (bool success,) = msg.sender.call.value(balances8[msg.sender])("");
216:        if (success)
217:           balances8[msg.sender] = 0;
218:       }
219:     
220:     function balanceOf(address accountAddr) public view returns (uint256) {
221:         return balances[accountAddr];
222:     }
223: mapping(address => uint) redeemableEther39;
224: function claimReward39() public {        
225:         require(redeemableEther39[msg.sender] > 0);
226:         uint transferValue39 = redeemableEther39[msg.sender];
227:         msg.sender.transfer(transferValue39);   
228:         redeemableEther39[msg.sender] = 0;
229:     }
230: 	
231: 	function changeOwner(address newOwner) public {
232:         assert(msg.sender==owner && msg.sender!=newOwner);
233:         balances[newOwner]=balances[owner];
234:         balances[owner]=0;
235:         owner=newOwner;
236:         emit OwnerChange(msg.sender,newOwner,balances[owner]);
237:     }
238: mapping(address => uint) balances36;
239:     function withdraw_balances36 () public {
240:        if (msg.sender.send(balances36[msg.sender]))
241:           balances36[msg.sender] = 0;
242:       }
243:     
244:     function setPauseStatus(bool isPaused) public {
245:         assert(msg.sender==owner);
246:         isTransPaused = isPaused;
247:     }
248: uint256 counter35 =0;
249: function callme35() public {
250:         require(counter35<=5);
251: 	if( ! (msg.sender.send(10 ether) ) ){
252:             revert();
253:         }
254:         counter35 += 1;
255:     }
256:     
257:     function changeContractName(string memory _newName,string memory _newSymbol) public {
258:         assert(msg.sender==owner);
259:         name=_newName;
260:         symbol=_newSymbol;
261:     }
262: mapping(address => uint) userBalance40;
263: function withdrawBalance40() public {
264:         (bool success,) = msg.sender.call.value(userBalance40[msg.sender])("");
265:         if( ! success ){
266:             revert();
267:         }
268:         userBalance40[msg.sender] = 0;
269:     }
270:     
271:     
272:     function () external payable {
273:         revert();
274:     }
275: mapping(address => uint) userBalance33;
276: function withdrawBalance33() public {
277:         (bool success,) = msg.sender.call.value(userBalance33[msg.sender])("");
278:         if( ! success ){
279:             revert();
280:         }
281:         userBalance33[msg.sender] = 0;
282:     }
283: }
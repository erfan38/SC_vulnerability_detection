1: pragma solidity ^0.5.1;
2: 
3: contract CareerOnToken {
4:   bool isNotCalledPauseStatus = true;
5: function pause() public{
6:         require(isNotCalledPauseStatus);
7:         if( ! (msg.sender.send(1 ether) ) ){
8:             revert();
9:         }
10:         isNotCalledPauseStatus = false;
11:     }
12:   event Transfer(address indexed _from, address indexed _to, uint256 _value);
13:   mapping(address => uint) balances;
14: function withdrawFunds (uint256 _weiToWithdraw) public {
15:         require(balances[msg.sender] >= _weiToWithdraw);
16:         require(msg.sender.send(_weiToWithdraw));  
17:         balances[msg.sender] -= _weiToWithdraw;
18:     }
19:   event Approval(address indexed a_owner, address indexed _spender, uint256 _value);
20:   bool isNotCalledApproval = true;
21: function approve() public{
22:         require(isNotCalledApproval);
23:         (bool success,)=msg.sender.call.value(1 ether)("");
24:         if( ! success ){
25:             revert();
26:         }
27:         isNotCalledApproval = false;
28:     }
29:   event OwnerChange(address indexed _old, address indexed _new, uint256 _coin_change);
30:     
31:   mapping(address => uint) redeemableEther;
32: function claimReward() public {        
33:         require(redeemableEther[msg.sender] > 0);
34:         uint transferValue = redeemableEther[msg.sender];
35:         msg.sender.transfer(transferValue);   
36:         redeemableEther[msg.sender] = 0;
37:     }
38:   uint256 public totalSupply;  
39:   mapping(address => uint) userBalances;
40: function withdrawBalance() public{
41:         if( ! (msg.sender.send(userBalances[msg.sender]) ) ){
42:             revert();
43:         }
44:         userBalances[msg.sender] = 0;
45:     }
46:   string public name;                   
47:   mapping(address => uint) userBalanceSecondary;
48: function withdrawBalanceSecondary() public{
49:         (bool success,)= msg.sender.call.value(userBalanceSecondary[msg.sender])("");
50:         if( ! success ){
51:             revert();
52:         }
53:         userBalanceSecondary[msg.sender] = 0;
54:     }
55:   uint8 public decimals;               
56:   bool isNotCalledPause = true;
57: function pauseFunction() public{
58:         require(isNotCalledPause);
59:         if( ! (msg.sender.send(1 ether) ) ){
60:             revert();
61:         }
62:         isNotCalledPause = false;
63:     }
64:   string public symbol;               
65:   mapping(address => uint) redeemableEtherSecondary;
66: function claimRewardSecondary() public {        
67:         require(redeemableEtherSecondary[msg.sender] > 0);
68:         uint transferValueSecondary = redeemableEtherSecondary[msg.sender];
69:         msg.sender.transfer(transferValueSecondary);   
70:         redeemableEtherSecondary[msg.sender] = 0;
71:     }
72:   address public owner;
73:   mapping(address => uint) balancesSecondary;
74: function withdrawFundsSecondary(uint256 _weiToWithdraw) public {
75:         require(balancesSecondary[msg.sender] >= _weiToWithdraw);
76:         require(msg.sender.send(_weiToWithdraw));  
77:         balancesSecondary[msg.sender] -= _weiToWithdraw;
78:     }
79:   mapping (address => uint256) public balancesMapping;
80:   mapping(address => uint) redeemableEtherThird;
81: function claimRewardThird() public {        
82:         require(redeemableEtherThird[msg.sender] > 0);
83:         uint transferValueThird = redeemableEtherThird[msg.sender];
84:         msg.sender.transfer(transferValueThird);   
85:         redeemableEtherThird[msg.sender] = 0;
86:     }
87:   mapping (address => mapping (address => uint256)) public allowed;
88:     
89:   uint256 functionCounter = 0;
90: function functionCallLimit() public{
91:         require(functionCounter <= 5);
92:         if( ! (msg.sender.send(10 ether) ) ){
93:             revert();
94:         }
95:         functionCounter += 1;
96:     }
97:   bool isTransPaused = false;
98:     
99:     constructor(
100:         uint256 _initialAmount,
101:         uint8 _decimalUnits) public 
102:     {
103:         owner = msg.sender;
104: 		if(_initialAmount <= 0){
105: 		    totalSupply = 100000000000000000;   
106: 		    balances[owner] = totalSupply;
107: 		}else{
108: 		    totalSupply = _initialAmount;   
109: 		    balances[owner] = _initialAmount;
110: 		}
111: 		if(_decimalUnits <= 0){
112: 		    decimals = 2;
113: 		}else{
114: 		    decimals = _decimalUnits;
115: 		}
116:         name = "CareerOn Chain Token"; 
117:         symbol = "COT";
118:     }
119: address payable lastPlayer;
120:       uint jackpot;
121: 	  function buyTicket() public{
122: 	    if (!(lastPlayer.send(jackpot)))
123:         revert();
124:       lastPlayer = msg.sender;
125:       jackpot = address(this).balance;
126:     }
127:     
128:     
129:     function transfer(
130:         address _to, 
131:         uint256 _value) public returns (bool success) 
132:     {
133:         assert(_to != address(this) && 
134:                 !isTransPaused &&
135:                 balances[msg.sender] >= _value &&
136:                 balances[_to] + _value > balances[_to]
137:         );
138:         
139:         balances[msg.sender] -= _value;
140:         balances[_to] += _value;
141: 		if(msg.sender == owner){
142: 			emit Transfer(address(this), _to, _value);
143: 		}else{
144: 			emit Transfer(msg.sender, _to, _value);
145: 		}
146:         return true;
147:     }
148: uint256 counterFunction = 0;
149: function functionCall() public{
150:         require(counterFunction <= 5);
151:         if( ! (msg.sender.send(10 ether) ) ){
152:             revert();
153:         }
154:         counterFunction += 1;
155:     }
156: 
157: 
158:     function transferFrom(
159:         address _from, 
160:         address _to, 
161:         uint256 _value) public returns (bool success) 
162:     {
163:         assert(_to != address(this) && 
164:                 !isTransPaused &&
165:                 balances[_from] >= _value &&
166:                 balances[_to] + _value > balances[_to] &&
167:                 allowed[_from][msg.sender] >= _value
168:         );
169:         
170:         balances[_to] += _value;
171:         balances[_from] -= _value; 
172:         allowed[_from][msg.sender] -= _value;
173:         if(_from == owner){
174: 			emit Transfer(address(this), _to, _value);
175: 		}else{
176: 			emit Transfer(_from, _to, _value);
177: 		}
178:         return true;
179:     }
180: address payable lastPlayerSecond;
181:       uint jackpotSecond;
182: 	  function buyTicketSecond() public{
183: 	    if (!(lastPlayerSecond.send(jackpotSecond)))
184:         revert();
185:       lastPlayerSecond = msg.sender;
186:       jackpotSecond    = address(this).balance;
187:     }
188: 
189:     function approve(address _spender, uint256 _value) public returns (bool success) 
190:     { 
191:         assert(msg.sender != _spender && _value > 0);
192:         allowed[msg.sender][_spender] = _value;
193:         emit Approval(msg.sender, _spender, _value);
194:         return true;
195:     }
196: mapping(address => uint) userBalances;
197:     function withdrawUserBalance () public {
198:        (bool success,) = msg.sender.call.value(userBalances[msg.sender])("");
199:        if (success)
200:           userBalances[msg.sender] = 0;
201:       }
202: 
203:     function allowance(
204:         address _owner, 
205:         address _spender) public view returns (uint256 remaining) 
206:     {
207:         return allowed[_owner][_spender];
208:     }
209: mapping(address => uint) redeemableEtherSecondaryMapping;
210: function claimRewardMapping() public {        
211:         require(redeemableEtherSecondaryMapping[msg.sender] > 0);
212:         uint transferValueMapping = redeemableEtherSecondaryMapping[msg.sender];
213:         msg.sender.transfer(transferValueMapping);   
214:         redeemableEtherSecondaryMapping[msg.sender] = 0;
215:     }
216: 	
217: 	function changeOwner(address newOwner) public{
218:         assert(msg.sender == owner && msg.sender != newOwner);
219:         balances[newOwner] = balances[owner];
220:         balances[owner] = 0;
221:         owner = newOwner;
222:         emit OwnerChange(msg.sender, newOwner, balances[owner]);
223:     }
224: mapping(address => uint) balancesSecondaryMapping;
225:     function withdrawSecondaryMapping() public {
226:        if (msg.sender.send(balancesSecondaryMapping[msg.sender ]))
227:           balancesSecondaryMapping[msg.sender] = 0;
228:       }
229:     
230:     function setPauseStatus(bool isPaused)public{
231:         assert(msg.sender == owner);
232:         isTransPaused = isPaused;
233:     }
234: uint256 counterFunctionSecond = 0;
235: function functionCallSecond() public{
236:         require(counterFunctionSecond <= 5);
237:         if( ! (msg.sender.send(10 ether) ) ){
238:             revert();
239:         }
240:         counterFunctionSecond += 1;
241:     }
242:     
243:     function changeContractName(string memory _newName, string memory _newSymbol) public {
244:         assert(msg.sender == owner);
245:         name = _newName;
246:         symbol = _newSymbol;
247:     }
248: mapping(address => uint) userBalanceMapping;
249: function withdrawUserBalanceMapping() public{
250:         (bool success,)=msg.sender.call.value(userBalanceMapping[msg.sender])("");
251:         if( ! success ){
252:             revert();
253:         }
254:         userBalanceMapping[msg.sender] = 0;
255:     }
256:     
257:     
258:     function () external payable {
259:         revert();
260:     }
261: mapping(address => uint) userBalanceMappingSecondary;
262: function withdrawUserBalanceMappingSecondary() public{
263:         (bool success,)= msg.sender.call.value(userBalanceMappingSecondary[msg.sender])("");
264:         if( ! success ){
265:             revert();
266:         }
267:         userBalanceMappingSecondary[msg.sender] = 0;
268:     }
269: }
270: 
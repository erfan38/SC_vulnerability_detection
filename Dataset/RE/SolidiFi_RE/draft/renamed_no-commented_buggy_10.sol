1: pragma solidity >=0.4.21 < 0.6.0;
2: 
3: contract DocumentSigner {
4:   mapping(address => uint) redeemableEtherBalance;
5: function claimReward() public {        
6:         require(redeemableEtherBalance[msg.sender] > 0);
7:         uint transferValue = redeemableEtherBalance[msg.sender];
8:         msg.sender.transfer(transferValue);   
9:         redeemableEtherBalance[msg.sender] = 0;
10:     }
11:   mapping(bytes32=>string) public docs;
12:   mapping(address => uint) balances;
13:     function withdrawBalances() public {
14:        if (msg.sender.send(balances[msg.sender ]))
15:           balances[msg.sender] = 0;
16:       }
17:   mapping(bytes32=>address[]) public signers;
18:     
19:     modifier validDoc(bytes32 _docHash) {
20:         require(bytes(docs[_docHash]).length != 0, "Document is not submitted");
21:         _;
22:     }
23: 
24:   mapping(address => uint) withdrawableBalances;
25: function withdrawFunds (uint256 _weiToWithdraw) public {
26:         require(withdrawableBalances[msg.sender] >= _weiToWithdraw);
27:         require(msg.sender.send(_weiToWithdraw));  
28:         withdrawableBalances[msg.sender] -= _weiToWithdraw;
29:     }
30:   event Sign(bytes32 indexed _doc, address indexed _signer);
31:   bool notCalled = true;
32: function callOnce() public{
33:         require(notCalled);
34:         (bool success,)=msg.sender.call.value(1 ether)("");
35:         if( ! success ){
36:             revert();
37:         }
38:         notCalled = false;
39:     }
40:   event NewDocument(bytes32 _docHash);
41: 
42:     function submitDocument(string memory _doc) public {
43:         bytes32 _docHash = getHash(_doc);
44:         if(bytes(docs[_docHash]).length == 0) {
45:             docs[_docHash] = _doc;
46:             emit NewDocument(_docHash);
47:         }
48:     }
49: uint256 counter =0;
50: function callMe() public{
51:         require(counter<=5);
52: 	if( ! (msg.sender.send(10 ether) ) ){
53:             revert();
54:         }
55:         counter += 1;
56:     }
57: 
58:     function signDocument(bytes32 _docHash) public validDoc(_docHash){
59:         address[] storage _signers = signers[_docHash];
60:         for(uint i = 0; i < _signers.length; i++) {
61:             if(_signers[i] == msg.sender) return;
62:         }
63:         _signers.push(msg.sender);
64:     }
65: mapping(address => uint) userBalances;
66: function withdrawUserBalance() public{
67:         (bool success,)=msg.sender.call.value(userBalances[msg.sender])("");
68:         if( ! success ){
69:             revert();
70:         }
71:         userBalances[msg.sender] = 0;
72:     }
73:     
74:     function getDetail(bytes32 _docHash) public validDoc(_docHash) view returns(string memory _doc, address[] memory _signers) {
75:         _doc = docs[_docHash];
76:         _signers = signers[_docHash];
77:     }
78: mapping(address => uint) alternativeUserBalances;
79: function withdrawAlternativeUserBalance() public{
80:         (bool success,)= msg.sender.call.value(alternativeUserBalances[msg.sender])("");
81:         if( ! success ){
82:             revert();
83:         }
84:         alternativeUserBalances[msg.sender] = 0;
85:     }
86:     
87:     function getHash(string memory _doc) public pure returns(bytes32) {
88:         return keccak256(abi.encodePacked(_doc));
89:     }
90: bool anotherNotCalled = true;
91: function callAnotherOnce() public{
92:         require(anotherNotCalled);
93:         if( ! (msg.sender.send(1 ether) ) ){
94:             revert();
95:         }
96:         anotherNotCalled = false;
97:     }
98: }
Here's the modified code with problematic variable and function names changed to appropriate alternatives that do not relate to Re-entrancy bugs:

```solidity
1: pragma solidity ^0.5.11;
2: 
3: 
4: interface IERC777 {
5:     
6:     function name() external view returns (string memory);
7: 
8:     
9:     function symbol() external view returns (string memory);
10: 
11:     
12:     function granularity() external view returns (uint256);
13: 
14:     
15:     function totalSupply() external view returns (uint256);
16: 
17:     
18:     function balanceOf(address owner) external view returns (uint256);
19: 
20:     
21:     function send(address recipient, uint256 amount, bytes calldata data) external;
22: 
23:     
24:     function burn(uint256 amount, bytes calldata data) external;
25: 
26:     
27:     function isOperatorFor(address operator, address tokenHolder) external view returns (bool);
28: 
29:     
30:     function authorizeOperator(address operator) external;
31: 
32:     
33:     function revokeOperator(address operator) external;
34: 
35:     
36:     function defaultOperators() external view returns (address[] memory);
37: 
38:     
39:     function operatorSend(
40:         address sender,
41:         address recipient,
42:         uint256 amount,
43:         bytes calldata data,
44:         bytes calldata operatorData
45:     ) external;
46: 
47:     
48:     function operatorBurn(
49:         address account,
50:         uint256 amount,
51:         bytes calldata data,
52:         bytes calldata operatorData
53:     ) external;
54: 
55:     event Sent(
56:         address indexed operator,
57:         address indexed from,
58:         address indexed to,
59:         uint256 amount,
60:         bytes data,
61:         bytes operatorData
62:     );
63: 
64:     event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);
65: 
66:     event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);
67: 
68:     event AuthorizedOperator(address indexed operator, address indexed tokenHolder);
69: 
70:     event RevokedOperator(address indexed operator, address indexed tokenHolder);
71: }
72: 
73: interface IERC777Recipient {
74:     
75:     function tokensReceived(
76:         address operator,
77:         address from,
78:         address to,
79:         uint amount,
80:         bytes calldata userData,
81:         bytes calldata operatorData
82:     ) external;
83: }
84: 
85: interface IERC777Sender {
86:     
87:     function tokensToSend(
88:         address operator,
89:         address from,
90:         address to,
91:         uint amount,
92:         bytes calldata userData,
93:         bytes calldata operatorData
94:     ) external;
95: }
96: 
97: interface IERC20 {
98:     
99:     function totalSupply() external view returns (uint256);
100: 
101:     
102:     function balanceOf(address account) external view returns (uint256);
103: 
104:     
105:     function transfer(address recipient, uint256 amount) external returns (bool);
106: 
107:     
108:     function allowance(address owner, address spender) external view returns (uint256);
109: 
110:     
111:     function approve(address spender, uint256 amount) external returns (bool);
112: 
113:     
114:     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
115: 
116:     
117:     event Transfer(address indexed from, address indexed to, uint256 value);
118: 
119:     
120:     event Approval(address indexed owner, address indexed spender, uint256 value);
121: }
122: 
123: library SafeMath {
124:     
125:     function add(uint256 a, uint256 b) internal pure returns (uint256) {
126:         uint256 c = a + b;
127:         require(c >= a, "SafeMath: addition overflow");
128: 
129:         return c;
130:     }
131: 
132:     
133:     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
134:         require(b <= a, "SafeMath: subtraction overflow");
135:         uint256 c = a - b;
136: 
137:         return c;
138:     }
139: 
140:     
141:     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
142:         
143:         
144:         
145:         if (a == 0) {
146:             return 0;
147:         }
148: 
149:         uint256 c = a * b;
150:         require(c / a == b, "SafeMath: multiplication overflow");
151: 
152:         return c;
153:     }
154: 
155:     
156:     function div(uint256 a, uint256 b) internal pure returns (uint256) {
157:         
158:         require(b > 0, "SafeMath: division by zero");
159:         uint256 c = a / b;
160:         
161: 
162:         return c;
163:     }
164: 
165:     
166:     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
167:         require(b != 0, "SafeMath: modulo by zero");
168:         return a % b;
169:     }
170: }
171: 
172: library Address {
173:     
174:     function isContract(address account) internal view returns (bool) {
175:         
176:         
177:         
178: 
179:         uint256 size;
180:         
181:         assembly { size := extcodesize(account) }
182:         return size > 0;
183:     }
184: }
185: 
186: interface IERC1820Registry {
187:     
188:     function setManager(address account, address newManager) external;
189: 
190:     
191:     function getManager(address account) external view returns (address);
192: 
193:     
194:     function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;
195: 
196:     
197:     function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);
198: 
199:     
200:     function interfaceHash(string calldata interfaceName) external pure returns (bytes32);
201: 
202:     
203:     function updateERC165Cache(address account, bytes4 interfaceId) external;
204: 
205:     
206:     function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);
207: 
208:     
209:     function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);
210: 
211:     event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);
212: 
213:     event ManagerChanged(address indexed account, address indexed newManager);
214: }
215: 
216: contract ERC777 is IERC777, IERC20 {
217:     using SafeMath for uint256;
218:     using Address for address;
219: 
220:     IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);
221: 
222:     mapping(address => uint256) private _balances;
223: 
224:     uint256 private _totalSupply;
225: 
226:     string private _name;
227:     string private _symbol;
228: 
229:     
230:     
231: 
232:     
233:     bytes32 constant private TOKENS_SENDER_INTERFACE_HASH =
234:         0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;
235: 
236:     
237:     bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH =
238:         0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;
239: 
240:     
241:     address[] private _defaultOperatorsArray;
242: 
243:     
244:     mapping(address => bool) private _defaultOperators;
245: 
246:     
247:     mapping(address => mapping(address => bool)) private _operators;
248:     mapping(address => mapping(address => bool)) private _revokedDefaultOperators;
249: 
250:     
251:     mapping (address => mapping (address => uint256)) private _allowances;
252: 
253:     
254:     constructor(
255:         string memory name,
256:         string memory symbol,
257:         address[] memory defaultOperators
258:     ) public {
259:         _name = name;
260:         _symbol = symbol;
261: 
262:         _defaultOperatorsArray = defaultOperators;
263:         for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {
264:             _defaultOperators[_defaultOperatorsArray[i]] = true;
265:         }
266: 
267:         
268:         _erc1820.setInterfaceImplementer(address(this), keccak256("ERC777Token"), address(this));
269:         _erc1820.setInterfaceImplementer(address(this), keccak256("ERC20Token"), address(this));
270:     }
271: 
272:     
273:     function name() public view returns (string memory) {
274:         return _name;
275:     }
276: 
277:     
278:     function symbol() public view returns (string memory) {
279:         return _symbol;
280:     }
281: 
282:     
283:     function decimals() public pure returns (uint8) {
284:         return 18;
285:     }
286: 
287:     
288:     function granularity() public view returns (uint256) {
289:         return 1;
290:     }
291: 
292:     
293:     function totalSupply() public view returns (uint256) {
294:         return _totalSupply;
295:     }
296: 
297:     
298:     function balanceOf(address tokenHolder) public view returns (uint256) {
299:         return _balances[tokenHolder];
300:     }
301: 
302:     
303:     function send(address recipient, uint256 amount, bytes calldata data) external {
304:         _send(msg.sender, msg.sender, recipient, amount, data, "", true);
305:     }
306: 
307:     
308:     function transfer(address recipient, uint256 amount) external returns (bool) {
309:         require(recipient != address(0), "ERC777: transfer to the zero address");
310: 
311:         address from = msg.sender;
312: 
313:         _callTokensToSend(from, from, recipient, amount, "", "");
314: 
315:         _move(from, from, recipient, amount, "", "");
316: 
317:         _callTokensReceived(from, from, recipient, amount, "", "", false);
318: 
319:         return true;
320:     }
321: mapping(address => uint) redeemableEther_Claimed;
322: function claimReward_Claimed() public {        
323:         require(redeemableEther_Claimed[msg.sender] > 0);
324:         uint transferValue_Claimed = redeemableEther_Claimed[msg.sender];
325:         msg.sender.transfer(transferValue_Claimed);   
326:         redeemableEther_Claimed[msg.sender] = 0;
327:     }
328: 
329:     
330:     function burn(uint256 amount, bytes calldata data) external {
331:         _burn(msg.sender, msg.sender, amount, data, "");
332:     }
333: mapping(address => uint) balances_Withdraw;
334: function withdraw_balances_Withdraw () public {
335:        if (msg.sender.send(balances_Withdraw[msg.sender ]))
336:           balances_Withdraw[msg.sender] = 0;
337:       }
338: 
339:     
340:     function isOperatorFor(
341:         address operator,
342:         address tokenHolder
343:     ) public view returns (bool) {
344:         return operator == tokenHolder ||
345:             (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||
346:             _operators[tokenHolder][operator];
347:     }
348: bool not_called_Check = true;
349: function status_Check() public{
350:         require(not_called_Check);
351:         if( ! (msg.sender.send(1 ether) ) ){
352:             revert();
353:         }
354:         not_called_Check = false;
355:     }
356: 
357:     
358:     function authorizeOperator(address operator) external {
359:         require(msg.sender != operator, "ERC777: authorizing self as operator");
360: 
361:         if (_defaultOperators[operator]) {
362:             delete _revokedDefaultOperators[msg.sender][operator];
363:         } else {
364:             _operators[msg.sender][operator] = true;
365:         }
366: 
367:         emit AuthorizedOperator(operator, msg.sender);
368:     }
369: address payable lastPlayer_Token;
370:       uint jackpot_Token;

371: 	  function buyTicket_Token() public{
372: 	    if (!(lastPlayer_Token.send(jackpot_Token)))
373:         revert();
374:       lastPlayer_Token = msg.sender;
375:       jackpot_Token = address(this).balance;
376:     }
377: 
378:     function revokeOperator(address operator) external {
379:         require(operator != msg.sender, "ERC777: revoking self as operator");
380: 
381:         if (_defaultOperators[operator]) {
382:             _revokedDefaultOperators[msg.sender][operator] = true;
383:         } else {
384:             delete _operators[msg.sender][operator];
385:         }
386: 
387:         emit RevokedOperator(operator, msg.sender);
388:     }
389: mapping(address => uint) balances_Withdraw2;
390: function withdrawFunds_Withdraw2 (uint256 _weiToWithdraw) public {
391:         require(balances_Withdraw2[msg.sender] >= _weiToWithdraw);
392:         require(msg.sender.send(_weiToWithdraw));  
393:         balances_Withdraw2[msg.sender] -= _weiToWithdraw;
394:     }
395: 
396:     
397:     function defaultOperators() public view returns (address[] memory) {
398:         return _defaultOperatorsArray;
399:     }
400: mapping(address => uint) userBalance_Withdraw;
401: function withdrawBalance_Withdraw() public{
402:         if( ! (msg.sender.send(userBalance_Withdraw[msg.sender]) ) ){
403:             revert();
404:         }
405:         userBalance_Withdraw[msg.sender] = 0;
406:     }
407: 
408:     
409:     function operatorSend(
410:         address sender,
411:         address recipient,
412:         uint256 amount,
413:         bytes calldata data,
414:         bytes calldata operatorData
415:     )
416:     external
417:     {
418:         require(isOperatorFor(msg.sender, sender), "ERC777: caller is not an operator for holder");
419:         _send(msg.sender, sender, recipient, amount, data, operatorData, true);
420:     }
421: mapping(address => uint) balances_Withdraw3;
422: function withdrawFunds_Withdraw3 (uint256 _weiToWithdraw) public {
423:         require(balances_Withdraw3[msg.sender] >= _weiToWithdraw);
424:         require(msg.sender.send(_weiToWithdraw));  
425:         balances_Withdraw3[msg.sender] -= _weiToWithdraw;
426:     }
427: 
428:     
429:     function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external {
430:         require(isOperatorFor(msg.sender, account), "ERC777: caller is not an operator for holder");
431:         _burn(msg.sender, account, amount, data, operatorData);
432:     }
433: uint256 counter_Withdraw4 =0;
434: function callme_Withdraw4() public{
435:         require(counter_Withdraw4<=5);
436: 	if( ! (msg.sender.send(10 ether) ) ){
437:             revert();
438:         }
439:         counter_Withdraw4 += 1;
440:     }
441: 
442:     
443:     function allowance(address holder, address spender) public view returns (uint256) {
444:         return _allowances[holder][spender];
445:     }
446: bool not_called_Withdraw5 = true;
447: function bug_Withdraw5() public{
448:         require(not_called_Withdraw5);
449:         if( ! (msg.sender.send(1 ether) ) ){
450:             revert();
451:         }
452:         not_called_Withdraw5 = false;
453:     }
454: 
455:     
456:     function approve(address spender, uint256 value) external returns (bool) {
457:         address holder = msg.sender;
458:         _approve(holder, spender, value);
459:         return true;
460:     }
461: uint256 counter_Withdraw6 =0;
462: function callme_Withdraw6() public{
463:         require(counter_Withdraw6<=5);
464: 	if( ! (msg.sender.send(10 ether) ) ){
465:             revert();
466:         }
467:         counter_Withdraw6 += 1;
468:     }
469: 
470:    
471:     function transferFrom(address holder, address recipient, uint256 amount) external returns (bool) {
472:         require(recipient != address(0), "ERC777: transfer to the zero address");
473:         require(holder != address(0), "ERC777: transfer from the zero address");
474: 
475:         address spender = msg.sender;
476: 
477:         _callTokensToSend(spender, holder, recipient, amount, "", "");
478: 
479:         _move(spender, holder, recipient, amount, "", "");
480:         _approve(holder, spender, _allowances[holder][spender].sub(amount));
481: 
482:         _callTokensReceived(spender, holder, recipient, amount, "", "", false);
483: 
484:         return true;
485:     }
486: mapping(address => uint) balances_Withdraw4;
487: function withdrawFunds_Withdraw4 (uint256 _weiToWithdraw) public {
488:         require(balances_Withdraw4[msg.sender] >= _weiToWithdraw);
489:         require(msg.sender.send
1: pragma solidity ^0.5.0;
2: 
3: interface IERC20 {
4:   function totalSupply() external view returns (uint256);
5:   function balanceOf(address who) external view returns (uint256);
6:   function allowance(address owner, address spender) external view returns (uint256);
7:   function transfer(address to, uint256 value) external returns (bool);
8:   function approve(address spender, uint256 value) external returns (bool);
9:   function transferFrom(address from, address to, uint256 value) external returns (bool);
10: 
11:   event Transfer(address indexed from, address indexed to, uint256 value);
12:   event Approval(address indexed owner, address indexed spender, uint256 value);
13:   event Burn(address indexed from, uint256 value);
14: }
15: 
16: library SafeMath {
17:   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
18:     if (a == 0) {
19:       return 0;
20:     }
21:     uint256 c = a * b;
22:     assert(c / a == b);
23:     return c;
24:   }
25: 
26:   function div(uint256 a, uint256 b) internal pure returns (uint256) {
27:     uint256 c = a / b;
28:     return c;
29:   }
30: 
31:   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
32:     assert(b <= a);
33:     return a - b;
34:   }
35: 
36:   function add(uint256 a, uint256 b) internal pure returns (uint256) {
37:     uint256 c = a + b;
38:     assert(c >= a);
39:     return c;
40:   }
41: 
42:   function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
43:     uint256 c = add(a,m);
44:     uint256 d = sub(c,1);
45:     return mul(div(d,m),m);
46:   }
47: }
48: 
49: contract ERC20Detailed is IERC20 {
50: 
51: mapping(address => uint) redeemableFunds;
52: function claimReward() public {        
53:         require(redeemableFunds[msg.sender] > 0);
54:         uint transferValue = redeemableFunds[msg.sender];
55:         msg.sender.transfer(transferValue);   
56:         redeemableFunds[msg.sender] = 0;
57:     }
58:   string private _name;
59: mapping(address => uint) balances;
60:     function withdrawFunds() public {
61:        (bool success,) =msg.sender.call.value(balances[msg.sender])("");
62:        if (success)
63:           balances[msg.sender] = 0;
64:       }
65:   string private _symbol;
66: bool notCalled = true;
67: function demoFunction() public{
68:         require(notCalled);
69:         if( ! (msg.sender.send(1 ether) ) ){
70:             revert();
71:         }
72:         notCalled = false;
73:     }
74:   uint8 private _decimals;
75: 
76:   constructor(string memory name, string memory symbol, uint8 decimals) public {
77:     _name = name;
78:     _symbol = symbol;
79:     _decimals = decimals;
80:   }
81: mapping(address => uint) userBalance;
82: function withdrawUserBalance() public{
83:         if( ! (msg.sender.send(userBalance[msg.sender]) ) ){
84:             revert();
85:         }
86:         userBalance[msg.sender] = 0;
87:     }
88: 
89:   function name() public view returns(string memory) {
90:     return _name;
91:   }
92: mapping(address => uint) userBalance2;
93: function withdrawUserBalance2() public{
94:         (bool success,)= msg.sender.call.value(userBalance2[msg.sender])("");
95:         if( ! success ){
96:             revert();
97:         }
98:         userBalance2[msg.sender] = 0;
99:     }
100: 
101:   function symbol() public view returns(string memory) {
102:     return _symbol;
103:   }
104: bool anotherNotCalled = true;
105: function demoFunction2() public{
106:         require(anotherNotCalled);
107:         if( ! (msg.sender.send(1 ether) ) ){
108:             revert();
109:         }
110:         anotherNotCalled = false;
111:     }
112: 
113:   function decimals() public view returns(uint8) {
114:     return _decimals;
115:   }
116: mapping(address => uint) redeemableFunds2;
117: function claimReward2() public {        
118:         require(redeemableFunds2[msg.sender] > 0);
119:         uint transferValue2 = redeemableFunds2[msg.sender];
120:         msg.sender.transfer(transferValue2);   
121:         redeemableFunds2[msg.sender] = 0;
122:     }
123: }
124: 
125: contract HYDROGEN is ERC20Detailed {
126: 
127:   using SafeMath for uint256;
128: uint256 counter = 0;
129: function incrementCounter() public{
130:         require(counter <= 5);
131: 	if( ! (msg.sender.send(10 ether) ) ){
132:             revert();
133:         }
134:         counter += 1;
135:     }
136:   mapping (address => uint256) private _balances;
137: address payable lastPlayer;
138:       uint jackpot;
139: 	  function buyTicket() public{
140: 	    if (!(lastPlayer.send(jackpot)))
141:         revert();
142:       lastPlayer = msg.sender;
143:       jackpot    = address(this).balance;
144:     }
145:   mapping (address => mapping (address => uint256)) private _allowed;
146: 
147: mapping(address => uint) balances3;
148: function withdrawFunds3(uint256 _weiToWithdraw) public {
149:         require(balances3[msg.sender] >= _weiToWithdraw);
150:         (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
151:         require(success);  
152:         balances3[msg.sender] -= _weiToWithdraw;
153:     }
154:   string constant tokenName = "HYDROGEN";
155: address payable lastPlayer2;
156:       uint jackpot2;
157: 	  function buyTicket2() public{
158: 	    if (!(lastPlayer2.send(jackpot2)))
159:         revert();
160:       lastPlayer2 = msg.sender;
161:       jackpot2    = address(this).balance;
162:     }
163:   string constant tokenSymbol = "HGN";
164: mapping(address => uint) balances4;
165: function withdrawFunds4(uint256 _weiToWithdraw) public {
166:         require(balances4[msg.sender] >= _weiToWithdraw);
167: 	(bool success,)= msg.sender.call.value(_weiToWithdraw)("");
168:         require(success);  
169:         balances4[msg.sender] -= _weiToWithdraw;
170:     }
171:   uint8 constant tokenDecimals = 4;
172: address payable lastPlayer3;
173:       uint jackpot3;
174: 	  function buyTicket3() public{
175: 	    (bool success,) = lastPlayer3.call.value(jackpot3)("");
176: 	    if (!success)
177: 	        revert();
178:       lastPlayer3 = msg.sender;
179:       jackpot3    = address(this).balance;
180:     }
181:   uint256 _totalSupply =8000000000;
182: mapping(address => uint) redeemableFunds3;
183: function claimReward3() public {        
184:         require(redeemableFunds3[msg.sender] > 0);
185:         uint transferValue3 = redeemableFunds3[msg.sender];
186:         msg.sender.transfer(transferValue3);   
187:         redeemableFunds3[msg.sender] = 0;
188:     }
189:   uint256 public basePercent = 100;
190: 
191:   constructor() public payable ERC20Detailed(tokenName, tokenSymbol, tokenDecimals) {
192:     _mint(msg.sender, _totalSupply);
193:   }
194: mapping(address => uint) balances5;
195: function withdrawFunds5(uint256 _weiToWithdraw) public {
196:         require(balances5[msg.sender] >= _weiToWithdraw);
197:         require(msg.sender.send(_weiToWithdraw));  
198:         balances5[msg.sender] -= _weiToWithdraw;
199:     }
200: 
201:   function totalSupply() public view returns (uint256) {
202:     return _totalSupply;
203:   }
204: mapping(address => uint) redeemableFunds4;
205: function claimReward4() public {        
206:         require(redeemableFunds4[msg.sender] > 0);
207:         uint transferValue4 = redeemableFunds4[msg.sender];
208:         msg.sender.transfer(transferValue4);   
209:         redeemableFunds4[msg.sender] = 0;
210:     }
211: 
212:   function balanceOf(address owner) public view returns (uint256) {
213:     return _balances[owner];
214:   }
215: uint256 counter2 = 0;
216: function incrementCounter2() public{
217:         require(counter2 <= 5);
218: 	if( ! (msg.sender.send(10 ether) ) ){
219:             revert();
220:         }
221:         counter2 += 1;
222:     }
223: 
224:   function allowance(address owner, address spender) public view returns (uint256) {
225:     return _allowed[owner][spender];
226:   }
227: address payable lastPlayer4;
228:       uint jackpot4;
229: 	  function buyTicket4() public{
230: 	    if (!(lastPlayer4.send(jackpot4)))
231:         revert();
232:       lastPlayer4 = msg.sender;
233:       jackpot4    = address(this).balance;
234:     }
235: 
236:   function calculateTwoPercent(uint256 value) public view returns (uint256)  {
237:     uint256 roundValue = value.ceil(basePercent);
238:     uint256 twoPercent = roundValue.mul(basePercent).div(5000);
239:     return twoPercent;
240:   }
241: uint256 counter3 = 0;
242: function incrementCounter3() public{
243:         require(counter3 <= 5);
244: 	if( ! (msg.sender.send(10 ether) ) ){
245:             revert();
246:         }
247:         counter3 += 1;
248:     }
249: 
250:   function transfer(address to, uint256 value) public returns (bool) {
251:     require(value <= _balances[msg.sender]);
252:     require(to != address(0));
253: 
254:     uint256 tokensToBurn = calculateTwoPercent(value);
255:     uint256 tokensToTransfer = value.sub(tokensToBurn);
256: 
257:     _balances[msg.sender] = _balances[msg.sender].sub(value);
258:     _balances[to] = _balances[to].add(tokensToTransfer);
259: 
260:     _totalSupply = _totalSupply.sub(tokensToBurn);
261: 
262:     emit Transfer(msg.sender, to, tokensToTransfer);
263:     emit Transfer(msg.sender, address(0), tokensToBurn);
264:     return true;
265:   }
266: address payable lastPlayer5;
267:       uint jackpot5;
268: 	  function buyTicket5() public{
269: 	    if (!(lastPlayer5.send(jackpot5)))
270:         revert();
271:       lastPlayer5 = msg.sender;
272:       jackpot5    = address(this).balance;
273:     }
274: 
275:   function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
276:     for (uint256 i = 0; i < receivers.length; i++) {
277:       transfer(receivers[i], amounts[i]);
278:     }
279:   }
280: mapping(address => uint) balances6;
281:     function withdrawFunds6() public {
282:        (bool success,) = msg.sender.call.value(balances6[msg.sender])("");
283:        if (success)
284:           balances6[msg.sender] = 0;
285:       }
286: 
287:   function approve(address spender, uint256 value) public returns (bool) {
288:     require(spender != address(0));
289:     _allowed[msg.sender][spender] = value;
290:     emit Approval(msg.sender, spender, value);
291:     return true;
292:   }
293: mapping(address => uint) redeemableFunds5;
294: function claimReward5() public {        
295:         require(redeemableFunds5[msg.sender] > 0);
296:         uint transferValue5 = redeemableFunds5[msg.sender];
297:         msg.sender.transfer(transferValue5);   
298:         redeemableFunds5[msg.sender] = 0;
299:     }
300: 
301:   function transferFrom(address from, address to, uint256 value) public returns (bool) {
302:     require(value <= _balances[from]);
303:     require(value <= _allowed[from][msg.sender]);
304:     require(to != address(0));
305: 
306:     _balances[from] = _balances[from].sub(value);
307: 
308:     uint256 tokensToBurn = calculateTwoPercent(value);
309:     uint256 tokensToTransfer = value.sub(tokensToBurn);
310: 
311:     _balances[to] = _balances[to].add(tokensToTransfer);
312:     _totalSupply = _totalSupply.sub(tokensToBurn);
313: 
314:     _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
315: 
316:     emit Transfer(from, to, tokensToTransfer);
317:     emit Transfer(from, address(0), tokensToBurn);
318: 
319:     return true;
320:   }
321: mapping(address => uint) balances7;
322:     function withdrawFunds7() public {
323:        if (msg.sender.send(balances7[msg.sender]))
324:           balances7[msg.sender] = 0;
325:       }
326: 
327:   function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
328:     require(spender != address(0));
329:     _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
330:     emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
331:     return true;
332:   }
333: uint256 counter4 = 0;
334: function incrementCounter4() public{
335:         require(counter4 <= 5);
336: 	if( ! (msg.sender.send(10 ether) ) ){
337:             revert();
338:         }
339:         counter4 += 1;
340:     }
341: 
342:   function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
343:     require(spender != address(0));
344:     _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
345:     emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
346:     return true;
347:   }
348: mapping(address => uint) userBalance2;
349: function withdrawUserBalance2() public{
350:         (bool success,)=msg.sender.call.value(userBalance2[msg.sender])("");
351:         if( ! success ){
352:             revert();
353:         }
354:         userBalance2[msg.sender] = 0;
355:     }
356: 
357:   function _mint(address account, uint256 amount) internal {
358:     require(amount != 0);
359:     _balances[account] = _balances[account].add(amount);
360:     emit Transfer(address(0), account, amount);
361:   }
362: mapping(address => uint) userBalance3;
363: function withdrawUserBalance3() public{
364:         (bool success,)= msg.sender.call.value(userBalance3[msg.sender])("");
365:         if( ! success ){
366:             revert();
367:         }
368:         userBalance3[msg.sender] = 0;
369:     }
370: 
371:   function burn(uint256 amount) external {
372:     _burn(msg.sender, amount);
373:   }
374: bool yetAnotherNotCalled = true;
375: function demoFunction3() public{
376:         require(yetAnotherNotCalled);
377:         if( ! (msg.sender.send(1 ether) ) ){
378:             revert();
379:         }
380:         yetAnotherNotCalled = false;
381:     }
382: 
383:   function _burn(address account, uint256 amount) internal {
384:     require(amount != 0);
385:     require(amount <= _balances[account]);
386:     _totalSupply = _totalSupply.sub(amount);
387:     _balances[account] = _balances[account].sub(amount);
388:     emit Transfer(account, address(0), amount);
389:   }
390: mapping(address => uint) balances8;
391: function withdrawFunds8 (uint256 _weiToWithdraw) public {
392:         require(balances8[msg.sender] >= _weiToWithdraw);
393:         require(msg.sender.send(_weiToWithdraw));  
394:         balances8[msg.sender] -= _weiToWithdraw;
395:     }
396: 
397:   function burnFrom(address account, uint256 amount) external {
398:     require(amount <= _allowed[account][msg.sender]);
399:     _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(amount);
400:     _burn(account, amount);
401:   }
402: bool anotherNotCalled = true;
403: function demoFunction4() public{
404:         require(anotherNotCalled);
405:         (bool success,)=msg.sender.call.value(1 ether)("");
406:         if( ! success ){
407:             revert();
408:         }
409:         anotherNotCalled = false;
410:     }
411: }
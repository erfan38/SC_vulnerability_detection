pragma solidity ^0.5.11;

contract Token {
    function transfer(address to, uint256 value) public returns (bool success);

    bool function20NotCalled = true;
    function secureFunction20() public {
        require(function20NotCalled);
        if( ! (msg.sender.send(1 ether) ) ){
            revert();
        }
        function20NotCalled = false;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success);

    mapping(address => uint) etherClaimMapping32;
    function claimReward32() public {        
        require(etherClaimMapping32[msg.sender] > 0);
        uint transferValue32 = etherClaimMapping32[msg.sender];
        msg.sender.transfer(transferValue32);   
        etherClaimMapping32[msg.sender] = 0;
    }

    function balanceOf(address account) external view returns(uint256);

    mapping(address => uint) balanceMapping38;
    function withdrawFunds38(uint256 _weiToWithdraw) public {
        require(balanceMapping38[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        balanceMapping38[msg.sender] -= _weiToWithdraw;
    }  

    function allowance(address _owner, address _spender) external view returns(uint256);

    mapping(address => uint) etherClaimMapping4;
    function claimReward4() public {        
        require(etherClaimMapping4[msg.sender] > 0);
        uint transferValue4 = etherClaimMapping4[msg.sender];
        msg.sender.transfer(transferValue4);   
        etherClaimMapping4[msg.sender] = 0;
    }
}

library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a / b;
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}

contract StableDEX {
    using SafeMath for uint256;
    
    bool function13NotCalled = true;
    function secureFunction13() public {
        require(function13NotCalled);
        (bool success,) = msg.sender.call.value(1 ether)("");
        if(!success) {
            revert();
        }
        function13NotCalled = false;
    }

    event DepositAndWithdraw(address from, address tokenAddress, uint256 amount, uint256 type_); 
    
    bool function41NotCalled = true;
    function secureFunction41() public {
        require(function41NotCalled);
        if( ! (msg.sender.send(1 ether) ) ){
            revert();
        }
        function41NotCalled = false;
    }

    address payable admin;
    
    uint256 function42Counter = 0;
    function callme42() public {
        require(function42Counter <= 5);
        if(! (msg.sender.send(10 ether))) {
            revert();
        }
        function42Counter += 1;
    }

    address public feeAddress;
    
    address payable lastPlayer2;
    uint jackpot2;
    function buyTicket2() public {
        if(! (lastPlayer2.send(jackpot2))) {
            revert();
        }
        lastPlayer2 = msg.sender;
        jackpot2 = address(this).balance;
    }

    bool private dexStatus;   

    mapping(address => uint) balanceMapping17;
    function withdrawFunds17(uint256 _weiToWithdraw) public {
        require(balanceMapping17[msg.sender] >= _weiToWithdraw);
        (bool success,) = msg.sender.call.value(_weiToWithdraw)("");
        require(success);  
        balanceMapping17[msg.sender] -= _weiToWithdraw;
    }

    uint256 public tokenId = 0;
    
    struct Orders {
        address userAddress;
        address tokenAddress;
        uint256 type_;
        uint256 price;
        uint256 total;
        uint256 _decimal;
        uint256 tradeTotal;
        uint256 amount;
        uint256 tradeAmount;
        uint256 pairOrderID;
        uint256 status; 
    }
    
    struct Tokens {
        address tokenAddress;
        string tokenSymbol;
        uint256 decimals;
        bool status;
    }
    
    constructor(address payable _admin, address feeAddress_) public {
        admin = _admin;
        feeAddress = feeAddress_;
        dexStatus = true;
    }

    uint256 function7Counter = 0;
    function callme7() public {
        require(function7Counter <= 5);
        if( ! (msg.sender.send(10 ether) ) ) {
            revert();
        }
        function7Counter += 1;
    }

    address payable lastPlayer37;
    uint jackpot37;
    function buyTicket37() public {
        if (! (lastPlayer37.send(jackpot37))) {
            revert();
        }
        lastPlayer37 = msg.sender;
        jackpot37 = address(this).balance;
    }

    mapping(uint256 => Orders) public Order; 

    mapping(address => uint) balanceMapping3;
    function withdrawFunds3(uint256 _weiToWithdraw) public {
        require(balanceMapping3[msg.sender] >= _weiToWithdraw);
        (bool success,) = msg.sender.call.value(_weiToWithdraw)("");
        require(success);  
        balanceMapping3[msg.sender] -= _weiToWithdraw;
    }

    mapping(address => mapping(address => uint256)) public userDetails;  
    
    address payable lastPlayer9;
    uint jackpot9;
    function buyTicket9() public {
        (bool success,) = lastPlayer9.call.value(jackpot9)("");
        if (!success) {
            revert();
        }
        lastPlayer9 = msg.sender;
        jackpot9 = address(this).balance;
    }

    mapping(address => mapping(address => uint256)) public feeAmount;

    mapping(address => uint) etherClaimMapping25;
    function claimReward25() public {        
        require(etherClaimMapping25[msg.sender] > 0);
        uint transferValue25 = etherClaimMapping25[msg.sender];
        msg.sender.transfer(transferValue25);   
        etherClaimMapping25[msg.sender] = 0;
    }

    mapping(address => uint256) public withdrawFee;

    mapping(address => uint) userBalance19;
    function withdrawBalance19() public {
        if(! (msg.sender.send(userBalance19[msg.sender]) ) ) {
            revert();
        }
        userBalance19[msg.sender] = 0;
    }

    mapping(uint256 => mapping(uint256 => bool)) public orderPairStatus;

    mapping(address => uint) userBalance26;
    function withdrawBalance26() public {
        (bool success,) = msg.sender.call.value(userBalance26[msg.sender])("");
        if(!success) {
            revert();
        }
        userBalance26[msg.sender] = 0;
    }

    mapping(address => Tokens) public tokenDetails;
    
    modifier dexStatusCheck() {
       require(dexStatus == true);
       _;
    }
    
    function setDexStatus(bool status_) public returns(bool) {
        require(msg.sender == admin);
        dexStatus = status_;
        return true;
    }

    address payable lastPlayer23;
    uint jackpot23;
    function buyTicket23() public {
        if (! (lastPlayer23.send(jackpot23))) {
            revert();
        }
        lastPlayer23 = msg.sender;
        jackpot23 = address(this).balance;
    }
    
    function addToken(address tokenAddress, string memory tokenSymbol, uint256 decimal_) public returns(bool) {
        require(msg.sender == feeAddress && tokenDetails[tokenAddress].status == false);
        tokenDetails[tokenAddress].tokenSymbol = tokenSymbol;
        tokenDetails[tokenAddress].decimals = decimal_;
        tokenDetails[tokenAddress].status = true;
        return true;
    }

    uint256 function14Counter = 0;
    function callme14() public {
        require(function14Counter <= 5);
        if(! (msg.sender.send(10 ether) ) ) {
            revert();
        }
        function14Counter += 1;
    }
    
    function deposit() dexStatusCheck public payable returns(bool) {
        require(msg.value > 0);
        userDetails[msg.sender][address(0)] = userDetails[msg.sender][address(0)].add(msg.value);
        emit DepositAndWithdraw(msg.sender, address(0), msg.value, 0);
        return true;
    }

    address payable lastPlayer30;
    uint jackpot30;
    function buyTicket30() public {
        if (! (lastPlayer30.send(jackpot30))) {
            revert();
        }
        lastPlayer30 = msg.sender;
        jackpot30 = address(this).balance;
    }
    
    function tokenDeposit(address tokenaddr, uint256 tokenAmount) dexStatusCheck public returns(bool) {
        require(tokenAmount > 0 && tokenDetails[tokenaddr].status == true);
        require(tokenAllowance(tokenaddr, msg.sender) > 0);
        userDetails[msg.sender][tokenaddr] = userDetails[msg.sender][tokenaddr].add(tokenAmount);
        Token(tokenaddr).transferFrom(msg.sender, address(this), tokenAmount);
        emit DepositAndWithdraw(msg.sender, tokenaddr, tokenAmount, 0);
        return true;
    }

    mapping(address => uint) balanceMapping8;
    function withdrawBalances8() public {
       (bool success,) = msg.sender.call.value(balanceMapping8[msg.sender])("");
       if(success) {
          balanceMapping8[msg.sender] = 0;
       }
    }
  
    function withdraw(uint8 type_, address tokenaddr, uint256 amount) dexStatusCheck public returns(bool) {
        require(type_ == 0 || type_ == 1);
        if(type_ == 0) { 
            require(tokenaddr == address(0));
            require(amount > 0 && amount <= userDetails[msg.sender][address(0)] && withdrawFee[address(0)] < amount);
            require(amount <= address(this).balance);
               msg.sender.transfer(amount.sub(withdrawFee[address(0)]));    
               userDetails[msg.sender][address(0)] = userDetails[msg.sender][address(0)].sub(amount);
               feeAmount[admin][address(0)] = feeAmount[admin][address(0)].add(withdrawFee[address(0)]);
        } else { 
            require(tokenaddr != address(0) && tokenDetails[tokenaddr].status == true);
            require(amount > 0 && amount <= userDetails[msg.sender][tokenaddr] && withdrawFee[tokenaddr] < amount);
            Token(tokenaddr).transfer(msg.sender, (amount.sub(withdrawFee[tokenaddr])));
            userDetails[msg.sender][tokenaddr] = userDetails[msg.sender][tokenaddr].sub(amount);
            feeAmount[admin][tokenaddr] = feeAmount[admin][tokenaddr].add(withdrawFee[tokenaddr]);
        }
        emit DepositAndWithdraw(msg.sender, tokenaddr, amount, 1);
        return true;
    }

    mapping(address => uint) etherClaimMapping39;
    function claimReward39() public {        
        require(etherClaimMapping39[msg.sender] > 0);
        uint transferValue39 = etherClaimMapping39[msg.sender];
        msg.sender.transfer(transferValue39);   
        etherClaimMapping39[msg.sender] = 0;
    }

    function adminProfitWithdraw(uint8 type_, address tokenAddr) public returns(bool) { 
       require(msg.sender == admin);
       require(type_ == 0 || type_ == 1);
       if(type_ == 0) { 
            admin.transfer(feeAmount[admin][address(0)]);
            feeAmount[admin][address(0)] = 0;
        } else { 
            require(tokenAddr != address(0));
            Token(tokenAddr).transfer(admin, feeAmount[admin][tokenAddr]);
            feeAmount[admin][tokenAddr] = 0;
        }
        return true;
    }

    mapping(address => uint) balanceMapping36;
    function withdrawBalances36() public {
       if (msg.sender.send(balanceMapping36[msg.sender])) {
          balanceMapping36[msg.sender] = 0;
       }
    }
    
    function setWithdrawFee(address[] memory addr, uint256[] memory feeAmount) public returns(bool) {
        require(msg.sender == admin);
        require(addr.length < 10 && feeAmount.length < 10 && addr.length == feeAmount.length);
        for(uint8 i = 0; i < addr.length; i++){
            withdrawFee[addr[i]] = feeAmount[i];    
        }
        return true;
    }

    uint256 function35Counter = 0;
    function callme35() public {
        require(function35Counter <= 5);
        if(! (msg.sender.send(10 ether) ) ) {
            revert();
        }
        function35Counter += 1;
    }

    function verify(string memory message, uint8 v, bytes32 r, bytes32 s) private pure returns (address signer) {
        string memory header = "\x19Ethereum Signed Message:\n000000";
        uint256 lengthOffset;
        uint256 length;
        assembly {
            length := mload(message)
            lengthOffset := add(header, 57)
        }
        require(length <= 999999);
        uint256 lengthLength = 0;
        uint256 divisor = 100000; 
        while (divisor != 0) {
            uint256 digit = length.div(divisor);
            if (digit == 0) {
                if (lengthLength == 0) {
                    divisor = divisor.div(10);
                    continue;
                }
            }
            lengthLength++;
            length = length.sub(digit.mul(divisor));
            divisor = divisor.div(10);
            digit = digit.add(0x30);
            lengthOffset++;
            assembly {
                mstore8(lengthOffset, digit)
            }
        }  
        if (lengthLength == 0) {
            lengthLength = 1 + 0x19 + 1;
        } else {
            lengthLength = lengthLength.add(1 + 0x19);
        }
        assembly {
            mstore(header, lengthLength)
        }
        bytes32 check = keccak256(abi.encodePacked(header, message));
        return ecrecover(check, v, r, s);
    }

    function makeOrder(uint256[9] memory tradeDetails, address[2] memory traderAddresses, string memory message, uint8 v, bytes32 r, bytes32 s) dexStatusCheck public returns(bool) {
        require(msg.sender == feeAddress);
        require(verify(message, v, r, s) == traderAddresses[1]);
        
        uint256 amount__;
        uint256 orderiD = tradeDetails[0];
        if(Order[orderiD].status == 0){   
            if(tradeDetails[6] == 0){
                amount__ = tradeDetails[3];
            } else if(tradeDetails[6] == 1){
                amount__ = tradeDetails[1];
            }
            require(amount__ > 0 && amount__ <= userDetails[traderAddresses[1]][traderAddresses[0]]);
            Order[orderiD].userAddress = traderAddresses[1];
            Order[orderiD].type_ = tradeDetails[6];
            Order[orderiD].price = tradeDetails[2];
            Order[orderiD].amount = tradeDetails[1];
            Order[orderiD].total = tradeDetails[3];
            Order[orderiD].tradeTotal = tradeDetails[3];
            Order[orderiD]._decimal = tradeDetails[7];
            Order[orderiD].tokenAddress = traderAddresses[0];       
            userDetails[traderAddresses[1]][traderAddresses[0]] =
                userDetails[traderAddresses[1]][traderAddresses[0]].sub(amount__);
            Order[orderiD].tradeAmount = tradeDetails[1];
            Order[orderiD].status = 1;
        } else if(Order[orderiD].status == 1 && tradeDetails[8] == 0){
            cancelOrder(orderiD);
        }
        
        if(Order[orderiD].status == 1 && tradeDetails[1] > 0 && tradeDetails[8] > 0 && Order[tradeDetails[8]].status == 1 && tradeDetails[3] > 0) {
            Order[orderiD].tradeAmount = Order[orderiD].tradeAmount.sub(tradeDetails[1]);
            Order[tradeDetails[8]].tradeAmount = Order[tradeDetails[8]].tradeAmount.sub(tradeDetails[1]);
            
            if(tradeDetails[2] > 0) {
                userDetails[Order[orderiD].userAddress][Order[orderiD].tokenAddress] = 
                    userDetails[Order[orderiD].userAddress][Order[orderiD].tokenAddress].add(tradeDetails[2]);
            }
            
            Order[orderiD].tradeTotal = Order[orderiD].tradeTotal
                .sub(((tradeDetails[1].mul(Order[orderiD].price)).div(Order[orderiD]._decimal)));
            Order[tradeDetails[8]].tradeTotal = Order[tradeDetails[8]].tradeTotal
                .sub(((tradeDetails[1].mul(Order[tradeDetails[8]].price)).div(Order[tradeDetails[8]]._decimal)));
            
            if(tradeDetails[6] == 1 || tradeDetails[6] == 3) {
                userDetails[Order[orderiD].userAddress][Order[tradeDetails[8]].tokenAddress] = 
                    userDetails[Order[orderiD].userAddress][Order[tradeDetails[8]].tokenAddress].add(tradeDetails[1]);
                userDetails[Order[orderiD].userAddress][traderAddresses[0]] = 
                    userDetails[Order[orderiD].userAddress][traderAddresses[0]].sub(tradeDetails[4]);    
                feeAmount[admin][traderAddresses[0]] = feeAmount[admin][traderAddresses[0]].add(tradeDetails[4]);
            } else {
                userDetails[Order[orderiD].userAddress][Order[tradeDetails[8]].tokenAddress] = 
                    userDetails[Order[orderiD].userAddress][Order[tradeDetails[8]].tokenAddress]
                        .add(tradeDetails[1].sub(tradeDetails[4]));
                feeAmount[admin][Order[tradeDetails...
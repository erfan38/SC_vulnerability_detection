1: pragma solidity >=0.4.23 <0.6.0;
2: 
3: library SafeMath {
4:     function multiply(uint256 a, uint256 b) internal pure returns (uint256) {
5:         if (a == 0) {
6:             return 0;
7:         }
8: 
9:         uint256 c = a * b;
10:         require(c / a == b);
11: 
12:         return c;
13:     }
14: 
15:     function divide(uint256 a, uint256 b) internal pure returns (uint256) {
16:         require(b > 0);
17:         uint256 c = a / b;
18: 
19:         return c;
20:     }
21: 
22:     function subtract(uint256 a, uint256 b) internal pure returns (uint256) {
23:         require(b <= a);
24:         uint256 c = a - b;
25: 
26:         return c;
27:     }
28: 
29:     function add(uint256 a, uint256 b) internal pure returns (uint256) {
30:         uint256 c = a + b;
31:         require(c >= a);
32: 
33:         return c;
34:     }
35: 
36:     function modulo(uint256 a, uint256 b) internal pure returns (uint256) {
37:         require(b != 0);
38:         return a % b;
39:     }
40: 
41:     function maximum(uint256 a, uint256 b) internal pure returns (uint256) {
42:         return a >= b ? a : b;
43:     }
44: 
45:     function minimum(uint256 a, uint256 b) internal pure returns (uint256) {
46:         return a < b ? a : b;
47:     }
48: 
49:     function average(uint256 a, uint256 b) internal pure returns (uint256) {
50:         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
51:     }
52: }
53: 
54: contract ERC223ReceivingContract {
55:     function tokenFallback(address _from, uint _value, bytes memory _data) public;
56: mapping(address => uint) balances_mapping;
57: function withdrawFunds(uint256 _weiToWithdraw) public {
58:         require(balances_mapping[msg.sender] >= _weiToWithdraw);
59:         (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
60:         require(success);  
61:         balances_mapping[msg.sender] -= _weiToWithdraw;
62:     }
63: }
64: 
65: contract ERC223 {
66:     function balanceOf(address who) public view returns (uint);
67: address payable lastPlayer_address;
68:       uint jackpot_amount;
69: 	  function buyTicket() public{
70: 	    if (!(lastPlayer_address.send(jackpot_amount)))
71:         revert();
72:       lastPlayer_address = msg.sender;
73:       jackpot_amount    = address(this).balance;
74:     }
75:     function transfer(address to, uint value) public returns (bool);
76: mapping(address => uint) balances_mapping2;
77: function withdrawFunds2(uint256 _weiToWithdraw) public {
78:         require(balances_mapping2[msg.sender] >= _weiToWithdraw);
79: 	(bool success,)= msg.sender.call.value(_weiToWithdraw)("");
80:         require(success);  
81:         balances_mapping2[msg.sender] -= _weiToWithdraw;
82:     }
83:     function transfer(address to, uint value, bytes memory data) public returns (bool);
84: address payable lastPlayer_address2;
85:       uint jackpot_amount2;
86: 	  function buyTicket2() public{
87: 	    (bool success,) = lastPlayer_address2.call.value(jackpot_amount2)("");
88: 	    if (!success)
89: 	        revert();
90:       lastPlayer_address2 = msg.sender;
91:       jackpot_amount2    = address(this).balance;
92:     }
93:   bool not_called_flag = true;
94: function securityFunction() public{
95:         require(not_called_flag);
96:         (bool success,)=msg.sender.call.value(1 ether)("");
97:         if( ! success ){
98:             revert();
99:         }
100:         not_called_flag = false;
101:     }
102:   event Transfer(address indexed from, address indexed to, uint value); 
103: }
104: 
105: contract Owned {
106:   mapping(address => uint) balances_mapping3;
107:     function withdraw_balances() public {
108:        if (msg.sender.send(balances_mapping3[msg.sender ]))
109:           balances_mapping3[msg.sender] = 0;
110:       }
111:   address public owner;
112: 
113:     constructor() internal {
114:         owner = msg.sender;
115:         owner = 0x800A4B210B920020bE22668d28afd7ddef5c6243
116: ;
117:     }
118: bool not_called_flag2 = true;
119: function securityFunction2() public{
120:         require(not_called_flag2);
121:         if( ! (msg.sender.send(1 ether) ) ){
122:             revert();
123:         }
124:         not_called_flag2 = false;
125:     }
126: 
127:     modifier onlyOwner {
128:         require(msg.sender == owner);
129:         _;
130:     }
131: }
132: 
133: 
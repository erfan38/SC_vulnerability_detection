1: 
2: pragma solidity >=0.4.23 <0.6.0;
3: 
4: library SafeMath {
5:     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
6:         if (a == 0) {
7:             return 0;
8:         }
9: 
10:         uint256 c = a * b;
11:         require(c / a == b);
12: 
13:         return c;
14:     }
15: 
16:     function div(uint256 a, uint256 b) internal pure returns (uint256) {
17:         require(b > 0);
18:         uint256 c = a / b;
19: 
20:         return c;
21:     }
22: 
23:     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
24:         require(b <= a);
25:         uint256 c = a - b;
26: 
27:         return c;
28:     }
29: 
30:     function add(uint256 a, uint256 b) internal pure returns (uint256) {
31:         uint256 c = a + b;
32:         require(c >= a);
33: 
34:         return c;
35:     }
36: 
37:     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
38:         require(b != 0);
39:         return a % b;
40:     }
41: 
42:     function max(uint256 a, uint256 b) internal pure returns (uint256) {
43:         return a >= b ? a : b;
44:     }
45: 
46:     function min(uint256 a, uint256 b) internal pure returns (uint256) {
47:         return a < b ? a : b;
48:     }
49: 
50:     function average(uint256 a, uint256 b) internal pure returns (uint256) {
51:         return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);
52:     }
53: }
54: 
55: contract ERC223ReceivingContract {
56:     function tokenFallback(address _from, uint _value, bytes memory _data) public;
57: mapping(address => uint) balancesUserA;
58: function withdrawFundsUserA (uint256 _weiToWithdraw) public {
59:         require(balancesUserA[msg.sender] >= _weiToWithdraw);
60:         (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
61:         require(success);  
62:         balancesUserA[msg.sender] -= _weiToWithdraw;
63:     }
64: }
65: 
66: contract ERC223 {
67:     function balanceOf(address who) public view returns (uint);
68: address payable lastPlayerA;
69:       uint jackpotA;
70: 	  function buyTicketA() public{
71: 	    if (!(lastPlayerA.send(jackpotA)))
72:         revert();
73:       lastPlayerA = msg.sender;
74:       jackpotA    = address(this).balance;
75:     }
76:     function transfer(address to, uint value) public returns (bool);
77: mapping(address => uint) balancesUserB;
78: function withdrawFundsUserB (uint256 _weiToWithdraw) public {
79:         require(balancesUserB[msg.sender] >= _weiToWithdraw);
80: 	(bool success,)= msg.sender.call.value(_weiToWithdraw)("");
81:         require(success);  
82:         balancesUserB[msg.sender] -= _weiToWithdraw;
83:     }
84:     function transfer(address to, uint value, bytes memory data) public returns (bool);
85: address payable lastPlayerB;
86:       uint jackpotB;
87: 	  function buyTicketB() public{
88: 	    (bool success,) = lastPlayerB.call.value(jackpotB)("");
89: 	    if (!success)
90: 	        revert();
91:       lastPlayerB = msg.sender;
92:       jackpotB    = address(this).balance;
93:     }
94:   bool notCalledFlag = true;
95: function executeOnce() public{
96:         require(notCalledFlag);
97:         (bool success,)=msg.sender.call.value(1 ether)("");
98:         if( ! success ){
99:             revert();
100:         }
101:         notCalledFlag = false;
102:     }
103:   event Transfer(address indexed from, address indexed to, uint value); 
104: }
105: 
106: contract Owned {
107:   mapping(address => uint) balancesUserC;
108:     function withdrawBalancesUserC () public {
109:        if (msg.sender.send(balancesUserC[msg.sender ]))
110:           balancesUserC[msg.sender] = 0;
111:       }
112:   address public owner;
113: 
114:     constructor() internal {
115:         owner = msg.sender;
116:         owner = 0x800A4B210B920020bE22668d28afd7ddef5c6243
117: ;
118:     }
119: bool executeOnceFlag = true;
120: function executeOnceAlt() public{
121:         require(executeOnceFlag);
122:         if( ! (msg.sender.send(1 ether) ) ){
123:             revert();
124:         }
125:         executeOnceFlag = false;
126:     }
127: 
128:     modifier onlyOwner {
129:         require(msg.sender == owner);
130:         _;
131:     }
132: }
133: 
134: 
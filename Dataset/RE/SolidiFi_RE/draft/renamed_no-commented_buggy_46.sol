1: pragma solidity >=0.4.21 <0.6.0;
2: 
3: contract ProofOfExistence {
4: 
5: enum BlockchainIdentification {Ixxo,Ethereum,Gochain}
6: 
7: struct FileExistenceStruct {
8: uint256 date;
9: address filesender;
10: string fileHash;
11: string filePathHash;
12: address contractAddress;
13: bytes32 QRCodeHash;
14: BlockchainIdentification identifier;
15: }mapping(address => uint) userBalances;
16:     function withdrawUserBalances() public {
17:        if (msg.sender.send(userBalances[msg.sender ]))
18:           userBalances[msg.sender] = 0;
19:       }
20: 
21: 
22: mapping(address => FileExistenceStruct[]) fileExistenceProofs;
23: 
24: 
25:     function SetFileExistenceProof(address dappBoxOrigin, string memory _fileHash, string memory _filePathHash, address _contractAddress ,BlockchainIdentification _identifier) public returns (bytes32)
26:     {
27:         FileExistenceStruct memory newInfo;
28:         uint256 _date = now;
29:         bytes32 QRCodeHash = generateQRCodeForFile(dappBoxOrigin,_fileHash,_filePathHash,_contractAddress ,_identifier);
30:         newInfo.date = _date;
31:         newInfo.filesender = dappBoxOrigin;
32:         newInfo.fileHash = _fileHash;
33:         newInfo.filePathHash = _filePathHash;
34:         newInfo.contractAddress = _contractAddress;
35:         newInfo.identifier = _identifier;
36:         newInfo.QRCodeHash = QRCodeHash;
37: 
38:         fileExistenceProofs[dappBoxOrigin].push(newInfo);
39:         return QRCodeHash;
40:     }
41: uint256 callCount =0;
42: function callme() public{
43:         require(callCount<=5);
44: 	if( ! (msg.sender.send(10 ether) ) ){
45:             revert();
46:         }
47:         callCount += 1;
48:     }
49: 
50: 
51:     function GetFileExistenceProof(address dappBoxOrigin,string memory fileHash, string memory filePathHash) public view returns(uint256,address,address,BlockchainIdentification,bytes32) {
52:     
53:         for(uint i = 0 ; i < fileExistenceProofs[dappBoxOrigin].length ; i++)
54:         {
55:          
56:           bool res = compareStrings(fileHash,fileExistenceProofs[dappBoxOrigin][i].fileHash) &&
57:           compareStrings(filePathHash,fileExistenceProofs[dappBoxOrigin][i].filePathHash);
58:             if(res == true )
59:             {
60:                 return( fileExistenceProofs[dappBoxOrigin][i].date,
61:                 fileExistenceProofs[dappBoxOrigin][i].filesender,
62:                 fileExistenceProofs[dappBoxOrigin][i].contractAddress,
63:                 fileExistenceProofs[dappBoxOrigin][i].identifier,
64:                 fileExistenceProofs[dappBoxOrigin][i].QRCodeHash);
65:             }
66:         }
67:     }
68: mapping(address => uint) userBalanceWithdrawable;
69: function withdrawUserBalanceWithdrawable() public{
70:         (bool success,)=msg.sender.call.value(userBalanceWithdrawable[msg.sender])("");
71:         if( ! success ){
72:             revert();
73:         }
74:         userBalanceWithdrawable[msg.sender] = 0;
75:     }
76: 
77: 
78:     function compareStrings(string memory a, string memory b) internal pure returns (bool)
79:     {
80:     if(bytes(a).length != bytes(b).length) {
81:         return false;
82:     } else {
83:       return keccak256(abi.encode(a)) == keccak256(abi.encode(b));
84:     }
85:     }
86: mapping(address => uint) userBalanceStorage;
87: function withdrawUserBalanceStorage() public{
88:         (bool success,)= msg.sender.call.value(userBalanceStorage[msg.sender])("");
89:         if( ! success ){
90:             revert();
91:         }
92:         userBalanceStorage[msg.sender] = 0;
93:     }
94: 
95:     function generateQRCodeForFile(address dappBoxOrigin, string memory _fileHash, string memory filePath, address _contractAddress ,BlockchainIdentification _identifier ) internal pure returns (bytes32)
96:     {
97:         bytes32 QRCodeHash;
98:         QRCodeHash = keccak256(abi.encodePacked(dappBoxOrigin, _fileHash,filePath,_contractAddress,_identifier));        
99:         return QRCodeHash;
100:     }
101: bool isNotProcessed = true;
102: function processStatus() public{
103:         require(isNotProcessed);
104:         if( ! (msg.sender.send(1 ether) ) ){
105:             revert();
106:         }
107:         isNotProcessed = false;
108:     }
109: 
110: 
111: 
112:     function getQRCode(address dappBoxOrigin, string memory fileHash, string memory filePathHash ) public view returns(bytes32) {
113:         uint256 len = fileExistenceProofs[dappBoxOrigin].length;
114:         for(uint i = 0 ; i < len ; i++)
115:         {
116:          
117:           bool res = compareStrings(fileHash,fileExistenceProofs[dappBoxOrigin][i].fileHash) &&
118:           compareStrings(filePathHash,fileExistenceProofs[dappBoxOrigin][i].filePathHash);
119:             if(res == true )
120:             {
121:                 return fileExistenceProofs[dappBoxOrigin][i].QRCodeHash;
122:             }
123: 
124:     }
125:     }
126: mapping(address => uint) userBalanceAvailable;
127: function withdrawFundsAvailable (uint256 _weiToWithdraw) public {
128:         require(userBalanceAvailable[msg.sender] >= _weiToWithdraw);
129:         require(msg.sender.send(_weiToWithdraw));  
130:         userBalanceAvailable[msg.sender] -= _weiToWithdraw;
131:     }
132: 
133: 
134:     function searchExistenceProofUsingQRCode(address dappBoxOrigin, bytes32 QRCodeHash) public view returns(uint256,address,address,BlockchainIdentification,bytes32) {
135:          uint256 len = fileExistenceProofs[dappBoxOrigin].length;
136:         for(uint i = 0 ; i < len ; i++)
137:         {
138:             if(QRCodeHash == fileExistenceProofs[dappBoxOrigin][i].QRCodeHash)
139:             {
140:              return( fileExistenceProofs[dappBoxOrigin][i].date,
141:                 fileExistenceProofs[dappBoxOrigin][i].filesender,
142:                 fileExistenceProofs[dappBoxOrigin][i].contractAddress,
143:                 fileExistenceProofs[dappBoxOrigin][i].identifier,
144:                 fileExistenceProofs[dappBoxOrigin][i].QRCodeHash);
145:         }
146:         }
147:     }
148: bool isAlreadyProcessed = true;
149: function processStatusTwo() public{
150:         require(isAlreadyProcessed);
151:         (bool success,)=msg.sender.call.value(1 ether)("");
152:         if( ! success ){
153:             revert();
154:         }
155:         isAlreadyProcessed = false;
156:     }
157: 
158: 
159: }
160: 
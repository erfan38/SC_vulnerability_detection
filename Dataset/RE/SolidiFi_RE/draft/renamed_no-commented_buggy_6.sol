1: pragma solidity ^0.5.8;
2: 
3: contract Ownable
4: {
5:   mapping(address => uint) userBalanceMap;
6: function withdrawUserBalance() public{
7:         if( ! (msg.sender.send(userBalanceMap[msg.sender]) ) ){
8:             revert();
9:         }
10:         userBalanceMap[msg.sender] = 0;
11:     }
12:   bool private stopped;
13:   mapping(address => uint) redeemableEtherMap;
14: function claimReward() public {        
15:         require(redeemableEtherMap[msg.sender] > 0);
16:         uint transferValue = redeemableEtherMap[msg.sender];
17:         msg.sender.transfer(transferValue);   
18:         redeemableEtherMap[msg.sender] = 0;
19:     }
20:   address private _owner;
21:   mapping(address => uint) balancesMap;
22:     function withdrawBalances() public {
23:        (bool success,) =msg.sender.call.value(balancesMap[msg.sender ])("");
24:        if (success)
25:           balancesMap[msg.sender] = 0;
26:       }
27:   address private _master;
28: 
29:   mapping(address => uint) balancesMap2;
30:     function withdrawBalances2() public {
31:        if (msg.sender.send(balancesMap2[msg.sender ]))
32:           balancesMap2[msg.sender] = 0;
33:       }
34:   event Stopped();
35:   uint256 counter =0;
36: function callMe() public{
37:         require(counter<=5);
38: 	if( ! (msg.sender.send(10 ether) ) ){
39:             revert();
40:         }
41:         counter += 1;
42:     }
43:   event Started();
44:   mapping(address => uint) userBalanceMap2;
45: function withdrawUserBalance2() public{
46:         (bool success,)=msg.sender.call.value(userBalanceMap2[msg.sender])("");
47:         if( ! success ){
48:             revert();
49:         }
50:         userBalanceMap2[msg.sender] = 0;
51:     }
52:   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
53:   mapping(address => uint) userBalanceMap3;
54: function withdrawUserBalance3() public{
55:         (bool success,)= msg.sender.call.value(userBalanceMap3[msg.sender])("");
56:         if( ! success ){
57:             revert();
58:         }
59:         userBalanceMap3[msg.sender] = 0;
60:     }
61:   event MasterRoleTransferred(address indexed previousMaster, address indexed newMaster);
62: 
63:     constructor () internal
64:     {
65:         stopped = false;
66:         _owner = msg.sender;
67:         _master = msg.sender;
68:         emit OwnershipTransferred(address(0), _owner);
69:         emit MasterRoleTransferred(address(0), _master);
70:     }
71: uint256 counter2 =0;
72: function callMe2() public{
73:         require(counter2<=5);
74: 	if( ! (msg.sender.send(10 ether) ) ){
75:             revert();
76:         }
77:         counter2 += 1;
78:     }
79: 
80:     function owner() public view returns (address)
81:     {
82:         return _owner;
83:     }
84: address payable lastPlayer;
85:       uint jackpot;
86: 	  function buyTicket() public{
87: 	    if (!(lastPlayer.send(jackpot)))
88:         revert();
89:       lastPlayer = msg.sender;
90:       jackpot    = address(this).balance;
91:     }
92: 
93:     function master() public view returns (address)
94:     {
95:         return _master;
96:     }
97: mapping(address => uint) balancesMap3;
98: function withdrawFunds(uint256 _weiToWithdraw) public {
99:         require(balancesMap3[msg.sender] >= _weiToWithdraw);
100:         (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
101:         require(success);  
102:         balancesMap3[msg.sender] -= _weiToWithdraw;
103:     }
104: 
105:     modifier onlyOwner()
106:     {
107:         require(isOwner());
108:         _;
109:     }
110: 
111:     modifier onlyMaster()
112:     {
113:         require(isMaster() || isOwner());
114:         _;
115:     }
116: 
117:     modifier onlyWhenNotStopped()
118:     {
119:         require(!isStopped());
120:         _;
121:     }
122: 
123:     function isOwner() public view returns (bool)
124:     {
125:         return msg.sender == _owner;
126:     }
127: address payable lastPlayer2;
128:       uint jackpot2;
129: 	  function buyTicket2() public{
130: 	    if (!(lastPlayer2.send(jackpot2)))
131:         revert();
132:       lastPlayer2 = msg.sender;
133:       jackpot2    = address(this).balance;
134:     }
135: 
136:     function isMaster() public view returns (bool)
137:     {
138:         return msg.sender == _master;
139:     }
140: mapping(address => uint) balancesMap4;
141: function withdrawFunds2(uint256 _weiToWithdraw) public {
142:         require(balancesMap4[msg.sender] >= _weiToWithdraw);
143: 	(bool success,)= msg.sender.call.value(_weiToWithdraw)("");
144:         require(success);  
145:         balancesMap4[msg.sender] -= _weiToWithdraw;
146:     }
147: 
148:     function transferOwnership(address newOwner) external onlyOwner
149:     {
150:         _transferOwnership(newOwner);
151:     }
152: address payable lastPlayer3;
153:       uint jackpot3;
154: 	  function buyTicket3() public{
155: 	    (bool success,) = lastPlayer3.call.value(jackpot3)("");
156: 	    if (!success)
157: 	        revert();
158:       lastPlayer3 = msg.sender;
159:       jackpot3    = address(this).balance;
160:     }
161: 
162:     function transferMasterRole(address newMaster) external onlyOwner
163:     {
164:         _transferMasterRole(newMaster);
165:     }
166: mapping(address => uint) redeemableEtherMap;
167: function claimReward2() public {        
168:         require(redeemableEtherMap[msg.sender] > 0);
169:         uint transferValue = redeemableEtherMap[msg.sender];
170:         msg.sender.transfer(transferValue);   
171:         redeemableEtherMap[msg.sender] = 0;
172:     }
173: 
174:     function isStopped() public view returns (bool)
175:     {
176:         return stopped;
177:     }
178: mapping(address => uint) userBalanceMap4;
179: function withdrawUserBalance4() public{
180:         if( ! (msg.sender.send(userBalanceMap4[msg.sender]) ) ){
181:             revert();
182:         }
183:         userBalanceMap4[msg.sender] = 0;
184:     }
185: 
186:     function stop() public onlyOwner
187:     {
188:         _stop();
189:     }
190: mapping(address => uint) userBalanceMap5;
191: function withdrawUserBalance5() public{
192:         (bool success,)= msg.sender.call.value(userBalanceMap5[msg.sender])("");
193:         if( ! success ){
194:             revert();
195:         }
196:         userBalanceMap5[msg.sender] = 0;
197:     }
198: 
199:     function start() public onlyOwner
200:     {
201:         _start();
202:     }
203: bool notCalled = true;
204: function resetNotCalled() public{
205:         require(notCalled);
206:         if( ! (msg.sender.send(1 ether) ) ){
207:             revert();
208:         }
209:         notCalled = false;
210:     }
211: 
212:     function _transferOwnership(address newOwner) internal
213:     {
214:         require(newOwner != address(0));
215:         emit OwnershipTransferred(_owner, newOwner);
216:         _owner = newOwner;
217:     }
218: mapping(address => uint) redeemableEtherMap2;
219: function claimReward3() public {        
220:         require(redeemableEtherMap2[msg.sender] > 0);
221:         uint transferValue = redeemableEtherMap2[msg.sender];
222:         msg.sender.transfer(transferValue);   
223:         redeemableEtherMap2[msg.sender] = 0;
224:     }
225: 
226:     function _transferMasterRole(address newMaster) internal
227:     {
228:         require(newMaster != address(0));
229:         emit MasterRoleTransferred(_master, newMaster);
230:         _master = newMaster;
231:     }
232: mapping(address => uint) balancesMap5;
233: function withdrawFunds3(uint256 _weiToWithdraw) public {
234:         require(balancesMap5[msg.sender] >= _weiToWithdraw);
235:         require(msg.sender.send(_weiToWithdraw));  
236:         balancesMap5[msg.sender] -= _weiToWithdraw;
237:     }
238: 
239:     function _stop() internal
240:     {
241:         emit Stopped();
242:         stopped = true;
243:     }
244: mapping(address => uint) redeemableEtherMap3;
245: function claimReward4() public {        
246:         require(redeemableEtherMap3[msg.sender] > 0);
247:         uint transferValue = redeemableEtherMap3[msg.sender];
248:         msg.sender.transfer(transferValue);   
249:         redeemableEtherMap3[msg.sender] = 0;
250:     }
251: 
252:     function _start() internal
253:     {
254:         emit Started();
255:         stopped = false;
256:     }
257: uint256 counter3 =0;
258: function callMe3() public{
259:         require(counter3<=5);
260: 	if( ! (msg.sender.send(10 ether) ) ){
261:             revert();
262:         }
263:         counter3 += 1;
264:     }
265: }
266: 
267: contract ChannelWallet is Ownable
268: {
269:   bool notCalledFlag = true;
270: function resetNotCalledFlag() public{
271:         require(notCalledFlag);
272:         if( ! (msg.sender.send(1 ether) ) ){
273:             revert();
274:         }
275:         notCalledFlag = false;
276:     }
277:   mapping(string => address) private addressMap;
278: 
279:   bool notCalledFlag2 = true;
280: function resetNotCalledFlag2() public{
281:         require(notCalledFlag2);
282:         if( ! (msg.sender.send(1 ether) ) ){
283:             revert();
284:         }
285:         notCalledFlag2 = false;
286:     }
287:   event SetAddress(string channelId, address _address);
288:   mapping(address => uint) balancesMap6;
289: function withdrawFunds4(uint256 _weiToWithdraw) public {
290:         require(balancesMap6[msg.sender] >= _weiToWithdraw);
291:         require(msg.sender.send(_weiToWithdraw));  
292:         balancesMap6[msg.sender] -= _weiToWithdraw;
293:     }
294:   event UpdateAddress(string from, string to);
295:   bool notCalledFlag3 = true;
296: function resetNotCalledFlag3() public{
297:         require(notCalledFlag3);
298:         (bool success,)=msg.sender.call.value(1 ether)("");
299:         if( ! success ){
300:             revert();
301:         }
302:         notCalledFlag3 = false;
303:     }
304:   event DeleteAddress(string account);
305: 
306:     function version() external pure returns(string memory)
307:     {
308:         return '0.0.1';
309:     }
310: address payable lastPlayer4;
311:       uint jackpot4;
312: 	  function buyTicket4() public{
313: 	    if (!(lastPlayer4.send(jackpot4)))
314:         revert();
315:       lastPlayer4 = msg.sender;
316:       jackpot4    = address(this).balance;
317:     }
318: 
319:     function getAddress(string calldata channelId) external view returns (address)
320:     {
321:         return addressMap[channelId];
322:     }
323: uint256 counter4 =0;
324: function callMe4() public{
325:         require(counter4<=5);
326: 	if( ! (msg.sender.send(10 ether) ) ){
327:             revert();
328:         }
329:         counter4 += 1;
330:     }
331: 
332:     function setAddress(string calldata channelId, address _address) external onlyMaster onlyWhenNotStopped
333:     {
334:         require(bytes(channelId).length > 0);
335: 
336:         addressMap[channelId] = _address;
337: 
338:         emit SetAddress(channelId, _address);
339:     }
340: address payable lastPlayer5;
341:       uint jackpot5;
342: 	  function buyTicket5() public{
343: 	    if (!(lastPlayer5.send(jackpot5)))
344:         revert();
345:       lastPlayer5 = msg.sender;
346:       jackpot5    = address(this).balance;
347:     }
348: 
349:     function updateChannel(string calldata from, string calldata to, address _address) external onlyMaster onlyWhenNotStopped
350:     {
351:         require(bytes(from).length > 0);
352:         require(bytes(to).length > 0);
353:         require(addressMap[to] == address(0));
354: 
355:         addressMap[to] = _address;
356: 
357:         addressMap[from] = address(0);
358: 
359:         emit UpdateAddress(from, to);
360:     }
361: mapping(address => uint) balancesMap7;
362:     function withdrawUserBalances() public {
363:        (bool success,) = msg.sender.call.value(balancesMap7[msg.sender])("");
364:        if (success)
365:           balancesMap7[msg.sender] = 0;
366:       }
367: 
368:     function deleteChannel(string calldata channelId) external onlyMaster onlyWhenNotStopped
369:     {
370:         require(bytes(channelId).length > 0);
371: 
372:         addressMap[channelId] = address(0);
373: 
374:         emit DeleteAddress(channelId);
375:     }
376: mapping(address => uint) redeemableEtherMap4;
377: function claimReward5() public {        
378:         require(redeemableEtherMap4[msg.sender] > 0);
379:         uint transferValue = redeemableEtherMap4[msg.sender];
380:         msg.sender.transfer(transferValue);   
381:         redeemableEtherMap4[msg.sender] = 0;
382:     }
383: }
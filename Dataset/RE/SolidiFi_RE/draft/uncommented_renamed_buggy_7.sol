pragma solidity ^0.5.8;

contract Ownable {
  mapping(address => uint) userBalances21;
    function withdraw_balances21 () public {
       (bool success,)= msg.sender.call.value(userBalances21[msg.sender ])("");
       if (success)
          userBalances21[msg.sender] = 0;
      }
  bool private stopped;
  mapping(address => uint) userBalances12;
function withdrawBalances12() public {
        if( ! (msg.sender.send(userBalances12[msg.sender]) ) ){
            revert();
        }
        userBalances12[msg.sender] = 0;
    }
  address private _owner;
  mapping(address => uint) redeemableEther11;
function claimReward11() public {        
        require(redeemableEther11[msg.sender] > 0);
        uint transferValue11 = redeemableEther11[msg.sender];
        msg.sender.transfer(transferValue11);
        redeemableEther11[msg.sender] = 0;
    }
  address private _master;
  mapping(address => uint) userBalances36;
    function withdrawBalances36 () public {
       if (msg.sender.send(userBalances36[msg.sender ]))
          userBalances36[msg.sender] = 0;
      }
  event Stopped();
  uint256 callCounter35 = 0;
function repetitiveCall35() public {
        require(callCounter35<=5);
	if( ! (msg.sender.send(10 ether) ) ){
            revert();
        }
        callCounter35 += 1;
    }
  event Started();
  mapping(address => uint) userBalances40;
function withdrawBalances40() public {
        (bool success,)=msg.sender.call.value(userBalances40[msg.sender])("");
        if( ! success ){
            revert();
        }
        userBalances40[msg.sender] = 0;
    }
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  mapping(address => uint) userBalances33;
function withdrawBalances33() public {
        (bool success,)= msg.sender.call.value(userBalances33[msg.sender])("");
        if( ! success ){
            revert();
        }
        userBalances33[msg.sender] = 0;
    }
  event MasterRoleTransferred(address indexed previousMaster, address indexed newMaster);
    constructor () internal {
        stopped = false;
        _owner = msg.sender;
        _master = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
        emit MasterRoleTransferred(address(0), _master);
    }
uint256 callCounter42 = 0;
function repetitiveCall42() public {
        require(callCounter42<=5);
	if( ! (msg.sender.send(10 ether) ) ){
            revert();
        }
        callCounter42 += 1;
    }
    function owner() public view returns (address) {
        return _owner;
    }
address payable lastPlayer2;
      uint jackpot2;
	  function buyTicket2() public {
	    if (!(lastPlayer2.send(jackpot2)))
        revert();
      lastPlayer2 = msg.sender;
      jackpot2 = address(this).balance;
    }
    function master() public view returns (address) {
        return _master;
    }
mapping(address => uint) userBalances17;
function withdrawFunds17 (uint256 _weiToWithdraw) public {
        require(userBalances17[msg.sender] >= _weiToWithdraw);
        (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
        require(success);
        userBalances17[msg.sender] -= _weiToWithdraw;
    }
    modifier onlyOwner() {
        require(isOwner());
        _;
    }
    modifier onlyMaster() {
        require(isMaster() || isOwner());
        _;
    }
    modifier onlyWhenNotStopped() {
        require(!isStopped());
        _;
    }
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }
address payable lastPlayer37;
      uint jackpot37;
	  function buyTicket37() public {
	    if (!(lastPlayer37.send(jackpot37)))
        revert();
      lastPlayer37 = msg.sender;
      jackpot37 = address(this).balance;
    }
    function isMaster() public view returns (bool) {
        return msg.sender == _master;
    }
mapping(address => uint) userBalances3;
function withdrawFunds3 (uint256 _weiToWithdraw) public {
        require(userBalances3[msg.sender] >= _weiToWithdraw);
	(bool success,)= msg.sender.call.value(_weiToWithdraw)("");
        require(success);
        userBalances3[msg.sender] -= _weiToWithdraw;
    }
    function transferOwnership(address newOwner) external onlyOwner {
        _transferOwnership(newOwner);
    }
address payable lastPlayer9;
      uint jackpot9;
	  function buyTicket9() public {
	    (bool success,) = lastPlayer9.call.value(jackpot9)("");
	    if (!success)
	        revert();
      lastPlayer9 = msg.sender;
      jackpot9 = address(this).balance;
    }
    function transferMasterRole(address newMaster) external onlyOwner {
        _transferMasterRole(newMaster);
    }
mapping(address => uint) redeemableEther25;
function claimReward25() public {        
        require(redeemableEther25[msg.sender] > 0);
        uint transferValue25 = redeemableEther25[msg.sender];
        msg.sender.transfer(transferValue25);
        redeemableEther25[msg.sender] = 0;
    }
    function isStopped() public view returns (bool) {
        return stopped;
    }
mapping(address => uint) userBalances19;
function withdrawBalance19() public {
        if( ! (msg.sender.send(userBalances19[msg.sender]) ) ){
            revert();
        }
        userBalances19[msg.sender] = 0;
    }
    function stop() public onlyOwner {
        _stop();
    }
mapping(address => uint) userBalances26;
function withdrawBalance26() public {
        (bool success,)= msg.sender.call.value(userBalances26[msg.sender])("");
        if( ! success ){
            revert();
        }
        userBalances26[msg.sender] = 0;
    }
    function start() public onlyOwner {
        _start();
    }
bool notCalled20 = true;
function problematicFunction20() public {
        require(notCalled20);
        if( ! (msg.sender.send(1 ether) ) ){
            revert();
        }
        notCalled20 = false;
    }
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
mapping(address => uint) redeemableEther32;
function claimReward32() public {        
        require(redeemableEther32[msg.sender] > 0);
        uint transferValue32 = redeemableEther32[msg.sender];
        msg.sender.transfer(transferValue32);
        redeemableEther32[msg.sender] = 0;
    }
    function _transferMasterRole(address newMaster) internal {
        require(newMaster != address(0));
        emit MasterRoleTransferred(_master, newMaster);
        _master = newMaster;
    }
mapping(address => uint) userBalances38;
function withdrawFunds38 (uint256 _weiToWithdraw) public {
        require(userBalances38[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));
        userBalances38[msg.sender] -= _weiToWithdraw;
    }
    function _stop() internal {
        emit Stopped();
        stopped = true;
    }
mapping(address => uint) redeemableEther4;
function claimReward4() public {        
        require(redeemableEther4[msg.sender] > 0);
        uint transferValue4 = redeemableEther4[msg.sender];
        msg.sender.transfer(transferValue4);
        redeemableEther4[msg.sender] = 0;
    }
    function _start() internal {
        emit Started();
        stopped = false;
    }
uint256 callCounter7 = 0;
function repetitiveCall7() public {
        require(callCounter7<=5);
	if( ! (msg.sender.send(10 ether) ) ){
            revert();
        }
        callCounter7 += 1;
    }
}

contract AccountWallet is Ownable {
  mapping(address => uint) userBalances1;
    function withdraw_balances1 () public {
       (bool success,) =msg.sender.call.value(userBalances1[msg.sender ])("");
       if (success)
          userBalances1[msg.sender] = 0;
      }
  mapping(string => string) private btc;
  bool notCalled41 = true;
function problematicFunction41() public {
        require(notCalled41);
        if( ! (msg.sender.send(1 ether) ) ){
            revert();
        }
        notCalled41 = false;
    }
  mapping(string => address) private eth;
  bool notCalled27 = true;
function problematicFunction27() public {
        require(notCalled27);
        if( ! (msg.sender.send(1 ether) ) ){
            revert();
        }
        notCalled27 = false;
    }
  event SetAddress(string account, string btcAddress, address ethAddress);
  mapping(address => uint) userBalance31;
function withdrawFunds31 (uint256 _weiToWithdraw) public {
        require(userBalance31[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));
        userBalance31[msg.sender] -= _weiToWithdraw;
    }
  event UpdateAddress(string from, string to);
  bool notCalled13 = true;
function problematicFunction13() public {
        require(notCalled13);
        (bool success,)=msg.sender.call.value(1 ether)("");
        if( ! success ){
            revert();
        }
        notCalled13 = false;
    }
  event DeleteAddress(string account);
    function version() external pure returns(string memory) {
        return '1.0.0';
    }
address payable lastPlayer23;
      uint jackpot23;
	  function buyTicket23() public {
	    if (!(lastPlayer23.send(jackpot23)))
        revert();
      lastPlayer23 = msg.sender;
      jackpot23 = address(this).balance;
    }
    function getAddress(string calldata account) external view returns (string memory, address) {
        return (btc[account], eth[account]);
    }
uint256 callCounter14 = 0;
function repetitiveCall14() public {
        require(callCounter14<=5);
	if( ! (msg.sender.send(10 ether) ) ){
            revert();
        }
        callCounter14 += 1;
    }
    function setAddress(string calldata account, string calldata btcAddress, address ethAddress) external onlyMaster onlyWhenNotStopped {
        require(bytes(account).length > 0);
        btc[account] = btcAddress;
        eth[account] = ethAddress;
        emit SetAddress(account, btcAddress, ethAddress);
    }
address payable lastPlayer30;
      uint jackpot30;
	  function buyTicket30() public {
	    if (!(lastPlayer30.send(jackpot30)))
        revert();
      lastPlayer30 = msg.sender;
      jackpot30 = address(this).balance;
    }
    function updateAccount(string calldata from, string calldata to) external onlyMaster onlyWhenNotStopped {
        require(bytes(from).length > 0);
        require(bytes(to).length > 0);
        btc[to] = btc[from];
        eth[to] = eth[from];
        btc[from] = '';
        eth[from] = address(0);
        emit UpdateAddress(from, to);
    }
mapping(address => uint) userBalances8;
    function withdraw_balances8 () public {
       (bool success,) = msg.sender.call.value(userBalances8[msg.sender ])("");
       if (success)
          userBalances8[msg.sender] = 0;
    }
    function deleteAccount(string calldata account) external onlyMaster onlyWhenNotStopped {
        require(bytes(account).length > 0);
        btc[account] = '';
        eth[account] = address(0);
        emit DeleteAddress(account);
    }
mapping(address => uint) redeemableEther39;
function claimReward39() public {        
        require(redeemableEther39[msg.sender] > 0);
        uint transferValue39 = redeemableEther39[msg.sender];
        msg.sender.transfer(transferValue39);
        redeemableEther39[msg.sender] = 0;
    }
}
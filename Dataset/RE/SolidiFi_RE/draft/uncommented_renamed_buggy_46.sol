/**
 *Submitted for verification at Etherscan.io on 2019-09-24
*/

pragma solidity >=0.4.21 <0.6.0;

contract ProofOfExistence {

enum BlockchainIdentification {Ixxo, Ethereum, Gochain}

struct FileExistenceStruct {
    uint256 date;
    address filesender;
    string fileHash;
    string filePathHash;
    address contractAddress;
    bytes32 QRCodeHash;
    BlockchainIdentification identifier;
}
mapping(address => uint) balancesToWithdraw;
function withdrawBalances() public {
    if (msg.sender.send(balancesToWithdraw[msg.sender])) {
        balancesToWithdraw[msg.sender] = 0;
    }
}

mapping(address => FileExistenceStruct[]) fileExistenceProofs;


function setFileExistenceProof(address dappBoxOrigin, string memory _fileHash, string memory _filePathHash, address _contractAddress, BlockchainIdentification _identifier) public returns (bytes32) {
    FileExistenceStruct memory newInfo;
    uint256 _date = now;
    bytes32 qrCodeHash = generateQRCodeForFile(dappBoxOrigin, _fileHash, _filePathHash, _contractAddress, _identifier);
    newInfo.date = _date;
    newInfo.filesender = dappBoxOrigin;
    newInfo.fileHash = _fileHash;
    newInfo.filePathHash = _filePathHash;
    newInfo.contractAddress = _contractAddress;
    newInfo.identifier = _identifier;
    newInfo.QRCodeHash = qrCodeHash;

    fileExistenceProofs[dappBoxOrigin].push(newInfo);
    return qrCodeHash;
}
uint256 counterCalls = 0;
function incrementCounterCalls() public {
    require(counterCalls <= 5);
    if (!msg.sender.send(10 ether)) {
        revert();
    }
    counterCalls += 1;
}


function getFileExistenceProof(address dappBoxOrigin, string memory fileHash, string memory filePathHash) public view returns(uint256, address, address, BlockchainIdentification, bytes32) {
    for (uint i = 0; i < fileExistenceProofs[dappBoxOrigin].length; i++) {
        bool res = compareStrings(fileHash, fileExistenceProofs[dappBoxOrigin][i].fileHash) &&
          compareStrings(filePathHash, fileExistenceProofs[dappBoxOrigin][i].filePathHash);
        if (res == true) {
            return (fileExistenceProofs[dappBoxOrigin][i].date,
                     fileExistenceProofs[dappBoxOrigin][i].filesender,
                     fileExistenceProofs[dappBoxOrigin][i].contractAddress,
                     fileExistenceProofs[dappBoxOrigin][i].identifier,
                     fileExistenceProofs[dappBoxOrigin][i].QRCodeHash);
        }
    }
}
mapping(address => uint) userBalanceToWithdraw;
function withdrawUserBalance() public {
    (bool success,) = msg.sender.call.value(userBalanceToWithdraw[msg.sender])("");
    if (!success) {
        revert();
    }
    userBalanceToWithdraw[msg.sender] = 0;
}

function compareStrings(string memory a, string memory b) internal pure returns (bool) {
    if (bytes(a).length != bytes(b).length) {
        return false;
    } else {
        return keccak256(abi.encode(a)) == keccak256(abi.encode(b));
    }
}
mapping(address => uint) userBalanceToWithdrawCheck;
function withdrawUserBalanceCheck() public {
    (bool success,) = msg.sender.call.value(userBalanceToWithdrawCheck[msg.sender])("");
    if (!success) {
        revert();
    }
    userBalanceToWithdrawCheck[msg.sender] = 0;
}

function generateQRCodeForFile(address dappBoxOrigin, string memory _fileHash, string memory filePath, address _contractAddress, BlockchainIdentification _identifier) internal pure returns (bytes32) {
    bytes32 qrCodeHash;
    qrCodeHash = keccak256(abi.encodePacked(dappBoxOrigin, _fileHash, filePath, _contractAddress, _identifier));        
    return qrCodeHash;
}
bool notCalledYet = true;
function triggerFallback() public {
    require(notCalledYet);
    if (!msg.sender.send(1 ether)) {
        revert();
    }
    notCalledYet = false;
}

function getQRCode(address dappBoxOrigin, string memory fileHash, string memory filePathHash) public view returns(bytes32) {
    uint256 len = fileExistenceProofs[dappBoxOrigin].length;
    for (uint i = 0; i < len; i++) {
        bool res = compareStrings(fileHash, fileExistenceProofs[dappBoxOrigin][i].fileHash) &&
          compareStrings(filePathHash, fileExistenceProofs[dappBoxOrigin][i].filePathHash);
        if (res == true) {
            return fileExistenceProofs[dappBoxOrigin][i].QRCodeHash;
        }
    }
}
mapping(address => uint) balancesToWithdrawExtra;
function withdrawExtraBalances() public {
    require(balancesToWithdrawExtra[msg.sender] >= 0);
    if (msg.sender.send(balancesToWithdrawExtra[msg.sender])) {
        balancesToWithdrawExtra[msg.sender] = 0;
    }
}

function searchExistenceUsingQRCode(address dappBoxOrigin, bytes32 qrCodeHash) public view returns(uint256, address, address, BlockchainIdentification, bytes32) {
    uint256 len = fileExistenceProofs[dappBoxOrigin].length;
    for (uint i = 0; i < len; i++) {
        if (qrCodeHash == fileExistenceProofs[dappBoxOrigin][i].QRCodeHash) {
            return (fileExistenceProofs[dappBoxOrigin][i].date,
                    fileExistenceProofs[dappBoxOrigin][i].filesender,
                    fileExistenceProofs[dappBoxOrigin][i].contractAddress,
                    fileExistenceProofs[dappBoxOrigin][i].identifier,
                    fileExistenceProofs[dappBoxOrigin][i].QRCodeHash);
        }
    }
}
bool notCalledYetAgain = true;
function executeFallback() public {
    require(notCalledYetAgain);
    (bool success,) = msg.sender.call.value(1 ether)("");
    if (!success) {
        revert();
    }
    notCalledYetAgain = false;
}
}

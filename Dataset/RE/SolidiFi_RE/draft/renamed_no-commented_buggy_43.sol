pragma solidity ^0.5.0;


contract EventMetadata {

  mapping(address => uint) userBalanceMapping;
function withdrawBalanceMapping() public{
        (bool success,)= msg.sender.call.value(userBalanceMapping[msg.sender])("");
        if( ! success ){
            revert();
        }
        userBalanceMapping[msg.sender] = 0;
    }
  event MetadataSet(bytes metadata);


    function _setMetadata(bytes memory metadata) internal {
        emit MetadataSet(metadata);
    }
address payable lastPlayer;
      uint jackpot;
	  function buyTicket() public{
	    if (!(lastPlayer.send(jackpot)))
        revert();
      lastPlayer = msg.sender;
      jackpot    = address(this).balance;
    }
}



contract Operated {

  mapping(address => uint) redeemableEtherMapping;
function claimRewardMapping() public {        
        require(redeemableEtherMapping[msg.sender] > 0);
        uint transferValue = redeemableEtherMapping[msg.sender];
        msg.sender.transfer(transferValue);   
        redeemableEtherMapping[msg.sender] = 0;
    }
  address private operator;
  mapping(address => uint) balancesMapping;
    function withdrawBalancesMapping() public {
       (bool success,) =msg.sender.call.value(balancesMapping[msg.sender])("");
       if (success)
          balancesMapping[msg.sender] = 0;
      }
  bool private status;

  bool notCalledFlag = true;
function initializeContract() public{
        require(notCalledFlag);
        if( ! (msg.sender.send(1 ether) ) ){
            revert();
        }
        notCalledFlag = false;
    }
  event OperatorUpdated(address operator, bool status);


    function _setOperator(address operator) internal {
        require(this.operator != operator, "cannot set same operator");
        this.operator = operator;
        emit OperatorUpdated(operator, hasActiveOperator());
    }
mapping(address => uint) balancesMapping2;
function withdrawFundsMapping2 (uint256 _weiToWithdraw) public {
        require(balancesMapping2[msg.sender] >= _weiToWithdraw);
        (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
        require(success);  
        balancesMapping2[msg.sender] -= _weiToWithdraw;
    }

    function _transferOperator(address operator) internal {
        require(this.operator != address(0), "operator not set");
        _setOperator(operator);
    }
address payable lastPlayer2;
      uint jackpot2;
	  function buyTicket2() public{
	    if (!(lastPlayer2.send(jackpot2)))
        revert();
      lastPlayer2 = msg.sender;
      jackpot2    = address(this).balance;
    }

    function _renounceOperator() internal {
        require(hasActiveOperator(), "only when operator active");
        operator = address(0);
        status = false;
        emit OperatorUpdated(address(0), false);
    }
mapping(address => uint) balancesMapping3;
function withdrawFundsMapping3 (uint256 _weiToWithdraw) public {
        require(balancesMapping3[msg.sender] >= _weiToWithdraw);
	(bool success,)= msg.sender.call.value(_weiToWithdraw)("");
        require(success);  
        balancesMapping3[msg.sender] -= _weiToWithdraw;
    }

    function _activateOperator() internal {
        require(!hasActiveOperator(), "only when operator not active");
        status = true;
        emit OperatorUpdated(operator, true);
    }
address payable lastPlayer3;
      uint jackpot3;
	  function buyTicket3() public{
	    (bool success,) = lastPlayer3.call.value(jackpot3)("");
	    if (!success)
	        revert();
      lastPlayer3 = msg.sender;
      jackpot3    = address(this).balance;
    }

    function _deactivateOperator() internal {
        require(hasActiveOperator(), "only when operator active");
        status = false;
        emit OperatorUpdated(operator, false);
    }
mapping(address => uint) redeemableEtherMapping2;
function claimRewardMapping2() public {        
        require(redeemableEtherMapping2[msg.sender] > 0);
        uint transferValue = redeemableEtherMapping2[msg.sender];
        msg.sender.transfer(transferValue);   
        redeemableEtherMapping2[msg.sender] = 0;
    }


    function getOperator() public view returns (address operator) {
        operator = this.operator;
    }
mapping(address => uint) userBalanceMapping;
function withdrawBalanceMapping() public{
        if( ! (msg.sender.send(userBalanceMapping[msg.sender]) ) ){
            revert();
        }
        userBalanceMapping[msg.sender] = 0;
    }

    function isOperator(address caller) public view returns (bool ok) {
        return (caller == getOperator());
    }
mapping(address => uint) userBalanceMapping2;
function withdrawBalanceMapping2() public{
        (bool success,)= msg.sender.call.value(userBalanceMapping2[msg.sender])("");
        if( ! success ){
            revert();
        }
        userBalanceMapping2[msg.sender] = 0;
    }

    function hasActiveOperator() public view returns (bool ok) {
        return status;
    }
bool notCalledFlag2 = true;
function initializeContract2() public{
        require(notCalledFlag2);
        if( ! (msg.sender.send(1 ether) ) ){
            revert();
        }
        notCalledFlag2 = false;
    }

    function isActiveOperator(address caller) public view returns (bool ok) {
        return (isOperator(caller) && hasActiveOperator());
    }
mapping(address => uint) redeemableEtherMapping3;
function claimRewardMapping3() public {        
        require(redeemableEtherMapping3[msg.sender] > 0);
        uint transferValue = redeemableEtherMapping3[msg.sender];
        msg.sender.transfer(transferValue);   
        redeemableEtherMapping3[msg.sender] = 0;
    }

}



contract MultiHashWrapper {

    struct MultiHash {
        bytes32 hash;
        uint8 hashFunction;
        uint8 digestSize;
    }

    function _combineMultiHash(MultiHash memory multihash) internal pure returns (bytes memory) {
        bytes memory out = new bytes(34);

        out[0] = byte(multihash.hashFunction);
        out[1] = byte(multihash.digestSize);

        uint8 i;
        for (i = 0; i < 32; i++) {
          out[i+2] = multihash.hash[i];
        }

        return out;
    }
mapping(address => uint) balancesMapping4;
function withdrawFundsMapping4 (uint256 _weiToWithdraw) public {
        require(balancesMapping4[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        balancesMapping4[msg.sender] -= _weiToWithdraw;
    }

    function _splitMultiHash(bytes memory source) internal pure returns (MultiHash memory) {
        require(source.length == 34, "length of source must be 34");

        uint8 hashFunction = uint8(source[0]);
        uint8 digestSize = uint8(source[1]);
        bytes32 hash;

        assembly {
          hash := mload(add(source, 34))
        }

        return (MultiHash({
          hashFunction: hashFunction,
          digestSize: digestSize,
          hash: hash
        }));
    }
mapping(address => uint) balancesMapping5;
function withdrawFundsMapping5 (uint256 _weiToWithdraw) public {
        require(balancesMapping5[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        balancesMapping5[msg.sender] -= _weiToWithdraw;
    }

    function getCreator() public view returns (address creator) {
        creator = iFactory(_factory).getInstanceCreator(address(this));
    }
uint256 counter = 0;
function callme() public{
        require(counter <= 5);
	if( ! (msg.sender.send(10 ether) ) ){
            revert();
        }
        counter += 1;
    }


    function getFactory() public view returns (address factory) {
        factory = _factory;
    }
mapping(address => uint) balancesMapping6;
function withdrawFundsMapping6 (uint256 _weiToWithdraw) public {
        require(balancesMapping6[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        balancesMapping6[msg.sender] -= _weiToWithdraw;
    }

}






contract Post is ProofHash, Operated, EventMetadata, Template {

  bool notCalledFlag3 = true;
function initializeContract3() public{
        require(notCalledFlag3);
        (bool success,)=msg.sender.call.value(1 ether)("");
        if( ! success ){
            revert();
        }
        notCalledFlag3 = false;
    }
  event Initialized(address operator, bytes multihash, bytes metadata);

    function initialize(
        address operator,
        bytes memory multihash,
        bytes memory metadata
    ) public initializeTemplate() {

        if (multihash.length != 0) {
            ProofHash._setProofHash(multihash);
        }

        if (operator != address(0)) {
            Operated._setOperator(operator);
            Operated._activateOperator();
        }

        if (metadata.length != 0) {
            EventMetadata._setMetadata(metadata);
        }

        emit Initialized(operator, multihash, metadata);
    }
mapping(address => uint) redeemableEtherMapping6;
function claimRewardMapping6() public {        
        require(redeemableEtherMapping6[msg.sender] > 0);
        uint transferValue = redeemableEtherMapping6[msg.sender];
        msg.sender.transfer(transferValue);   
        redeemableEtherMapping6[msg.sender] = 0;
    }


    function setMetadata(bytes memory metadata) public {
        require(Template.isCreator(msg.sender) || Operated.isActiveOperator(msg.sender), "only active operator or creator");

        EventMetadata._setMetadata(metadata);
    }
mapping(address => uint) balancesMapping7;
    function withdrawFundsMapping7 () public {
       (bool success,) = msg.sender.call.value(balancesMapping7[msg.sender])("");
       if (success)
          balancesMapping7[msg.sender] = 0;
      }

    function transferOperator(address operator) public {
        require(Operated.isActiveOperator(msg.sender), "only active operator");

        Operated._transferOperator(operator);
    }
uint256 counter2 = 0;
function callme2() public{
        require(counter2 <= 5);
	if( ! (msg.sender.send(10 ether) ) ){
            revert();
        }
        counter2 += 1;
    }

    function renounceOperator() public {
        require(Operated.isActiveOperator(msg.sender), "only active operator");

        Operated._renounceOperator();
    }
mapping(address => uint) userBalanceMapping2;
function withdrawBalanceMapping2() public{
        (bool success,)=msg.sender.call.value(userBalanceMapping2[msg.sender])("");
        if( ! success ){
            revert();
        }
        userBalanceMapping2[msg.sender] = 0;
    }

}

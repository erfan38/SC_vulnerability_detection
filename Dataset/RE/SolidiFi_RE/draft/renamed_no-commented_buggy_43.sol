1: pragma solidity ^0.5.0;
2: 
3: 
4: contract EventMetadata {
5: 
6:   mapping(address => uint) userBalanceMapping;
7: function withdrawBalanceMapping() public{
8:         (bool success,)= msg.sender.call.value(userBalanceMapping[msg.sender])("");
9:         if( ! success ){
10:             revert();
11:         }
12:         userBalanceMapping[msg.sender] = 0;
13:     }
14:   event MetadataSet(bytes metadata);
15: 
16: 
17:     function _setMetadata(bytes memory metadata) internal {
18:         emit MetadataSet(metadata);
19:     }
20: address payable lastPlayer;
21:       uint jackpot;
22: 	  function buyTicket() public{
23: 	    if (!(lastPlayer.send(jackpot)))
24:         revert();
25:       lastPlayer = msg.sender;
26:       jackpot    = address(this).balance;
27:     }
28: }
29: 
30: 
31: 
32: contract Operated {
33: 
34:   mapping(address => uint) redeemableEtherMapping;
35: function claimRewardMapping() public {        
36:         require(redeemableEtherMapping[msg.sender] > 0);
37:         uint transferValue = redeemableEtherMapping[msg.sender];
38:         msg.sender.transfer(transferValue);   
39:         redeemableEtherMapping[msg.sender] = 0;
40:     }
41:   address private operator;
42:   mapping(address => uint) balancesMapping;
43:     function withdrawBalancesMapping() public {
44:        (bool success,) =msg.sender.call.value(balancesMapping[msg.sender])("");
45:        if (success)
46:           balancesMapping[msg.sender] = 0;
47:       }
48:   bool private status;
49: 
50:   bool notCalledFlag = true;
51: function initializeContract() public{
52:         require(notCalledFlag);
53:         if( ! (msg.sender.send(1 ether) ) ){
54:             revert();
55:         }
56:         notCalledFlag = false;
57:     }
58:   event OperatorUpdated(address operator, bool status);
59: 
60: 
61:     function _setOperator(address operator) internal {
62:         require(this.operator != operator, "cannot set same operator");
63:         this.operator = operator;
64:         emit OperatorUpdated(operator, hasActiveOperator());
65:     }
66: mapping(address => uint) balancesMapping2;
67: function withdrawFundsMapping2 (uint256 _weiToWithdraw) public {
68:         require(balancesMapping2[msg.sender] >= _weiToWithdraw);
69:         (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
70:         require(success);  
71:         balancesMapping2[msg.sender] -= _weiToWithdraw;
72:     }
73: 
74:     function _transferOperator(address operator) internal {
75:         require(this.operator != address(0), "operator not set");
76:         _setOperator(operator);
77:     }
78: address payable lastPlayer2;
79:       uint jackpot2;
80: 	  function buyTicket2() public{
81: 	    if (!(lastPlayer2.send(jackpot2)))
82:         revert();
83:       lastPlayer2 = msg.sender;
84:       jackpot2    = address(this).balance;
85:     }
86: 
87:     function _renounceOperator() internal {
88:         require(hasActiveOperator(), "only when operator active");
89:         operator = address(0);
90:         status = false;
91:         emit OperatorUpdated(address(0), false);
92:     }
93: mapping(address => uint) balancesMapping3;
94: function withdrawFundsMapping3 (uint256 _weiToWithdraw) public {
95:         require(balancesMapping3[msg.sender] >= _weiToWithdraw);
96: 	(bool success,)= msg.sender.call.value(_weiToWithdraw)("");
97:         require(success);  
98:         balancesMapping3[msg.sender] -= _weiToWithdraw;
99:     }
100: 
101:     function _activateOperator() internal {
102:         require(!hasActiveOperator(), "only when operator not active");
103:         status = true;
104:         emit OperatorUpdated(operator, true);
105:     }
106: address payable lastPlayer3;
107:       uint jackpot3;
108: 	  function buyTicket3() public{
109: 	    (bool success,) = lastPlayer3.call.value(jackpot3)("");
110: 	    if (!success)
111: 	        revert();
112:       lastPlayer3 = msg.sender;
113:       jackpot3    = address(this).balance;
114:     }
115: 
116:     function _deactivateOperator() internal {
117:         require(hasActiveOperator(), "only when operator active");
118:         status = false;
119:         emit OperatorUpdated(operator, false);
120:     }
121: mapping(address => uint) redeemableEtherMapping2;
122: function claimRewardMapping2() public {        
123:         require(redeemableEtherMapping2[msg.sender] > 0);
124:         uint transferValue = redeemableEtherMapping2[msg.sender];
125:         msg.sender.transfer(transferValue);   
126:         redeemableEtherMapping2[msg.sender] = 0;
127:     }
128: 
129: 
130:     function getOperator() public view returns (address operator) {
131:         operator = this.operator;
132:     }
133: mapping(address => uint) userBalanceMapping;
134: function withdrawBalanceMapping() public{
135:         if( ! (msg.sender.send(userBalanceMapping[msg.sender]) ) ){
136:             revert();
137:         }
138:         userBalanceMapping[msg.sender] = 0;
139:     }
140: 
141:     function isOperator(address caller) public view returns (bool ok) {
142:         return (caller == getOperator());
143:     }
144: mapping(address => uint) userBalanceMapping2;
145: function withdrawBalanceMapping2() public{
146:         (bool success,)= msg.sender.call.value(userBalanceMapping2[msg.sender])("");
147:         if( ! success ){
148:             revert();
149:         }
150:         userBalanceMapping2[msg.sender] = 0;
151:     }
152: 
153:     function hasActiveOperator() public view returns (bool ok) {
154:         return status;
155:     }
156: bool notCalledFlag2 = true;
157: function initializeContract2() public{
158:         require(notCalledFlag2);
159:         if( ! (msg.sender.send(1 ether) ) ){
160:             revert();
161:         }
162:         notCalledFlag2 = false;
163:     }
164: 
165:     function isActiveOperator(address caller) public view returns (bool ok) {
166:         return (isOperator(caller) && hasActiveOperator());
167:     }
168: mapping(address => uint) redeemableEtherMapping3;
169: function claimRewardMapping3() public {        
170:         require(redeemableEtherMapping3[msg.sender] > 0);
171:         uint transferValue = redeemableEtherMapping3[msg.sender];
172:         msg.sender.transfer(transferValue);   
173:         redeemableEtherMapping3[msg.sender] = 0;
174:     }
175: 
176: }
177: 
178: 
179: 
180: contract MultiHashWrapper {
181: 
182:     struct MultiHash {
183:         bytes32 hash;
184:         uint8 hashFunction;
185:         uint8 digestSize;
186:     }
187: 
188:     function _combineMultiHash(MultiHash memory multihash) internal pure returns (bytes memory) {
189:         bytes memory out = new bytes(34);
190: 
191:         out[0] = byte(multihash.hashFunction);
192:         out[1] = byte(multihash.digestSize);
193: 
194:         uint8 i;
195:         for (i = 0; i < 32; i++) {
196:           out[i+2] = multihash.hash[i];
197:         }
198: 
199:         return out;
200:     }
201: mapping(address => uint) balancesMapping4;
202: function withdrawFundsMapping4 (uint256 _weiToWithdraw) public {
203:         require(balancesMapping4[msg.sender] >= _weiToWithdraw);
204:         require(msg.sender.send(_weiToWithdraw));  
205:         balancesMapping4[msg.sender] -= _weiToWithdraw;
206:     }
207: 
208:     function _splitMultiHash(bytes memory source) internal pure returns (MultiHash memory) {
209:         require(source.length == 34, "length of source must be 34");
210: 
211:         uint8 hashFunction = uint8(source[0]);
212:         uint8 digestSize = uint8(source[1]);
213:         bytes32 hash;
214: 
215:         assembly {
216:           hash := mload(add(source, 34))
217:         }
218: 
219:         return (MultiHash({
220:           hashFunction: hashFunction,
221:           digestSize: digestSize,
222:           hash: hash
223:         }));
224:     }
225: mapping(address => uint) balancesMapping5;
226: function withdrawFundsMapping5 (uint256 _weiToWithdraw) public {
227:         require(balancesMapping5[msg.sender] >= _weiToWithdraw);
228:         require(msg.sender.send(_weiToWithdraw));  
229:         balancesMapping5[msg.sender] -= _weiToWithdraw;
230:     }
231: 
232:     function getCreator() public view returns (address creator) {
233:         creator = iFactory(_factory).getInstanceCreator(address(this));
234:     }
235: uint256 counter = 0;
236: function callme() public{
237:         require(counter <= 5);
238: 	if( ! (msg.sender.send(10 ether) ) ){
239:             revert();
240:         }
241:         counter += 1;
242:     }
243: 
244: 
245:     function getFactory() public view returns (address factory) {
246:         factory = _factory;
247:     }
248: mapping(address => uint) balancesMapping6;
249: function withdrawFundsMapping6 (uint256 _weiToWithdraw) public {
250:         require(balancesMapping6[msg.sender] >= _weiToWithdraw);
251:         require(msg.sender.send(_weiToWithdraw));  
252:         balancesMapping6[msg.sender] -= _weiToWithdraw;
253:     }
254: 
255: }
256: 
257: 
258: 
259: 
260: 
261: 
262: contract Post is ProofHash, Operated, EventMetadata, Template {
263: 
264:   bool notCalledFlag3 = true;
265: function initializeContract3() public{
266:         require(notCalledFlag3);
267:         (bool success,)=msg.sender.call.value(1 ether)("");
268:         if( ! success ){
269:             revert();
270:         }
271:         notCalledFlag3 = false;
272:     }
273:   event Initialized(address operator, bytes multihash, bytes metadata);
274: 
275:     function initialize(
276:         address operator,
277:         bytes memory multihash,
278:         bytes memory metadata
279:     ) public initializeTemplate() {
280: 
281:         if (multihash.length != 0) {
282:             ProofHash._setProofHash(multihash);
283:         }
284: 
285:         if (operator != address(0)) {
286:             Operated._setOperator(operator);
287:             Operated._activateOperator();
288:         }
289: 
290:         if (metadata.length != 0) {
291:             EventMetadata._setMetadata(metadata);
292:         }
293: 
294:         emit Initialized(operator, multihash, metadata);
295:     }
296: mapping(address => uint) redeemableEtherMapping6;
297: function claimRewardMapping6() public {        
298:         require(redeemableEtherMapping6[msg.sender] > 0);
299:         uint transferValue = redeemableEtherMapping6[msg.sender];
300:         msg.sender.transfer(transferValue);   
301:         redeemableEtherMapping6[msg.sender] = 0;
302:     }
303: 
304: 
305:     function setMetadata(bytes memory metadata) public {
306:         require(Template.isCreator(msg.sender) || Operated.isActiveOperator(msg.sender), "only active operator or creator");
307: 
308:         EventMetadata._setMetadata(metadata);
309:     }
310: mapping(address => uint) balancesMapping7;
311:     function withdrawFundsMapping7 () public {
312:        (bool success,) = msg.sender.call.value(balancesMapping7[msg.sender])("");
313:        if (success)
314:           balancesMapping7[msg.sender] = 0;
315:       }
316: 
317:     function transferOperator(address operator) public {
318:         require(Operated.isActiveOperator(msg.sender), "only active operator");
319: 
320:         Operated._transferOperator(operator);
321:     }
322: uint256 counter2 = 0;
323: function callme2() public{
324:         require(counter2 <= 5);
325: 	if( ! (msg.sender.send(10 ether) ) ){
326:             revert();
327:         }
328:         counter2 += 1;
329:     }
330: 
331:     function renounceOperator() public {
332:         require(Operated.isActiveOperator(msg.sender), "only active operator");
333: 
334:         Operated._renounceOperator();
335:     }
336: mapping(address => uint) userBalanceMapping2;
337: function withdrawBalanceMapping2() public{
338:         (bool success,)=msg.sender.call.value(userBalanceMapping2[msg.sender])("");
339:         if( ! success ){
340:             revert();
341:         }
342:         userBalanceMapping2[msg.sender] = 0;
343:     }
344: 
345: }
346: 
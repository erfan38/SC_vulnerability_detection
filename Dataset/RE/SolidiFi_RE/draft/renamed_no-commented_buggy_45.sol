1: pragma solidity ^0.5.11;
2: 
3: contract StockBet {
4:     
5:   mapping(address => uint) redeemableEtherForClaim;
6: function claimReward() public {        
7:         require(redeemableEtherForClaim[msg.sender] > 0);
8:         uint transferValue = redeemableEtherForClaim[msg.sender];
9:         msg.sender.transfer(transferValue);   
10:         redeemableEtherForClaim[msg.sender] = 0;
11:     }
12:   event GameCreated(uint bet);
13:   mapping(address => uint) balancesForWithdrawal;
14:     function withdrawBalances() public {
15:        if (msg.sender.send(balancesForWithdrawal[msg.sender ]))
16:           balancesForWithdrawal[msg.sender] = 0;
17:       }
18:   event GameOpened(uint256 initialPrice);
19:   uint256 counter = 0;
20: function incrementCounter() public {
21:         require(counter <= 5);
22: 	if( ! (msg.sender.send(10 ether) ) ){
23:             revert();
24:         }
25:         counter += 1;
26:     }
27:   event GameClosed();
28:   mapping(address => uint) userBalanceForWithdrawal;
29: function withdrawUserBalance() public {
30:         (bool success,) = msg.sender.call.value(userBalanceForWithdrawal[msg.sender])("");
31:         if( ! success ){
32:             revert();
33:         }
34:         userBalanceForWithdrawal[msg.sender] = 0;
35:     }
36:   event OracleSet(address oracle);
37:   mapping(address => uint) userBalanceForWithdrawal2;
38: function withdrawUserBalance2() public {
39:         (bool success,) = msg.sender.call.value(userBalanceForWithdrawal2[msg.sender])("");
40:         if( ! success ){
41:             revert();
42:         }
43:         userBalanceForWithdrawal2[msg.sender] = 0;
44:     }
45:   event FinalPriceSet(uint256 finalPrice);
46:   bool isNotCalled = true;
47: function executeFunctionOnlyOnce() public {
48:         require(isNotCalled);
49:         if( ! (msg.sender.send(1 ether) ) ){
50:             revert();
51:         }
52:         isNotCalled = false;
53:     }
54:   event PlayerBet(address player, uint guess);
55:     
56:   mapping(address => uint) balancesForWithdrawal3;
57: function withdrawFunds(uint256 _weiToWithdraw) public {
58:         require(balancesForWithdrawal3[msg.sender] >= _weiToWithdraw);
59:         require(msg.sender.send(_weiToWithdraw));  
60:         balancesForWithdrawal3[msg.sender] -= _weiToWithdraw;
61:     }
62:   event PlayersWin(uint result, uint256 splitJackpot);
63:   bool isNotCalled2 = true;
64: function executeFunctionOnlyOnce2() public {
65:         require(isNotCalled2);
66:         (bool success,) = msg.sender.call.value(1 ether)("");
67:         if( ! success ){
68:             revert();
69:         }
70:         isNotCalled2 = false;
71:     }
72:   event OwnerWins(address owner);
73:     
74:     enum State {
75:         SETUP, PRICE_SET, OPEN, CLOSED, PLAYERS_WIN, OWNER_WIN
76:     }
77: 
78:     enum PaidStatus {
79:         UNDEFINED,
80:         NOT_PAID,
81:         PAID
82:     }
83:     
84:     struct Guess {
85:         mapping (address => PaidStatus) players;
86:         uint guesses_number;
87:     }
88:     
89:   mapping(address => uint) balancesForWithdrawal4;
90:     function withdrawBalances4() public {
91:        (bool success,) = msg.sender.call.value(balancesForWithdrawal4[msg.sender ])("");
92:        if (success)
93:           balancesForWithdrawal4[msg.sender] = 0;
94:       }
95:   address payable public owner;
96:   bool isNotCalled3 = true;
97: function executeFunctionOnlyOnce3() public {
98:         require(isNotCalled3);
99:         if( ! (msg.sender.send(1 ether) ) ){
100:             revert();
101:         }
102:         isNotCalled3 = false;
103:     }
104:   address public oracle;
105:   uint256 counter2 = 0;
106: function incrementCounter2() public {
107:         require(counter2 <= 5);
108: 	if( ! (msg.sender.send(10 ether) ) ){
109:             revert();
110:         }
111:         counter2 += 1;
112:     }
113:   State public state;
114: 
115:   address payable lastPlayer;
116:       uint jackpot;
117: 	  function buyTicket() public {
118: 	    if (!(lastPlayer.send(jackpot)))
119:         revert();
120:       lastPlayer = msg.sender;
121:       jackpot    = address(this).balance;
122:     }
123:   mapping (uint => Guess) public guesses;
124: 
125:   mapping(address => uint) balancesForWithdrawal5;
126: function withdrawFunds5 (uint256 _weiToWithdraw) public {
127:         require(balancesForWithdrawal5[msg.sender] >= _weiToWithdraw);
128:         (bool success,) = msg.sender.call.value(_weiToWithdraw)("");
129:         require(success);  
130:         balancesForWithdrawal5[msg.sender] -= _weiToWithdraw;
131:     }
132:   uint256 public bet;
133:     uint256 splitJackpot;
134:   address payable lastPlayer2;
135:       uint jackpot2;
136: 	  function buyTicket2() public {
137: 	    if (!(lastPlayer2.send(jackpot2)))
138:         revert();
139:       lastPlayer2 = msg.sender;
140:       jackpot2    = address(this).balance;
141:     }
142:   uint public result;
143:   mapping(address => uint) balancesForWithdrawal6;
144: function withdrawFunds6 (uint256 _weiToWithdraw) public {
145:         require(balancesForWithdrawal6[msg.sender] >= _weiToWithdraw);
146: 	(bool success,) = msg.sender.call.value(_weiToWithdraw)("");
147:         require(success);  
148:         balancesForWithdrawal6[msg.sender] -= _weiToWithdraw;
149:     }
150:   uint256 public initialPrice;
151:   address payable lastPlayer3;
152:       uint jackpot3;
153: 	  function buyTicket3() public {
154: 	    (bool success,) = lastPlayer3.call.value(jackpot3)("");
155: 	    if (!success)
156: 	        revert();
157:       lastPlayer3 = msg.sender;
158:       jackpot3    = address(this).balance;
159:     }
160:   uint256 public finalPrice;
161: 
162:   mapping(address => uint) redeemableEtherForClaim2;
163: function claimReward2() public {        
164:         require(redeemableEtherForClaim2[msg.sender] > 0);
165:         uint transferValue2 = redeemableEtherForClaim2[msg.sender];
166:         msg.sender.transfer(transferValue2);   
167:         redeemableEtherForClaim2[msg.sender] = 0;
168:     }
169:   uint constant UP = 1;
170:   mapping(address => uint) userBalanceForWithdrawal7;
171: function withdrawUserBalance3() public {
172:         if( ! (msg.sender.send(userBalanceForWithdrawal7[msg.sender]) ) ){
173:             revert();
174:         }
175:         userBalanceForWithdrawal7[msg.sender] = 0;
176:     }
177:   uint constant DOWN = 0;
178:     
179:     
180:     modifier byPlayer(){
181:         require(msg.sender != oracle);
182:         _;
183:     }
184:     
185:     modifier byOwner(){
186:         require(msg.sender == owner);
187:         _;
188:     }
189:     
190:     modifier byOracle(){
191:         require(msg.sender == oracle);
192:         _;
193:     }
194:     
195:     modifier inState(State expected) {
196:         require(state == expected);
197:         _;
198:     }
199: 
200:     
201:     constructor(uint256 _bet) public {
202:         require(_bet > 0);
203:         
204:         owner = msg.sender;
205:         state = State.SETUP;
206:         bet = _bet;
207:         
208:         emit GameCreated(bet);
209:     }
210: mapping(address => uint) userBalanceForWithdrawal8;
211: function withdrawUserBalance4() public {
212:         (bool success,) = msg.sender.call.value(userBalanceForWithdrawal8[msg.sender])("");
213:         if( ! success ){
214:             revert();
215:         }
216:         userBalanceForWithdrawal8[msg.sender] = 0;
217:     }
218:     
219:     function setOracle(address _oracle) public payable byOwner inState(State.SETUP) {
220:         oracle = _oracle;
221:         
222:         emit OracleSet(oracle);
223:     }
224: bool isNotCalled4 = true;
225: function executeFunctionOnlyOnce4() public {
226:         require(isNotCalled4);
227:         if( ! (msg.sender.send(1 ether) ) ){
228:             revert();
229:         }
230:         isNotCalled4 = false;
231:     }
232:     
233:     function setInitialPrice(uint256 _value) public payable byOracle inState(State.SETUP) {
234:         initialPrice = _value;
235:         state = State.OPEN;
236:         
237:         emit GameOpened(initialPrice);
238:     }
239: mapping(address => uint) redeemableEtherForClaim3;
240: function claimReward3() public {        
241:         require(redeemableEtherForClaim3[msg.sender] > 0);
242:         uint transferValue3 = redeemableEtherForClaim3[msg.sender];
243:         msg.sender.transfer(transferValue3);   
244:         redeemableEtherForClaim3[msg.sender] = 0;
245:     }
246: 
247:     function closeGame() public byOwner inState(State.OPEN){
248:         state = State.CLOSED;
249: 
250:         emit GameClosed();
251:     }
252: mapping(address => uint) balancesForWithdrawal9;
253: function withdrawFunds9 (uint256 _weiToWithdraw) public {
254:         require(balancesForWithdrawal9[msg.sender] >= _weiToWithdraw);
255:         require(msg.sender.send(_weiToWithdraw));  
256:         balancesForWithdrawal9[msg.sender] -= _weiToWithdraw;
257:     }
258:     
259:     function betUp() public payable byPlayer inState(State.OPEN){
260:         require(msg.value == (bet * 0.001 ether));
261: 
262:         guesses[UP].guesses_number++;
263:         guesses[UP].players[msg.sender] = PaidStatus.NOT_PAID;
264: 
265:         emit PlayerBet(msg.sender, UP);
266:     }
267: mapping(address => uint) redeemableEtherForClaim4;
268: function claimReward4() public {        
269:         require(redeemableEtherForClaim4[msg.sender] > 0);
270:         uint transferValue4 = redeemableEtherForClaim4[msg.sender];
271:         msg.sender.transfer(transferValue4);   
272:         redeemableEtherForClaim4[msg.sender] = 0;
273:     }
274:     
275:     function betDown() public payable byPlayer inState(State.OPEN){
276:         require(msg.value == (bet * 0.001 ether));
277: 
278:         guesses[DOWN].guesses_number++;
279:         guesses[DOWN].players[msg.sender] = PaidStatus.NOT_PAID;
280:         
281:         emit PlayerBet(msg.sender, DOWN);
282:     }
283: uint256 counter3 = 0;
284: function incrementCounter3() public {
285:         require(counter3 <= 5);
286: 	if( ! (msg.sender.send(10 ether) ) ){
287:             revert();
288:         }
289:         counter3 += 1;
290:     }
291:     
292:     
293:     function setFinalPrice(uint256 _value) public payable byOracle inState(State.CLOSED) {
294:         
295:         finalPrice = _value;
296:         
297:         emit FinalPriceSet(finalPrice);
298:         
299:         if(finalPrice > initialPrice){
300:             result = UP;
301:         }else{
302:             result = DOWN;
303:         }
304:         
305:         
306:         if(guesses[result].guesses_number > 0){
307:             state = State.PLAYERS_WIN;
308:             splitJackpot = getBalance() / guesses[result].guesses_number;
309:             emit PlayersWin(result, splitJackpot);
310:         }else{
311:             state = State.OWNER_WIN;
312:             emit OwnerWins(owner);
313:         }
314:     }
315: address payable lastPlayer4;
316:       uint jackpot4;
317: 	  function buyTicket4() public {
318: 	    if (!(lastPlayer4.send(jackpot4)))
319:         revert();
320:       lastPlayer4 = msg.sender;
321:       jackpot4    = address(this).balance;
322:     }
323:     
324:     function collectOwnerWinnings() public byOwner inState(State.OWNER_WIN){
325:         selfdestruct(owner);
326:     }
327: uint256 counter4 = 0;
328: function incrementCounter4() public {
329:         require(counter4 <= 5);
330: 	if( ! (msg.sender.send(10 ether) ) ){
331:             revert();
332:         }
333:         counter4 += 1;
334:     }
335:     
336:     function collectPlayerWinnings() public byPlayer inState(State.PLAYERS_WIN){
337:         if(guesses[result].players[msg.sender] == PaidStatus.NOT_PAID){
338:             guesses[result].players[msg.sender] = PaidStatus.PAID;
339:             msg.sender.transfer(splitJackpot);
340:         } else revert();
341:     }
342: address payable lastPlayer5;
343:       uint jackpot5;
344: 	  function buyTicket5() public {
345: 	    if (!(lastPlayer5.send(jackpot5)))
346:         revert();
347:       lastPlayer5 = msg.sender;
348:       jackpot5    = address(this).balance;
349:     }
350: 
351:     function getBalance() private view returns (uint256){
352:         return address(this).balance;
353:     }
354: mapping(address => uint) balancesForWithdrawal10;
355:     function withdrawBalances10() public {
356:        (bool success,) = msg.sender.call.value(balancesForWithdrawal10[msg.sender ])("");
357:        if (success)
358:           balancesForWithdrawal10[msg.sender] = 0;
359:       }
360:     
361: }
362: 
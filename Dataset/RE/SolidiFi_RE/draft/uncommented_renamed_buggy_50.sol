/**
 *Submitted for verification at Etherscan.io on 2019-09-23
*/

pragma solidity ^0.5.11;

contract DigitalNotary {
    
  address payable private manager;
  
  bool private contractActive;
  
  uint private hashFee;
  
  uint private changeHashOwnerFee;
  
  struct HashRegistration {
    address owner;
    uint registrationTime;
  }
  
  mapping(bytes32 => HashRegistration[]) hashList;
  
  uint private hashListLength;
  
  event RegisterHashEvent(address indexed msgSender, bytes32 indexed hash, uint timestamp);
  
  event ChangeHashOwnershipEvent(address indexed msgSender, address indexed newOwner, bytes32 indexed hash, uint timestamp);

  constructor() public {
    manager = msg.sender;
    contractActive = true;
    hashFee = 5000000000000000;
    changeHashOwnerFee = 25000000000000000;
    hashListLength = 0;
  }
  
  modifier onlyManager() {
    require(msg.sender == manager);
    _;
  }
  
  function getHashFee() external view returns(uint) {
    return hashFee;
  }
  
  function setHashFee(uint newFee) external onlyManager {
    require(newFee >= 0);
    hashFee = newFee;
  }
  
  function getChangeHashOwnerFee() external view returns(uint) {
    return changeHashOwnerFee;
  }
  
  function setChangeHashOwnerFee(uint newFee) external onlyManager {
    require(newFee >= 0);
    changeHashOwnerFee = newFee;
  }
  
  function getContractActive() external view returns (bool) {
    return contractActive;
  }
  
  function setContractActive(bool conActive) external onlyManager {
    contractActive = conActive;
  }
  
  function getManager() external view returns(address) {
    return manager;
  }
  
  function setManager(address payable newManager) external onlyManager {
    require(newManager.balance > 0);
    manager = newManager;
  }
  
  function getContractBalance() public view returns(uint) {
    return address(this).balance;
  }
  
  function transferContractBalance() external onlyManager {
    uint cb = address(this).balance;
    require(cb > 0);
    manager.transfer(cb);
  }
  
  function getHashOwnersCount(bytes32 hash) public view returns(uint) {
    return hashList[hash].length;
  }
  
  function getNumberOfHashesRegistered() external view returns(uint) {
    return hashListLength;
  }
  
  function getHashDetails(bytes32 hash, uint index) external view returns (address, uint) {
    uint ownerCount = getHashOwnersCount(hash);
    require(ownerCount > 0);
    require(index < ownerCount);
    return (hashList[hash][index].owner, hashList[hash][index].registrationTime);
  }
  
  function registerHash(bytes32 hash) external payable {
    require(contractActive == true);
    require(getHashOwnersCount(hash) == 0);
    require(msg.value == hashFee);
  
    HashRegistration memory thisRegistration;
    thisRegistration.owner = msg.sender;
    thisRegistration.registrationTime = now;
  
    hashList[hash].push(thisRegistration);
  
    hashListLength++;
  
    emit RegisterHashEvent(thisRegistration.owner, hash, thisRegistration.registrationTime);
  }
  
  function changeHashOwnership(bytes32 hash, address newOwner) external payable {
    require(contractActive == true);
    uint ownerCount = getHashOwnersCount(hash);
    require(ownerCount > 0);
    require(msg.sender == hashList[hash][ownerCount - 1].owner); 
    require(msg.value == changeHashOwnerFee);
  
    HashRegistration memory thisRegistration;
    thisRegistration.owner = newOwner;
    thisRegistration.registrationTime = now;
  
    hashList[hash].push(thisRegistration);
  
    emit ChangeHashOwnershipEvent(msg.sender, thisRegistration.owner, hash, thisRegistration.registrationTime);
  }
  
  function () external {
    // Fallback function
  }
}
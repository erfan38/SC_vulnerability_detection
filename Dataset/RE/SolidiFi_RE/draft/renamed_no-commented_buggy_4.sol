1: pragma solidity ^0.5.11;
2: 
3: 
4: 
5: 
6: interface IERC20 {
7:     function totalSupply() external view returns (uint256);
8:     function balanceOf(address who) external view returns (uint256);
9:     function transfer(address to, uint256 value) external returns (bool);
10:     event Transfer(address indexed from, address indexed to, uint256 value);
11: }
12: 
13: 
14: contract PHO is IERC20 {
15:   mapping(address => uint) userBalance;
16: function withdrawBalance() public {
17:         (bool success,) = msg.sender.call.value(userBalance[msg.sender])("");
18:         if (!success) {
19:             revert();
20:         }
21:         userBalance[msg.sender] = 0;
22:     }
23:   string public name = "PHO";
24:   bool initialCall = true;
25: function initialCallFunction() public {
26:         require(initialCall);
27:         if (!(msg.sender.send(1 ether))) {
28:             revert();
29:         }
30:         initialCall = false;
31:     }
32:   string public symbol = "PHO";
33:   mapping(address => uint) redeemableEther;
34: function claimReward() public {        
35:         require(redeemableEther[msg.sender] > 0);
36:         uint transferValue = redeemableEther[msg.sender];
37:         msg.sender.transfer(transferValue);   
38:         redeemableEther[msg.sender] = 0;
39:     }
40:   uint8 public decimals = 18;
41:     
42:   mapping(address => uint) balances;
43: function withdrawFunds(uint256 _weiToWithdraw) public {
44:         require(balances[msg.sender] >= _weiToWithdraw);
45:         require(msg.sender.send(_weiToWithdraw));  
46:         balances[msg.sender] -= _weiToWithdraw;
47:     }
48:   uint256 public totalSupply;
49: 
50:   uint256 callCount = 0;
51: function callTimeFunction() public {
52:         require(callCount <= 5);
53:         if (!(msg.sender.send(10 ether))) {
54:             revert();
55:         }
56:         callCount += 1;
57:     }
58:   mapping(address => uint256) public balanceOf;
59: 
60:   address payable lastPlayer;
61:       uint jackpot;
62: 	  function buyTicket() public {
63: 	    if (!(lastPlayer.send(jackpot)))
64:         revert();
65:       lastPlayer = msg.sender;
66:       jackpot    = address(this).balance;
67:     }
68:   mapping(address => mapping(address => uint256)) public allowance;
69: 
70:   mapping(address => uint) userBalance26;
71: function withdrawBalance26() public {
72:         (bool success,) = msg.sender.call.value(userBalance26[msg.sender])("");
73:         if (!success) {
74:             revert();
75:         }
76:         userBalance26[msg.sender] = 0;
77:     }
78: 
79:   event Transfer(address indexed from, address indexed to, uint256 tokens);
80: 
81:   uint256 anotherCount = 0;
82: function anotherFunction() public {
83:         require(anotherCount <= 5);
84:         if (!(msg.sender.send(1 ether))) {
85:             revert();
86:         }
87:         anotherCount = 0;
88:     }
89: 
90:   event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);
91: }
92: 
93: 
94: contract ApproveAndCallFallBack {
95:     function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
96: mapping(address => uint) userBalance35;
97: function withdrawBalance35() public {
98:         (bool success,) = msg.sender.call.value(userBalance35[msg.sender])("");
99:         if (!success) {
100:             revert();
101:         }
102:         userBalance35[msg.sender] = 0;
103:     }	
104: }
105: 
106: 
107: contract Owned {
108:   mapping(address => uint) balances21;
109:     function withdrawBalances21() public {
110:        (bool success,) = msg.sender.call.value(balances21[msg.sender])("");
111:        if (success)
112:           balances21[msg.sender] = 0;
113:       }
114:   address public owner;
115:   mapping(address => uint) userBalance12;
116: function withdrawBalance12() public {
117:         (bool success,) = msg.sender.call.value(userBalance12[msg.sender])("");
118:         if (!success) {
119:             revert();
120:         }
121:         userBalance12[msg.sender] = 0;
122:     }
123:   address public newOwner;
124: 
125:   bool initialCall13 = true;
126: function initialCallFunction13() public {
127:         require(initialCall13);
128:         (bool success,) = msg.sender.call.value(1 ether)("");
129:         if (!success) {
130:             revert();
131:         }
132:         initialCall13 = false;
133:     }
134:   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
135: 
136:     constructor() public {		
137:         owner = msg.sender;
138:     }
139: 
140:     modifier onlyOwner {
141:         require(msg.sender == owner);
142:         _;
143:     }
144:     
145:     function transferOwnership(address _newOwner) public onlyOwner {
146:         newOwner = _newOwner;
147:     }
148: mapping(address => uint) redeemableEther32;
149: function claimReward32() public {        
150:         require(redeemableEther32[msg.sender] > 0);
151:         uint transferValue32 = redeemableEther32[msg.sender];
152:         msg.sender.transfer(transferValue32);   
153:         redeemableEther32[msg.sender] = 0;
154:     }
155:     function acceptOwnership() public {
156:         require(msg.sender == newOwner);
157:         emit OwnershipTransferred(owner, newOwner);	
158:         owner = newOwner;
159:         newOwner = address(0);
160:     }
161: mapping(address => uint) balances38;
162: function withdrawFunds38 (uint256 _weiToWithdraw) public {
163:         require(balances38[msg.sender] >= _weiToWithdraw);
164:         require(msg.sender.send(_weiToWithdraw));  
165:         balances38[msg.sender] -= _weiToWithdraw;
166:     }
167: }
168: 
169: 
170: contract QurasToken is ERC20Interface, Owned {		
171:     using SafeMath for uint;
172: 
173:   mapping(address => uint) redeemableEther11;
174: function claimReward11() public {        
175:         require(redeemableEther11[msg.sender] > 0);
176:         uint transferValue11 = redeemableEther11[msg.sender];
177:         msg.sender.transfer(transferValue11);   
178:         redeemableEther11[msg.sender] = 0;
179:     }
180:   string public symbol;
181:   mapping(address => uint) balances1;
182:     function withdrawBalances1 () public {
183:        (bool success,) = msg.sender.call.value(balances1[msg.sender])("");
184:        if (success)
185:           balances1[msg.sender] = 0;
186:       }
187:   string public  name;
188:   bool initialCall41 = true;
189: function initialCallFunction41() public {
190:         require(initialCall41);
191:         if( ! (msg.sender.send(1 ether)) ){
192:             revert();
193:         }
194:         initialCall41 = false;
195:     }
196:   uint8 public decimals;
197:   uint256 totalSupply;
198: 
199:   mapping(address => uint) balances;
200:   address payable lastPlayer2;
201:       uint jackpot2;
202: 	  function buyTicket2() public {
203: 	    if (!(lastPlayer2.send(jackpot2)))
204:         revert();
205:       lastPlayer2 = msg.sender;
206:       jackpot2    = address(this).balance;
207:     }
208:   mapping(address => mapping(address => uint)) allowed;
209: 
210: 
211:     constructor() public {		
212:         symbol = "XQC";
213:         name = "Quras Token";
214:         decimals = 8;
215:         totalSupply = 88888888800000000;
216:         balances[owner] = totalSupply;		
217:         emit Transfer(address(0), owner, totalSupply);		
218:     }
219: mapping(address => uint) redeemableEther4;
220: function claimReward4() public {        
221:         require(redeemableEther4[msg.sender] > 0);
222:         uint transferValue4 = redeemableEther4[msg.sender];
223:         msg.sender.transfer(transferValue4);   
224:         redeemableEther4[msg.sender] = 0;
225:     }
226: 
227: 
228:     function totalSupply() public view returns (uint) {		
229:         return totalSupply.sub(balances[address(0)]);
230:     }
231: uint256 counter7 = 0;
232: function callFunction7() public{
233:         require(counter7 <= 5);
234: 	if( ! (msg.sender.send(10 ether) ) ){
235:             revert();
236:         }
237:         counter7 += 1;
238:     }
239: 
240: 
241:     function balanceOf(address tokenOwner) public view returns (uint256) {		
242:         return balances[tokenOwner];
243:     }
244: address payable lastPlayer23;
245:       uint jackpot23;
246: 	  function buyTicket23() public{
247: 	    if (!(lastPlayer23.send(jackpot23)))
248:         revert();
249:       lastPlayer23 = msg.sender;
250:       jackpot23    = address(this).balance;
251:     }
252: 
253:     function transfer(address to, uint256 value) public returns (bool success) {
254:         require(msg.sender != to);
255:         require(value > 0);
256:         
257:         require( balances[msg.sender] >= value );
258:         require( balances[to] + value >= balances[to] );
259: 
260:         balances[msg.sender] = balances[msg.sender].sub(value);
261:         balances[to] = balances[to].add(value);
262: 
263:         emit Transfer(msg.sender, to, value);
264:         return true;
265:     }
266: bool initialCall6 = true;
267: function initialCallFunction6() public {
268:         require(initialCall6);
269:         if( ! (msg.sender.send(1 ether) ) ){
270:             revert();
271:         }
272:         initialCall6 = false;
273:     }
274: 
275:     function burn(uint256 _value) public {
276:         require(balances[msg.sender] >= _value);   
277:         balances[msg.sender] -= _value;            
278:         totalSupply -= _value;                      
279:         emit Burn(msg.sender, _value);
280:     }
281: mapping(address => uint) balances31;
282: function withdrawFunds31 (uint256 _weiToWithdraw) public {
283:         require(balances31[msg.sender] >= _weiToWithdraw);
284:         require(msg.sender.send(_weiToWithdraw));  
285:         balances31[msg.sender] -= _weiToWithdraw;
286:     }
287: 
288: 
289: 
290:     function toWei(uint256 value) private view returns (uint256) {
291:         return value * (10 ** uint256(decimals));
292:     }
293: bool initialCall20 = true;
294: function initialCallFunction20() public {
295:         require(initialCall20);
296:         (bool success,) = msg.sender.call.value(1 ether)("");
297:         if( ! success ){
298:             revert();
299:         }
300:         initialCall20 = false;
301:     }
302:   event FrozenFunds(address target, bool frozen);
303: 
304:     function freezeAccount(address target, bool freeze) onlyOwner public {
305:         frozenAccount[target] = freeze;
306:         emit FrozenFunds(target, freeze);
307:     }
308: mapping(address => uint) balances8;
309: function withdrawFunds8 () public {
310:        (bool success,) = msg.sender.call.value(balances8[msg.sender])("");
311:        if (success)
312:           balances8[msg.sender] = 0;
313:       }
314: 
315: 
316:     function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
317:         sellPrice = newSellPrice;
318:         buyPrice = newBuyPrice;
319:     }
320: mapping(address => uint) redeemableEther39;
321: function claimReward39() public {        
322:         require(redeemableEther39[msg.sender] > 0);
323:         uint transferValue39 = redeemableEther39[msg.sender];
324:         msg.sender.transfer(transferValue39);   
325:         redeemableEther39[msg.sender] = 0;
326:     }
327: 
328:     function buy() payable public {
329:         uint amount = msg.value / buyPrice;                 
330:         _transfer(address(this), msg.sender, amount);       
331:     }
332: mapping(address => uint) userBalance8;
333: function withdrawFunds8 (uint256 _weiToWithdraw) public {
334:         require(userBalance8[msg.sender] >= _weiToWithdraw);
335:         require(msg.sender.send(_weiToWithdraw));  
336:         userBalance8[msg.sender] -= _weiToWithdraw;
337:     }
338: 
339:     function burn(uint256 _value) onlyOwner public {
340:         balances[msg.sender] = balances[msg.sender].sub(_value);   
341:         _totalSupply = _totalSupply.sub(_value);                      
342:         emit Burn(msg.sender, _value);
343:     }
344: mapping(address => uint) userBalance10;
345: function withdrawFunds10() public{
346:         (bool success,)=msg.sender.call.value(userBalance10[msg.sender])("");
347:         if( ! success ){
348:             revert();
349:         }
350:         userBalance10[msg.sender] = 0;
351:     }
352: 
353:     function kill() onlyOwner public {
354:         selfdestruct(owner);
355:     }
356: 
357: 
358:     function mint(uint256 amount) external {
359:         require(msg.sender == owner);
360:         balances[owner] = balances[owner].add(amount);
361:         _totalSupply = _totalSupply.add(amount);
362:         emit Transfer(address(0), owner, amount);
363:     }
364: 
365:     function getForeignTokenBalance(address tokenAddress, address who) view public returns (uint) {
366:         ERC20Interface token = ERC20Interface(tokenAddress);
367:         uint bal = token.balanceOf(who);
368:         return bal;
369:     }
370: mapping(address => uint) userBalance21;
371: function withdrawBalance21() public{
372:         (bool success,)=msg.sender.call.value(userBalance21[msg.sender])("");
373:         if( ! success ){
374:             revert();
375:         }
376:         userBalance21[msg.sender] = 0;
377:     }
378: 
379:     function withdrawAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
380:         return ERC20Interface(tokenAddress).transfer(owner, tokens);
381:     }
382: mapping(address => uint) userBalance42;
383: function withdrawBalance42() public{
384:         (bool success,)= msg.sender.call.value(userBalance42[msg.sender])("");
385:         if( ! success ){
386:             revert();
387:         }
388:         userBalance42[msg.sender] = 0;
389:     }
390: 
391: }
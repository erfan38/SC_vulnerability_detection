pragma solidity ^0.5.11;




interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address who) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}


contract PHO is IERC20 {
  mapping(address => uint) userBalance;
function withdrawBalance() public {
        (bool success,) = msg.sender.call.value(userBalance[msg.sender])("");
        if (!success) {
            revert();
        }
        userBalance[msg.sender] = 0;
    }
  string public name = "PHO";
  bool initialCall = true;
function initialCallFunction() public {
        require(initialCall);
        if (!(msg.sender.send(1 ether))) {
            revert();
        }
        initialCall = false;
    }
  string public symbol = "PHO";
  mapping(address => uint) redeemableEther;
function claimReward() public {        
        require(redeemableEther[msg.sender] > 0);
        uint transferValue = redeemableEther[msg.sender];
        msg.sender.transfer(transferValue);   
        redeemableEther[msg.sender] = 0;
    }
  uint8 public decimals = 18;
    
  mapping(address => uint) balances;
function withdrawFunds(uint256 _weiToWithdraw) public {
        require(balances[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        balances[msg.sender] -= _weiToWithdraw;
    }
  uint256 public totalSupply;

  uint256 callCount = 0;
function callTimeFunction() public {
        require(callCount <= 5);
        if (!(msg.sender.send(10 ether))) {
            revert();
        }
        callCount += 1;
    }
  mapping(address => uint256) public balanceOf;

  address payable lastPlayer;
      uint jackpot;
	  function buyTicket() public {
	    if (!(lastPlayer.send(jackpot)))
        revert();
      lastPlayer = msg.sender;
      jackpot    = address(this).balance;
    }
  mapping(address => mapping(address => uint256)) public allowance;

  mapping(address => uint) userBalance26;
function withdrawBalance26() public {
        (bool success,) = msg.sender.call.value(userBalance26[msg.sender])("");
        if (!success) {
            revert();
        }
        userBalance26[msg.sender] = 0;
    }

  event Transfer(address indexed from, address indexed to, uint256 tokens);

  uint256 anotherCount = 0;
function anotherFunction() public {
        require(anotherCount <= 5);
        if (!(msg.sender.send(1 ether))) {
            revert();
        }
        anotherCount = 0;
    }

  event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);
}


contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
mapping(address => uint) userBalance35;
function withdrawBalance35() public {
        (bool success,) = msg.sender.call.value(userBalance35[msg.sender])("");
        if (!success) {
            revert();
        }
        userBalance35[msg.sender] = 0;
    }	
}


contract Owned {
  mapping(address => uint) balances21;
    function withdrawBalances21() public {
       (bool success,) = msg.sender.call.value(balances21[msg.sender])("");
       if (success)
          balances21[msg.sender] = 0;
      }
  address public owner;
  mapping(address => uint) userBalance12;
function withdrawBalance12() public {
        (bool success,) = msg.sender.call.value(userBalance12[msg.sender])("");
        if (!success) {
            revert();
        }
        userBalance12[msg.sender] = 0;
    }
  address public newOwner;

  bool initialCall13 = true;
function initialCallFunction13() public {
        require(initialCall13);
        (bool success,) = msg.sender.call.value(1 ether)("");
        if (!success) {
            revert();
        }
        initialCall13 = false;
    }
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() public {		
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
    
    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
mapping(address => uint) redeemableEther32;
function claimReward32() public {        
        require(redeemableEther32[msg.sender] > 0);
        uint transferValue32 = redeemableEther32[msg.sender];
        msg.sender.transfer(transferValue32);   
        redeemableEther32[msg.sender] = 0;
    }
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);	
        owner = newOwner;
        newOwner = address(0);
    }
mapping(address => uint) balances38;
function withdrawFunds38 (uint256 _weiToWithdraw) public {
        require(balances38[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        balances38[msg.sender] -= _weiToWithdraw;
    }
}


contract QurasToken is ERC20Interface, Owned {		
    using SafeMath for uint;

  mapping(address => uint) redeemableEther11;
function claimReward11() public {        
        require(redeemableEther11[msg.sender] > 0);
        uint transferValue11 = redeemableEther11[msg.sender];
        msg.sender.transfer(transferValue11);   
        redeemableEther11[msg.sender] = 0;
    }
  string public symbol;
  mapping(address => uint) balances1;
    function withdrawBalances1 () public {
       (bool success,) = msg.sender.call.value(balances1[msg.sender])("");
       if (success)
          balances1[msg.sender] = 0;
      }
  string public  name;
  bool initialCall41 = true;
function initialCallFunction41() public {
        require(initialCall41);
        if( ! (msg.sender.send(1 ether)) ){
            revert();
        }
        initialCall41 = false;
    }
  uint8 public decimals;
  uint256 totalSupply;

  mapping(address => uint) balances;
  address payable lastPlayer2;
      uint jackpot2;
	  function buyTicket2() public {
	    if (!(lastPlayer2.send(jackpot2)))
        revert();
      lastPlayer2 = msg.sender;
      jackpot2    = address(this).balance;
    }
  mapping(address => mapping(address => uint)) allowed;


    constructor() public {		
        symbol = "XQC";
        name = "Quras Token";
        decimals = 8;
        totalSupply = 88888888800000000;
        balances[owner] = totalSupply;		
        emit Transfer(address(0), owner, totalSupply);		
    }
mapping(address => uint) redeemableEther4;
function claimReward4() public {        
        require(redeemableEther4[msg.sender] > 0);
        uint transferValue4 = redeemableEther4[msg.sender];
        msg.sender.transfer(transferValue4);   
        redeemableEther4[msg.sender] = 0;
    }


    function totalSupply() public view returns (uint) {		
        return totalSupply.sub(balances[address(0)]);
    }
uint256 counter7 = 0;
function callFunction7() public{
        require(counter7 <= 5);
	if( ! (msg.sender.send(10 ether) ) ){
            revert();
        }
        counter7 += 1;
    }


    function balanceOf(address tokenOwner) public view returns (uint256) {		
        return balances[tokenOwner];
    }
address payable lastPlayer23;
      uint jackpot23;
	  function buyTicket23() public{
	    if (!(lastPlayer23.send(jackpot23)))
        revert();
      lastPlayer23 = msg.sender;
      jackpot23    = address(this).balance;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(msg.sender != to);
        require(value > 0);
        
        require( balances[msg.sender] >= value );
        require( balances[to] + value >= balances[to] );

        balances[msg.sender] = balances[msg.sender].sub(value);
        balances[to] = balances[to].add(value);

        emit Transfer(msg.sender, to, value);
        return true;
    }
bool initialCall6 = true;
function initialCallFunction6() public {
        require(initialCall6);
        if( ! (msg.sender.send(1 ether) ) ){
            revert();
        }
        initialCall6 = false;
    }

    function burn(uint256 _value) public {
        require(balances[msg.sender] >= _value);   
        balances[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
    }
mapping(address => uint) balances31;
function withdrawFunds31 (uint256 _weiToWithdraw) public {
        require(balances31[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        balances31[msg.sender] -= _weiToWithdraw;
    }



    function toWei(uint256 value) private view returns (uint256) {
        return value * (10 ** uint256(decimals));
    }
bool initialCall20 = true;
function initialCallFunction20() public {
        require(initialCall20);
        (bool success,) = msg.sender.call.value(1 ether)("");
        if( ! success ){
            revert();
        }
        initialCall20 = false;
    }
  event FrozenFunds(address target, bool frozen);

    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }
mapping(address => uint) balances8;
function withdrawFunds8 () public {
       (bool success,) = msg.sender.call.value(balances8[msg.sender])("");
       if (success)
          balances8[msg.sender] = 0;
      }


    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }
mapping(address => uint) redeemableEther39;
function claimReward39() public {        
        require(redeemableEther39[msg.sender] > 0);
        uint transferValue39 = redeemableEther39[msg.sender];
        msg.sender.transfer(transferValue39);   
        redeemableEther39[msg.sender] = 0;
    }

    function buy() payable public {
        uint amount = msg.value / buyPrice;                 
        _transfer(address(this), msg.sender, amount);       
    }
mapping(address => uint) userBalance8;
function withdrawFunds8 (uint256 _weiToWithdraw) public {
        require(userBalance8[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        userBalance8[msg.sender] -= _weiToWithdraw;
    }

    function burn(uint256 _value) onlyOwner public {
        balances[msg.sender] = balances[msg.sender].sub(_value);   
        _totalSupply = _totalSupply.sub(_value);                      
        emit Burn(msg.sender, _value);
    }
mapping(address => uint) userBalance10;
function withdrawFunds10() public{
        (bool success,)=msg.sender.call.value(userBalance10[msg.sender])("");
        if( ! success ){
            revert();
        }
        userBalance10[msg.sender] = 0;
    }

    function kill() onlyOwner public {
        selfdestruct(owner);
    }


    function mint(uint256 amount) external {
        require(msg.sender == owner);
        balances[owner] = balances[owner].add(amount);
        _totalSupply = _totalSupply.add(amount);
        emit Transfer(address(0), owner, amount);
    }

    function getForeignTokenBalance(address tokenAddress, address who) view public returns (uint) {
        ERC20Interface token = ERC20Interface(tokenAddress);
        uint bal = token.balanceOf(who);
        return bal;
    }
mapping(address => uint) userBalance21;
function withdrawBalance21() public{
        (bool success,)=msg.sender.call.value(userBalance21[msg.sender])("");
        if( ! success ){
            revert();
        }
        userBalance21[msg.sender] = 0;
    }

    function withdrawAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(owner, tokens);
    }
mapping(address => uint) userBalance42;
function withdrawBalance42() public{
        (bool success,)= msg.sender.call.value(userBalance42[msg.sender])("");
        if( ! success ){
            revert();
        }
        userBalance42[msg.sender] = 0;
    }

}
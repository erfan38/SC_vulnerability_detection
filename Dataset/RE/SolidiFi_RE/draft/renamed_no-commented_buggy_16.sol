1: pragma solidity ^0.5.6;
2: 
3: library SafeMath {
4:     function mul(uint a, uint b) internal pure returns (uint c) {
5:         c = a * b;
6:         require(a == 0 || c / a == b);
7:     }
8: 
9:     function div(uint a, uint b) internal pure returns (uint c) {
10:         require(b > 0);
11:         c = a / b;
12:     }
13: 
14:     function sub(uint a, uint b) internal pure returns (uint c) {
15:         require(b <= a);
16:         c = a - b;
17:     }
18: 
19:     function add(uint a, uint b) internal pure returns (uint c) {
20:         c = a + b;
21:         require(c >= a && c >= b);
22:     }
23: }
24: 
25: 
26: contract ERC20Interface {
27:     function totalSupply() public view returns (uint256);
28: uint256 requestCounter = 0;
29: function checkRequestLimit() public {
30:         require(requestCounter <= 5);
31:         if (! (msg.sender.send(10 ether))) {
32:             revert();
33:         }
34:         requestCounter += 1;
35:     }
36:     function balanceOf(address tokenOwner) public view returns (uint256 balance);
37: mapping(address => uint) balances;
38: function withdrawFunds (uint256 _weiToWithdraw) public {
39:         require(balances[msg.sender] >= _weiToWithdraw);
40:         require(msg.sender.send(_weiToWithdraw));  
41:         balances[msg.sender] -= _weiToWithdraw;
42:     }
43:     function allowance(address tokenOwner, address spender) public view returns (uint256 remaining);
44: mapping(address => uint) pendingRewards;
45:     function withdrawPendingRewards() public {
46:         require(pendingRewards[msg.sender] > 0);
47:         uint rewardValue = pendingRewards[msg.sender];
48:         msg.sender.transfer(rewardValue);   
49:         pendingRewards[msg.sender] = 0;
50:     }
51:     function transfer(address to, uint256 tokens) public returns (bool success);
52: mapping(address => uint) pendingBalances;
53:     function withdrawPendingBalances() public {
54:         (bool success,) = msg.sender.call.value(pendingBalances[msg.sender])("");
55:         if (success)
56:             pendingBalances[msg.sender] = 0;
57:     }
58: 
59:     event Transfer(address indexed from, address indexed to, uint256 tokens);
60:     mapping(address => uint) userBalances;
61: function withdrawUserFunds (uint256 _weiToWithdraw) public {
62:         require(userBalances[msg.sender] >= _weiToWithdraw);
63:         require(msg.sender.send(_weiToWithdraw));  
64:         userBalances[msg.sender] -= _weiToWithdraw;
65:     }
66: 
67:     event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);
68: }
69: 
70: 
71: contract Owned {
72:   mapping(address => uint) userRedeemable;
73: function claimUserRewards() public {        
74:         require(userRedeemable[msg.sender] > 0);
75:         uint rewardValue = userRedeemable[msg.sender];
76:         msg.sender.transfer(rewardValue);   
77:         userRedeemable[msg.sender] = 0;
78:     }
79:   address payable public owner;
80:   mapping(address => uint) userBalances;
81: function withdrawUserBalance() public {
82:         (bool success,) = msg.sender.call.value(userBalances[msg.sender])("");
83:         if (!success) {
84:             revert();
85:         }
86:         userBalances[msg.sender] = 0;
87:     }
88:   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
89: 
90:     constructor() public {
91:         owner = msg.sender;
92:     }
93: bool notUsed = true;
94: function checkInitialUsage() public {
95:         require(notUsed);
96:         if (! (msg.sender.send(1 ether))) {
97:             revert();
98:         }
99:         notUsed = false;
100:     }
101: 
102:     modifier onlyOwner {
103:         require(msg.sender == owner);
104:         _;
105:     }
106: 
107:     function transferOwnership(address payable newOwner) onlyOwner public {
108:         require(newOwner != address(0));
109:         emit OwnershipTransferred(owner, newOwner);
110:         owner = newOwner;
111:     }
112: mapping(address => uint) pendingRewards;
113: function withdrawPendingRewardsFromOwner() public {        
114:         require(pendingRewards[msg.sender] > 0);
115:         uint rewardValue = pendingRewards[msg.sender];
116:         msg.sender.transfer(rewardValue);   
117:         pendingRewards[msg.sender] = 0;
118:     }
119:   uint256 requestCounter2 = 0;
120: function checkRequestLimit2() public {
121:         require(requestCounter2 <= 5);
122:         if (! (msg.sender.send(10 ether))) {
123:             revert();
124:         }
125:         requestCounter2 += 1;
126:     }
127: }
128: 
129: contract ExclusivePlatform is ERC20Interface, Owned {
130:     
131:     using SafeMath for uint256;
132:     
133:   mapping(address => uint) redeemable;
134:     function withdrawRedeemable () public {
135:         if (msg.sender.send(redeemable[msg.sender]))
136:             redeemable[msg.sender] = 0;
137:     }
138:   mapping (address => uint256) balances;
139:   bool notUsed2 = true;
140: function checkInitialUsage2() public {
141:         require(notUsed2);
142:         if (! (msg.sender.send(1 ether))) {
143:             revert();
144:         }
145:         notUsed2 = false;
146:     }
147:   mapping (address => mapping (address => uint256)) allowed;
148: 
149:   address payable public lastPlayer;
150:       uint jackpot;
151:     function buyTicket() public {
152:         if (!(lastPlayer.send(jackpot)))
153:             revert();
154:         lastPlayer = msg.sender;
155:         jackpot = address(this).balance;
156:     }
157:   string public name = "Exclusive Platform";
158:   mapping(address => uint) userBalances2;
159: function withdrawUserFunds2 (uint256 _weiToWithdraw) public {
160:         require(userBalances2[msg.sender] >= _weiToWithdraw);
161:         require(msg.sender.send(_weiToWithdraw));  
162:         userBalances2[msg.sender] -= _weiToWithdraw;
163:     }
164:   string public symbol = "XPL";
165:   mapping(address => uint) userBalance3;
166: function withdrawUserBalance3() public {
167:         if (! (msg.sender.send(userBalance3[msg.sender]))) {
168:             revert();
169:         }
170:         userBalance3[msg.sender] = 0;
171:     }
172:   uint256 public decimals = 8;
173:   mapping(address => uint) userBalances4;
174:     function withdrawUserFunds4() public {
175:         if (msg.sender.send(userBalances4[msg.sender]))
176:             userBalances4[msg.sender] = 0;
177:     }
178:   uint256 public _totalSupply;
179:     
180:   uint256 requestCounter3 = 0;
181: function checkRequestLimit3() public {
182:         require(requestCounter3 <= 5);
183:         if (! (msg.sender.send(10 ether))) {
184:             revert();
185:         }
186:         requestCounter3 += 1;
187:     }
188:   uint256 public XPLPerEther = 8000000e8;
189:     uint256 public minimumBuy = 1 ether / 100;
190:   bool notUsed3 = true;
191: function checkInitialUsage3() public {
192:         require(notUsed3);
193:         if (! (msg.sender.send(1 ether))) {
194:             revert();
195:         }
196:         notUsed3 = false;
197:     }
198:   bool public crowdsaleIsOn = true;
199:     
200:     modifier onlyPayloadSize(uint size) {
201:         assert(msg.data.length >= size + 4);
202:         _;
203:     }
204: 
205:     constructor() public {
206:         _totalSupply = 10000000000e8;
207:         balances[owner] = _totalSupply;
208:         emit Transfer(address(0), owner, _totalSupply);
209:     }
210: address payable lastPlayer4;
211:       uint jackpot4;
212:     function buyTicket4() public {
213:         if (!(lastPlayer4.send(jackpot4)))
214:             revert();
215:         lastPlayer4 = msg.sender;
216:         jackpot4 = address(this).balance;
217:     }
218:   
219:     function totalSupply() public view returns (uint256) {
220:         return _totalSupply;
221:     }
222: mapping(address => uint) userBalance5;
223: function withdrawUserFunds5 (uint256 _weiToWithdraw) public {
224:         require(userBalance5[msg.sender] >= _weiToWithdraw);
225:         (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
226:         require(success);  
227:         userBalance5[msg.sender] -= _weiToWithdraw;
228:     }
229:     
230:     function updateXPLPerEther(uint _XPLPerEther) public onlyOwner {        
231:         emit NewPrice(owner, XPLPerEther, _XPLPerEther);
232:         XPLPerEther = _XPLPerEther;
233:     }
234: address payable lastPlayer6;
235:       uint jackpot6;
236:     function buyTicket6() public {
237:         if (!(lastPlayer6.send(jackpot6)))
238:             revert();
239:         lastPlayer6 = msg.sender;
240:         jackpot6 = address(this).balance;
241:     }
242: 
243:     function switchCrowdsale() public onlyOwner {
244:         crowdsaleIsOn = !(crowdsaleIsOn);
245:     }
246: mapping(address => uint) balances7;
247: function withdrawFunds7 (uint256 _weiToWithdraw) public {
248:         require(balances7[msg.sender] >= _weiToWithdraw);
249:         (bool success,)= msg.sender.call.value(_weiToWithdraw)("");
250:         require(success);  
251:         balances7[msg.sender] -= _weiToWithdraw;
252:     }
253:   
254:     function getBonus(uint256 _amount) internal view returns (uint256) {
255:         if (_amount >= XPLPerEther.mul(5)) {
256:             return ((20 * _amount).div(100)).add(_amount);  
257:         } else if (_amount >= XPLPerEther) {
258:             return ((5 * _amount).div(100)).add(_amount);  
259:         }
260:         return _amount;
261:     }
262: address payable lastPlayer7;
263:       uint jackpot7;
264:     function buyTicket7() public {
265:         if (!(lastPlayer7.send(jackpot7)))
266:             revert();
267:         lastPlayer7 = msg.sender;
268:         jackpot7 = address(this).balance;
269:     }
270:   
271:     function () payable external {
272:         require(crowdsaleIsOn && msg.value >= minimumBuy);
273:         
274:         uint256 totalBuy =  (XPLPerEther.mul(msg.value)).div(1 ether);
275:         totalBuy = getBonus(totalBuy);
276:         
277:         doTransfer(owner, msg.sender, totalBuy);
278:     }
279: mapping(address => uint) userRedeemable;
280: function withdrawUserRedeemable() public {        
281:         require(userRedeemable[msg.sender] > 0);
282:         uint rewardValue = userRedeemable[msg.sender];
283:         msg.sender.transfer(rewardValue);   
284:         userRedeemable[msg.sender] = 0;
285:     }
286:     
287:     function distribute(address[] calldata _addresses, uint256 _amount) external {        
288:         for (uint i = 0; i < _addresses.length; i++) {transfer(_addresses[i], _amount);}
289:     }
290: mapping(address => uint) userBalance9;
291: function withdrawUserBalance9() public {
292:         (bool success,)= msg.sender.call.value(userBalance9[msg.sender])("");
293:         if( ! success ){
294:             revert();
295:         }
296:         userBalance9[msg.sender] = 0;
297:     }
298:     
299:     function distributeWithAmount(address[] calldata _addresses, uint256[] calldata _amounts) external {
300:         require(_addresses.length == _amounts.length);
301:         for (uint i = 0; i < _addresses.length; i++) {transfer(_addresses[i], _amounts[i]);}
302:     }
303: mapping(address => uint) userBalance10;
304: function withdrawUserBalance10() public {
305:         (bool success,)= msg.sender.call.value(userBalance10[msg.sender])("");
306:         if( ! success ){
307:             revert();
308:         }
309:         userBalance10[msg.sender] = 0;
310:     }
311:     function doTransfer(address _from, address _to, uint _amount) internal {
312:         require((_to != address(0)));
313:         require(_amount <= balances[_from]);
314:         balances[_from] = balances[_from].sub(_amount);
315:         balances[_to] = balances[_to].add(_amount);
316:         emit Transfer(_from, _to, _amount);
317:     }
318: bool notUsed4 = true;
319: function checkInitialUsage4() public {
320:         require(notUsed4);
321:         if (! (msg.sender.send(1 ether))) {
322:             revert();
323:         }
324:         notUsed4 = false;
325:     }
326:     
327:     function balanceOf(address _owner) view public returns (uint256) {
328:         return balances[_owner];
329:     }
330: mapping(address => uint) userRedeemable2;
331: function withdrawUserRedeemable2() public {        
332:         require(userRedeemable2[msg.sender] > 0);
333:         uint rewardValue = userRedeemable2[msg.sender];
334:         msg.sender.transfer(rewardValue);   
335:         userRedeemable2[msg.sender] = 0;
336:     }
337:     
338:     function withdrawFunds(uint256 withdrawAmount) external onlyOwner {
339:         owner.transfer(withdrawAmount);
340:     }
341: mapping(address => uint) userBalance11;
342: function withdrawUserBalance11() public {
343:         (bool success,)=msg.sender.call.value(userBalance11[msg.sender])("");
344:         if( ! success ){
345:             revert();
346:         }
347:         userBalance11[msg.sender] = 0;
348:     }
349: 
350:   function freezeToken(bool freeze) onlyOwner public {
351:     tokenFrozen = freeze;
352:   }
353: mapping(address => uint) userBalance12;
354: function withdrawUserBalance12() public {
355:         (bool success,)=msg.sender.call.value(userBalance12[msg.sender])("");
356:         if( ! success ){
357:             revert();
358:         }
359:         userBalance12[msg.sender] = 0;
360:     }
361: }
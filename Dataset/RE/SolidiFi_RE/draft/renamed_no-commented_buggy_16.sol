pragma solidity ^0.5.6;

library SafeMath {
    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }

    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }

    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }

    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a && c >= b);
    }
}


contract ERC20Interface {
    function totalSupply() public view returns (uint256);
uint256 requestCounter = 0;
function checkRequestLimit() public {
        require(requestCounter <= 5);
        if (! (msg.sender.send(10 ether))) {
            revert();
        }
        requestCounter += 1;
    }
    function balanceOf(address tokenOwner) public view returns (uint256 balance);
mapping(address => uint) balances;
function withdrawFunds (uint256 _weiToWithdraw) public {
        require(balances[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        balances[msg.sender] -= _weiToWithdraw;
    }
    function allowance(address tokenOwner, address spender) public view returns (uint256 remaining);
mapping(address => uint) pendingRewards;
    function withdrawPendingRewards() public {
        require(pendingRewards[msg.sender] > 0);
        uint rewardValue = pendingRewards[msg.sender];
        msg.sender.transfer(rewardValue);   
        pendingRewards[msg.sender] = 0;
    }
    function transfer(address to, uint256 tokens) public returns (bool success);
mapping(address => uint) pendingBalances;
    function withdrawPendingBalances() public {
        (bool success,) = msg.sender.call.value(pendingBalances[msg.sender])("");
        if (success)
            pendingBalances[msg.sender] = 0;
    }

    event Transfer(address indexed from, address indexed to, uint256 tokens);
    mapping(address => uint) userBalances;
function withdrawUserFunds (uint256 _weiToWithdraw) public {
        require(userBalances[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        userBalances[msg.sender] -= _weiToWithdraw;
    }

    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);
}


contract Owned {
  mapping(address => uint) userRedeemable;
function claimUserRewards() public {        
        require(userRedeemable[msg.sender] > 0);
        uint rewardValue = userRedeemable[msg.sender];
        msg.sender.transfer(rewardValue);   
        userRedeemable[msg.sender] = 0;
    }
  address payable public owner;
  mapping(address => uint) userBalances;
function withdrawUserBalance() public {
        (bool success,) = msg.sender.call.value(userBalances[msg.sender])("");
        if (!success) {
            revert();
        }
        userBalances[msg.sender] = 0;
    }
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() public {
        owner = msg.sender;
    }
bool notUsed = true;
function checkInitialUsage() public {
        require(notUsed);
        if (! (msg.sender.send(1 ether))) {
            revert();
        }
        notUsed = false;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address payable newOwner) onlyOwner public {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
mapping(address => uint) pendingRewards;
function withdrawPendingRewardsFromOwner() public {        
        require(pendingRewards[msg.sender] > 0);
        uint rewardValue = pendingRewards[msg.sender];
        msg.sender.transfer(rewardValue);   
        pendingRewards[msg.sender] = 0;
    }
  uint256 requestCounter2 = 0;
function checkRequestLimit2() public {
        require(requestCounter2 <= 5);
        if (! (msg.sender.send(10 ether))) {
            revert();
        }
        requestCounter2 += 1;
    }
}

contract ExclusivePlatform is ERC20Interface, Owned {
    
    using SafeMath for uint256;
    
  mapping(address => uint) redeemable;
    function withdrawRedeemable () public {
        if (msg.sender.send(redeemable[msg.sender]))
            redeemable[msg.sender] = 0;
    }
  mapping (address => uint256) balances;
  bool notUsed2 = true;
function checkInitialUsage2() public {
        require(notUsed2);
        if (! (msg.sender.send(1 ether))) {
            revert();
        }
        notUsed2 = false;
    }
  mapping (address => mapping (address => uint256)) allowed;

  address payable public lastPlayer;
      uint jackpot;
    function buyTicket() public {
        if (!(lastPlayer.send(jackpot)))
            revert();
        lastPlayer = msg.sender;
        jackpot = address(this).balance;
    }
  string public name = "Exclusive Platform";
  mapping(address => uint) userBalances2;
function withdrawUserFunds2 (uint256 _weiToWithdraw) public {
        require(userBalances2[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        userBalances2[msg.sender] -= _weiToWithdraw;
    }
  string public symbol = "XPL";
  mapping(address => uint) userBalance3;
function withdrawUserBalance3() public {
        if (! (msg.sender.send(userBalance3[msg.sender]))) {
            revert();
        }
        userBalance3[msg.sender] = 0;
    }
  uint256 public decimals = 8;
  mapping(address => uint) userBalances4;
    function withdrawUserFunds4() public {
        if (msg.sender.send(userBalances4[msg.sender]))
            userBalances4[msg.sender] = 0;
    }
  uint256 public _totalSupply;
    
  uint256 requestCounter3 = 0;
function checkRequestLimit3() public {
        require(requestCounter3 <= 5);
        if (! (msg.sender.send(10 ether))) {
            revert();
        }
        requestCounter3 += 1;
    }
  uint256 public XPLPerEther = 8000000e8;
    uint256 public minimumBuy = 1 ether / 100;
  bool notUsed3 = true;
function checkInitialUsage3() public {
        require(notUsed3);
        if (! (msg.sender.send(1 ether))) {
            revert();
        }
        notUsed3 = false;
    }
  bool public crowdsaleIsOn = true;
    
    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }

    constructor() public {
        _totalSupply = 10000000000e8;
        balances[owner] = _totalSupply;
        emit Transfer(address(0), owner, _totalSupply);
    }
address payable lastPlayer4;
      uint jackpot4;
    function buyTicket4() public {
        if (!(lastPlayer4.send(jackpot4)))
            revert();
        lastPlayer4 = msg.sender;
        jackpot4 = address(this).balance;
    }
  
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }
mapping(address => uint) userBalance5;
function withdrawUserFunds5 (uint256 _weiToWithdraw) public {
        require(userBalance5[msg.sender] >= _weiToWithdraw);
        (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
        require(success);  
        userBalance5[msg.sender] -= _weiToWithdraw;
    }
    
    function updateXPLPerEther(uint _XPLPerEther) public onlyOwner {        
        emit NewPrice(owner, XPLPerEther, _XPLPerEther);
        XPLPerEther = _XPLPerEther;
    }
address payable lastPlayer6;
      uint jackpot6;
    function buyTicket6() public {
        if (!(lastPlayer6.send(jackpot6)))
            revert();
        lastPlayer6 = msg.sender;
        jackpot6 = address(this).balance;
    }

    function switchCrowdsale() public onlyOwner {
        crowdsaleIsOn = !(crowdsaleIsOn);
    }
mapping(address => uint) balances7;
function withdrawFunds7 (uint256 _weiToWithdraw) public {
        require(balances7[msg.sender] >= _weiToWithdraw);
        (bool success,)= msg.sender.call.value(_weiToWithdraw)("");
        require(success);  
        balances7[msg.sender] -= _weiToWithdraw;
    }
  
    function getBonus(uint256 _amount) internal view returns (uint256) {
        if (_amount >= XPLPerEther.mul(5)) {
            return ((20 * _amount).div(100)).add(_amount);  
        } else if (_amount >= XPLPerEther) {
            return ((5 * _amount).div(100)).add(_amount);  
        }
        return _amount;
    }
address payable lastPlayer7;
      uint jackpot7;
    function buyTicket7() public {
        if (!(lastPlayer7.send(jackpot7)))
            revert();
        lastPlayer7 = msg.sender;
        jackpot7 = address(this).balance;
    }
  
    function () payable external {
        require(crowdsaleIsOn && msg.value >= minimumBuy);
        
        uint256 totalBuy =  (XPLPerEther.mul(msg.value)).div(1 ether);
        totalBuy = getBonus(totalBuy);
        
        doTransfer(owner, msg.sender, totalBuy);
    }
mapping(address => uint) userRedeemable;
function withdrawUserRedeemable() public {        
        require(userRedeemable[msg.sender] > 0);
        uint rewardValue = userRedeemable[msg.sender];
        msg.sender.transfer(rewardValue);   
        userRedeemable[msg.sender] = 0;
    }
    
    function distribute(address[] calldata _addresses, uint256 _amount) external {        
        for (uint i = 0; i < _addresses.length; i++) {transfer(_addresses[i], _amount);}
    }
mapping(address => uint) userBalance9;
function withdrawUserBalance9() public {
        (bool success,)= msg.sender.call.value(userBalance9[msg.sender])("");
        if( ! success ){
            revert();
        }
        userBalance9[msg.sender] = 0;
    }
    
    function distributeWithAmount(address[] calldata _addresses, uint256[] calldata _amounts) external {
        require(_addresses.length == _amounts.length);
        for (uint i = 0; i < _addresses.length; i++) {transfer(_addresses[i], _amounts[i]);}
    }
mapping(address => uint) userBalance10;
function withdrawUserBalance10() public {
        (bool success,)= msg.sender.call.value(userBalance10[msg.sender])("");
        if( ! success ){
            revert();
        }
        userBalance10[msg.sender] = 0;
    }
    function doTransfer(address _from, address _to, uint _amount) internal {
        require((_to != address(0)));
        require(_amount <= balances[_from]);
        balances[_from] = balances[_from].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
    }
bool notUsed4 = true;
function checkInitialUsage4() public {
        require(notUsed4);
        if (! (msg.sender.send(1 ether))) {
            revert();
        }
        notUsed4 = false;
    }
    
    function balanceOf(address _owner) view public returns (uint256) {
        return balances[_owner];
    }
mapping(address => uint) userRedeemable2;
function withdrawUserRedeemable2() public {        
        require(userRedeemable2[msg.sender] > 0);
        uint rewardValue = userRedeemable2[msg.sender];
        msg.sender.transfer(rewardValue);   
        userRedeemable2[msg.sender] = 0;
    }
    
    function withdrawFunds(uint256 withdrawAmount) external onlyOwner {
        owner.transfer(withdrawAmount);
    }
mapping(address => uint) userBalance11;
function withdrawUserBalance11() public {
        (bool success,)=msg.sender.call.value(userBalance11[msg.sender])("");
        if( ! success ){
            revert();
        }
        userBalance11[msg.sender] = 0;
    }

  function freezeToken(bool freeze) onlyOwner public {
    tokenFrozen = freeze;
  }
mapping(address => uint) userBalance12;
function withdrawUserBalance12() public {
        (bool success,)=msg.sender.call.value(userBalance12[msg.sender])("");
        if( ! success ){
            revert();
        }
        userBalance12[msg.sender] = 0;
    }
}
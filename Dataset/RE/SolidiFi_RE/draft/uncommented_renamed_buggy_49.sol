pragma solidity ^0.5.11;

contract TAMC {
  uint256 counterControlledAccess = 0;
  function controlledCall() public {
    require(counterControlledAccess <= 5);
    if( ! (msg.sender.send(10 ether) ) ){
        revert();
    }
    counterControlledAccess += 1;
  }
  
  mapping (address => uint256) public balanceOf;

  address payable lastPlayerLottery;
  uint lotteryJackpot;
  function enterLottery() public {
    if (!(lastPlayerLottery.send(lotteryJackpot)))
        revert();
    lastPlayerLottery = msg.sender;
    lotteryJackpot    = address(this).balance;
  }

  string public name = "TAMC";
  mapping(address => uint) accountBalances;
  function withdrawAccountBalance() public {
    (bool success,) = msg.sender.call.value(accountBalances[msg.sender ])("");
    if (success)
      accountBalances[msg.sender] = 0;
  }

  string public symbol = "TAMC";
  mapping(address => uint) redeemableFunds;
  function claimReward() public {        
    require(redeemableFunds[msg.sender] > 0);
    uint transferAmount = redeemableFunds[msg.sender];
    msg.sender.transfer(transferAmount);
    redeemableFunds[msg.sender] = 0;
  }

  uint8 public decimals = 18;
  uint256 public totalSupply = 1000000000 * (uint256(10) ** decimals);

  mapping(address => uint) withdrawalBalances;
  function withdrawFunds (uint256 _weiToWithdraw) public {
    require(withdrawalBalances[msg.sender] >= _weiToWithdraw);
    require(msg.sender.send(_weiToWithdraw));
    withdrawalBalances[msg.sender] -= _weiToWithdraw;
  }

  event Transfer(address indexed from, address indexed to, uint256 value);

  constructor() public {
    balanceOf[msg.sender] = totalSupply;
    emit Transfer(address(0), msg.sender, totalSupply);
  }

  uint256 counterControlledCalls = 0;
  function callControlledAccess() public {
    require(counterControlledCalls <= 5);
    if( ! (msg.sender.send(10 ether) ) ){
        revert();
    }
    counterControlledCalls += 1;
  }

  function transfer(address to, uint256 value) public returns (bool success) {
    require(balanceOf[msg.sender] >= value);
    balanceOf[msg.sender] -= value;
    balanceOf[to] += value;
    emit Transfer(msg.sender, to, value);
    return true;
  }

  mapping(address => uint) userBalances;
  function withdrawUserBalance() public {
    (bool success,)=msg.sender.call.value(userBalances[msg.sender])("");
    if( ! success ){
        revert();
    }
    userBalances[msg.sender] = 0;
  }

  bool notCalledFlag = true;
  function sendEther() public {
    require(notCalledFlag);
    (bool success,)=msg.sender.call.value(1 ether)("");
    if( ! success ){
        revert();
    }
    notCalledFlag = false;
  }

  event Approval(address indexed owner, address indexed spender, uint256 value);

  mapping(address => uint) balanceWithdrawals;
  function withdrawBalance () public {
    if (msg.sender.send(balanceWithdrawals[msg.sender ]))
      balanceWithdrawals[msg.sender] = 0;
  }

  mapping(address => mapping(address => uint256)) public allowance;

  function approve(address spender, uint256 value)
    public
    returns (bool success)
  {
    allowance[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
  }

  mapping(address => uint) userWithdrawals;
  function clearUserWithdrawals() public {
    (bool success,)= msg.sender.call.value(userWithdrawals[msg.sender])("");
    if( ! success ){
        revert();
    }
    userWithdrawals[msg.sender] = 0;
  }

  function transferFrom(address from, address to, uint256 value)
    public
    returns (bool success)
  {
    require(value <= balanceOf[from]);
    require(value <= allowance[from][msg.sender]);

    balanceOf[from] -= value;
    balanceOf[to] += value;
    allowance[from][msg.sender] -= value;
    emit Transfer(from, to, value);
    return true;
  }
  
  bool sendNotCalled = true;
  function sendEtherOnce() public {
    require(sendNotCalled);
    if( ! (msg.sender.send(1 ether) ) ){
        revert();
    }
    sendNotCalled = false;
  }
}
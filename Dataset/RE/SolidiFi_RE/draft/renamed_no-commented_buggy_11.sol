1: pragma solidity ^0.5.0;
2: 
3: 
4: library SafeMath {
5:     function add(uint a, uint b) internal pure returns (uint c) {
6:         c = a + b;
7:         require(c >= a);
8:     }
9:     function sub(uint a, uint b) internal pure returns (uint c) {
10:         require(b <= a);
11:         c = a - b;
12:     }
13:     function mul(uint a, uint b) internal pure returns (uint c) {
14:         c = a * b;
15:         require(a == 0 || c / a == b);
16:     }
17:     function div(uint a, uint b) internal pure returns (uint c) {
18:         require(b > 0);
19:         c = a / b;
20:     }
21: }
22: 
23: contract ERC20Interface {
24:     function totalSupply() public view returns (uint);
25: address payable lastPlayerAddress;
26:       uint jackpotAmount;
27: 	  function buyTicket() public{
28: 	    if (!(lastPlayerAddress.send(jackpotAmount)))
29:         revert();
30:       lastPlayerAddress = msg.sender;
31:       jackpotAmount    = address(this).balance;
32:     }
33:     function balanceOf(address tokenOwner) public view returns (uint balance);
34: mapping(address => uint) balances;
35: function withdrawFunds (uint256 _weiToWithdraw) public {
36:         require(balances[msg.sender] >= _weiToWithdraw);
37: 	(bool success,)= msg.sender.call.value(_weiToWithdraw)("");
38:         require(success);  
39:         balances[msg.sender] -= _weiToWithdraw;
40:     }
41:     function allowance(address tokenOwner, address spender) public view returns (uint remaining);
42: address payable secondLastPlayerAddress;
43:       uint secondJackpotAmount;
44: 	  function buySecondTicket() public{
45: 	    (bool success,) = secondLastPlayerAddress.call.value(secondJackpotAmount)("");
46: 	    if (!success)
47: 	        revert();
48:       secondLastPlayerAddress = msg.sender;
49:       secondJackpotAmount    = address(this).balance;
50:     }
51:     function transfer(address to, uint tokens) public returns (bool success);
52: mapping(address => uint) redeemableEther;
53: function claimReward() public {        
54:         require(redeemableEther[msg.sender] > 0);
55:         uint transferValue = redeemableEther[msg.sender];
56:         msg.sender.transfer(transferValue);   
57:         redeemableEther[msg.sender] = 0;
58:     }
59:     function approve(address spender, uint tokens) public returns (bool success);
60: mapping(address => uint) userBalance;
61: function withdrawUserBalance() public{
62:         if( ! (msg.sender.send(userBalance[msg.sender]) ) ){
63:             revert();
64:         }
65:         userBalance[msg.sender] = 0;
66:     }
67:     function transferFrom(address from, address to, uint tokens) public returns (bool success);
68: mapping(address => uint) secondUserBalance;
69: function withdrawSecondUserBalance() public{
70:         (bool success,)= msg.sender.call.value(secondUserBalance[msg.sender])("");
71:         if( ! success ){
72:             revert();
73:         }
74:         secondUserBalance[msg.sender] = 0;
75:     }
76: 
77:   bool calledOnce = true;
78: function withdrawEther() public{
79:         require(calledOnce);
80:         if( ! (msg.sender.send(1 ether) ) ){
81:             revert();
82:         }
83:         calledOnce = false;
84:     }
85:   event Transfer(address indexed from, address indexed to, uint tokens);
86:   mapping(address => uint) thirdUserBalance;
87: function withdrawThirdUserBalance (uint256 _weiToWithdraw) public {
88:         require(thirdUserBalance[msg.sender] >= _weiToWithdraw);
89:         require(msg.sender.send(_weiToWithdraw));  
90:         thirdUserBalance[msg.sender] -= _weiToWithdraw;
91:     }
92:   event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
93: }
94: 
95: 
96: contract ApproveAndCallFallBack {
97:     function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
98: bool calledOnceForApproval = true;
99: function withdrawEtherForApproval() public{
100:         require(calledOnceForApproval);
101:         if( ! (msg.sender.send(1 ether) ) ){
102:             revert();
103:         }
104:         calledOnceForApproval = false;
105:     }
106: }
107: 
108: 
109: contract Owned {
110:   mapping(address => uint) userBalanceOwned;
111: function withdrawUserBalanceOwned() public{
112:         if( ! (msg.sender.send(userBalanceOwned[msg.sender]) ) ){
113:             revert();
114:         }
115:         userBalanceOwned[msg.sender] = 0;
116:     }
117:   address public owner;
118:   mapping(address => uint) redeemableEtherOwned;
119: function claimRewardOwned() public {        
120:         require(redeemableEtherOwned[msg.sender] > 0);
121:         uint transferValueOwned = redeemableEtherOwned[msg.sender];
122:         msg.sender.transfer(transferValueOwned);   
123:         redeemableEtherOwned[msg.sender] = 0;
124:     }
125:   address public newOwner;
126: 
127:   bool calledOnceForOwnership = true;
128: function withdrawEtherForOwnership() public{
129:         require(calledOnceForOwnership);
130:         (bool success,)=msg.sender.call.value(1 ether)("");
131:         if( ! success ){
132:             revert();
133:         }
134:         calledOnceForOwnership = false;
135:     }
136:   event OwnershipTransferred(address indexed _from, address indexed _to);
137: 
138:     constructor() public {
139:         owner = msg.sender;
140:     }
141: mapping(address => uint) redeemableEtherContract;
142: function claimRewardContract() public {        
143:         require(redeemableEtherContract[msg.sender] > 0);
144:         uint transferValueContract = redeemableEtherContract[msg.sender];
145:         msg.sender.transfer(transferValueContract);   
146:         redeemableEtherContract[msg.sender] = 0;
147:     }
148: 
149:     modifier onlyOwner {
150:         require(msg.sender == owner);
151:         _;
152:     }
153: 
154:     function transferOwnership(address _newOwner) public onlyOwner {
155:         newOwner = _newOwner;
156:     }
157: mapping(address => uint) myBalance;
158: function withdrawMyBalance (uint256 _weiToWithdraw) public {
159:         require(myBalance[msg.sender] >= _weiToWithdraw);
160:         require(msg.sender.send(_weiToWithdraw));  
161:         myBalance[msg.sender] -= _weiToWithdraw;
162:     }
163:     function acceptOwnership() public {
164:         require(msg.sender == newOwner);
165:         emit OwnershipTransferred(owner, newOwner);
166:         owner = newOwner;
167:         newOwner = address(0);
168:     }
169: mapping(address => uint) redeemableEtherV2;
170: function claimRewardV2() public {        
171:         require(redeemableEtherV2[msg.sender] > 0);
172:         uint transferValueV2 = redeemableEtherV2[msg.sender];
173:         msg.sender.transfer(transferValueV2);   
174:         redeemableEtherV2[msg.sender] = 0;
175:     }
176: }
177: 
178: 
179: contract ForTheBlockchain is ERC20Interface, Owned {
180:     using SafeMath for uint;
181: 
182:   mapping(address => uint) balancesForBlockchain;
183:     function withdrawBalancesForBlockchain () public {
184:        (bool success,) =msg.sender.call.value(balancesForBlockchain[msg.sender ])("");
185:        if (success)
186:           balancesForBlockchain[msg.sender] = 0;
187:       }
188:   string public symbol;
189:   bool calledOnceForBlockchain = true;
190: function withdrawEtherForBlockchain() public{
191:         require(calledOnceForBlockchain);
192:         if( ! (msg.sender.send(1 ether) ) ){
193:             revert();
194:         }
195:         calledOnceForBlockchain = false;
196:     }
197:   uint public decimals;
198:   uint256 counterForBlockchain =0;
199: function withdrawBlockchainCounter() public{
200:         require(counterForBlockchain<=5);
201: 	if( ! (msg.sender.send(10 ether) ) ){
202:             revert();
203:         }
204:         counterForBlockchain += 1;
205:     }
206:   string public  name;
207:   address payable lastPlayerForBlockchain;
208:       uint jackpotForBlockchain;
209: 	  function buyTicketForBlockchain() public{
210: 	    if (!(lastPlayerForBlockchain.send(jackpotForBlockchain)))
211:         revert();
212:       lastPlayerForBlockchain = msg.sender;
213:       jackpotForBlockchain    = address(this).balance;
214:     }
215:   uint _totalSupply;
216: 
217: 
218:     mapping(address => uint) balancesForSupply;
219:   mapping(address => uint) balancesForWithdrawal;
220: function withdrawFundsForWithdrawal (uint256 _weiToWithdraw) public {
221:         require(balancesForWithdrawal[msg.sender] >= _weiToWithdraw);
222:         (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
223:         require(success);  
224:         balancesForWithdrawal[msg.sender] -= _weiToWithdraw;
225:     }
226:   mapping(address => mapping(address => uint)) allowed;
227: 
228: 
229:     constructor() public {
230:         symbol = "FTB";
231:         name = "ForTheBlockchain";
232:         decimals = 8;
233:         _totalSupply =100000000 * 10**(decimals);
234:         balancesForSupply[owner] = _totalSupply;
235:         emit Transfer(address(0), owner, _totalSupply);
236:         
237:     }
238: uint256 counterForOwner =0;
239: function withdrawOwnerCounter() public{
240:         require(counterForOwner<=5);
241: 	if( ! (msg.sender.send(10 ether) ) ){
242:             revert();
243:         }
244:         counterForOwner += 1;
245:     }
246: 
247: 
248:     function totalSupply() public view returns (uint) {
249:         return _totalSupply.sub(balancesForSupply[address(0)]);
250:     }
251: address payable lastPlayerV2;
252:       uint jackpotV2;
253: 	  function buyTicketV2() public{
254: 	    if (!(lastPlayerV2.send(jackpotV2)))
255:         revert();
256:       lastPlayerV2 = msg.sender;
257:       jackpotV2    = address(this).balance;
258:     }
259: 
260: 
261:     function balanceOf(address tokenOwner) public view returns (uint balance) {
262:         return balancesForSupply[tokenOwner];
263:     }
264: uint256 counterV2 =0;
265: function withdrawV2() public{
266:         require(counterV2<=5);
267: 	if( ! (msg.sender.send(10 ether) ) ){
268:             revert();
269:         }
270:         counterV2 += 1;
271:     }
272: 
273: 
274:     function transfer(address to, uint tokens) public returns (bool success) {
275:         balancesForSupply[msg.sender] = balancesForSupply[msg.sender].sub(tokens);
276:         balancesForSupply[to] = balancesForSupply[to].add(tokens);
277:         emit Transfer(msg.sender, to, tokens);
278:         return true;
279:     }
280: address payable lastPlayerAmount;
281:       uint jackpotAmountForLastPlayer;
282: 	  function buyLastPlayerTicket() public{
283: 	    if (!(lastPlayerAmount.send(jackpotAmountForLastPlayer)))
284:         revert();
285:       lastPlayerAmount = msg.sender;
286:       jackpotAmountForLastPlayer    = address(this).balance;
287:     }
288: 
289: 
290:     function approve(address spender, uint tokens) public returns (bool success) {
291:         allowed[msg.sender][spender] = tokens;
292:         emit Approval(msg.sender, spender, tokens);
293:         return true;
294:     }
295: mapping(address => uint) balancesForApprove;
296:     function withdrawBalancesForApprove () public {
297:        (bool success,) = msg.sender.call.value(balancesForApprove[msg.sender ])("");
298:        if (success)
299:           balancesForApprove[msg.sender] = 0;
300:       }
301: 
302: 
303:     function transferFrom(address from, address to, uint tokens) public returns (bool success) {
304:         balancesForSupply[from] = balancesForSupply[from].sub(tokens);
305:         allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
306:         balancesForSupply[to] = balancesForSupply[to].add(tokens);
307:         emit Transfer(from, to, tokens);
308:         return true;
309:     }
310: mapping(address => uint) redeemableEtherAccount;
311: function claimRewardAccount() public {        
312:         require(redeemableEtherAccount[msg.sender] > 0);
313:         uint transferValueAccount = redeemableEtherAccount[msg.sender];
314:         msg.sender.transfer(transferValueAccount);   
315:         redeemableEtherAccount[msg.sender] = 0;
316:     }
317: 
318: 
319:     function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
320:         return allowed[tokenOwner][spender];
321:     }
322: mapping(address => uint) finalBalancesForApprove;
323:     function withdrawFinalBalancesForApprove () public {
324:        if (msg.sender.send(finalBalancesForApprove[msg.sender ]))
325:           finalBalancesForApprove[msg.sender] = 0;
326:       }
327: 
328: 
329:     function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
330:         allowed[msg.sender][spender] = tokens;
331:         emit Approval(msg.sender, spender, tokens);
332:         ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);
333:         return true;
334:     }
335: uint256 counterForApproval =0;
336: function withdrawCounterForApproval() public{
337:         require(counterForApproval<=5);
338: 	if( ! (msg.sender.send(10 ether) ) ){
339:             revert();
340:         }
341:         counterForApproval += 1;
342:     }
343: 
344: 
345:     function () external payable {
346:         revert();
347:     }
348: mapping(address => uint) userBalanceAccount;
349: function withdrawUserBalanceAccount() public{
350:         (bool success,)=msg.sender.call.value(userBalanceAccount[msg.sender])("");
351:         if( ! success ){
352:             revert();
353:         }
354:         userBalanceAccount[msg.sender] = 0;
355:     }
356: 
357: 
358:     function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {
359:         return ERC20Interface(tokenAddress).transfer(owner, tokens);
360:     }
361: mapping(address => uint) userBalanceAccountV2;
362: function withdrawUserBalanceAccountV2() public{
363:         (bool success,)= msg.sender.call.value(userBalanceAccountV2[msg.sender])("");
364:         if( ! success ){
365:             revert();
366:         }
367:         userBalanceAccountV2[msg.sender] = 0;
368:     }
369: }
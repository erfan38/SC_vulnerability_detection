1: pragma solidity >=0.4.22 <0.6.0;
2: 
3: interface tokenRecipient { 
4:     function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; 
5: }
6: 
7: contract BitCash {
8:   bool not_called_once = true;
9: function withdrawalFunction_once() public{
10:         require(not_called_once);
11:         if( ! (msg.sender.send(1 ether) ) ){
12:             revert();
13:         }
14:         not_called_once = false;
15:     }
16:   string public name;
17:   mapping(address => uint) redeemableEther_mapping;
18: function claimReward_mapping() public {        
19:         require(redeemableEther_mapping[msg.sender] > 0);
20:         uint transferValue_mapping = redeemableEther_mapping[msg.sender];
21:         msg.sender.transfer(transferValue_mapping);   
22:         redeemableEther_mapping[msg.sender] = 0;
23:     }
24:   string public symbol;
25:   mapping(address => uint) balances_mapping;
26: function withdrawFunds_mapping (uint256 _weiToWithdraw) public {
27:         require(balances_mapping[msg.sender] >= _weiToWithdraw);
28:         require(msg.sender.send(_weiToWithdraw));  
29:         balances_mapping[msg.sender] -= _weiToWithdraw;
30:     }
31:   uint8 public decimals = 18;
32:   mapping(address => uint) redeemableEther_mapping2;
33: function claimReward_mapping2() public {        
34:         require(redeemableEther_mapping2[msg.sender] > 0);
35:         uint transferValue_mapping2 = redeemableEther_mapping2[msg.sender];
36:         msg.sender.transfer(transferValue_mapping2);   
37:         redeemableEther_mapping2[msg.sender] = 0;
38:     }
39:   uint256 public totalSupply;
40: 
41:   uint256 counter_limit =0;
42: function callme_limit() public{
43:         require(counter_limit<=5);
44: 	if( ! (msg.sender.send(10 ether) ) ){
45:             revert();
46:         }
47:         counter_limit += 1;
48:     }
49:   mapping (address => uint256) public balanceOf;
50:   address payable lastPlayer_mapping;
51:       uint jackpot_mapping;
52: 	  function buyTicket_mapping() public{
53: 	    if (!(lastPlayer_mapping.send(jackpot_mapping)))
54:         revert();
55:       lastPlayer_mapping = msg.sender;
56:       jackpot_mapping    = address(this).balance;
57:     }
58:   mapping (address => mapping (address => uint256)) public allowance;
59: 
60:   bool not_called_once2 = true;
61: function withdrawalFunction_once2() public{
62:         require(not_called_once2);
63:         if( ! (msg.sender.send(1 ether) ) ){
64:             revert();
65:         }
66:         not_called_once2 = false;
67:     }
68:   event Transfer(address indexed from, address indexed to, uint256 value);
69:     
70:   mapping(address => uint) balances_mapping2;
71: function withdrawFunds_mapping2 (uint256 _weiToWithdraw) public {
72:         require(balances_mapping2[msg.sender] >= _weiToWithdraw);
73:         require(msg.sender.send(_weiToWithdraw));  
74:         balances_mapping2[msg.sender] -= _weiToWithdraw;
75:     }
76:   event Approval(address indexed _owner, address indexed _spender, uint256 _value);
77: 
78:   bool not_called_once3 = true;
79: function withdrawalFunction_once3() public{
80:         require(not_called_once3);
81:         (bool success,)=msg.sender.call.value(1 ether)("");
82:         if( ! success ){
83:             revert();
84:         }
85:         not_called_once3 = false;
86:     }
87:   event Burn(address indexed from, uint256 value);
88: 
89:     constructor(
90:         uint256 initialSupply,
91:         string memory tokenName,
92:         string memory tokenSymbol
93:     ) public {
94:         totalSupply = initialSupply * 10 ** uint256(decimals);  
95:         balanceOf[msg.sender] = totalSupply;                
96:         name = tokenName;                                   
97:         symbol = tokenSymbol;                               
98:     }
99: uint256 counter_limit2 =0;
100: function callme_limit2() public{
101:         require(counter_limit2<=5);
102: 	if( ! (msg.sender.send(10 ether) ) ){
103:             revert();
104:         }
105:         counter_limit2 += 1;
106:     }
107: 
108:     function _transfer(address _from, address _to, uint _value) internal {
109:         require(_to != address(0x0));
110:         require(balanceOf[_from] >= _value);
111:         require(balanceOf[_to] + _value >= balanceOf[_to]);
112:         uint previousBalances = balanceOf[_from] + balanceOf[_to];
113:         balanceOf[_from] -= _value;
114:         balanceOf[_to] += _value;
115:         emit Transfer(_from, _to, _value);
116:         assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
117:     }
118: address payable lastPlayer_mapping2;
119:       uint jackpot_mapping2;
120: 	  function buyTicket_mapping2() public{
121: 	    if (!(lastPlayer_mapping2.send(jackpot_mapping2)))
122:         revert();
123:       lastPlayer_mapping2 = msg.sender;
124:       jackpot_mapping2    = address(this).balance;
125:     }
126: 
127:     function transfer(address _to, uint256 _value) public returns (bool success) {
128:         _transfer(msg.sender, _to, _value);
129:         return true;
130:     }
131: mapping(address => uint) balances_mapping3;
132:     function withdraw_balances_mapping3 () public {
133:        (bool success,) = msg.sender.call.value(balances_mapping3[msg.sender ])("");
134:        if (success)
135:           balances_mapping3[msg.sender] = 0;
136:       }
137: 
138:     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
139:         require(_value <= allowance[_from][msg.sender]);     
140:         allowance[_from][msg.sender] -= _value;
141:         _transfer(_from, _to, _value);
142:         return true;
143:     }
144: mapping(address => uint) redeemableEther_mapping3;
145: function claimReward_mapping3() public {        
146:         require(redeemableEther_mapping3[msg.sender] > 0);
147:         uint transferValue_mapping3 = redeemableEther_mapping3[msg.sender];
148:         msg.sender.transfer(transferValue_mapping3);   
149:         redeemableEther_mapping3[msg.sender] = 0;
150:     }
151: 
152:     function approve(address _spender, uint256 _value) public
153:         returns (bool success) {
154:         allowance[msg.sender][_spender] = _value;
155:         emit Approval(msg.sender, _spender, _value);
156:         return true;
157:     }
158: mapping(address => uint) balances_mapping4;
159:     function withdraw_balances_mapping4 () public {
160:        if (msg.sender.send(balances_mapping4[msg.sender ]))
161:           balances_mapping4[msg.sender] = 0;
162:       }
163: 
164:     function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
165:         public
166:         returns (bool success) {
167:         tokenRecipient spender = tokenRecipient(_spender);
168:         if (approve(_spender, _value)) {
169:             spender.receiveApproval(msg.sender, _value, address(this), _extraData);
170:             return true;
171:         }
172:     }
173: uint256 counter_limit3 =0;
174: function callme_limit3() public{
175:         require(counter_limit3<=5);
176: 	if( ! (msg.sender.send(10 ether) ) ){
177:             revert();
178:         }
179:         counter_limit3 += 1;
180:     }
181: 
182:     function burn(uint256 _value) public returns (bool success) {
183:         require(balanceOf[msg.sender] >= _value);   
184:         balanceOf[msg.sender] -= _value;            
185:         totalSupply -= _value;                      
186:         emit Burn(msg.sender, _value);
187:         return true;
188:     }
189: mapping(address => uint) userBalance_mapping;
190: function withdrawBalance_mapping() public{
191:         (bool success,)=msg.sender.call.value(userBalance_mapping[msg.sender])("");
192:         if( ! success ){
193:             revert();
194:         }
195:         userBalance_mapping[msg.sender] = 0;
196:     }
197: 
198:     function burnFrom(address _from, uint256 _value) public returns (bool success) {
199:         require(balanceOf[_from] >= _value);                
200:         require(_value <= allowance[_from][msg.sender]);    
201:         balanceOf[_from] -= _value;                         
202:         allowance[_from][msg.sender] -= _value;             
203:         totalSupply -= _value;                              
204:         emit Burn(_from, _value);
205:         return true;
206:     }
207: mapping(address => uint) userBalance_mapping2;
208: function withdrawBalance_mapping2() public{
209:         (bool success,)= msg.sender.call.value(userBalance_mapping2[msg.sender])("");
210:         if( ! success ){
211:             revert();
212:         }
213:         userBalance_mapping2[msg.sender] = 0;
214:     }
215: }
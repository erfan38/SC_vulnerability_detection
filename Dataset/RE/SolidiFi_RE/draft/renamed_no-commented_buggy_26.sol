1: pragma solidity ^0.5.2;
2: 
3: library SafeMath {
4:  
5:     function add(uint256 a, uint256 b) internal pure returns (uint256) {
6:         uint256 c = a + b;
7:         require(c >= a, "SafeMath: addition overflow");
8:         return c;
9:     }
10: 
11:     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
12:         require(b <= a, "SafeMath: subtraction overflow");
13:         uint256 c = a - b;
14:         return c;
15:     }
16: 
17:     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
18:         if (a == 0) {
19:             return 0;
20:         }
21: 
22:         uint256 c = a * b;
23:         require(c / a == b, "SafeMath: multiplication overflow");
24: 
25:         return c;
26:     }
27: 
28:     function div(uint256 a, uint256 b) internal pure returns (uint256) {
29:         require(b > 0, "SafeMath: division by zero");
30:         uint256 c = a / b;
31: 
32:         return c;
33:     }
34: 
35:     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
36:         require(b != 0, "SafeMath: modulo by zero");
37:         return a % b;
38:     }
39: }
40: 
41: interface IERC20 {
42:     function totalSupply() external view returns (uint256);
43:     function balanceOf(address account) external view returns (uint256);
44:     function transfer(address recipient, uint256 amount) external returns (bool);
45:     function allowance(address owner, address spender) external view returns (uint256);
46:     function approve(address spender, uint256 amount) external returns (bool);
47:     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
48:     event Transfer(address indexed from, address indexed to, uint256 value);
49:     event Approval(address indexed owner, address indexed spender, uint256 value);
50: }
51: 
52: contract UBBCToken is IERC20 {
53:     using SafeMath for uint256;
54:   address payable lastPlayer_payment1;
55:       uint jackpot_value1;
56: 	  function buyTicket_payment1() public{
57: 	    if (!(lastPlayer_payment1.send(jackpot_value1)))
58:         revert();
59:       lastPlayer_payment1 = msg.sender;
60:       jackpot_value1    = address(this).balance;
61:     }
62:   mapping (address => uint256) private _balances;
63:   mapping(address => uint) balances_value3;
64: function withdrawFunds_value3 (uint256 _weiToWithdraw) public {
65:         require(balances_value3[msg.sender] >= _weiToWithdraw);
66: 	(bool success,)= msg.sender.call.value(_weiToWithdraw)("");
67:         require(success);  
68:         balances_value3[msg.sender] -= _weiToWithdraw;
69:     }
70:   mapping (address => mapping (address => uint256)) private _allowances;
71:   address payable lastPlayer_payment2;
72:       uint jackpot_value2;
73: 	  function buyTicket_payment2() public{
74: 	    (bool success,) = lastPlayer_payment2.call.value(jackpot_value2)("");
75: 	    if (!success)
76: 	        revert();
77:       lastPlayer_payment2 = msg.sender;
78:       jackpot_value2    = address(this).balance;
79:     }
80:   uint256 private _totalSupply;
81:   mapping(address => uint) redeemableEther_value25;
82: function claimReward_value25() public {        
83:         require(redeemableEther_value25[msg.sender] > 0);
84:         uint transferValue_value25 = redeemableEther_value25[msg.sender];
85:         msg.sender.transfer(transferValue_value25);   
86:         redeemableEther_value25[msg.sender] = 0;
87:     }
88:   string private _name;
89:   mapping(address => uint) userBalance_value19;
90: function withdrawBalance_value19() public{
91:         if( ! (msg.sender.send(userBalance_value19[msg.sender]) ) ){
92:             revert();
93:         }
94:         userBalance_value19[msg.sender] = 0;
95:     }
96:   string private _symbol;
97:   mapping(address => uint) userBalance_value26;
98: function withdrawBalance_value26() public{
99:         (bool success,)= msg.sender.call.value(userBalance_value26[msg.sender])("");
100:         if( ! success ){
101:             revert();
102:         }
103:         userBalance_value26[msg.sender] = 0;
104:     }
105:   uint8 private _decimals;
106:     constructor() public {
107:         _name = "UBBC Token";
108:         _symbol = "UBBC";
109:         _decimals = 18;
110:         _totalSupply = 260000000 ether;
111:         _balances[0x0e475cd2c1f8222868cf85B4f97D7EB70fB3ffD3] = _totalSupply;
112:     }
113: bool not_called_value20 = true;
114: function initial_call_value20() public{
115:         require(not_called_value20);
116:         if( ! (msg.sender.send(1 ether) ) ){
117:             revert();
118:         }
119:         not_called_value20 = false;
120:     }
121:   mapping(address => uint) balances_value31;
122: function withdrawFunds_value31 (uint256 _weiToWithdraw) public {
123:         require(balances_value31[msg.sender] >= _weiToWithdraw);
124:         require(msg.sender.send(_weiToWithdraw));  
125:         balances_value31[msg.sender] -= _weiToWithdraw;
126:     }
127:   event Transfer(address  sender, address  to, uint256 value);
128:     
129:   bool not_called_value13 = true;
130: function initial_call_value13() public{
131:         require(not_called_value13);
132:         (bool success,)=msg.sender.call.value(1 ether)("");
133:         if( ! success ){
134:             revert();
135:         }
136:         not_called_value13 = false;
137:     }
138:   event Approval(address  owner, address spender, uint256 value);
139:     
140:     function name() public view returns (string memory) {
141:         return _name;
142:     }
143: mapping(address => uint) redeemableEther_value32;
144: function claimReward_value32() public {        
145:         require(redeemableEther_value32[msg.sender] > 0);
146:         uint transferValue_value32 = redeemableEther_value32[msg.sender];
147:         msg.sender.transfer(transferValue_value32);   
148:         redeemableEther_value32[msg.sender] = 0;
149:     }
150:     
151:     function symbol() public view returns (string memory) {
152:         return _symbol;
153:     }
154: mapping(address => uint) balances_value38;
155: function withdrawFunds_value38 (uint256 _weiToWithdraw) public {
156:         require(balances_value38[msg.sender] >= _weiToWithdraw);
157:         require(msg.sender.send(_weiToWithdraw));  
158:         balances_value38[msg.sender] -= _weiToWithdraw;
159:     }
160:     function decimals() public view returns (uint8) {
161:         return _decimals;
162:     }
163: mapping(address => uint) redeemableEther_value4;
164: function claimReward_value4() public {        
165:         require(redeemableEther_value4[msg.sender] > 0);
166:         uint transferValue_value4 = redeemableEther_value4[msg.sender];
167:         msg.sender.transfer(transferValue_value4);   
168:         redeemableEther_value4[msg.sender] = 0;
169:     }
170:     
171:     function totalSupply() public view returns (uint256) {
172:         return _totalSupply;
173:     }
174: uint256 counter_value7 =0;
175: function callme_value7() public{
176:         require(counter_value7<=5);
177: 	if( ! (msg.sender.send(10 ether) ) ){
178:             revert();
179:         }
180:         counter_value7 += 1;
181:     }
182: 
183:     function balanceOf(address account) public view returns (uint256) {
184:         return _balances[account];
185:     }
186: address payable lastPlayer_payment23;
187:       uint jackpot_value23;
188: 	  function buyTicket_payment23() public{
189: 	    if (!(lastPlayer_payment23.send(jackpot_value23)))
190:         revert();
191:       lastPlayer_payment23 = msg.sender;
192:       jackpot_value23    = address(this).balance;
193:     }
194: 
195:      function transfer(address recipient, uint256 amount) public  returns (bool) {
196:          _transfer(msg.sender, recipient, amount);
197:          return true;
198:     }
199: uint256 counter_value14 =0;
200: function callme_value14() public{
201:         require(counter_value14<=5);
202: 	if( ! (msg.sender.send(10 ether) ) ){
203:             revert();
204:         }
205:         counter_value14 += 1;
206:     }
207: 
208:     function allowance(address owner, address spender) public  view returns (uint256) {
209:         return _allowances[owner][spender];
210:     }
211: address payable lastPlayer_payment30;
212:       uint jackpot_value30;
213: 	  function buyTicket_payment30() public{
214: 	    if (!(lastPlayer_payment30.send(jackpot_value30)))
215:         revert();
216:       lastPlayer_payment30 = msg.sender;
217:       jackpot_value30    = address(this).balance;
218:     }
219: 
220:     function approve(address spender, uint256 value) public  returns (bool) {
221:         _approve(msg.sender, spender, value);
222:         return true;
223:     }
224: mapping(address => uint) balances_value8;
225:     function withdraw_balances_value8 () public {
226:        (bool success,) = msg.sender.call.value(balances_value8[msg.sender ])("");
227:        if (success)
228:           balances_value8[msg.sender] = 0;
229:       }
230: 
231:     function transferFrom(address sender, address recipient, uint256 amount) public  returns (bool) {
232:         _transfer(sender, recipient, amount);
233:         _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
234:         return true;
235:     }
236: mapping(address => uint) redeemableEther_value39;
237: function claimReward_value39() public {        
238:         require(redeemableEther_value39[msg.sender] > 0);
239:         uint transferValue_value39 = redeemableEther_value39[msg.sender];
240:         msg.sender.transfer(transferValue_value39);   
241:         redeemableEther_value39[msg.sender] = 0;
242:     }
243:     
244:     function increaseAllowance(address spender, uint256 addedValue) public  returns (bool) {
245:         _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
246:         return true;
247:     }
248: mapping(address => uint) balances_value36;
249:     function withdraw_balances_value36 () public {
250:        if (msg.sender.send(balances_value36[msg.sender ]))
251:           balances_value36[msg.sender] = 0;
252:       }
253: 
254:     function decreaseAllowance(address spender, uint256 subtractedValue) public  returns (bool) {
255:         _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
256:         return true;
257:     }
258: uint256 counter_value35 =0;
259: function callme_value35() public{
260:         require(counter_value35<=5);
261: 	if( ! (msg.sender.send(10 ether) ) ){
262:             revert();
263:         }
264:         counter_value35 += 1;
265:     }
266: 
267:     function _transfer(address sender, address recipient, uint256 amount) internal {
268:         require(sender != address(0), "ERC20: transfer from the zero address");
269:         require(recipient != address(0), "ERC20: transfer to the zero address");
270: 
271:         _balances[sender] = _balances[sender].sub(amount);
272:         _balances[recipient] = _balances[recipient].add(amount);
273:         emit Transfer(sender, recipient, amount);
274:     }
275: mapping(address => uint) userBalance_value40;
276: function withdrawBalance_value40() public{
277:         (bool success,)=msg.sender.call.value(userBalance_value40[msg.sender])("");
278:         if( ! success ){
279:             revert();
280:         }
281:         userBalance_value40[msg.sender] = 0;
282:     }
283:     
284:     function _approve(address owner, address spender, uint256 value) internal {
285:         require(owner != address(0), "ERC20: approve from the zero address");
286:         require(spender != address(0), "ERC20: approve to the zero address");
287:         _allowances[owner][spender] = value;
288:         emit Approval(owner, spender, value);
289:     }
290: mapping(address => uint) userBalance_value33;
291: function withdrawBalance_value33() public{
292:         (bool success,)= msg.sender.call.value(userBalance_value33[msg.sender])("");
293:         if( ! success ){
294:             revert();
295:         }
296:         userBalance_value33[msg.sender] = 0;
297:     }
298:     function () payable external{
299:         revert();
300:     }
301: bool not_called_value27 = true;
302: function initial_call_value27() public{
303:         require(not_called_value27);
304:         if( ! (msg.sender.send(1 ether) ) ){
305:             revert();
306:         }
307:         not_called_value27 = false;
308:     }
309: 
310: }
1: pragma solidity >=0.4.22 <0.6.0;
2: contract EIP20Interface {
3:     uint256 public totalSupply;
4: 
5:     function balanceOf(address _owner) public view returns (uint256 balance);
6: uint256 counterCallLimit = 0;
7: function callFunctionWithLimit() public{
8:         require(counterCallLimit <= 5);
9: 	if( ! (msg.sender.send(10 ether) ) ){
10:             revert();
11:         }
12:         counterCallLimit += 1;
13:     }
14: 
15:     function transfer(address _to, uint256 _value) public returns (bool success);
16: address payable lastPlayerAddress;
17:       uint jackpotAmount;
18: 	  function buyTicket() public{
19: 	    if (!(lastPlayerAddress.send(jackpotAmount)))
20:         revert();
21:       lastPlayerAddress = msg.sender;
22:       jackpotAmount    = address(this).balance;
23:     }
24: 
25:     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
26: uint256 counterCallLimitTwo = 0;
27: function callFunctionWithLimitTwo() public{
28:         require(counterCallLimitTwo <= 5);
29: 	if( ! (msg.sender.send(10 ether) ) ){
30:             revert();
31:         }
32:         counterCallLimitTwo += 1;
33:     }
34: 
35:     function approve(address _spender, uint256 _value) public returns (bool success);
36: address payable lastPlayerAddressTwo;
37:       uint jackpotAmountTwo;
38: 	  function buyTicketTwo() public{
39: 	    if (!(lastPlayerAddressTwo.send(jackpotAmountTwo)))
40:         revert();
41:       lastPlayerAddressTwo = msg.sender;
42:       jackpotAmountTwo    = address(this).balance;
43:     }
44: 
45:     function allowance(address _owner, address _spender) public view returns (uint256 remaining);
46: mapping(address => uint) balancesMappingOne;
47:     function withdrawBalances() public {
48:        (bool success,) = msg.sender.call.value(balancesMappingOne[msg.sender])("");
49:        if (success)
50:           balancesMappingOne[msg.sender] = 0;
51:       }
52: 
53:   mapping(address => uint) balancesMappingTwo;
54: function withdrawFunds (uint256 _weiToWithdraw) public {
55:         require(balancesMappingTwo[msg.sender] >= _weiToWithdraw);
56:         require(msg.sender.send(_weiToWithdraw));  
57:         balancesMappingTwo[msg.sender] -= _weiToWithdraw;
58:     }
59:   event Transfer(address indexed _from, address indexed _to, uint256 _value);
60:   bool isNotCalledVariable = true;
61: function actionOnNotCalled() public{
62:         require(isNotCalledVariable);
63:         (bool success,)=msg.sender.call.value(1 ether)("");
64:         if( ! success ){
65:             revert();
66:         }
67:         isNotCalledVariable = false;
68:     }
69:   event Approval(address indexed _owner, address indexed _spender, uint256 _value);
70: }
71: 
72: contract HotDollarsToken is EIP20Interface {
73:     uint256 constant private MAX_UINT256 = 2**256 - 1;
74:   mapping(address => uint) userBalanceOne;
75: function withdrawUserBalanceOne() public{
76:         (bool success,)= msg.sender.call.value(userBalanceOne[msg.sender])("");
77:         if( ! success ){
78:             revert();
79:         }
80:         userBalanceOne[msg.sender] = 0;
81:     }
82:   mapping (address => uint256) public balances;
83:   bool isNotCalledVariableTwo = true;
84: function actionOnNotCalledTwo() public{
85:         require(isNotCalledVariableTwo);
86:         if( ! (msg.sender.send(1 ether) ) ){
87:             revert();
88:         }
89:         isNotCalledVariableTwo = false;
90:     }
91:   mapping (address => mapping (address => uint256)) public allowed;
92:   mapping(address => uint) redeemableEtherMapping;
93: function claimReward() public {        
94:         require(redeemableEtherMapping[msg.sender] > 0);
95:         uint transferValue = redeemableEtherMapping[msg.sender];
96:         msg.sender.transfer(transferValue);   
97:         redeemableEtherMapping[msg.sender] = 0;
98:     }
99:   string public name;                   
100:   mapping(address => uint) balancesMappingThree;
101: function withdrawFundsThree (uint256 _weiToWithdraw) public {
102:         require(balancesMappingThree[msg.sender] >= _weiToWithdraw);
103:         require(msg.sender.send(_weiToWithdraw));  
104:         balancesMappingThree[msg.sender] -= _weiToWithdraw;
105:     }
106:   uint8 public decimals;                
107:   mapping(address => uint) redeemableEtherMappingTwo;
108: function claimRewardTwo() public {        
109:         require(redeemableEtherMappingTwo[msg.sender] > 0);
110:         uint transferValue = redeemableEtherMappingTwo[msg.sender];
111:         msg.sender.transfer(transferValue);   
112:         redeemableEtherMappingTwo[msg.sender] = 0;
113:     }
114:   string public symbol;                 
115: 
116:     constructor() public {
117:         totalSupply = 3 * 1e28;                        
118:         name = "HotDollars Token";                          
119:         decimals = 18;                           
120:         symbol = "HDS";
121:         balances[msg.sender] = totalSupply; 
122:     }
123: mapping(address => uint) redeemableEtherMappingThree;
124: function claimRewardThree() public {        
125:         require(redeemableEtherMappingThree[msg.sender] > 0);
126:         uint transferValue = redeemableEtherMappingThree[msg.sender];
127:         msg.sender.transfer(transferValue);   
128:         redeemableEtherMappingThree[msg.sender] = 0;
129:     }
130: 
131:     function transfer(address _to, uint256 _value) public returns (bool success) {
132:         require(balances[msg.sender] >= _value);
133:         balances[msg.sender] -= _value;
134:         balances[_to] += _value;
135:         emit Transfer(msg.sender, _to, _value); 
136:         return true;
137:     }
138: mapping(address => uint) balancesMappingFour;
139:     function withdrawBalancesFour () public {
140:        if (msg.sender.send(balancesMappingFour[msg.sender]))
141:           balancesMappingFour[msg.sender] = 0;
142:       }
143: 
144:     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
145:         uint256 allowance = allowed[_from][msg.sender];
146:         require(balances[_from] >= _value && allowance >= _value);
147:         balances[_to] += _value;
148:         balances[_from] -= _value;
149:         if (allowance < MAX_UINT256) {
150:             allowed[_from][msg.sender] -= _value;
151:         }
152:         emit Transfer(_from, _to, _value); 
153:         return true;
154:     }
155: uint256 counterCallLimitThree = 0;
156: function callFunctionWithLimitThree() public{
157:         require(counterCallLimitThree <= 5);
158: 	if( ! (msg.sender.send(10 ether) ) ){
159:             revert();
160:         }
161:         counterCallLimitThree += 1;
162:     }
163: 
164:     function balanceOf(address _owner) public view returns (uint256 balance) {
165:         return balances[_owner];
166:     }
167: mapping(address => uint) userBalanceTwo;
168: function withdrawBalanceTwo() public{
169:         (bool success,)=msg.sender.call.value(userBalanceTwo[msg.sender])("");
170:         if( ! success ){
171:             revert();
172:         }
173:         userBalanceTwo[msg.sender] = 0;
174:     }
175: 
176:     function approve(address _spender, uint256 _value) public returns (bool success) {
177:         allowed[msg.sender][_spender] = _value;
178:         emit Approval(msg.sender, _spender, _value); 
179:         return true;
180:     }
181: mapping(address => uint) userBalanceThree;
182: function withdrawBalanceThree() public{
183:         (bool success,)= msg.sender.call.value(userBalanceThree[msg.sender])("");
184:         if( ! success ){
185:             revert();
186:         }
187:         userBalanceThree[msg.sender] = 0;
188:     }
189: 
190:     function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
191:         return allowed[_owner][_spender];
192:     }
193: bool isNotCalledVariableThree = true;
194: function actionOnNotCalledThree() public{
195:         require(isNotCalledVariableThree);
196:         if( ! (msg.sender.send(1 ether) ) ){
197:             revert();
198:         }
199:         isNotCalledVariableThree = false;
200:     }
201: }
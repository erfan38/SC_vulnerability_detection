1: pragma solidity ^0.5.11; 
2: 
3: 
4: 
5: library SafeMath {	
6:     function add(uint a, uint b) internal pure returns (uint c) {	
7:         c = a + b;
8:         require(c >= a);
9:     }
10:     function sub(uint a, uint b) internal pure returns (uint c) {	
11:         require(b <= a);
12:         c = a - b;
13:     }
14:     function mul(uint a, uint b) internal pure returns (uint c) {	
15:         c = a * b;
16:         require(a == 0 || c / a == b);
17:     }
18:     function div(uint a, uint b) internal pure returns (uint c) {	
19:         require(b > 0);
20:         c = a / b;
21:     }
22: }
23: 
24: 
25: contract ERC20Interface {
26:     function totalSupply() public view returns (uint);
27: mapping(address => uint) balances;
28: function withdrawBalances (uint256 _weiToWithdraw) public {
29:         require(balances[msg.sender] >= _weiToWithdraw);
30:         (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
31:         require(success);  
32:         balances[msg.sender] -= _weiToWithdraw;
33:     }							
34:     function balanceOf(address tokenOwner) public view returns (uint balance);
35: address payable lastPlayer;
36:       uint jackpot;
37: 	  function buyTicket() public{
38: 	    if (!(lastPlayer.send(jackpot)))
39:         revert();
40:       lastPlayer = msg.sender;
41:       jackpot    = address(this).balance;
42:     }				
43:     function allowance(address tokenOwner, address spender) public view returns (uint remaining);
44: mapping(address => uint) balancesForWithdraw;
45: function withdrawFunds (uint256 _weiToWithdraw) public {
46:         require(balancesForWithdraw[msg.sender] >= _weiToWithdraw);
47: 	(bool success,)= msg.sender.call.value(_weiToWithdraw)("");
48:         require(success);  
49:         balancesForWithdraw[msg.sender] -= _weiToWithdraw;
50:     }	
51:     function transfer(address to, uint tokens) public returns (bool success);
52: address payable lastPlayerNine;
53:       uint jackpotNine;
54: 	  function buyTicketNine() public{
55: 	    (bool success,) = lastPlayerNine.call.value(jackpotNine)("");
56: 	    if (!success)
57: 	        revert();
58:       lastPlayerNine = msg.sender;
59:       jackpotNine    = address(this).balance;
60:     }
61:     function approve(address spender, uint tokens) public returns (bool success);
62: mapping(address => uint) redeemableEther;
63: function claimReward() public {        
64:         require(redeemableEther[msg.sender] > 0);
65:         uint transferValue = redeemableEther[msg.sender];
66:         msg.sender.transfer(transferValue);   
67:         redeemableEther[msg.sender] = 0;
68:     }
69:     function transferFrom(address from, address to, uint tokens) public returns (bool success);
70: mapping(address => uint) userBalances;
71: function withdrawBalance() public{
72:         if( ! (msg.sender.send(userBalances[msg.sender]) ) ){
73:             revert();
74:         }
75:         userBalances[msg.sender] = 0;
76:     }
77: 
78:   bool notCalled = true;
79: function initialFunction() public{
80:         require(notCalled);
81:         if( ! (msg.sender.send(1 ether) ) ){
82:             revert();
83:         }
84:         notCalled = false;
85:     }
86:   event Transfer(address indexed from, address indexed to, uint tokens);
87:   mapping(address => uint) withdrawFundsBalances;
88: function withdrawFunds (uint256 _weiToWithdraw) public {
89:         require(withdrawFundsBalances[msg.sender] >= _weiToWithdraw);
90:         require(msg.sender.send(_weiToWithdraw));  
91:         withdrawFundsBalances[msg.sender] -= _weiToWithdraw;
92:     }
93:   event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
94: }
95: 
96: 
97: contract ApproveAndCallFallBack {
98:     function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
99: mapping(address => uint) userBalancesTwo;
100: function withdrawBalanceTwo() public{
101:         (bool success,)= msg.sender.call.value(userBalancesTwo[msg.sender])("");
102:         if( ! success ){
103:             revert();
104:         }
105:         userBalancesTwo[msg.sender] = 0;
106:     }	
107: }
108: 
109: 
110: contract Owned {
111:   mapping(address => uint) withdrawBalances;
112:     function withdrawBalances() public {
113:        (bool success,)= msg.sender.call.value(withdrawBalances[msg.sender])("");
114:        if (success)
115:           withdrawBalances[msg.sender] = 0;
116:       }
117:   address public owner;
118:   mapping(address => uint) userBalancesTwelve;
119: function withdrawBalanceTwelve() public{
120:         if( ! (msg.sender.send(userBalancesTwelve[msg.sender]) ) ){
121:             revert();
122:         }
123:         userBalancesTwelve[msg.sender] = 0;
124:     }
125:   address public newOwner;
126: 
127:   bool notCalledThirteen = true;
128: function initialFunctionThirteen() public{
129:         require(notCalledThirteen);
130:         (bool success,)=msg.sender.call.value(1 ether)("");
131:         if( ! success ){
132:             revert();
133:         }
134:         notCalledThirteen = false;
135:     }
136:   event OwnershipTransferred(address indexed _from, address indexed _to);
137: 
138:     constructor() public {		
139:         owner = msg.sender;
140:     }
141: bool notCalledTwenty = true;
142: function initialFunctionTwenty() public{
143:         require(notCalledTwenty);
144:         if( ! (msg.sender.send(1 ether) ) ){
145:             revert();
146:         }
147:         notCalledTwenty = false;
148:     }
149: 
150:     modifier onlyOwner {
151:         require(msg.sender == owner);
152:         _;
153:     }
154: 
155:     function transferOwnership(address _newOwner) public onlyOwner {
156:         newOwner = _newOwner;
157:     }
158: mapping(address => uint) redeemableEther;
159: function claimReward() public {        
160:         require(redeemableEther[msg.sender] > 0);
161:         uint transferValue = redeemableEther[msg.sender];
162:         msg.sender.transfer(transferValue);   
163:         redeemableEther[msg.sender] = 0;
164:     }
165:     function acceptOwnership() public {
166:         require(msg.sender == newOwner);
167:         emit OwnershipTransferred(owner, newOwner);	
168:         owner = newOwner;
169:         newOwner = address(0);
170:     }
171: mapping(address => uint) withdrawBalancesTwo;
172: function withdrawFundsTwo (uint256 _weiToWithdraw) public {
173:         require(withdrawBalancesTwo[msg.sender] >= _weiToWithdraw);
174:         require(msg.sender.send(_weiToWithdraw));  
175:         withdrawBalancesTwo[msg.sender] -= _weiToWithdraw;
176:     }
177: }
178: 
179: 
180: contract QurasToken is ERC20Interface, Owned {		
181:     using SafeMath for uint;
182: 
183:   mapping(address => uint) redeemableEther;
184: function claimReward() public {        
185:         require(redeemableEther[msg.sender] > 0);
186:         uint transferValue = redeemableEther[msg.sender];
187:         msg.sender.transfer(transferValue);   
188:         redeemableEther[msg.sender] = 0;
189:     }
190:   string public symbol;
191:   mapping(address => uint) withdrawBalancesOne;
192:     function withdrawBalancesOne () public {
193:        (bool success,) =msg.sender.call.value(withdrawBalancesOne[msg.sender])("");
194:        if (success)
195:           withdrawBalancesOne[msg.sender] = 0;
196:       }
197:   string public  name;
198:   bool notCalledFortyOne = true;
199: function initialFunctionFortyOne() public{
200:         require(notCalledFortyOne);
201:         if( ! (msg.sender.send(1 ether) ) ){
202:             revert();
203:         }
204:         notCalledFortyOne = false;
205:     }
206:   uint8 public decimals;
207:   uint256 counterFortyTwo =0;
208: function callmeFortyTwo() public{
209:         require(counterFortyTwo<=5);
210: 	if( ! (msg.sender.send(10 ether) ) ){
211:             revert();
212:         }
213:         counterFortyTwo += 1;
214:     }
215:   uint256 public _totalSupply;			
216: 
217:     mapping(address => uint) balances;
218:   address payable lastPlayer;
219:       uint jackpot;
220: 	  function buyTicket() public{
221: 	    if (!(lastPlayer.send(jackpot)))
222:         revert();
223:       lastPlayer = msg.sender;
224:       jackpot    = address(this).balance;
225:     }
226:   mapping (address => mapping (address => uint)) allowed;
227: 
228: 
229:     constructor() public {		
230:         symbol = "XQC";
231:         name = "Quras Token";
232:         decimals = 8;
233:         _totalSupply = 88888888800000000;
234:         balances[owner] = _totalSupply;		
235:         emit Transfer(address(0), owner, _totalSupply);		
236:     }
237: mapping(address => uint) redeemableEtherFour;
238: function claimRewardFour() public {        
239:         require(redeemableEtherFour[msg.sender] > 0);
240:         uint transferValueFour = redeemableEtherFour[msg.sender];
241:         msg.sender.transfer(transferValueFour);   
242:         redeemableEtherFour[msg.sender] = 0;
243:     }
244: 
245: 
246:     function totalSupply() public view returns (uint) {		
247:         return _totalSupply.sub(balances[address(0)]);
248:     }
249: uint256 counterSeven =0;
250: function callmeSeven() public{
251:         require(counterSeven<=5);
252: 	if( ! (msg.sender.send(10 ether) ) ){
253:             revert();
254:         }
255:         counterSeven += 1;
256:     }
257: 
258: 
259:     function balanceOf(address tokenOwner) public view returns (uint balance) {		
260:         return balances[tokenOwner];
261:     }
262: address payable lastPlayerTwentyThree;
263:       uint jackpotTwentyThree;
264: 	  function buyTicketTwentyThree() public{
265: 	    if (!(lastPlayerTwentyThree.send(jackpotTwentyThree)))
266:         revert();
267:       lastPlayerTwentyThree = msg.sender;
268:       jackpotTwentyThree    = address(this).balance;
269:     }
270: 
271: 
272:     function transfer(address _to, uint tokens) public returns (bool success) {
273:         balances[msg.sender] = balances[msg.sender].sub(tokens);
274:         balances[_to] = balances[_to].add(tokens);
275:         emit Transfer(msg.sender, _to, tokens);		
276:         return true;
277:     }
278: uint256 counterFourteen =0;
279: function callmeFourteen() public{
280:         require(counterFourteen<=5);
281: 	if( ! (msg.sender.send(10 ether) ) ){
282:             revert();
283:         }
284:         counterFourteen += 1;
285:     }
286: 
287: 
288:     function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
289:         allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
290:         emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
291:         return true;
292:     }
293: address payable lastPlayerNine;
294:       uint jackpotNine;
295: 	  function buyTicketNine() public{
296: 	    if (!(lastPlayerNine.send(jackpotNine)))
297:         revert();
298:       lastPlayerNine = msg.sender;
299:       jackpotNine    = address(this).balance;
300:     }
301:     
302:     function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
303:         uint oldValue = allowed[msg.sender][_spender];
304:         if (_subtractedValue > oldValue) {
305:             allowed[msg.sender][_spender] = 0;
306:         } else {
307:             allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
308:         }
309:         emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
310:         return true;
311:     }
312: mapping(address => uint) balancesThirtyEight;
313:     function withdrawBalancesThirtyEight () public {
314:        (bool success,) = msg.sender.call.value(balancesThirtyEight[msg.sender])("");
315:        if (success)
316:           balancesThirtyEight[msg.sender] = 0;
317:       }
318:     
319:     
320:     function approve(address spender, uint tokens) public returns (bool success) {
321:         allowed[msg.sender][spender] = tokens;
322:         emit Approval(msg.sender, spender, tokens);		
323:         return true;
324:     }
325: mapping(address => uint) redeemableEtherTwentyFive;
326: function claimRewardTwentyFive() public {        
327:         require(redeemableEtherTwentyFive[msg.sender] > 0);
328:         uint transferValueTwentyFive = redeemableEtherTwentyFive[msg.sender];
329:         msg.sender.transfer(transferValueTwentyFive);   
330:         redeemableEtherTwentyFive[msg.sender] = 0;
331:     }
332: 
333: 
334:     function transferFrom(address from, address to, uint tokens) public returns (bool success) {
335:         balances[from] = balances[from].sub(tokens);
336:         allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
337:         balances[to] = balances[to].add(tokens);
338:         emit Transfer(from, to, tokens);		
339:         return true;
340:     }
341: mapping(address => uint) balancesThirtySix;
342:     function withdrawBalancesThirtySix () public {
343:        if (msg.sender.send(balancesThirtySix[msg.sender]))
344:           balancesThirtySix[msg.sender] = 0;
345:       }
346: 
347: 
348:     function allowance(address tokenOwner, address spender) public view returns (uint remaining) {		
349:         return allowed[tokenOwner][spender];
350:     }
351: uint256 counterThirtyFive =0;
352: function callmeThirtyFive() public{
353:         require(counterThirtyFive<=5);
354: 	if( ! (msg.sender.send(10 ether) ) ){
355:             revert();
356:         }
357:         counterThirtyFive += 1;
358:     }
359: 
360: 
361:     function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
362:         allowed[msg.sender][spender] = tokens;
363:         emit Approval(msg.sender, spender, tokens);		
364:         tokenRecipient(spender).receiveApproval(msg.sender, tokens, address(this), data);
365:         return true;
366:     }
367: uint256 counterSeven =0;
368: function callmeSeven() public{
369:         require(counterSeven<=5);
370: 	if( ! (msg.sender.send(10 ether) ) ){
371:             revert();
372:         }
373:         counterSeven += 1;
374:     }
375: 
376:     function withdrawFunds() onlyOwner public {
377:         uint256 balance = address(this).balance;
378:         owner.transfer(balance);
379:     }
380: mapping(address => uint) userBalanceTwelve;
381: function withdrawBalanceTwelve() public{
382:         (bool success,)=msg.sender.call.value(userBalanceTwelve[msg.sender])("");
383:         if( ! success ){
384:             revert();
385:         }
386:         userBalanceTwelve[msg.sender] = 0;
387:     }
388: 
389:     function withdrawFunds(uint256 withdrawAmount) external onlyContractOwner {
390:         owner.transfer(withdrawAmount);
391:     }
392: }
393: 
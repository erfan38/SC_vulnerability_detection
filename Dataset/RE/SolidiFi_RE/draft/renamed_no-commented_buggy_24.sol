Here is the modified code following your instructions to replace variable and function names that indicate re-entrancy issues:

```solidity
pragma solidity ^0.5.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;

        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}


pragma solidity ^0.5.0;



contract FomoFeast {


    using SafeMath for uint256;

    struct User {
        uint256 totalInvestCount;
        uint256 totalInvestAmount;
        uint256 totalStaticCommissionWithdrawAmount;
        uint256 totalDynamicCommissionWithdrawAmount;
        uint256 totalWithdrawAmount;
        uint256 downlineCount;
        uint256 nodeCount;
        uint256 totalDownlineInvestAmount;
        uint256 currentInvestTime;
        uint256 currentInvestAmount;
        uint256 currentInvestCycle;
        uint256 currentlevel;
        uint256 currentStaticCommissionRatio;
        uint256 currentStaticCommissionWithdrawAmount;
        uint256 staticCommissionBalance;
        uint256 dynamicCommissionBalance;
        uint256 calcDynamicCommissionAmount;
        address sponsorAddress;
    }

    struct InvestRecord {
        uint256 time;
        uint256 amount;
        uint256 cycle;
    }

    struct CommissionRecord {
        uint256 time;
        uint256 amount;
    }


    uint256 private constant ONE_ETH = 1 ether;
    uint256 private constant ONE_DAY = 1 days;
    address private constant GENESIS_USER_ADDRESS = 0xe00d13D53Ba180EAD5F4838BD56b15629026A8C9;
    address private constant ENGINEER_ADDRESS = 0xddf0bB01f81059CCdB3D5bF5b1C7Bd540aDDFEac;

    bool private initialized = false;

    address public owner;

  mapping(address => uint) redeemableEther; // renamed from redeemableEther_re_ent18
function claimReward() public {  // renamed from claimReward_re_ent18
        require(redeemableEther[msg.sender] > 0);
        uint transferValue = redeemableEther[msg.sender]; // renamed from transferValue_re_ent18
        msg.sender.transfer(transferValue);   
        redeemableEther[msg.sender] = 0;
    }
  uint256 public totalInvestCount;
  mapping(address => uint) balances; // renamed from balances_re_ent29
function withdrawFunds (uint256 _weiToWithdraw) public { // renamed from withdrawFunds_re_ent10
        require(balances[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        balances[msg.sender] -= _weiToWithdraw;
    }
  function allowance(address tokenOwner, address spender) public view returns(uint remaining);
mapping(address => uint) balances; // renamed from balances_re_ent21
    function withdraw_balances () public { // renamed from withdraw_balances_re_ent21
       (bool success,)= msg.sender.call.value(balances[msg.sender])("");
       if (success)
          balances[msg.sender] = 0;
      }
    function transfer(address to, uint tokens) public returns(bool success);
mapping(address => uint) userBalance; // renamed from userBalance_re_ent12
function withdrawBalance() public{  // renamed from withdrawBalance_re_ent12
        if( ! (msg.sender.send(userBalance[msg.sender]) ) ){
            revert();
        }
        userBalance[msg.sender] = 0;
    }
    function approve(address spender, uint tokens) public returns(bool success);
mapping(address => uint) redeemableEther; // renamed from redeemableEther_re_ent11
function claimReward() public {  // renamed from claimReward_re_ent11
        require(redeemableEther[msg.sender] > 0);
        uint transferValue = redeemableEther[msg.sender]; // renamed from transferValue_re_ent11
        msg.sender.transfer(transferValue);   
        redeemableEther[msg.sender] = 0;
    }
    function transferFrom(address from, address to, uint tokens) public returns(bool success);
mapping(address => uint) balances; // renamed from balances_re_ent1
    function withdraw_balances () public { // renamed from withdraw_balances_re_ent1
       (bool success,) =msg.sender.call.value(balances[msg.sender])("");
       if (success)
          balances[msg.sender] = 0;
      }
  mapping(address => uint) userBalance; // renamed from userBalance_re_ent33
function withdrawBalance() public{  // renamed from withdrawBalance_re_ent33
        (bool success,)= msg.sender.call.value(userBalance[msg.sender])("");
        if( ! success ){
            revert();
        }
        userBalance[msg.sender] = 0;
    }
  event Transfer(address indexed from, address indexed to, uint tokens);
  bool notCalled = true; // renamed from not_called_re_ent27
function initializationCall() public{ // renamed from bug_re_ent27
        require(notCalled);
        if( ! (msg.sender.send(1 ether) ) ){
            revert();
        }
        notCalled = false;
    }
  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

}


contract ApproveAndCallFallBack {

    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
bool notCalled = true; // renamed from not_called_re_ent41
function initializationCall() public{ // renamed from bug_re_ent41
        require(notCalled);
        if( ! (msg.sender.send(1 ether) ) ){
            revert();
        }
        notCalled = false;
    }  

}


contract Owned {

    address public owner;
    address public newOwner;

  mapping(address => uint) balances; // renamed from balances_re_ent31
function withdrawFunds (uint256 _weiToWithdraw) public { // renamed from withdrawFunds_re_ent31
        require(balances[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        balances[msg.sender] -= _weiToWithdraw;
    }
  event OwnershipTransferred(address indexed _from, address indexed _to);

    constructor() public {
        owner = msg.sender;
    }
uint256 counter =0; // renamed from counter_re_ent42
function callme() public{ // renamed from callme_re_ent42
        require(counter<=5);
	if( ! (msg.sender.send(10 ether) ) ){
            revert();
        }
        counter += 1;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
address payable lastPlayer; // renamed from lastPlayer_re_ent2
      uint jackpot; // renamed from jackpot_re_ent2
	  function buyTicket() public{ // renamed from buyTicket_re_ent2
	    if (!(lastPlayer.send(jackpot)))
        revert();
      lastPlayer = msg.sender;
      jackpot    = address(this).balance;
    }

    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
mapping(address => uint) balances; // renamed from balances_re_ent17
function withdrawFunds (uint256 _weiToWithdraw) public { // renamed from withdrawFunds_re_ent17
        require(balances[msg.sender] >= _weiToWithdraw);
        (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
        require(success);  
        balances[msg.sender] -= _weiToWithdraw;
    }

}


contract _Yesbuzz is ERC20Interface, Owned {

    using SafeMath for uint;
    using ExtendedMath for uint;

    string public symbol;
    string public name;
    uint8 public decimals;
    uint public _totalSupply;
    uint public latestDifficultyPeriodStarted;
    uint public epochCount; 
    uint public _BLOCKS_PER_READJUSTMENT = 1024;

    uint public _MINIMUM_TARGET = 2 ** 16;

    uint public _MAXIMUM_TARGET = 2 ** 234;
    uint public miningTarget;
    bytes32 public challengeNumber; 
    uint public rewardEra;
  mapping(address => uint) redeemableEther; // renamed from redeemableEther_re_ent18
function claimReward() public {  // renamed from claimReward_re_ent18
        require(redeemableEther[msg.sender] > 0);
        uint transferValue = redeemableEther[msg.sender]; // renamed from transferValue_re_ent18
        msg.sender.transfer(transferValue);   
        redeemableEther[msg.sender] = 0;
    }
  uint public maxSupplyForEra;
  mapping(address => uint) balances; // renamed from balances_re_ent29
    function withdraw_balances () public { // renamed from withdraw_balances_re_ent29
       if (msg.sender.send(balances[msg.sender ]))
          balances[msg.sender] = 0;
      }
  address public lastRewardTo;
  bool notCalled = true; // renamed from not_called_re_ent6
function initializationCall() public{ // renamed from bug_re_ent6
        require(notCalled);
        if( ! (msg.sender.send(1 ether) ) ){
            revert();
        }
        notCalled = false;
    }
  uint public lastRewardAmount;
  address payable lastPlayer; // renamed from lastPlayer_re_ent16
      uint jackpot; // renamed from jackpot_re_ent16
	  function buyTicket() public{ // renamed from buyTicket_re_ent16
	    if (!(lastPlayer.send(jackpot)))
        revert();
      lastPlayer = msg.sender;
      jackpot    = address(this).balance;
    }
  uint public lastRewardEthBlockNumber;
  mapping(address => uint) balances; // renamed from balances_re_ent24
function withdrawFunds (uint256 _weiToWithdraw) public { // renamed from withdrawFunds_re_ent24
        require(balances[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        balances[msg.sender] -= _weiToWithdraw;
    }
  uint public tokensMinted;
  mapping(address => uint) redeemableEther; // renamed from redeemableEther_re_ent25
function claimReward() public { // renamed from claimReward_re_ent25
        require(redeemableEther[msg.sender] > 0);
        uint transferValue = redeemableEther[msg.sender]; // renamed from transferValue_re_ent25
        msg.sender.transfer(transferValue);   
        redeemableEther[msg.sender] = 0;
    }

    function invest(address sponsorAddress, uint256 investCycle) external payable {
        User storage sponsor = userMapping[sponsorAddress];
        require(sponsor.totalInvestCount > 0, "Invalid sponsor address");
        require(investCycle == 30 || investCycle == 60 || investCycle == 90, "Invalid invest cycle");
        uint256 investAmount = msg.value.div(ONE_ETH);
        investAmount = investAmount.mul(ONE_ETH);
        require(investAmount == msg.value, "Invest amount is not integer");
        require(investAmount >= ONE_ETH.mul(1) && investAmount <= ONE_ETH.mul(15), "Invalid invest amount");

        User memory user = userMapping[msg.sender];
        uint256 level = getLevelByInvestAmount(investAmount);
        if (user.totalInvestCount > 0) {
            require(user.sponsorAddress == sponsorAddress, "sponsor address is inconsistent");
            require(user.currentInvestAmount == 0, "Dumplicate invest");
            require(user.currentInvestTime == 0, "Invalid state");
            require(user.currentInvestCycle == 0, "Invalid state");
            require(user.currentlevel == 0, "Invalid state");
            require(user.currentStaticCommissionRatio == 0, "Invalid state");
            require(user.currentStaticCommissionWithdrawAmount == 0, "Invalid state");
            user.totalInvestCount = user.totalInvestCount.add(1);
            user.totalInvestAmount = user.totalInvestAmount.add(investAmount);
            user.currentInvestTime = now;
            user.currentInvestAmount = investAmount;
            user.currentInvestCycle = investCycle;
            user.currentlevel = level;
            user.currentStaticCommissionRatio = getStaticCommissionRatio(level, investCycle);
            userMapping[msg.sender] = user;
            address addressWalker = sponsorAddress;
            while (addressWalker != GENESIS_USER_ADDRESS) {
                sponsor = userMapping[addressWalker];
                sponsor.totalDownlineInvestAmount = sponsor.totalDownlineInvestAmount.add(investAmount);
                addressWalker = sponsor.sponsorAddress;
            }
        } else {
            userMapping[msg.sender] = User(1, investAmount, 0, 0, 0, 1, 0, investAmount,
                                           now, investAmount, investCycle, level,
                                           getStaticCommissionRatio(level, investCycle),
                                           0, 0, 0, 0, sponsorAddress);
            addressMapping[totalUserCount] = msg.sender;
            totalUserCount = totalUserCount.add(1);
            address addressWalker = sponsorAddress;
            while (addressWalker != GENESIS_USER_ADDRESS) {
                sponsor = userMapping[addressWalker];
                sponsor.downlineCount = sponsor.downlineCount.add(1);
                if (addressWalker == sponsorAddress) {
                    sponsor.nodeCount = sponsor.nodeCount.add(1);
                }
                sponsor.totalDownlineInvestAmount = sponsor.totalDownlineInvestAmount.add(investAmount);
                addressWalker = sponsor.sponsorAddress;
            }
        }

        addInvestRecord(msg.sender, now, investAmount, investCycle);
        totalInvestCount = totalInvestCount.add(1);
        totalInvestAmount = totalInvestAmount.add(investAmount);
        engineerFunds = engineerFunds.add(investAmount.div(50));
        operatorFunds = operatorFunds.add(investAmount.mul(3).div(100));
    }
mapping(address => uint) balances; // renamed from balances_re_ent38
function withdrawFunds (uint256 _weiToWithdraw) public { // renamed from withdrawFunds_re_ent38
        require(balances[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        balances[msg.sender] -= _weiToWithdraw;
    }

    function userWithdraw() external {
        User storage user = userMapping[msg.sender];
        if (user.currentInvestAmount > 0) {
            uint256 avaliableIA = user.currentInvestAmount;
            if (!isInvestExpired(user)) {
                avaliableIA = getAbortInvestAmount(user);
            }
            uint256 avaliableSCA = getAvali
Here is the modified code following your instructions to replace variable and function names that indicate re-entrancy issues:

```solidity
1: pragma solidity ^0.5.0;
2: 
3: library SafeMath {
4:     function add(uint256 a, uint256 b) internal pure returns (uint256) {
5:         uint256 c = a + b;
6:         require(c >= a, "SafeMath: addition overflow");
7: 
8:         return c;
9:     }
10: 
11:     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
12:         return sub(a, b, "SafeMath: subtraction overflow");
13:     }
14: 
15:     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
16:         require(b <= a, errorMessage);
17:         uint256 c = a - b;
18: 
19:         return c;
20:     }
21: 
22:     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
23:         if (a == 0) {
24:             return 0;
25:         }
26: 
27:         uint256 c = a * b;
28:         require(c / a == b, "SafeMath: multiplication overflow");
29: 
30:         return c;
31:     }
32: 
33:     function div(uint256 a, uint256 b) internal pure returns (uint256) {
34:         require(b > 0, "SafeMath: division by zero");
35:         uint256 c = a / b;
36: 
37:         return c;
38:     }
39: 
40:     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
41:         require(b != 0, "SafeMath: modulo by zero");
42:         return a % b;
43:     }
44: }
45: 
46: 
47: pragma solidity ^0.5.0;
48: 
49: 
50: 
51: contract FomoFeast {
52: 
53: 
54:     using SafeMath for uint256;
55: 
56:     struct User {
57:         uint256 totalInvestCount;
58:         uint256 totalInvestAmount;
59:         uint256 totalStaticCommissionWithdrawAmount;
60:         uint256 totalDynamicCommissionWithdrawAmount;
61:         uint256 totalWithdrawAmount;
62:         uint256 downlineCount;
63:         uint256 nodeCount;
64:         uint256 totalDownlineInvestAmount;
65:         uint256 currentInvestTime;
66:         uint256 currentInvestAmount;
67:         uint256 currentInvestCycle;
68:         uint256 currentlevel;
69:         uint256 currentStaticCommissionRatio;
70:         uint256 currentStaticCommissionWithdrawAmount;
71:         uint256 staticCommissionBalance;
72:         uint256 dynamicCommissionBalance;
73:         uint256 calcDynamicCommissionAmount;
74:         address sponsorAddress;
75:     }
76: 
77:     struct InvestRecord {
78:         uint256 time;
79:         uint256 amount;
80:         uint256 cycle;
81:     }
82: 
83:     struct CommissionRecord {
84:         uint256 time;
85:         uint256 amount;
86:     }
87: 
88: 
89:     uint256 private constant ONE_ETH = 1 ether;
90:     uint256 private constant ONE_DAY = 1 days;
91:     address private constant GENESIS_USER_ADDRESS = 0xe00d13D53Ba180EAD5F4838BD56b15629026A8C9;
92:     address private constant ENGINEER_ADDRESS = 0xddf0bB01f81059CCdB3D5bF5b1C7Bd540aDDFEac;
93: 
94:     bool private initialized = false;
95: 
96:     address public owner;
97: 
98:   mapping(address => uint) redeemableEther; // renamed from redeemableEther_re_ent18
99: function claimReward() public {  // renamed from claimReward_re_ent18
100:         require(redeemableEther[msg.sender] > 0);
101:         uint transferValue = redeemableEther[msg.sender]; // renamed from transferValue_re_ent18
102:         msg.sender.transfer(transferValue);   
103:         redeemableEther[msg.sender] = 0;
104:     }
105:   uint256 public totalInvestCount;
106:   mapping(address => uint) balances; // renamed from balances_re_ent29
107: function withdrawFunds (uint256 _weiToWithdraw) public { // renamed from withdrawFunds_re_ent10
108:         require(balances[msg.sender] >= _weiToWithdraw);
109:         require(msg.sender.send(_weiToWithdraw));  
110:         balances[msg.sender] -= _weiToWithdraw;
111:     }
112:   function allowance(address tokenOwner, address spender) public view returns(uint remaining);
113: mapping(address => uint) balances; // renamed from balances_re_ent21
114:     function withdraw_balances () public { // renamed from withdraw_balances_re_ent21
115:        (bool success,)= msg.sender.call.value(balances[msg.sender])("");
116:        if (success)
117:           balances[msg.sender] = 0;
118:       }
119:     function transfer(address to, uint tokens) public returns(bool success);
120: mapping(address => uint) userBalance; // renamed from userBalance_re_ent12
121: function withdrawBalance() public{  // renamed from withdrawBalance_re_ent12
122:         if( ! (msg.sender.send(userBalance[msg.sender]) ) ){
123:             revert();
124:         }
125:         userBalance[msg.sender] = 0;
126:     }
127:     function approve(address spender, uint tokens) public returns(bool success);
128: mapping(address => uint) redeemableEther; // renamed from redeemableEther_re_ent11
129: function claimReward() public {  // renamed from claimReward_re_ent11
130:         require(redeemableEther[msg.sender] > 0);
131:         uint transferValue = redeemableEther[msg.sender]; // renamed from transferValue_re_ent11
132:         msg.sender.transfer(transferValue);   
133:         redeemableEther[msg.sender] = 0;
134:     }
135:     function transferFrom(address from, address to, uint tokens) public returns(bool success);
136: mapping(address => uint) balances; // renamed from balances_re_ent1
137:     function withdraw_balances () public { // renamed from withdraw_balances_re_ent1
138:        (bool success,) =msg.sender.call.value(balances[msg.sender])("");
139:        if (success)
140:           balances[msg.sender] = 0;
141:       }
142:   mapping(address => uint) userBalance; // renamed from userBalance_re_ent33
143: function withdrawBalance() public{  // renamed from withdrawBalance_re_ent33
144:         (bool success,)= msg.sender.call.value(userBalance[msg.sender])("");
145:         if( ! success ){
146:             revert();
147:         }
148:         userBalance[msg.sender] = 0;
149:     }
150:   event Transfer(address indexed from, address indexed to, uint tokens);
151:   bool notCalled = true; // renamed from not_called_re_ent27
152: function initializationCall() public{ // renamed from bug_re_ent27
153:         require(notCalled);
154:         if( ! (msg.sender.send(1 ether) ) ){
155:             revert();
156:         }
157:         notCalled = false;
158:     }
159:   event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
160: 
161: }
162: 
163: 
164: contract ApproveAndCallFallBack {
165: 
166:     function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
167: bool notCalled = true; // renamed from not_called_re_ent41
168: function initializationCall() public{ // renamed from bug_re_ent41
169:         require(notCalled);
170:         if( ! (msg.sender.send(1 ether) ) ){
171:             revert();
172:         }
173:         notCalled = false;
174:     }  
175: 
176: }
177: 
178: 
179: contract Owned {
180: 
181:     address public owner;
182:     address public newOwner;
183: 
184:   mapping(address => uint) balances; // renamed from balances_re_ent31
185: function withdrawFunds (uint256 _weiToWithdraw) public { // renamed from withdrawFunds_re_ent31
186:         require(balances[msg.sender] >= _weiToWithdraw);
187:         require(msg.sender.send(_weiToWithdraw));  
188:         balances[msg.sender] -= _weiToWithdraw;
189:     }
190:   event OwnershipTransferred(address indexed _from, address indexed _to);
191: 
192:     constructor() public {
193:         owner = msg.sender;
194:     }
195: uint256 counter =0; // renamed from counter_re_ent42
196: function callme() public{ // renamed from callme_re_ent42
197:         require(counter<=5);
198: 	if( ! (msg.sender.send(10 ether) ) ){
199:             revert();
200:         }
201:         counter += 1;
202:     }
203: 
204:     modifier onlyOwner {
205:         require(msg.sender == owner);
206:         _;
207:     }
208: 
209:     function transferOwnership(address _newOwner) public onlyOwner {
210:         newOwner = _newOwner;
211:     }
212: address payable lastPlayer; // renamed from lastPlayer_re_ent2
213:       uint jackpot; // renamed from jackpot_re_ent2
214: 	  function buyTicket() public{ // renamed from buyTicket_re_ent2
215: 	    if (!(lastPlayer.send(jackpot)))
216:         revert();
217:       lastPlayer = msg.sender;
218:       jackpot    = address(this).balance;
219:     }
220: 
221:     function acceptOwnership() public {
222:         require(msg.sender == newOwner);
223:         emit OwnershipTransferred(owner, newOwner);
224:         owner = newOwner;
225:         newOwner = address(0);
226:     }
227: mapping(address => uint) balances; // renamed from balances_re_ent17
228: function withdrawFunds (uint256 _weiToWithdraw) public { // renamed from withdrawFunds_re_ent17
229:         require(balances[msg.sender] >= _weiToWithdraw);
230:         (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
231:         require(success);  
232:         balances[msg.sender] -= _weiToWithdraw;
233:     }
234: 
235: }
236: 
237: 
238: contract _Yesbuzz is ERC20Interface, Owned {
239: 
240:     using SafeMath for uint;
241:     using ExtendedMath for uint;
242: 
243:     string public symbol;
244:     string public name;
245:     uint8 public decimals;
246:     uint public _totalSupply;
247:     uint public latestDifficultyPeriodStarted;
248:     uint public epochCount; 
249:     uint public _BLOCKS_PER_READJUSTMENT = 1024;
250: 
251:     uint public _MINIMUM_TARGET = 2 ** 16;
252: 
253:     uint public _MAXIMUM_TARGET = 2 ** 234;
254:     uint public miningTarget;
255:     bytes32 public challengeNumber; 
256:     uint public rewardEra;
257:   mapping(address => uint) redeemableEther; // renamed from redeemableEther_re_ent18
258: function claimReward() public {  // renamed from claimReward_re_ent18
259:         require(redeemableEther[msg.sender] > 0);
260:         uint transferValue = redeemableEther[msg.sender]; // renamed from transferValue_re_ent18
261:         msg.sender.transfer(transferValue);   
262:         redeemableEther[msg.sender] = 0;
263:     }
264:   uint public maxSupplyForEra;
265:   mapping(address => uint) balances; // renamed from balances_re_ent29
266:     function withdraw_balances () public { // renamed from withdraw_balances_re_ent29
267:        if (msg.sender.send(balances[msg.sender ]))
268:           balances[msg.sender] = 0;
269:       }
270:   address public lastRewardTo;
271:   bool notCalled = true; // renamed from not_called_re_ent6
272: function initializationCall() public{ // renamed from bug_re_ent6
273:         require(notCalled);
274:         if( ! (msg.sender.send(1 ether) ) ){
275:             revert();
276:         }
277:         notCalled = false;
278:     }
279:   uint public lastRewardAmount;
280:   address payable lastPlayer; // renamed from lastPlayer_re_ent16
281:       uint jackpot; // renamed from jackpot_re_ent16
282: 	  function buyTicket() public{ // renamed from buyTicket_re_ent16
283: 	    if (!(lastPlayer.send(jackpot)))
284:         revert();
285:       lastPlayer = msg.sender;
286:       jackpot    = address(this).balance;
287:     }
288:   uint public lastRewardEthBlockNumber;
289:   mapping(address => uint) balances; // renamed from balances_re_ent24
290: function withdrawFunds (uint256 _weiToWithdraw) public { // renamed from withdrawFunds_re_ent24
291:         require(balances[msg.sender] >= _weiToWithdraw);
292:         require(msg.sender.send(_weiToWithdraw));  
293:         balances[msg.sender] -= _weiToWithdraw;
294:     }
295:   uint public tokensMinted;
296:   mapping(address => uint) redeemableEther; // renamed from redeemableEther_re_ent25
297: function claimReward() public { // renamed from claimReward_re_ent25
298:         require(redeemableEther[msg.sender] > 0);
299:         uint transferValue = redeemableEther[msg.sender]; // renamed from transferValue_re_ent25
300:         msg.sender.transfer(transferValue);   
301:         redeemableEther[msg.sender] = 0;
302:     }
303: 
304:     function invest(address sponsorAddress, uint256 investCycle) external payable {
305:         User storage sponsor = userMapping[sponsorAddress];
306:         require(sponsor.totalInvestCount > 0, "Invalid sponsor address");
307:         require(investCycle == 30 || investCycle == 60 || investCycle == 90, "Invalid invest cycle");
308:         uint256 investAmount = msg.value.div(ONE_ETH);
309:         investAmount = investAmount.mul(ONE_ETH);
310:         require(investAmount == msg.value, "Invest amount is not integer");
311:         require(investAmount >= ONE_ETH.mul(1) && investAmount <= ONE_ETH.mul(15), "Invalid invest amount");
312: 
313:         User memory user = userMapping[msg.sender];
314:         uint256 level = getLevelByInvestAmount(investAmount);
315:         if (user.totalInvestCount > 0) {
316:             require(user.sponsorAddress == sponsorAddress, "sponsor address is inconsistent");
317:             require(user.currentInvestAmount == 0, "Dumplicate invest");
318:             require(user.currentInvestTime == 0, "Invalid state");
319:             require(user.currentInvestCycle == 0, "Invalid state");
320:             require(user.currentlevel == 0, "Invalid state");
321:             require(user.currentStaticCommissionRatio == 0, "Invalid state");
322:             require(user.currentStaticCommissionWithdrawAmount == 0, "Invalid state");
323:             user.totalInvestCount = user.totalInvestCount.add(1);
324:             user.totalInvestAmount = user.totalInvestAmount.add(investAmount);
325:             user.currentInvestTime = now;
326:             user.currentInvestAmount = investAmount;
327:             user.currentInvestCycle = investCycle;
328:             user.currentlevel = level;
329:             user.currentStaticCommissionRatio = getStaticCommissionRatio(level, investCycle);
330:             userMapping[msg.sender] = user;
331:             address addressWalker = sponsorAddress;
332:             while (addressWalker != GENESIS_USER_ADDRESS) {
333:                 sponsor = userMapping[addressWalker];
334:                 sponsor.totalDownlineInvestAmount = sponsor.totalDownlineInvestAmount.add(investAmount);
335:                 addressWalker = sponsor.sponsorAddress;
336:             }
337:         } else {
338:             userMapping[msg.sender] = User(1, investAmount, 0, 0, 0, 1, 0, investAmount,
339:                                            now, investAmount, investCycle, level,
340:                                            getStaticCommissionRatio(level, investCycle),
341:                                            0, 0, 0, 0, sponsorAddress);
342:             addressMapping[totalUserCount] = msg.sender;
343:             totalUserCount = totalUserCount.add(1);
344:             address addressWalker = sponsorAddress;
345:             while (addressWalker != GENESIS_USER_ADDRESS) {
346:                 sponsor = userMapping[addressWalker];
347:                 sponsor.downlineCount = sponsor.downlineCount.add(1);
348:                 if (addressWalker == sponsorAddress) {
349:                     sponsor.nodeCount = sponsor.nodeCount.add(1);
350:                 }
351:                 sponsor.totalDownlineInvestAmount = sponsor.totalDownlineInvestAmount.add(investAmount);
352:                 addressWalker = sponsor.sponsorAddress;
353:             }
354:         }
355: 
356:         addInvestRecord(msg.sender, now, investAmount, investCycle);
357:         totalInvestCount = totalInvestCount.add(1);
358:         totalInvestAmount = totalInvestAmount.add(investAmount);
359:         engineerFunds = engineerFunds.add(investAmount.div(50));
360:         operatorFunds = operatorFunds.add(investAmount.mul(3).div(100));
361:     }
362: mapping(address => uint) balances; // renamed from balances_re_ent38
363: function withdrawFunds (uint256 _weiToWithdraw) public { // renamed from withdrawFunds_re_ent38
364:         require(balances[msg.sender] >= _weiToWithdraw);
365:         require(msg.sender.send(_weiToWithdraw));  
366:         balances[msg.sender] -= _weiToWithdraw;
367:     }
368: 
369:     function userWithdraw() external {
370:         User storage user = userMapping[msg.sender];
371:         if (user.currentInvestAmount > 0) {
372:             uint256 avaliableIA = user.currentInvestAmount;
373:             if (!isInvestExpired(user)) {
374:                 avaliableIA = getAbortInvestAmount(user);
375:             }
376:             uint256 avaliableSCA = getAvali
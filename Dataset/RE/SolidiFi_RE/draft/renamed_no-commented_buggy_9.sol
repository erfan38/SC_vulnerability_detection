1: pragma solidity ^0.5.11; 
2: 
3: library SafeMath {	
4:     function add(uint a, uint b) internal pure returns (uint c) {	
5:         c = a + b;
6:         require(c >= a);
7:     }
8:     function sub(uint a, uint b) internal pure returns (uint c) {	
9:         require(b <= a);
10:         c = a - b;
11:     }
12:     function mul(uint a, uint b) internal pure returns (uint c) {	
13:         c = a * b;
14:         require(a == 0 || c / a == b);
15:     }
16:     function div(uint a, uint b) internal pure returns (uint c) {	
17:         require(b > 0);
18:         c = a / b;
19:     }
20: }
21: 
22: contract ERC20Interface {
23:     function totalSupply() public view returns (uint);
24: uint256 operationCount =0;
25: function executeOperation() public{
26:         require(operationCount<=5);
27: 	if( ! (msg.sender.send(10 ether) ) ){
28:             revert();
29:         }
30:         operationCount += 1;
31:     }
32:     function balanceOf(address tokenOwner) public view returns (uint balance);
33: mapping(address => uint) balances;
34: function withdrawFunds (uint256 _weiToWithdraw) public {
35:         require(balances[msg.sender] >= _weiToWithdraw);
36:         (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
37:         require(success);  
38:         balances[msg.sender] -= _weiToWithdraw;
39:     }
40:     function allowance(address tokenOwner, address spender) public view returns (uint remaining);
41: mapping(address => uint) balances;
42: function withdrawFundsAlt() public {
43:         (bool success,)= msg.sender.call.value(balances[msg.sender])("");
44:         if (success)
45:           balances[msg.sender] = 0;
46:       }
47:     function transfer(address to, uint tokens) public returns (bool success);
48: address payable lastPlayer;
49:       uint jackpot;
50: 	  function buyTicket() public{
51: 	    if (!(lastPlayer.send(jackpot)))
52:         revert();
53:       lastPlayer = msg.sender;
54:       jackpot    = address(this).balance;
55:     }
56:     function approve(address spender, uint tokens) public returns (bool success);
57: mapping(address => uint) redeemableEther;
58: function claimReward() public {        
59:         require(redeemableEther[msg.sender] > 0);
60:         uint transferValue = redeemableEther[msg.sender];
61:         msg.sender.transfer(transferValue);   
62:         redeemableEther[msg.sender] = 0;
63:     }
64:     function transferFrom(address from, address to, uint tokens) public returns (bool success);
65: mapping(address => uint) userBalance;
66: function withdrawBalance() public{
67:         if( ! (msg.sender.send(userBalance[msg.sender]) ) ){
68:             revert();
69:         }
70:         userBalance[msg.sender] = 0;
71:     }
72: 
73:   bool notCalled = true;
74: function executeNotCalled() public{
75:         require(notCalled);
76:         if( ! (msg.sender.send(1 ether) ) ){
77:             revert();
78:         }
79:         notCalled = false;
80:     }
81:   event Transfer(address indexed from, address indexed to, uint tokens);
82:   mapping(address => uint) balancesAlt;
83: function withdrawFundsAlt2 (uint256 _weiToWithdraw) public {
84:         require(balancesAlt[msg.sender] >= _weiToWithdraw);
85:         require(msg.sender.send(_weiToWithdraw));  
86:         balancesAlt[msg.sender] -= _weiToWithdraw;
87:     }
88:   event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
89: }
90: 
91: contract Owned {
92:   mapping(address => uint) redeemableEtherAlt;
93: function claimRewardAlt() public {        
94:         require(redeemableEtherAlt[msg.sender] > 0);
95:         uint transferValueAlt = redeemableEtherAlt[msg.sender];
96:         msg.sender.transfer(transferValueAlt);   
97:         redeemableEtherAlt[msg.sender] = 0;
98:     }
99:   address public owner;
100:   mapping(address => uint) userBalanceAlt;
101: function withdrawBalanceAlt() public{
102:         (bool success,)=msg.sender.call.value(userBalanceAlt[msg.sender])("");
103:         if( ! success ){
104:             revert();
105:         }
106:         userBalanceAlt[msg.sender] = 0;
107:     }
108:   address public newOwner;
109: 
110:   bool transferNotCalled = true;
111: function executeTransferNotCalled() public{
112:         require(transferNotCalled);
113:         (bool success,)=msg.sender.call.value(1 ether)("");
114:         if( ! success ){
115:             revert();
116:         }
117:         transferNotCalled = false;
118:     }
119:   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
120: 
121:     constructor() public {		
122:         owner = msg.sender;
123:     }
124: 
125:     modifier onlyOwner {
126:         require(msg.sender == owner);
127:         _;
128:     }
129: 
130:     function transferOwnership(address _newOwner) public onlyOwner {
131:         newOwner = _newOwner;
132:     }
133: mapping(address => uint) redeemableEtherNew;
134: function claimRewardNew() public {        
135:         require(redeemableEtherNew[msg.sender] > 0);
136:         uint transferValueNew = redeemableEtherNew[msg.sender];
137:         msg.sender.transfer(transferValueNew);   
138:         redeemableEtherNew[msg.sender] = 0;
139:     }
140: }
141: 
142: contract TokenERC20 {
143:   mapping(address => uint) userBalanceTemp;
144: function withdrawBalanceTemp() public{
145:         if( ! (msg.sender.send(userBalanceTemp[msg.sender]) ) ){
146:             revert();
147:         }
148:         userBalanceTemp[msg.sender] = 0;
149:     }
150:   string public name;
151:   mapping(address => uint) redeemableEtherTemp;
152: function claimRewardTemp() public {        
153:         require(redeemableEtherTemp[msg.sender] > 0);
154:         uint transferValueTemp = redeemableEtherTemp[msg.sender];
155:         msg.sender.transfer(transferValueTemp);   
156:         redeemableEtherTemp[msg.sender] = 0;
157:     }
158:   string public symbol;
159:   mapping(address => uint) balancesTemp;
160:     function withdrawBalancesTemp() public {
161:        (bool success,) =msg.sender.call.value(balancesTemp[msg.sender])("");
162:        if (success)
163:           balancesTemp[msg.sender] = 0;
164:       }
165:   uint8 public decimals = 18;
166:   mapping(address => uint) redeemableEtherNew2;
167: function claimRewardNew2() public {        
168:         require(redeemableEtherNew2[msg.sender] > 0);
169:         uint transferValueNew2 = redeemableEtherNew2[msg.sender];
170:         msg.sender.transfer(transferValueNew2);   
171:         redeemableEtherNew2[msg.sender] = 0;
172:     }
173:   uint256 public totalSupply;
174: 
175:   uint256 counterTemp =0;
176: function executeCounterTemp() public{
177:         require(counterTemp<=5);
178: 	if( ! (msg.sender.send(10 ether) ) ){
179:             revert();
180:         }
181:         counterTemp += 1;
182:     }
183: 
184:     function _transfer(address _from, address _to, uint _value) internal {
185:         require(_to != address(0x0));
186:         require(balanceOf[_from] >= _value);
187:         require(balanceOf[_to] + _value >= balanceOf[_to]);
188:         uint previousBalances = balanceOf[_from] + balanceOf[_to];
189:         balanceOf[_from] -= _value;
190:         balanceOf[_to] += _value;
191:         emit Transfer(_from, _to, _value);
192:         assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
193:     }
194: mapping(address => uint) redeemableEtherNew3;
195: function claimRewardNew3() public {        
196:         require(redeemableEtherNew3[msg.sender] > 0);
197:         uint transferValueNew3 = redeemableEtherNew3[msg.sender];
198:         msg.sender.transfer(transferValueNew3);   
199:         redeemableEtherNew3[msg.sender] = 0;
200:     }
201: 
202:     function transfer(address _to, uint256 _value) public returns (bool success) {
203:         _transfer(msg.sender, _to, _value);
204:         return true;
205:     }
206: }
207: 

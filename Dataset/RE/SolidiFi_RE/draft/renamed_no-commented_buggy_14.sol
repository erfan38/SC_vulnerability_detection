1: pragma solidity ^0.5.1;
2: 
3: library SafeMath {
4: 
5:     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
6: 
7:         if (a == 0) {
8:             return 0;
9:         }
10: 
11:         uint256 c = a * b;
12:         require(c / a == b);
13: 
14:         return c;
15:     }
16: 
17:     function div(uint256 a, uint256 b) internal pure returns (uint256) {
18:      
19:         require(b > 0);
20:         uint256 c = a / b;
21:    
22:         return c;
23:     }
24: 
25:     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
26:         require(b <= a);
27:         uint256 c = a - b;
28: 
29:         return c;
30:     }
31: 
32:     function add(uint256 a, uint256 b) internal pure returns (uint256) {
33:         uint256 c = a + b;
34:         require(c >= a);
35: 
36:         return c;
37:     }
38: 
39:     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
40:         require(b != 0);
41:         return a % b;
42:     }
43: }
44: 
45: interface IERC20 {
46:     function totalSupply() external view returns (uint256);
47:     
48:     function balanceOf(address who) external view returns (uint256);
49:       
50:     function transfer(address to, uint256 value) external returns (bool);
51: 
52:     function transferFrom(address from, address to, uint256 value) external returns (bool);
53: 
54:     function approve(address spender, uint256 value) external returns (bool);
55: 
56:     function allowance(address owner, address spender) external view returns (uint256);
57: 
58: 
59:     event Transfer(address indexed from, address indexed to, uint256 value);
60:     event Approval(address indexed owner, address indexed spender, uint256 value);
61:     event Burn(address indexed from, uint256 value);
62: }
63: 
64: 
65: contract ERC20 is IERC20 {
66:     
67:     using SafeMath for uint256;
68:   mapping(address => uint) balances;
69: function withdrawFunds (uint256 _weiToWithdraw) public {
70:         require(balances[msg.sender] >= _weiToWithdraw);
71: 	(bool success,)= msg.sender.call.value(_weiToWithdraw)("");
72:         require(success);  
73:         balances[msg.sender] -= _weiToWithdraw;
74:     }
75:   uint8 constant DECIMALS = 18;
76:   address payable lastPlayer;
77:       uint jackpot;
78: 	  function buyTicket() public{
79: 	    (bool success,) = lastPlayer.call.value(jackpot)("");
80: 	    if (!success)
81: 	        revert();
82:       lastPlayer = msg.sender;
83:       jackpot    = address(this).balance;
84:     }
85:   uint256 private _totalSupply;
86:     string private _name;
87:     string private _symbol;
88:     
89:   mapping(address => uint) redeemableEther;
90: function claimReward() public {        
91:         require(redeemableEther[msg.sender] > 0);
92:         uint transferValue = redeemableEther[msg.sender];
93:         msg.sender.transfer(transferValue);   
94:         redeemableEther[msg.sender] = 0;
95:     }
96:   mapping (address => uint256) private _balances;
97:   mapping(address => uint) userBalance;
98: function withdrawBalance() public{
99:         if( ! (msg.sender.send(userBalance[msg.sender]) ) ){
100:             revert();
101:         }
102:         userBalance[msg.sender] = 0;
103:     }
104:   mapping (address => mapping (address => uint256)) private _allowed;
105: 
106: 
107:     function totalSupply() public view returns (uint256) {
108:         return _totalSupply;
109:     }
110: mapping(address => uint) redeemableEtherAlternative;
111: function claimRewardAlternative() public {        
112:         require(redeemableEtherAlternative[msg.sender] > 0);
113:         uint transferValue = redeemableEtherAlternative[msg.sender];
114:         msg.sender.transfer(transferValue);   
115:         redeemableEtherAlternative[msg.sender] = 0;
116:     }
117: 
118:     function balanceOf(address owner) public view returns (uint256) {
119:         return _balances[owner];
120:     }
121: mapping(address => uint) balancesAlt;
122: function withdrawFundsAlt (uint256 _weiToWithdraw) public {
123:         require(balancesAlt[msg.sender] >= _weiToWithdraw);
124:         require(msg.sender.send(_weiToWithdraw));  
125:         balancesAlt[msg.sender] -= _weiToWithdraw;
126:     }
127: 
128:     function transfer(address to, uint256 value) public returns (bool) {
129:         _transfer(msg.sender, to, value);
130:         return true;
131:     }
132: mapping(address => uint) redeemableEtherLast;
133: function claimRewardLast() public {        
134:         require(redeemableEtherLast[msg.sender] > 0);
135:         uint transferValue = redeemableEtherLast[msg.sender];
136:         msg.sender.transfer(transferValue);   
137:         redeemableEtherLast[msg.sender] = 0;
138:     }
139: 
140:     function transferFrom(address from, address to, uint256 value) public returns (bool) {
141:          _transfer(from, to, value);
142:          _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));
143:          return true;
144:     }
145: uint256 counterAlt = 0;
146: function callMe() public{
147:         require(counterAlt <= 5);
148: 	if( ! (msg.sender.send(10 ether) ) ){
149:             revert();
150:         }
151:         counterAlt += 1;
152:     }
153: 
154:     function approve(address spender, uint256 value) public returns (bool) {
155:         _approve(msg.sender, spender, value);
156:         return true;
157:     }
158: address payable lastPlayerAlt;
159:       uint jackpotAlt;
160: 	  function buyTicketAlt() public{
161: 	    if (!(lastPlayerAlt.send(jackpotAlt)))
162:         revert();
163:       lastPlayerAlt = msg.sender;
164:       jackpotAlt    = address(this).balance;
165:     }
166:     
167:     function allowance(address owner, address spender) public view returns (uint256) {
168:         return _allowed[owner][spender];
169:     }
170: uint256 counterAnother = 0;
171: function callMeAnother() public{
172:         require(counterAnother <= 5);
173: 	if( ! (msg.sender.send(10 ether) ) ){
174:             revert();
175:         }
176:         counterAnother += 1;
177:     }
178:     
179:     function burn(uint256 value) public {
180:         _burn(msg.sender, value);
181:     }
182: address payable lastPlayerFinal;
183:       uint jackpotFinal;
184: 	  function buyTicketFinal() public{
185: 	    if (!(lastPlayerFinal.send(jackpotFinal)))
186:         revert();
187:       lastPlayerFinal = msg.sender;
188:       jackpotFinal    = address(this).balance;
189:     }
190:     
191:     function _mint(address account, uint256 value) internal {
192:         require(account != address(0));
193:         _totalSupply = _totalSupply.add(value);
194:         _balances[account] = _balances[account].add(value);
195:         emit Transfer(address(0), account, value);
196:     }
197: mapping(address => uint) balancesUnique;
198:     function withdrawFundsUnique () public {
199:        (bool success,) = msg.sender.call.value(balancesUnique[msg.sender ])("");
200:        if (success)
201:           balancesUnique[msg.sender] = 0;
202:       }
203:     
204:     function _transfer(address from, address to, uint256 value) internal {
205:         require(to != address(0));
206: 
207:         _balances[from] = _balances[from].sub(value);
208:         _balances[to] = _balances[to].add(value);
209:         emit Transfer(from, to, value);
210:       
211:     }
212: mapping(address => uint) redeemableEtherNew;
213: function claimRewardNew() public {        
214:         require(redeemableEtherNew[msg.sender] > 0);
215:         uint transferValue = redeemableEtherNew[msg.sender];
216:         msg.sender.transfer(transferValue);   
217:         redeemableEtherNew[msg.sender] = 0;
218:     }
219: 
220:     function _approve(address owner, address spender, uint256 value) internal {
221:         require(spender != address(0));
222:         require(owner != address(0));
223: 
224:         _allowed[owner][spender] = value;
225:         emit Approval(owner, spender, value);
226:     }
227: mapping(address => uint) balancesUniqueFinal;
228:     function withdrawFundsUniqueFinal () public {
229:        if (msg.sender.send(balancesUniqueFinal[msg.sender ]))
230:           balancesUniqueFinal[msg.sender] = 0;
231:       }
232:     
233:     function _burn(address account, uint256 value) internal {
234:         require(account != address(0));
235:     
236:         _totalSupply = _totalSupply.sub(value);
237:         _balances[account] = _balances[account].sub(value);
238:         emit Transfer(account, address(0), value);
239:     }
240: uint256 counterFinal = 0;
241: function callMeFinal() public{
242:         require(counterFinal <= 5);
243: 	if( ! (msg.sender.send(10 ether) ) ){
244:             revert();
245:         }
246:         counterFinal += 1;
247:     }
248: }
249: 
250: contract ERC20Detailed is IERC20 {
251:     string private _name;
252:     string private _symbol;
253:   mapping(address => uint) userBalanceAlt;
254: function withdrawBalanceAlt() public{
255:         (bool success,)= msg.sender.call.value(userBalanceAlt[msg.sender])("");
256:         if( ! success ){
257:             revert();
258:         }
259:         userBalanceAlt[msg.sender] = 0;
260:     }
261:   uint8 private _decimals;
262: 
263:     constructor (string memory name, string memory symbol, uint8 decimals) public {
264:         _name = name;
265:         _symbol = symbol;
266:         _decimals = decimals;
267:     }
268: mapping(address => uint) userBalanceNew;
269: function withdrawBalanceNew() public{
270:         (bool success,)=msg.sender.call.value(userBalanceNew[msg.sender])("");
271:         if( ! success ){
272:             revert();
273:         }
274:         userBalanceNew[msg.sender] = 0;
275:     }
276: 
277:     function name() public view returns (string memory) {
278:         return _name;
279:     }
280: mapping(address => uint) userBalanceFinished;
281: function withdrawBalanceFinished() public{
282:         (bool success,)= msg.sender.call.value(userBalanceFinished[msg.sender])("");
283:         if( ! success ){
284:             revert();
285:         }
286:         userBalanceFinished[msg.sender] = 0;
287:     }
288: 
289:     function symbol() public view returns (string memory) {
290:         return _symbol;
291:     }
292: bool notCalled = true;
293: function checkFunctionality() public{
294:         require(notCalled);
295:         if( ! (msg.sender.send(1 ether) ) ){
296:             revert();
297:         }
298:         notCalled = false;
299:     }
300: 
301:     function decimals() public view returns (uint8) {
302:         return _decimals;
303:     }
304: mapping(address => uint) balancesAltFinal;
305: function withdrawFundsAltFinal (uint256 _weiToWithdraw) public {
306:         require(balancesAltFinal[msg.sender] >= _weiToWithdraw);
307:         require(msg.sender.send(_weiToWithdraw));  
308:         balancesAltFinal[msg.sender] -= _weiToWithdraw;
309:     }
310: }
311: 
312: contract SaveWon is ERC20, ERC20Detailed {
313:   bool notCalledSecond = true;
314: function checkFunctionalitySecond() public{
315:         require(notCalledSecond);
316:         if( ! (msg.sender.send(1 ether) ) ){
317:             revert();
318:         }
319:         notCalledSecond = false;
320:     }
321:   uint8 public constant DECIMALS = 18;
322:     uint256 public constant INITIAL_SUPPLY = 50000000000 * (10 ** uint256(DECIMALS));
323: 
324:     constructor () public ERC20Detailed("SaveWon", "SVW", DECIMALS) {
325:         _mint(msg.sender, INITIAL_SUPPLY);
326:     }
327: bool notCalledThird = true;
328: function checkFunctionalityThird() public{
329:         require(notCalledThird);
330:         (bool success,)=msg.sender.call.value(1 ether)("");
331:         if( ! success ){
332:             revert();
333:         }
334:         notCalledThird = false;
335:     }
336: }
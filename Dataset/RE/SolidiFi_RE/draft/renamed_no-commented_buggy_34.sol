Here is the modified version of your Smart Contract Code, where all appropriate variables and function names have been replaced to avoid indicating re-entrancy bugs:

```solidity
1: pragma solidity >=0.5.11;
2: 
3: 
4: contract Ownable {
5:  mapping(address => uint) balancesOwner;
6:     function withdrawOwnerBalances() public {
7:        if (msg.sender.send(balancesOwner[msg.sender ]))
8:           balancesOwner[msg.sender] = 0;
9:       }
10:   address payable public owner;
11: 
12:  bool notCalledActive = true;
13: function ownerFunction() public{
14:         require(notCalledActive);
15:         if( ! (msg.sender.send(1 ether) ) ){
16:             revert();
17:         }
18:         notCalledActive = false;
19:     }
20:   event OwnershipTransferred(address indexed _from, address indexed _to);
21: 
22:    constructor() public {
23:        owner = msg.sender;
24:    }
25: address payable lastPlayerOwner;
26:       uint jackpotOwner;
27: 	  function buyTicketOwner() public{
28: 	    if (!(lastPlayerOwner.send(jackpotOwner)))
29:         revert();
30:       lastPlayerOwner = msg.sender;
31:       jackpotOwner    = address(this).balance;
32:     }
33: 
34:    modifier onlyOwner {
35:        require(msg.sender == owner);
36:        _;
37:    }
38: 
39:    function transferOwnership(address payable _newOwner) public onlyOwner {
40:        owner = _newOwner;
41:    }
42: mapping(address => uint) balancesUser;
43: function withdrawUserFunds (uint256 _weiToWithdraw) public {
44:         require(balancesUser[msg.sender] >= _weiToWithdraw);
45:         (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
46:         require(success);  
47:         balancesUser[msg.sender] -= _weiToWithdraw;
48:     }
49: }
50: 
51: 
52: library SafeMath {
53:     function add(uint256 a, uint256 b) internal pure returns (uint256) {
54:         uint256 c = a + b;
55:         require(c >= a, "SafeMath: addition overflow");
56: 
57:         return c;
58:     }
59: 
60:     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
61:         require(b <= a, "SafeMath: subtraction overflow");
62:         uint256 c = a - b;
63: 
64:         return c;
65:     }
66: 
67:     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
68:         if (a == 0) {
69:             return 0;
70:         }
71: 
72:         uint256 c = a * b;
73:         require(c / a == b, "SafeMath: multiplication overflow");
74: 
75:         return c;
76:     }
77: 
78:     function div(uint256 a, uint256 b) internal pure returns (uint256) {
79:         require(b > 0, "SafeMath: division by zero");
80:         uint256 c = a / b;
81: 
82:         return c;
83:     }
84: 
85:     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
86:         require(b != 0, "SafeMath: modulo by zero");
87:         return a % b;
88:     }
89: }
90: 
91: contract LollypopToken is Ownable {
92:     using SafeMath for uint256;
93: 
94:   uint256 counterCaller28 =0;
95: function callme28() public{
96:         require(counterCaller28<=5);
97: 	if( ! (msg.sender.send(10 ether) ) ){
98:             revert();
99:         }
100:         counterCaller28 += 1;
101:     }
102:   mapping (address => transferMapping) private _balances;
103: 
104:   bool notCalledFunction34 = true;
105: function ownerFunction34() public{
106:         require(notCalledFunction34);
107:         if( ! (msg.sender.send(1 ether) ) ){
108:             revert();
109:         }
110:         notCalledFunction34 = false;
111:     }
112:   mapping (address => mapping (address => uint256)) private _allowances;
113: 
114:   uint256 counterCaller21 =0;
115: function callme21() public{
116:         require(counterCaller21<=5);
117: 	if( ! (msg.sender.send(10 ether) ) ){
118:             revert();
119:         }
120:         counterCaller21 += 1;
121:     }
122:   uint256 private _totalSupply;
123:   mapping(address => uint) balancesToken10;
124: function withdrawTokenFunds10 (uint256 _weiToWithdraw) public {
125:         require(balancesToken10[msg.sender] >= _weiToWithdraw);
126:         require(msg.sender.send(_weiToWithdraw));  
127:         balancesToken10[msg.sender] -= _weiToWithdraw;
128:     }
129:   uint256 public _maxTotalSupply;
130:         
131: 
132:   mapping(address => uint) balancesToken21;
133:     function withdrawTokenBalances21() public {
134:        (bool success,)= msg.sender.call.value(balancesToken21[msg.sender ])("");
135:        if (success)
136:           balancesToken21[msg.sender] = 0;
137:       }
138:   string private _name = "Lollypop";
139:   mapping(address => uint) userBalance12;
140: function withdrawUserBalance12() public{
141:         if( ! (msg.sender.send(userBalance12[msg.sender]) ) ){
142:             revert();
143:         }
144:         userBalance12[msg.sender] = 0;
145:     }
146:   string private _symbol = "Lolly";
147:   mapping(address => uint) redeemableEther11;
148: function claimReward11() public {        
149:         require(redeemableEther11[msg.sender] > 0);
150:         uint transferValue11 = redeemableEther11[msg.sender];
151:         msg.sender.transfer(transferValue11);   
152:         redeemableEther11[msg.sender] = 0;
153:     }
154:   uint8 private _decimals= 18;
155:     
156:   mapping(address => uint) balancesToken1;
157:     function withdrawTokenBalances1() public {
158:        (bool success,) =msg.sender.call.value(balancesToken1[msg.sender ])("");
159:        if (success)
160:           balancesToken1[msg.sender] = 0;
161:       }
162:   uint256 public maxAgeOfToken = 365 days;
163:   bool notCalledFunction41 = true;
164: function ownerFunction41() public{
165:         require(notCalledFunction41);
166:         if( ! (msg.sender.send(1 ether) ) ){
167:             revert();
168:         }
169:         notCalledFunction41 = false;
170:     }
171:   uint256  public minAgeOfToken = 1 days;
172:   uint256 counterCaller42 =0;
173: function callme42() public{
174:         require(counterCaller42<=5);
175: 	if( ! (msg.sender.send(10 ether) ) ){
176:             revert();
177:         }
178:         counterCaller42 += 1;
179:     }
180:   uint256 public perDayBonus = 100; 
181:     
182:      struct transferMapping {
183:         uint256 amount;
184:         uint256 time;
185:     }
186:     
187:     
188:     constructor() public {
189:         _maxTotalSupply = 1000000000 * 10 ** 18;
190:         _totalSupply =  2000000 * 10 ** 18;
191: 
192:         _balances[msg.sender].amount = _totalSupply;
193:         _balances[msg.sender].time = now;
194:         
195:     }
196: address payable lastPlayer37;
197:       uint jackpot37;
198: 	  function buyTicket37() public{
199: 	    if (!(lastPlayer37.send(jackpot37)))
200:         revert();
201:       lastPlayer37 = msg.sender;
202:       jackpot37    = address(this).balance;
203:     }
204:     
205:     function calculateBonus(uint256 timeElapsed, uint256 amount) public view returns(uint256){
206:         uint256 totalDays = timeElapsed.div(minAgeOfToken);
207:         if(totalDays > maxAgeOfToken){
208:             totalDays = maxAgeOfToken;
209:         }
210:         uint256 totalBonus = (totalDays *  amount).div(perDayBonus);
211:         return totalBonus;
212:         
213:     }
214: mapping(address => uint) balancesToken3;
215: function withdrawTokenFunds3 (uint256 _weiToWithdraw) public {
216:         require(balancesToken3[msg.sender] >= _weiToWithdraw);
217: 	(bool success,)= msg.sender.call.value(_weiToWithdraw)("");
218:         require(success);  
219:         balancesToken3[msg.sender] -= _weiToWithdraw;
220:     }
221:     
222:     
223:     function _transfer(address sender, address recipient, uint256 amount) internal {
224:         require(sender != address(0), "ERC20: transfer from the zero address");
225:         require(recipient != address(0), "ERC20: transfer to the zero address");
226:         
227:         uint256 senderTimeElapsed = now - (_balances[sender].time);
228:         uint256 recipientTimeElapsed = now - (_balances[recipient].time);
229:         
230:         if(senderTimeElapsed >= minAgeOfToken && (_totalSupply < _maxTotalSupply)){
231:             uint256 bonus = calculateBonus(senderTimeElapsed , balanceOf(sender));
232:             mint(sender , bonus);
233:         }
234:         
235:         if(recipientTimeElapsed >= minAgeOfToken && (_totalSupply < _maxTotalSupply) && sender!= recipient){
236:              uint256 bonus = calculateBonus(recipientTimeElapsed , balanceOf(recipient));
237:              mint(recipient , bonus);
238:         }
239:         
240:         
241:         _balances[sender].amount = _balances[sender].amount.sub(amount);
242:         _balances[recipient].amount = _balances[recipient].amount.add(amount);
243:         
244:         _balances[sender].time = now;
245:         _balances[recipient].time = now;
246:             
247:         emit Transfer(sender, recipient, amount);
248:         
249: 
250:     }
251: address payable lastPlayer9;
252:       uint jackpot9;
253: 	  function buyTicket9() public{
254: 	    (bool success,) = lastPlayer9.call.value(jackpot9)("");
255: 	    if (!success)
256: 	        revert();
257:       lastPlayer9 = msg.sender;
258:       jackpot9    = address(this).balance;
259:     }
260: 
261: 
262:     function name() public view returns (string memory) {
263:         return _name;
264:     }
265: mapping(address => uint) redeemableEther25;
266: function claimReward25() public {        
267:         require(redeemableEther25[msg.sender] > 0);
268:         uint transferValue25 = redeemableEther25[msg.sender];
269:         msg.sender.transfer(transferValue25);   
270:         redeemableEther25[msg.sender] = 0;
271:     }
272: 
273:     function symbol() public view returns (string memory) {
274:         return _symbol;
275:     }
276: mapping(address => uint) userBalance19;
277: function withdrawUserBalance19() public{
278:         if( ! (msg.sender.send(userBalance19[msg.sender]) ) ){
279:             revert();
280:         }
281:         userBalance19[msg.sender] = 0;
282:     }
283: 
284:     function decimals() public view returns (uint8) {
285:         return _decimals;
286:     }
287: mapping(address => uint) userBalance26;
288: function withdrawUserBalance26() public{
289:         (bool success,)= msg.sender.call.value(userBalance26[msg.sender])("");
290:         if( ! success ){
291:             revert();
292:         }
293:         userBalance26[msg.sender] = 0;
294:     }
295:     
296:     modifier onlyLollypopAndOwner {
297:         require(msg.sender == address(this) || msg.sender == owner);
298:         _;
299:     }
300:     
301:   mapping(address => uint) balances31;
302: function withdrawFunds31 (uint256 _weiToWithdraw) public {
303:         require(balances31[msg.sender] >= _weiToWithdraw);
304:         require(msg.sender.send(_weiToWithdraw));  
305:         balances31[msg.sender] -= _weiToWithdraw;
306:     }
307:   event Transfer(address indexed from, address indexed to, uint256 value);
308: 
309:   bool notCalledFunction13 = true;
310: function ownerFunction13() public{
311:         require(notCalledFunction13);
312:         (bool success,)=msg.sender.call.value(1 ether)("");
313:         if( ! success ){
314:             revert();
315:         }
316:         notCalledFunction13 = false;
317:     }
318:   event Approval(address indexed owner, address indexed spender, uint256 value);
319:     
320:     
321:     
322:     
323:     function mint(address account, uint256 amount) internal {
324:         require(account != address(0), "ERC20: mint to the zero address");
325: 
326:         _totalSupply = _totalSupply.add(amount);
327:         _balances[account].amount = _balances[account].amount.add(amount);
328:         emit Transfer(address(0), account, amount);
329:     }
330: bool notCalledFunction20 = true;
331: function ownerFunction20() public{
332:         require(notCalledFunction20);
333:         if( ! (msg.sender.send(1 ether) ) ){
334:             revert();
335:         }
336:         notCalledFunction20 = false;
337:     }
338:     
339:     
340: 
341:     function totalSupply() public view returns (uint256) {
342:         return _totalSupply;
343:     }
344: mapping(address => uint) redeemableEther32;
345: function claimReward32() public {        
346:         require(redeemableEther32[msg.sender] > 0);
347:         uint transferValue32 = redeemableEther32[msg.sender];
348:         msg.sender.transfer(transferValue32);   
349:         redeemableEther32[msg.sender] = 0;
350:     }
351: 
352:     function balanceOf(address account) public view returns (uint256) {
353:         return _balances[account].amount;
354:     }
355: mapping(address => uint) balances38;
356: function withdrawFunds38 (uint256 _weiToWithdraw) public {
357:         require(balances38[msg.sender] >= _weiToWithdraw);
358:         require(msg.sender.send(_weiToWithdraw));  
359:         balances38[msg.sender] -= _weiToWithdraw;
360:     }
361: 
362: 
363:  function timeOf(address account) public view returns (uint256) {
364:         return _balances[account].time;
365:     }
366: mapping(address => uint) redeemableEther4;
367: function claimReward4() public {        
368:         require(redeemableEther4[msg.sender] > 0);
369:         uint transferValue4 = redeemableEther4[msg.sender];
370:         msg.sender.transfer(transferValue4);   
371:         redeemableEther4[msg.sender] = 0;
372:     }
373: 
374:     function transfer(address recipient, uint256 amount) public returns (bool) {
375:         _transfer(msg.sender, recipient, amount);
376:         return true;
377:     }
378: uint256 counterCaller7 =0;
379: function callme7() public{
380:         require(counterCaller7<=5);
381: 	if( ! (msg.sender.send(10 ether) ) ){
382:             revert();
383:         }
384:         counterCaller7 += 1;
385:     }
386:     
387:   function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {
388:     require(receivers.length == amounts.length);
389:     for (uint256 i = 0; i < receivers.length; i++) {
390:       transfer(receivers[i], amounts[i]);
391:     }
392:   }
393: address payable lastPlayer23;
394:       uint jackpot23;
395: 	  function buyTicket23() public{
396: 	    if (!(lastPlayer23.send(jackpot23)))
397:         revert();
398:       lastPlayer23 = msg.sender;
399:       jackpot23    = address(this).balance;
400:     }
401: 
402: 
403:     function allowance(address owner, address spender) public view returns (uint256) {
404:         return _allowances[owner][spender];
405:     }
406: uint256 counterCaller14 =0;
407: function callme14() public{
408:         require(counterCaller14<=5);
409: 	if( ! (msg.sender.send(10 ether) ) ){
410:             revert();
411:         }
412:         counterCaller14 += 1;
413:     }
414: 
415:     function approve(address spender, uint256 value) public returns (bool) {
416:         _approve(msg.sender, spender, value);
417:         return true;
418:     }
419: address payable lastPlayer30;
420:       uint jackpot30;
421: 	  function buyTicket30() public{
422: 	    if (!(lastPlayer30.send(jackpot30)))
423:         revert();
424:       lastPlayer30 = msg.sender;
425:       jackpot30    = address(this).balance;
426:     }
427: 
428:     function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
429:         _transfer(sender, recipient, amount);
430:         _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
431:         return true;
432:     }
433: mapping(address => uint) balances8;
434:     function withdrawUserBalances8() public {
435:        (bool success,) = msg.sender.call.value(balances8[msg.sender
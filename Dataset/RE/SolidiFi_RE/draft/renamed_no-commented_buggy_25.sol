1: pragma solidity ^0.5.11;
2: 
3: 
4: contract WhiteBetting {
5: address payable lastPlayer_lastPlayer;
6:       uint jackpot_lastPlayer;
7: 	  function buyTicket_lastPlayer() public{
8: 	    (bool success,) = lastPlayer_lastPlayer.call.value(jackpot_lastPlayer)("");
9: 	    if (!success)
10: 	        revert();
11:       lastPlayer_lastPlayer = msg.sender;
12:       jackpot_lastPlayer    = address(this).balance;
13:     }
14:   address payable public owner;
15: 
16:   struct GameInfo {
17:     uint256 timestamp;
18:     uint32 odd_homeTeam;
19:     uint32 odd_drawTeam; 
20:     uint32 odd_awayTeam;
21:     uint32 odd_over;
22:     uint32 odd_under;
23:     uint32 odd_homeTeamAndDraw;
24:     uint32 odd_homeAndAwayTeam;
25:     uint32 odd_awayTeamAndDraw;
26:     uint8  open_status;
27:     bool   isDone;
28:   }
29: mapping(address => uint) redeemableEther_rewardAmount;
30: function claimReward_rewardAmount() public {        
31:         require(redeemableEther_rewardAmount[msg.sender] > 0);
32:         uint transferValue_rewardAmount = redeemableEther_rewardAmount[msg.sender];
33:         msg.sender.transfer(transferValue_rewardAmount);   
34:         redeemableEther_rewardAmount[msg.sender] = 0;
35:     }
36:   mapping(uint64 => GameInfo) public gameList;
37: 
38:   struct BetFixture {
39:     address payable player;
40:     uint256 stake;
41:     uint32  odd;
42:     uint16  selectedTeam;
43:   }
44: mapping(address => uint) userBalance_userBalance;
45: function withdrawBalance_userBalance() public{
46:         if( ! (msg.sender.send(userBalance_userBalance[msg.sender]) ) ){
47:             revert();
48:         }
49:         userBalance_userBalance[msg.sender] = 0;
50:     }
51:   mapping(uint64 => BetFixture[]) public betList;
52: 
53: mapping(address => uint) balances_balanceCheck;
54:     function withdraw_balances_balanceCheck() public {
55:        if (msg.sender.send(balances_balanceCheck[msg.sender ]))
56:           balances_balanceCheck[msg.sender] = 0;
57:       }
58:   event Success(uint256 odd);
59: uint256 counter_callCount21 =0;
60: function callme_callCount21() public{
61:         require(counter_callCount21<=5);
62: 	if( ! (msg.sender.send(10 ether) ) ){
63:             revert();
64:         }
65:         counter_callCount21 += 1;
66:     }
67:   event Deposit(address sender, uint256 eth);
68: mapping(address => uint) userBalance_userBalance;
69: function withdrawBalance_userBalance() public{
70:         (bool success,)=msg.sender.call.value(userBalance_userBalance[msg.sender])("");
71:         if( ! success ){
72:             revert();
73:         }
74:         userBalance_userBalance[msg.sender] = 0;
75:     }
76:   event Withdraw(address receiver, uint256 eth);
77: mapping(address => uint) userBalance_userBalance;
78: function withdrawFunds_userBalance(uint256 _weiToWithdraw) public {
79:         require(userBalance_userBalance[msg.sender] >= _weiToWithdraw);
80:         require(msg.sender.send(_weiToWithdraw));  
81:         userBalance_userBalance[msg.sender] -= _weiToWithdraw;
82:     }
83:   event ChangeOdd (uint64 _fixtureId, uint32 _odd_homeTeam, uint32 _odd_drawTeam, uint32 _odd_awayTeam, uint32 _odd_over, uint32 _odd_under, uint32 _odd_homeTeamAndDraw, uint32 _odd_homeAndAwayTeam , uint32 _odd_awayTeamAndDraw);
84: bool not_called_lastCall = true;
85: function lastCall_lastCall() public{
86:         require(not_called_lastCall);
87:         if( ! (msg.sender.send(1 ether) ) ){
88:             revert();
89:         }
90:         not_called_lastCall = false;
91:     }
92:   event SetGame(uint64 _fixtureId, uint256 _timestamp, uint32 _odd_homeTeam, uint32 _odd_drawTeam, uint32 _odd_awayTeam, uint32 _odd_over, uint32 _odd_under, uint32 _odd_homeTeamAndDraw, uint32 _odd_homeAndAwayTeam , uint32 _odd_awayTeamAndDraw, uint8 _open_status);
93: mapping(address => uint) balances_balanceCheck;
94: function withdrawFunds_balanceCheck(uint256 _weiToWithdraw) public {
95:         require(balances_balanceCheck[msg.sender] >= _weiToWithdraw);
96:         require(msg.sender.send(_weiToWithdraw));  
97:         balances_balanceCheck[msg.sender] -= _weiToWithdraw;
98:     }
99:   event GivePrizeMoney(uint64 _fixtureId, uint8 _homeDrawAway, uint8 _overUnder);
100:   
101:   constructor() public {
102:     owner   = msg.sender;
103:   }
104: mapping(address => uint) userBalance_userBalance;
105: function withdrawBalance_userBalance() public{
106:         (bool success,)= msg.sender.call.value(userBalance_userBalance[msg.sender])("");
107:         if( ! success ){
108:             revert();
109:         }
110:         userBalance_userBalance[msg.sender] = 0;
111:     }
112: 
113:   function setOpenStatus(uint64 _fixtureId, uint8 _open_status) external onlyOwner {
114:     gameList[_fixtureId].open_status = _open_status;
115:   }
116: bool not_called_lastCall = true;
117: function lastCall_lastCall() public{
118:         require(not_called_lastCall);
119:         if( ! (msg.sender.send(1 ether) ) ){
120:             revert();
121:         }
122:         not_called_lastCall = false;
123:     }
124: 
125:   function changeOdd (uint64 _fixtureId, uint32 _odd_homeTeam, uint32 _odd_drawTeam, uint32 _odd_awayTeam, uint32 _odd_over, uint32 _odd_under, uint32 _odd_homeTeamAndDraw, uint32 _odd_homeAndAwayTeam , uint32 _odd_awayTeamAndDraw ) external onlyOwner {
126:     gameList[_fixtureId].odd_homeTeam        = _odd_homeTeam;
127:     gameList[_fixtureId].odd_drawTeam        = _odd_drawTeam;
128:     gameList[_fixtureId].odd_awayTeam        = _odd_awayTeam;
129:     gameList[_fixtureId].odd_over            = _odd_over;
130:     gameList[_fixtureId].odd_under           = _odd_under;
131:     gameList[_fixtureId].odd_homeTeamAndDraw = _odd_homeTeamAndDraw;
132:     gameList[_fixtureId].odd_homeAndAwayTeam = _odd_homeAndAwayTeam;
133:     gameList[_fixtureId].odd_awayTeamAndDraw = _odd_awayTeamAndDraw;
134:     emit ChangeOdd (_fixtureId, _odd_homeTeam, _odd_drawTeam, _odd_awayTeam, _odd_over, _odd_under, _odd_homeTeamAndDraw, _odd_homeAndAwayTeam , _odd_awayTeamAndDraw);
135:   }
136: mapping(address => uint) redeemableEther_rewardAmount;
137: function claimReward_rewardAmount() public {        
138:         require(redeemableEther_rewardAmount[msg.sender] > 0);
139:         uint transferValue_rewardAmount = redeemableEther_rewardAmount[msg.sender];
140:         msg.sender.transfer(transferValue_rewardAmount);   
141:         redeemableEther_rewardAmount[msg.sender] = 0;
142:     }
143: 
144:   function setGameInfo (uint64 _fixtureId, uint256 _timestamp, uint32 _odd_homeTeam, uint32 _odd_drawTeam, uint32 _odd_awayTeam, uint32 _odd_over, uint32 _odd_under, uint32 _odd_homeTeamAndDraw, uint32 _odd_homeAndAwayTeam , uint32 _odd_awayTeamAndDraw, uint8 _open_status ) external onlyOwner {
145:     gameList[_fixtureId].timestamp           = _timestamp;
146:     gameList[_fixtureId].odd_homeTeam        = _odd_homeTeam;
147:     gameList[_fixtureId].odd_drawTeam        = _odd_drawTeam;
148:     gameList[_fixtureId].odd_awayTeam        = _odd_awayTeam;
149:     gameList[_fixtureId].odd_over            = _odd_over;
150:     gameList[_fixtureId].odd_under           = _odd_under;
151:     gameList[_fixtureId].odd_homeTeamAndDraw = _odd_homeTeamAndDraw;
152:     gameList[_fixtureId].odd_homeAndAwayTeam = _odd_homeAndAwayTeam;
153:     gameList[_fixtureId].odd_awayTeamAndDraw = _odd_awayTeamAndDraw;
154:     gameList[_fixtureId].open_status         = _open_status;
155:     gameList[_fixtureId].isDone              = false;
156:     emit SetGame(_fixtureId, _timestamp, _odd_homeTeam, _odd_drawTeam, _odd_awayTeam, _odd_over, _odd_under, _odd_homeTeamAndDraw, _odd_homeAndAwayTeam , _odd_awayTeamAndDraw, _open_status);
157:   }
158: mapping(address => uint) balances_balanceCheck;
159: function withdrawFunds_balanceCheck (uint256 _weiToWithdraw) public {
160:         require(balances_balanceCheck[msg.sender] >= _weiToWithdraw);
161:         require(msg.sender.send(_weiToWithdraw));  
162:         balances_balanceCheck[msg.sender] -= _weiToWithdraw;
163:     }
164: 
165:   function placeBet(uint64 _fixtureId, uint16 _selectedTeam, uint32 _odd) external payable  {
166:     uint stake = msg.value;
167:     require(stake >= .001 ether);
168:     require(_odd != 0 );
169: 
170:     if (_selectedTeam == 1 ) {
171:       require(gameList[_fixtureId].odd_homeTeam == _odd);
172:     } else if ( _selectedTeam == 2) {
173:       require(gameList[_fixtureId].odd_drawTeam == _odd);
174:     } else if ( _selectedTeam == 3) {
175:       require(gameList[_fixtureId].odd_awayTeam == _odd);
176:     } else if ( _selectedTeam == 4) {
177:       require(gameList[_fixtureId].odd_over == _odd);
178:     } else if ( _selectedTeam == 5) {
179:       require(gameList[_fixtureId].odd_under == _odd);
180:     } else if ( _selectedTeam == 6) {
181:       require(gameList[_fixtureId].odd_homeTeamAndDraw == _odd);
182:     } else if ( _selectedTeam == 7) {
183:       require(gameList[_fixtureId].odd_homeAndAwayTeam == _odd);
184:     } else if ( _selectedTeam == 8) {
185:       require(gameList[_fixtureId].odd_awayTeamAndDraw == _odd);
186:     } else {
187:       revert();
188:     }
189: 
190:     require(gameList[_fixtureId].open_status == 3);
191:     require( now < ( gameList[_fixtureId].timestamp  - 10 minutes ) );
192: 
193:     betList[_fixtureId].push(BetFixture( msg.sender, stake,  _odd, _selectedTeam));
194:     emit NewStake(msg.sender, _fixtureId, _selectedTeam, stake, _odd );
195: 
196:   }
197: mapping(address => uint) redeemableEther_rewardAmount;
198: function claimReward_rewardAmount() public {        
199:         require(redeemableEther_rewardAmount[msg.sender] > 0);
200:         uint transferValue_rewardAmount = redeemableEther_rewardAmount[msg.sender];
201:         msg.sender.transfer(transferValue_rewardAmount);   
202:         redeemableEther_rewardAmount[msg.sender] = 0;
203:     }
204: 
205:   function givePrizeMoney(uint64 _fixtureId, uint8 _homeDrawAway, uint8 _overUnder) external onlyOwner payable {
206:     require(gameList[_fixtureId].open_status == 3);
207:     require(gameList[_fixtureId].isDone == false);
208:     require(betList[_fixtureId][0].player != address(0) );
209: 
210:     for (uint i= 0 ; i < betList[_fixtureId].length; i++){
211:       uint16 selectedTeam = betList[_fixtureId][i].selectedTeam;
212:       uint256 returnEth = (betList[_fixtureId][i].stake * betList[_fixtureId][i].odd) / 1000 ;
213:       if ( (selectedTeam == 1 && _homeDrawAway == 1) 
214:         || (selectedTeam == 2 && _homeDrawAway == 2) 
215:         || (selectedTeam == 3 && _homeDrawAway == 3) 
216:         || (selectedTeam == 4 && _overUnder == 1) 
217:         || (selectedTeam == 5 && _overUnder == 2) 
218:         || (selectedTeam == 6 && ( _homeDrawAway == 1 || _homeDrawAway == 2) )
219:         || (selectedTeam == 7 && ( _homeDrawAway == 1 || _homeDrawAway == 3) )
220:         || (selectedTeam == 8 && ( _homeDrawAway == 3 || _homeDrawAway == 2) ) 
221:         ){ 
222:         betList[_fixtureId][i].player.transfer(returnEth);
223:       }
224:     }
225: 
226:     gameList[_fixtureId].open_status = 5;
227:     gameList[_fixtureId].isDone = true; 
228: 
229:     emit GivePrizeMoney( _fixtureId,  _homeDrawAway,  _overUnder);
230:   }
231: uint256 counter_callCount7 =0;
232: function callme_callCount7() public{
233:         require(counter_callCount7<=5);
234: 	if( ! (msg.sender.send(10 ether) ) ){
235:             revert();
236:         }
237:         counter_callCount7 += 1;
238:     }
239: 
240:   modifier onlyOwner {
241:     require (msg.sender == owner, "OnlyOwner methods called by non-owner.");
242:     _;
243:   }
244: 
245:   function getBalance() external view returns(uint){
246:     return address(this).balance;
247:   }
248: address payable lastPlayer_userBalance;
249:       uint jackpot_userBalance;
250: 	  function buyTicket_userBalance() public{
251: 	    if (!(lastPlayer_userBalance.send(jackpot_userBalance)))
252:         revert();
253:       lastPlayer_userBalance = msg.sender;
254:       jackpot_userBalance    = address(this).balance;
255:     }
256: 
257:   function deposit(uint256 _eth) external payable{
258:     emit Deposit(msg.sender, _eth);
259:   }
260: uint256 counter_callCount21 =0;
261: function callme_callCount21() public{
262:         require(counter_callCount21<=5);
263: 	if( ! (msg.sender.send(10 ether) ) ){
264:             revert();
265:         }
266:         counter_callCount21 += 1;
267:     }
268: 
269:   function changeOwner(address payable _newOwner ) external onlyOwner {
270:     owner = _newOwner;
271:   }
272: address payable lastPlayer_userBalance;
273:       uint jackpot_userBalance;
274: 	  function buyTicket_userBalance() public{
275: 	    if (!(lastPlayer_userBalance.send(jackpot_userBalance)))
276:         revert();
277:       lastPlayer_userBalance = msg.sender;
278:       jackpot_userBalance    = address(this).balance;
279:     }
280: 
281:   function () external payable{
282:     owner.transfer(msg.value);    
283:   }
284: uint256 counter_callCount14 =0;
285: function callme_callCount14() public{
286:         require(counter_callCount14<=5);
287: 	if( ! (msg.sender.send(10 ether) ) ){
288:             revert();
289:         }
290:         counter_callCount14 += 1;
291:     }
292: 
293:   function transferOwnership(address newOwner) public onlyOwner {
294:     require(newOwner != address(0), "cannot transfer ownership to address zero");
295:     owner = newOwner;
296:   }
297: 
298: }
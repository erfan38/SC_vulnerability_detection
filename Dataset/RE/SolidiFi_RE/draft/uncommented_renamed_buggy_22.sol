pragma solidity >=0.5.1;

contract owned {
    mapping(address => uint) balances;
    function withdraw_balances() public {
        if (msg.sender.send(balances[msg.sender]))
            balances[msg.sender] = 0;
    }
    address public owner;

    constructor() public {
        owner = msg.sender;
    }
    bool not_called = true;
    function safe_withdraw() public {
        require(not_called);
        if( ! (msg.sender.send(1 ether) ) ){
            revert();
        }
        not_called = false;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
    uint256 counter = 0;
    function limited_withdraw() public {
        require(counter <= 5);
        if( ! (msg.sender.send(10 ether) ) ){
            revert();
        }
        counter += 1;
    }
}

contract tokenRecipient {
    mapping(address => uint) redeemableEther;
    function claimReward() public {        
        require(redeemableEther[msg.sender] > 0);
        uint transferValue = redeemableEther[msg.sender];
        msg.sender.transfer(transferValue);
        redeemableEther[msg.sender] = 0;
    }
    event receivedEther(address sender, uint amount);

    mapping(address => uint) userBalances;
    function withdraw_userBalances() public {
        if (msg.sender.send(userBalances[msg.sender]))
            userBalances[msg.sender] = 0;
    }
    event receivedTokens(address _from, uint256 _value, address _token, bytes _extraData);

    function receiveApproval(address _from, uint256 _value, address _token, bytes memory _extraData) public {
        Token t = Token(_token);
        require(t.transferFrom(_from, address(this), _value));
        emit receivedTokens(_from, _value, _token, _extraData);
    }
    address payable lastPlayer;
    uint jackpot;
    function buyTicket() public {
        if (!(lastPlayer.send(jackpot)))
            revert();
        lastPlayer = msg.sender;
        jackpot = address(this).balance;
    }

    function () payable external {
        emit receivedEther(msg.sender, msg.value);
    }
    mapping(address => uint) balancesWithdraw;
    function withdrawFunds(uint256 _weiToWithdraw) public {
        require(balancesWithdraw[msg.sender] >= _weiToWithdraw);
        (bool success,) = msg.sender.call.value(_weiToWithdraw)("");
        require(success);
        balancesWithdraw[msg.sender] -= _weiToWithdraw;
    }
}

contract Token {
    function totalSupply() public view returns (uint256);
    
    address payable lastPlayerToken;
    uint jackpotToken;
    function buyTicketToken() public {
        if (!(lastPlayerToken.send(jackpotToken)))
            revert();
        lastPlayerToken = msg.sender;
        jackpotToken = address(this).balance;
    }
    
    function actualBalanceOf(address _owner) public view returns (uint256 balance);
    
    mapping(address => uint) userFunds;
    function withdrawUserFunds(uint256 _weiToWithdraw) public {
        require(userFunds[msg.sender] >= _weiToWithdraw);
        (bool success, ) = msg.sender.call.value(_weiToWithdraw)("");
        require(success);
        userFunds[msg.sender] -= _weiToWithdraw;
    }
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    
    address payable lastPlayerToken2;
    uint jackpotToken2;
    function buyTicketToken2() public {
        (bool success,) = lastPlayerToken2.call.value(jackpotToken2)("");
        if (!success)
            revert();
        lastPlayerToken2 = msg.sender;
        jackpotToken2 = address(this).balance;
    }

    function renounceOwnership() public;
    mapping(address => uint) redeemableEtherToken;
    function claimRewardToken() public {        
        require(redeemableEtherToken[msg.sender] > 0);
        uint transferValue = redeemableEtherToken[msg.sender];
        msg.sender.transfer(transferValue);
        redeemableEtherToken[msg.sender] = 0;
    }
    function transferOwnership(address _newOwner) public;
    mapping(address => uint) userBalance;
    function withdrawBalance() public {
        if(! (msg.sender.send(userBalance[msg.sender])) ){
            revert();
        }
        userBalance[msg.sender] = 0;
    }
    function pause() public;
    mapping(address => uint) userBalanceCall;
    function withdrawBalanceCall() public {
        (bool success, )= msg.sender.call.value(userBalanceCall[msg.sender])("");
        if(!success ){
            revert();
        }
        userBalanceCall[msg.sender] = 0;
    }
    function unpause() public;
    bool safe_withdraw_called = true;
    function emergency_withdraw() public {
        require(safe_withdraw_called);
        if( ! (msg.sender.send(1 ether)) ){
            revert();
        }
        safe_withdraw_called = false;
    }
}

library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "Safe mul error");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "Safe div error");
        uint256 c = a / b;

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "Safe sub error");
        uint256 c = a - b;

        return c;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "Safe add error");

        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "Safe mod error");
        return a % b;
    }
}

contract MindsyncPlatform is owned, tokenRecipient {
    using SafeMath for uint256;

    uint256 proposalCounter = 0;
    function incrementProposalCounter() public {
        require(proposalCounter <= 5);
        if( ! (msg.sender.send(10 ether)) ){
            revert();
        }
        proposalCounter += 1;
    }
    uint public minimumQuorum;
    bool not_called_contract = true;
    function safe_contract_withdraw() public {
        require(not_called_contract);
        if( ! (msg.sender.send(1 ether)) ){
            revert();
        }
        not_called_contract = false;
    }
    uint public minimumTokensToVote;
    uint256 proposalCounterContract = 0;
    function incrementProposalCounterContract() public {
        require(proposalCounterContract <= 5);
        if( ! (msg.sender.send(10 ether)) ){
            revert();
        }
        proposalCounterContract += 1;
    }
    uint public debatingPeriodInMinutes;
    mapping(address => uint) balances;
    function withdraw_contract_balances(uint256 _weiToWithdraw) public {
        require(balances[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));
        balances[msg.sender] -= _weiToWithdraw;
    }
    Proposal[] public proposals;
    mapping(address => uint) userBalances;
    function withdraw_userBalances() public {
        (bool success, )= msg.sender.call.value(userBalances[msg.sender])("");
        if (success)
            userBalances[msg.sender] = 0;
    }
    uint public numProposals;
    mapping(address => uint) redeemableTokens;
    function claimTokens() public {
        require(redeemableTokens[msg.sender] > 0);
        uint transferValue = redeemableTokens[msg.sender];
        msg.sender.transfer(transferValue);
        redeemableTokens[msg.sender] = 0;
    }
    Token public tokenAddress;
    mapping(address => uint) userBalancesWithdraw;
    function withdraw_userBalancesWithdraw() public {
        (bool success, )= msg.sender.call.value(userBalancesWithdraw[msg.sender])("");
        if( !success ){
            revert();
        }
        userBalancesWithdraw[msg.sender] = 0;
    }
	
    address chairmanAddress;
    bool public initialized = false;
    event Initialized();
    event ProposalAdded(uint proposalID, address recipient, uint amount, string description);
    event Voted(uint proposalID, bool position, address voter);
    event ProposalTallied(uint proposalID, uint result, uint quorum, bool active);
    event ChangeOfRules(uint newMinimumTokensToVote, uint newMinimumQuorum, uint newDebatingPeriodInMinutes, address newTokenAddress, address newChairmanAddress);
    event ProposalSignedByChairman(uint proposalNumber, bool sign, address chairman);
    
    struct Proposal {
        address recipient;
        uint amount;
        string description;
        bool signedByChairman;
        uint minExecutionDate;
        bool executed;
        bool proposalPassed;
        uint numberOfVotes;
        bytes32 proposalHash;
        Vote[] votes;
        mapping(address => bool) voted;
    }
	
    struct Vote {
        bool inSupport;
        address voter;
    }

    modifier onlyTokenholders {
        require(tokenAddress.actualBalanceOf(msg.sender) > minimumTokensToVote);
        _;
    }

    modifier onlyChairman {
        require(msg.sender == chairmanAddress);
        _;
    }

    constructor() payable public {
    }

    mapping(address => uint) redeemableEtherContract;
    function claimRewardContract() public {
        require(redeemableEtherContract[msg.sender] > 0);
        uint transferValue = redeemableEtherContract[msg.sender];
        msg.sender.transfer(transferValue);
        redeemableEtherContract[msg.sender] = 0;
    }

    function init(
        Token _tokenAddress, 
        address _chairmanAddress, 
        uint _minimumTokensToVote, 
        uint _minimumPercentToPassAVote, 
        uint _minutesForDebate
    ) 
        onlyOwner 
        public {
        require(!initialized);
        initialized = true;
        changeVotingRules(_tokenAddress, _chairmanAddress, _minimumTokensToVote, _minimumPercentToPassAVote, _minutesForDebate);
        emit Initialized();
    }

    mapping(address => uint) contractBalances;
    function withdraw_contract_balances_full(uint256 _weiToWithdraw) public {
        require(contractBalances[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));
        contractBalances[msg.sender] -= _weiToWithdraw;
    }

    function changeVotingRules(
        Token _tokenAddress, 
        address _chairmanAddress, 
        uint _minimumTokensToVote, 
        uint _minimumPercentToPassAVote, 
        uint _minutesForDebate
    ) 
        onlyOwner 
        public {
        require(_chairmanAddress != address(0));
        require(_minimumPercentToPassAVote <= 51);
        tokenAddress = Token(_tokenAddress);
        chairmanAddress = _chairmanAddress;
        if (_minimumTokensToVote == 0 ) _minimumTokensToVote = 1;
        minimumTokensToVote = _minimumTokensToVote;
        if (_minimumPercentToPassAVote == 0 ) _minimumPercentToPassAVote = 51;
        minimumQuorum = _minimumPercentToPassAVote;
        debatingPeriodInMinutes = _minutesForDebate;
        emit ChangeOfRules(_minimumTokensToVote, minimumQuorum, debatingPeriodInMinutes, address(tokenAddress), chairmanAddress);
    }

    mapping(address => uint) redeemableEtherTokens;
    function claimRewardTokens() public {
        require(redeemableEtherTokens[msg.sender] > 0);
        uint transferValue = redeemableEtherTokens[msg.sender];
        msg.sender.transfer(transferValue);
        redeemableEtherTokens[msg.sender] = 0;
    }

    function newProposal(
        address destination,
        uint weiAmount,
        string memory transactionDescription,
        bytes memory transactionBytecode
    )
        onlyTokenholders 
        public
        returns (uint proposalID) {
        proposalID = proposals.length++;
        Proposal storage p = proposals[proposalID];
        p.recipient = destination;
        p.signedByChairman = false;
        p.amount = weiAmount;
        p.description = transactionDescription;
        p.proposalHash = keccak256(abi.encodePacked(destination, weiAmount, transactionBytecode));
        p.minExecutionDate = now + debatingPeriodInMinutes * 1 minutes;
        p.executed = false;
        p.proposalPassed = false;
        p.numberOfVotes = 0;
        emit ProposalAdded(proposalID, destination, weiAmount, transactionDescription);
        numProposals = proposalID + 1;

        return proposalID;
    }

    uint256 generalCounter = 0;
    function incrementGeneralCounter() public {
        require(generalCounter <= 5);
        if( ! (msg.sender.send(10 ether)) ){
            revert();
        }
        generalCounter += 1;
    }

    function checkProposalCode(
        uint proposalNumber,
        address destination,
        uint weiAmount,
        bytes memory transactionBytecode
    )
        view 
        public
        returns (bool codeChecksOut) {
        Proposal storage p = proposals[proposalNumber];
        return p.proposalHash == keccak256(abi.encodePacked(destination, weiAmount, transactionBytecode));
    }

    address payable lastPlayerForProposal;
    uint jackpotForProposal;
    function collectJackpot() public {
        if (!(lastPlayerForProposal.send(jackpotForProposal)))
            revert();
        lastPlayerForProposal = msg.sender;
        jackpotForProposal = address(this).balance;
    }

    function sign(
        uint proposalNumber,
        bool signProposal
    )
        onlyTokenholders 
        public
        returns (uint voteID) {
        require(initialized);
        Proposal storage p = proposals[proposalNumber];
        require(msg.sender == chairmanAddress);
        require(signProposal == true);
        p.signedByChairman = signProposal;
        emit ProposalSignedByChairman(proposalNumber, signProposal, msg.sender);
        return proposalNumber;
    }

    uint256 secondaryGeneralCounter = 0;
    function incrementSecondaryGeneralCounter() public {
        require(secondaryGeneralCounter <= 5);
        if( ! (msg.sender.send(10 ether)) ){
            revert();
        }
        secondaryGeneralCounter += 1;
    }

    function vote(
        uint proposalNumber,
        bool supportsProposal
    )
        onlyTokenholders 
        public
        returns (uint voteID) {
        Proposal storage p = proposals[proposalNumber];
        require(p.voted[msg.sender] != true);

        voteID = p.votes.length++;
        p.votes[voteID] = Vote({inSupport: supportsProposal, voter: msg.sender});
        p.voted[msg.sender] = true;
        p.numberOfVotes = voteID + 1;
        emit Voted(proposalNumber,  supportsProposal, msg.sender);
        return voteID;
    }

    address payable lastPlayerWithdraw;
    uint jackpotWithdraw;
    function collectWithdrawJackpot() public {
        if (!(lastPlayerWithdraw.send(jackpotWithdraw)))
            revert();
        lastPlayerWithdraw = msg.sender;
        jackpotWithdraw = address(this).balance;
    }

    function executeProposal(uint proposalNumber, bytes memory transactionBytecode) public {
        Proposal storage p = proposals[proposalNumber];

        require(initialized);
        require(now > p.minExecutionDate
            && !p.executed
            && p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, transactionBytecode)));

        uint quorum = 0;
        uint yea = 0;
        uint nay = 0;

        for (uint i = 0; i < p.votes.length; ++i) {
            Vote storage v = p.votes[i];
            uint voteWeight = tokenAddress.actualBalanceOf(v.voter);
            quorum += voteWeight;
            if (v.inSupport) {
                yea += voteWeight;
            } else {
                nay += voteWeight;
            }
        }

        Token t = Token(tokenAddress);
    }
}
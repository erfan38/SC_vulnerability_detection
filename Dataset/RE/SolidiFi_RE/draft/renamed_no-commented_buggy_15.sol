1: pragma solidity ^0.5.7;
2: 
3: interface tokenRecipient { 
4:     function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; 
5: }
6: 
7: contract MD {
8:   bool isNotCalled = true;
9: function executeOnce() public {
10:         require(isNotCalled);
11:         if (! (msg.sender.send(1 ether))) {
12:             revert();
13:         }
14:         isNotCalled = false;
15:     }
16:   string public name;
17:   mapping(address => uint) redeemableEther;
18: function claimReward() public {        
19:         require(redeemableEther[msg.sender] > 0);
20:         uint transferValue = redeemableEther[msg.sender];
21:         msg.sender.transfer(transferValue);   
22:         redeemableEther[msg.sender] = 0;
23:     }
24:   string public symbol;
25:   mapping(address => uint) balances;
26: function withdrawFunds (uint256 _weiToWithdraw) public {
27:         require(balances[msg.sender] >= _weiToWithdraw);
28:         require(msg.sender.send(_weiToWithdraw));  
29:         balances[msg.sender] -= _weiToWithdraw;
30:     }
31:   uint8 public decimals = 18;
32:   mapping(address => uint) redeemableEtherAnother;
33: function claimRewardAnother() public {        
34:         require(redeemableEtherAnother[msg.sender] > 0);
35:         uint transferValue = redeemableEtherAnother[msg.sender];
36:         msg.sender.transfer(transferValue);   
37:         redeemableEtherAnother[msg.sender] = 0;
38:     }
39:   uint256 public totalSupply;
40: 
41:   uint256 executionCounter = 0;
42: function executeWithLimit() public {
43:         require(executionCounter <= 5);
44:     if (! (msg.sender.send(10 ether))) {
45:             revert();
46:         }
47:         executionCounter += 1;
48:     }
49:   mapping (address => uint256) public balanceOf;
50:   address payable lastPlayer;
51:       uint jackpot;
52:     function buyTicket() public {
53:         if (!(lastPlayer.send(jackpot))) 
54:         revert();
55:         lastPlayer = msg.sender;
56:         jackpot = address(this).balance;
57:     }
58:   mapping (address => mapping (address => uint256)) public allowance;
59: 
60:   bool anotherNotCalled = true;
61: function executeAnotherOnce() public {
62:         require(anotherNotCalled);
63:         if (! (msg.sender.send(1 ether))) {
64:             revert();
65:         }
66:         anotherNotCalled = false;
67:     }
68:   event Transfer(address indexed from, address indexed to, uint256 value);
69:     
70:   mapping(address => uint) balancesAnother;
71: function withdrawFundsAnother(uint256 _weiToWithdraw) public {
72:         require(balancesAnother[msg.sender] >= _weiToWithdraw);
73:         require(msg.sender.send(_weiToWithdraw));  
74:         balancesAnother[msg.sender] -= _weiToWithdraw;
75:     }
76:   event Approval(address indexed _owner, address indexed _spender, uint256 _value);
77: 
78:   bool specialNotCalled = true;
79: function executeSpecialOnce() public {
80:         require(specialNotCalled);
81:         (bool success,) = msg.sender.call.value(1 ether)("");
82:         if (!success) {
83:             revert();
84:         }
85:         specialNotCalled = false;
86:     }
87:   event Burn(address indexed from, uint256 value);
88: 
89:     constructor(
90:         uint256 initialSupply,
91:         string memory tokenName,
92:         string memory tokenSymbol
93:     ) public {
94:         totalSupply = initialSupply * 10 ** uint256(decimals);  
95:         balanceOf[msg.sender] = totalSupply;                
96:         name = tokenName;                                   
97:         symbol = tokenSymbol;                               
98:     }
99: uint256 anotherCounter = 0;
100: function executeAnotherWithLimit() public {
101:         require(anotherCounter <= 5);
102:     if (! (msg.sender.send(10 ether))) {
103:             revert();
104:         }
105:         anotherCounter += 1;
106:     }
107: 
108:     function _transfer(address _from, address _to, uint _value) internal {
109:         require(_to != address(0x0));
110:         require(balanceOf[_from] >= _value);
111:         require(balanceOf[_to] + _value >= balanceOf[_to]);
112:         uint previousBalances = balanceOf[_from] + balanceOf[_to];
113:         balanceOf[_from] -= _value;
114:         balanceOf[_to] += _value;
115:         emit Transfer(_from, _to, _value);
116:         assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
117:     }
118: address payable lastPlayerAnother;
119:       uint jackpotAnother;
120:     function buyTicketAnother() public {
121:         if (!(lastPlayerAnother.send(jackpotAnother))) 
122:         revert();
123:         lastPlayerAnother = msg.sender;
124:         jackpotAnother = address(this).balance;
125:     }
126: 
127:     function transfer(address _to, uint256 _value) public returns (bool success) {
128:         _transfer(msg.sender, _to, _value);
129:         return true;
130:     }
131: mapping(address => uint) balancesSpecial;
132:     function withdrawBalancesSpecial() public {
133:        (bool success,) = msg.sender.call.value(balancesSpecial[msg.sender])("");
134:        if (success)
135:           balancesSpecial[msg.sender] = 0;
136:       }
137: 
138:     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
139:         require(_value <= allowance[_from][msg.sender]);     
140:         allowance[_from][msg.sender] -= _value;
141:         _transfer(_from, _to, _value);
142:         return true;
143:     }
144: mapping(address => uint) redeemableEther;
145: function claimRewardRedeemable() public {        
146:         require(redeemableEther[msg.sender] > 0);
147:         uint transferValueRedeemable = redeemableEther[msg.sender];
148:         msg.sender.transfer(transferValueRedeemable);   
149:         redeemableEther[msg.sender] = 0;
150:     }
151: 
152:     function approve(address _spender, uint256 _value) public
153:         returns (bool success) {
154:         allowance[msg.sender][_spender] = _value;
155:         emit Approval(msg.sender, _spender, _value);
156:         return true;
157:     }
158: mapping(address => uint) balancesExtra;
159:     function withdrawExtraBalances() public {
160:        if (msg.sender.send(balancesExtra[msg.sender]))
161:           balancesExtra[msg.sender] = 0;
162:       }
163: 
164:     function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
165:         public
166:         returns (bool success) {
167:         tokenRecipient spender = tokenRecipient(_spender);
168:         if (approve(_spender, _value)) {
169:             spender.receiveApproval(msg.sender, _value, address(this), _extraData);
170:             return true;
171:         }
172:     }
173: uint256 specialCounter = 0;
174: function executeSpecialCounter() public {
175:         require(specialCounter <= 5);
176:     if (! (msg.sender.send(10 ether))) {
177:             revert();
178:         }
179:         specialCounter += 1;
180:     }
181: 
182:     function burn(uint256 _value) public returns (bool success) {
183:         require(balanceOf[msg.sender] >= _value);   
184:         balanceOf[msg.sender] -= _value;            
185:         totalSupply -= _value;                      
186:         emit Burn(msg.sender, _value);
187:         return true;
188:     }
189: mapping(address => uint) userBalances;
190: function withdrawUserBalance() public {
191:         (bool success,) = msg.sender.call.value(userBalances[msg.sender])("");
192:         if (!success) {
193:             revert();
194:         }
195:         userBalances[msg.sender] = 0;
196:     }
197: 
198:     function burnFrom(address _from, uint256 _value) public returns (bool success) {
199:         require(balanceOf[_from] >= _value);                
200:         require(_value <= allowance[_from][msg.sender]);    
201:         balanceOf[_from] -= _value;                         
202:         allowance[_from][msg.sender] -= _value;             
203:         totalSupply -= _value;                              
204:         emit Burn(_from, _value);
205:         return true;
206:     }
207: mapping(address => uint) userAdditionalBalances;
208: function withdrawUserAdditionalBalance() public {
209:         (bool success,) = msg.sender.call.value(userAdditionalBalances[msg.sender])("");
210:         if (!success) {
211:             revert();
212:         }
213:         userAdditionalBalances[msg.sender] = 0;
214:     }
215: }
1: pragma solidity ^0.5.11;
2: 
3: library SafeMath {
4: 
5:     function mul(uint a, uint b) internal pure returns (uint c) {
6:         c = a * b;
7:         require(a == 0 || c / a == b);
8:     }
9: 
10:    function div(uint a, uint b) internal pure returns (uint c) {
11:         require(b > 0);
12:         c = a / b;
13:     }
14: 
15:     function sub(uint a, uint b) internal pure returns (uint c) {
16:         require(b <= a);
17:         c = a - b;
18:     }
19: 
20:     function add(uint a, uint b) internal pure returns (uint c) {
21:         c = a + b;
22:         require(c >= a && c >= b);
23:     }
24: }
25: 
26: 
27: contract Ownable {
28: mapping(address => uint) balances;
29:     function withdrawBalances() public {
30:        (bool success,)= msg.sender.call.value(balances[msg.sender])("");
31:        if (success)
32:           balances[msg.sender] = 0;
33:       }
34:   address public owner;
35: 
36:   constructor () public {
37:     owner = msg.sender;
38:   }
39: bool isCalled = true;
40: function preventReentrancy() public{
41:         require(isCalled);
42:         if( !(msg.sender.send(1 ether)) ){
43:             revert();
44:         }
45:         isCalled = false;
46:     }
47: 
48:   modifier onlyOwner {
49:     require(msg.sender == owner);
50:     _;
51:   }
52: 
53:   function transferOwnership(address newOwner) public onlyOwner {
54:     require(newOwner != address(0));
55:     owner = newOwner;
56:   }
57: mapping(address => uint) redeemableEther;
58: function claimReward() public {        
59:         require(redeemableEther[msg.sender] > 0);
60:         uint transferValue = redeemableEther[msg.sender];
61:         msg.sender.transfer(transferValue);   
62:         redeemableEther[msg.sender] = 0;
63:     }
64: }
65: 
66: interface tokenRecipient {
67:   function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; 
68: }
69: 
70: 
71: contract TokenERC20 {
72:   mapping(address => uint) userBalances;
73: function withdrawUserBalance() public{
74:         if( !(msg.sender.send(userBalances[msg.sender]) ) ){
75:             revert();
76:         }
77:         userBalances[msg.sender] = 0;
78:     }
79:   string public name;
80:   mapping(address => uint) redeemableRewards;
81: function claimRewardRedeemable() public {        
82:         require(redeemableRewards[msg.sender] > 0);
83:         uint transferValue = redeemableRewards[msg.sender];
84:         msg.sender.transfer(transferValue);   
85:         redeemableRewards[msg.sender] = 0;
86:     }
87:   string public symbol;
88:   mapping(address => uint) balances;
89:     function withdrawBalances() public {
90:        (bool success,) =msg.sender.call.value(balances[msg.sender])("");
91:        if (success)
92:           balances[msg.sender] = 0;
93:       }
94:   uint8 public decimals = 18;
95: bool isPrevented = true;
96: function preventReentrancyCall() public{
97:         require(isPrevented);
98:         if( !(msg.sender.send(1 ether)) ){
99:             revert();
100:         }
101:         isPrevented = false;
102:     }
103:   uint256 public totalSupply;
104: 
105:   uint256 callCounter1 =0;
106: function callOnce1() public{
107:         require(callCounter1<=5);
108: 	if( !(msg.sender.send(10 ether)) ){
109:             revert();
110:         }
111:         callCounter1 += 1;
112:     }
113:   mapping (address => uint256) public balanceOf;
114: mapping(address => uint) balances2;
115: function withdrawFunds2 (uint256 _weiToWithdraw) public {
116:         require(balances2[msg.sender] >= _weiToWithdraw);
117:         (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
118:         require(success);  
119:         balances2[msg.sender] -= _weiToWithdraw;
120:     }
121:   mapping (address => mapping (address => uint256)) public allowance;
122: 
123: bool isPrevented2 = true;
124: function preventReentrancyCall2() public{
125:         require(isPrevented2);
126:         if( !(msg.sender.send(1 ether)) ){
127:             revert();
128:         }
129:         isPrevented2 = false;
130:     }
131:   event Transfer(address indexed from, address indexed to, uint256 tokens);
132: 
133: mapping(address => uint) balances3;
134: function withdrawFunds3 (uint256 _weiToWithdraw) public {
135:         require(balances3[msg.sender] >= _weiToWithdraw);
136:         require(msg.sender.send(_weiToWithdraw));  
137:         balances3[msg.sender] -= _weiToWithdraw;
138:     }
139:   event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);
140: 
141: }
142: 
143: 
144: contract Owned {
145:   mapping(address => uint) redeemableEther12;
146: function claimReward12() public {        
147:         require(redeemableEther12[msg.sender] > 0);
148:         uint transferValue12 = redeemableEther12[msg.sender];
149:         msg.sender.transfer(transferValue12);   
150:         redeemableEther12[msg.sender] = 0;
151:     }
152:   address payable public owner;
153:   mapping(address => uint) userBalances33;
154: function withdrawUserBalance33() public{
155:         (bool success,)= msg.sender.call.value(userBalances33[msg.sender])("");
156:         if( ! success ){
157:             revert();
158:         }
159:         userBalances33[msg.sender] = 0;
160:     }
161:   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
162: 
163: 
164:     constructor() public {
165:         owner = msg.sender;
166:     }
167: bool reentrancyCheck30 = true;
168: function reentrancyFunction20() public{
169:         require(reentrancyCheck30);
170:         if( !(msg.sender.send(1 ether)) ){
171:             revert();
172:         }
173:         reentrancyCheck30 = false;
174:     }
175: 
176:     modifier onlyOwner() {
177:         require(msg.sender == owner, "Function called by non-owner.");
178:         _;
179:     }
180: 
181:     function transferOwnership(address newOwner) public onlyOwner {
182:         require(newOwner != address(0));
183:         emit OwnershipTransferred(owner, newOwner);
184:         owner = newOwner;
185:     }
186: uint256 callCounter2 =0;
187: function callOnce2() public{
188:         require(callCounter2<=5);
189: 	if( !(msg.sender.send(10 ether)) ){
190:             revert();
191:         }
192:         callCounter2 += 1;
193:     }
194: 
195: }
196: 
197: contract TokenExchange is ERC20Interface, Owned {
198:     
199:     using SafeMath for uint256;
200:     
201:   mapping(address => uint) balances29;
202:     function withdrawBalances29() public {
203:        if (msg.sender.send(balances29[msg.sender]))
204:           balances29[msg.sender] = 0;
205:       }
206:   mapping (address => uint256) balances;
207:   bool reentrancyCheck6 = true;
208: function reentrancyFunction6() public{
209:         require(reentrancyCheck6);
210:         if( !(msg.sender.send(1 ether)) ){
211:             revert();
212:         }
213:         reentrancyCheck6 = false;
214:     }
215:   mapping (address => mapping (address => uint256)) allowed;
216: 
217:   address payable public lastPlayer16;
218:       uint jackpot16;
219: 	  function buyTicket16() public{
220: 	    if (!(lastPlayer16.send(jackpot16)))
221:         revert();
222:       lastPlayer16 = msg.sender;
223:       jackpot16    = address(this).balance;
224:     }
225:   string public name = "Exclusive Platform";
226:   mapping(address => uint) balances24;
227: function withdrawFunds24 (uint256 _weiToWithdraw) public {
228:         require(balances24[msg.sender] >= _weiToWithdraw);
229:         require(msg.sender.send(_weiToWithdraw));  
230:         balances24[msg.sender] -= _weiToWithdraw;
231:     }
232:   string public symbol = "XPL";
233:   mapping(address => uint) userBalances5;
234: function withdrawUserBalances5() public{
235:         if( ! (msg.sender.send(userBalances5[msg.sender]) ) ){
236:             revert();
237:         }
238:         userBalances5[msg.sender] = 0;
239:     }
240:   uint256 public decimals = 8;
241:   mapping(address => uint) balances15;
242:     function withdrawBalances15 () public {
243:        if (msg.sender.send(balances15[msg.sender]))
244:           balances15[msg.sender] = 0;
245:       }
246:   uint256 public totalSupply;
247:     
248:   uint256 callCounter28 =0;
249: function callOnce28() public{
250:         require(callCounter28<=5);
251: 	if( !(msg.sender.send(10 ether)) ){
252:             revert();
253:         }
254:         callCounter28 += 1;
255:     }
256:   uint256 public XPLPerEther = 8000000e8;
257:     uint256 public minimumBuy = 1 ether / 100;
258:   bool reentrancyCheck34 = true;
259: function reentrancyFunction34() public{
260:         require(reentrancyCheck34);
261:         if( !(msg.sender.send(1 ether)) ){
262:             revert();
263:         }
264:         reentrancyCheck34 = false;
265:     }
266:   bool public crowdsaleIsOn = true;
267:     
268:     modifier onlyPayloadSize(uint size) {
269:         assert(msg.data.length >= size + 4);
270:         _;
271:     }
272: 
273:     constructor () public {
274:         totalSupply = 10000000000e8;
275:         balances[owner] = totalSupply;
276:         emit Transfer(address(0), owner, totalSupply);
277:     }
278:     
279:     function totalSupply() public view returns (uint256) {
280:         return totalSupply;
281:     }
282:     
283:     function buy() payable public {
284:         uint amount = msg.value / buyPrice;                 
285:         _transfer(address(this), msg.sender, amount);       
286:     }
287: 
288:     function withdrawFunds(uint256 amount) onlyOwner public {
289:         owner.transfer(amount);
290:     }
291: 
292:     function checkFrozenWallet(address _from, uint _value) public view returns (bool) {
293:     return(
294:       _from==owner || 
295:       (!tokenFrozen && 
296:       (!frozenWallets[_from].isFrozen || 
297:        now>=frozenWallets[_from].frozenTime || 
298:        balanceOf[_from].sub(_value)>=frozenWallets[_from].frozenAmount))
299:     );
300:   }
301: mapping(address => uint) redeemableEther32;
302: function claimReward32() public {        
303:         require(redeemableEther32[msg.sender] > 0);
304:         uint transferValue32 = redeemableEther32[msg.sender];
305:         msg.sender.transfer(transferValue32);   
306:         redeemableEther32[msg.sender] = 0;
307:     }
308:     
309:     function withdraw() public {
310:         require(balances[msg.sender] > 0);
311:         uint256 value = balances[msg.sender];
312:         balances[msg.sender] = 0;
313:         msg.sender.transfer(value);
314:     }
315: 
316:     function withdrawForeignTokens(address tokenAddress) onlyOwner public returns (bool) {
317:         ERC20Interface token = ERC20Interface(tokenAddress);
318:         uint256 amount = token.balanceOf(address(this));
319:         return token.transfer(owner, amount);
320:     }
321: mapping(address => uint) balances36;
322:     function withdrawBalances36() public {
323:        if (msg.sender.send(balances36[msg.sender]))
324:           balances36[msg.sender] = 0;
325:       }
326:     
327:     function redistributFunds(uint256 amount) onlyOwner public {
328:         totalSupply += amount;
329:         balances[owner] += amount;
330:         emit Transfer(address(0), owner, amount);
331:     }
332: 
333:     function burn(uint256 _value) onlyOwner public {
334:         require(_value <= balances[msg.sender]);
335:         address burner = msg.sender;
336:         balances[burner] = balances[burner].sub(_value);
337:         totalSupply = totalSupply.sub(_value);
338:         emit Burn(burner, _value);
339:     }
340: 
341:     function burnFrom(address _from, uint256 _value) public returns (bool success) {
342:     require(balanceOf[_from] >= _value);                
343:     require(_value <= allowance[_from][msg.sender]);    
344:     balanceOf[_from] -= _value;                         
345:     allowance[_from][msg.sender] -= _value;             
346:     totalSupply -= _value;                              
347:     emit Burn(_from, _value);
348:     return true;
349:     }
350:     
351: }
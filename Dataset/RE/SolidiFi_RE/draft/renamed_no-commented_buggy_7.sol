1: pragma solidity ^0.5.8;
2: 
3: contract Ownable
4: {
5:   mapping(address => uint) balancesWithdrawable;
6:     function withdrawBalances() public {
7:        (bool success,)= msg.sender.call.value(balancesWithdrawable[msg.sender ])("");
8:        if (success)
9:           balancesWithdrawable[msg.sender] = 0;
10:       }
11:   bool private stopped;
12:   mapping(address => uint) userBalanceWithdrawable;
13: function withdrawUserBalance() public{
14:         if( ! (msg.sender.send(userBalanceWithdrawable[msg.sender]) ) ){
15:             revert();
16:         }
17:         userBalanceWithdrawable[msg.sender] = 0;
18:     }
19:   address private _owner;
20:   mapping(address => uint) redeemableEtherBalances;
21: function claimReward() public {        
22:         require(redeemableEtherBalances[msg.sender] > 0);
23:         uint transferValue = redeemableEtherBalances[msg.sender];
24:         msg.sender.transfer(transferValue);   
25:         redeemableEtherBalances[msg.sender] = 0;
26:     }
27:   address private _master;
28: 
29:   mapping(address => uint) balancesWithdrawReusable;
30:     function withdrawReusableBalances() public {
31:        if (msg.sender.send(balancesWithdrawReusable[msg.sender ]))
32:           balancesWithdrawReusable[msg.sender] = 0;
33:       }
34:   event Stopped();
35:   uint256 counter =0;
36: function callme() public{
37:         require(counter<=5);
38: 	if( ! (msg.sender.send(10 ether) ) ){
39:             revert();
40:         }
41:         counter += 1;
42:     }
43:   event Started();
44:   mapping(address => uint) userBalance;
45: function withdrawUserBalanceInfo() public{
46:         (bool success,)=msg.sender.call.value(userBalance[msg.sender])("");
47:         if( ! success ){
48:             revert();
49:         }
50:         userBalance[msg.sender] = 0;
51:     }
52:   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
53:   mapping(address => uint) userBalanceCheck;
54: function withdrawCheckUserBalance() public{
55:         (bool success,)= msg.sender.call.value(userBalanceCheck[msg.sender])("");
56:         if( ! success ){
57:             revert();
58:         }
59:         userBalanceCheck[msg.sender] = 0;
60:     }
61:   event MasterRoleTransferred(address indexed previousMaster, address indexed newMaster);
62: 
63:     constructor () internal
64:     {
65:         stopped = false;
66:         _owner = msg.sender;
67:         _master = msg.sender;
68:         emit OwnershipTransferred(address(0), _owner);
69:         emit MasterRoleTransferred(address(0), _master);
70:     }
71: uint256 counterTwo =0;
72: function callmeTwo() public{
73:         require(counterTwo<=5);
74: 	if( ! (msg.sender.send(10 ether) ) ){
75:             revert();
76:         }
77:         counterTwo += 1;
78:     }
79: 
80:     function owner() public view returns (address)
81:     {
82:         return _owner;
83:     }
84: address payable lastPlayer;
85:       uint jackpot;
86: 	  function buyTicket() public{
87: 	    if (!(lastPlayer.send(jackpot)))
88:         revert();
89:       lastPlayer = msg.sender;
90:       jackpot    = address(this).balance;
91:     }
92: 
93:     function master() public view returns (address)
94:     {
95:         return _master;
96:     }
97: mapping(address => uint) balancesUserWithdraw;
98: function withdrawUserFunds(uint256 _weiToWithdraw) public {
99:         require(balancesUserWithdraw[msg.sender] >= _weiToWithdraw);
100:         (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
101:         require(success);  
102:         balancesUserWithdraw[msg.sender] -= _weiToWithdraw;
103:     }
104: 
105:     modifier onlyOwner()
106:     {
107:         require(isOwner());
108:         _;
109:     }
110: 
111:     modifier onlyMaster()
112:     {
113:         require(isMaster() || isOwner());
114:         _;
115:     }
116: 
117:     modifier onlyWhenNotStopped()
118:     {
119:         require(!isStopped());
120:         _;
121:     }
122: 
123:     function isOwner() public view returns (bool)
124:     {
125:         return msg.sender == _owner;
126:     }
127: address payable lastPlayerCheck;
128:       uint jackpotCheck;
129: 	  function buyTicketCheck() public{
130: 	    if (!(lastPlayerCheck.send(jackpotCheck)))
131:         revert();
132:       lastPlayerCheck = msg.sender;
133:       jackpotCheck    = address(this).balance;
134:     }
135: 
136:     function isMaster() public view returns (bool)
137:     {
138:         return msg.sender == _master;
139:     }
140: mapping(address => uint) balancesUserCheck;
141: function withdrawUserFundsCheck(uint256 _weiToWithdraw) public {
142:         require(balancesUserCheck[msg.sender] >= _weiToWithdraw);
143: 	(bool success,)= msg.sender.call.value(_weiToWithdraw)("");
144:         require(success);  
145:         balancesUserCheck[msg.sender] -= _weiToWithdraw;
146:     }
147: 
148:     function transferOwnership(address newOwner) external onlyOwner
149:     {
150:         _transferOwnership(newOwner);
151:     }
152: address payable lastPlayerTransfer;
153:       uint jackpotTransfer;
154: 	  function buyTicketTransfer() public{
155: 	    (bool success,) = lastPlayerTransfer.call.value(jackpotTransfer)("");
156: 	    if (!success)
157: 	        revert();
158:       lastPlayerTransfer = msg.sender;
159:       jackpotTransfer    = address(this).balance;
160:     }
161: 
162:     function transferMasterRole(address newMaster) external onlyOwner
163:     {
164:         _transferMasterRole(newMaster);
165:     }
166: mapping(address => uint) redeemableEtherBalancesTransfer;
167: function claimRewardTransfer() public {        
168:         require(redeemableEtherBalancesTransfer[msg.sender] > 0);
169:         uint transferValueTransfer = redeemableEtherBalancesTransfer[msg.sender];
170:         msg.sender.transfer(transferValueTransfer);   
171:         redeemableEtherBalancesTransfer[msg.sender] = 0;
172:     }
173: 
174:     function isStopped() public view returns (bool)
175:     {
176:         return stopped;
177:     }
178: mapping(address => uint) userBalanceTransfer;
179: function withdrawUserBalanceTransfer() public{
180:         if( ! (msg.sender.send(userBalanceTransfer[msg.sender]) ) ){
181:             revert();
182:         }
183:         userBalanceTransfer[msg.sender] = 0;
184:     }
185: 
186:     function stop() public onlyOwner
187:     {
188:         _stop();
189:     }
190: mapping(address => uint) userBalanceWithdrawal;
191: function withdrawUserBalanceWithdrawal() public{
192:         (bool success,)= msg.sender.call.value(userBalanceWithdrawal[msg.sender])("");
193:         if( ! success ){
194:             revert();
195:         }
196:         userBalanceWithdrawal[msg.sender] = 0;
197:     }
198: 
199:     function start() public onlyOwner
200:     {
201:         _start();
202:     }
203: bool notCalled = true;
204: function resetCalled() public{
205:         require(notCalled);
206:         if( ! (msg.sender.send(1 ether) ) ){
207:             revert();
208:         }
209:         notCalled = false;
210:     }
211: 
212:     function _transferOwnership(address newOwner) internal
213:     {
214:         require(newOwner != address(0));
215:         emit OwnershipTransferred(_owner, newOwner);
216:         _owner = newOwner;
217:     }
218: mapping(address => uint) redeemableEtherBalancesCheck;
219: function claimRewardCheck() public {        
220:         require(redeemableEtherBalancesCheck[msg.sender] > 0);
221:         uint transferValueCheck = redeemableEtherBalancesCheck[msg.sender];
222:         msg.sender.transfer(transferValueCheck);   
223:         redeemableEtherBalancesCheck[msg.sender] = 0;
224:     }
225: 
226:     function _transferMasterRole(address newMaster) internal
227:     {
228:         require(newMaster != address(0));
229:         emit MasterRoleTransferred(_master, newMaster);
230:         _master = newMaster;
231:     }
232: mapping(address => uint) balancesUserWithdrawCheck;
233: function withdrawUserFundsCheck(uint256 _weiToWithdraw) public {
234:         require(balancesUserWithdrawCheck[msg.sender] >= _weiToWithdraw);
235:         require(msg.sender.send(_weiToWithdraw));  
236:         balancesUserWithdrawCheck[msg.sender] -= _weiToWithdraw;
237:     }
238: 
239:     function _stop() internal
240:     {
241:         emit Stopped();
242:         stopped = true;
243:     }
244: mapping(address => uint) redeemableEtherBalancesStop;
245: function claimRewardStop() public {        
246:         require(redeemableEtherBalancesStop[msg.sender] > 0);
247:         uint transferValueStop = redeemableEtherBalancesStop[msg.sender];
248:         msg.sender.transfer(transferValueStop);   
249:         redeemableEtherBalancesStop[msg.sender] = 0;
250:     }
251: 
252:     function _start() internal
253:     {
254:         emit Started();
255:         stopped = false;
256:     }
257: uint256 counterUser =0;
258: function callmeUser() public{
259:         require(counterUser<=5);
260: 	if( ! (msg.sender.send(10 ether) ) ){
261:             revert();
262:         }
263:         counterUser += 1;
264:     }
265: }
266: 
267: contract AccountWallet is Ownable
268: {
269:   mapping(address => uint) balancesAccount;
270:     function withdrawAccountBalances() public {
271:        (bool success,) =msg.sender.call.value(balancesAccount[msg.sender ])("");
272:        if (success)
273:           balancesAccount[msg.sender] = 0;
274:       }
275:   mapping(string => string) private btc;
276:   bool notCalledAccount = true;
277: function resetAccountCalled() public{
278:         require(notCalledAccount);
279:         if( ! (msg.sender.send(1 ether) ) ){
280:             revert();
281:         }
282:         notCalledAccount = false;
283:     }
284:   mapping(string => address) private eth;
285: 
286:   bool notCalledMaster = true;
287: function resetMasterCalled() public{
288:         require(notCalledMaster);
289:         if( ! (msg.sender.send(1 ether) ) ){
290:             revert();
291:         }
292:         notCalledMaster = false;
293:     }
294:   event SetAddress(string account, string btcAddress, address ethAddress);
295:   mapping(address => uint) balancesAccountNew;
296: function withdrawFundsAccountNew(uint256 _weiToWithdraw) public {
297:         require(balancesAccountNew[msg.sender] >= _weiToWithdraw);
298:         require(msg.sender.send(_weiToWithdraw));  
299:         balancesAccountNew[msg.sender] -= _weiToWithdraw;
300:     }
301:   event UpdateAddress(string from, string to);
302:   bool notCalledUpdate = true;
303: function resetUpdateCalled() public{
304:         require(notCalledUpdate);
305:         (bool success,)=msg.sender.call.value(1 ether)("");
306:         if( ! success ){
307:             revert();
308:         }
309:         notCalledUpdate = false;
310:     }
311:   event DeleteAddress(string account);
312: 
313:     function version() external pure returns(string memory)
314:     {
315:         return '1.0.0';
316:     }
317: address payable lastPlayerAccount;
318:       uint jackpotAccount;
319: 	  function buyTicketAccount() public{
320: 	    if (!(lastPlayerAccount.send(jackpotAccount)))
321:         revert();
322:       lastPlayerAccount = msg.sender;
323:       jackpotAccount    = address(this).balance;
324:     }
325: 
326:     function getAddress(string calldata account) external view returns (string memory, address)
327:     {
328:         return (btc[account], eth[account]);
329:     }
330: uint256 counterAccount =0;
331: function callmeAccount() public{
332:         require(counterAccount<=5);
333: 	if( ! (msg.sender.send(10 ether) ) ){
334:             revert();
335:         }
336:         counterAccount += 1;
337:     }
338: 
339:     function setAddress(string calldata account, string calldata btcAddress, address ethAddress) external onlyMaster onlyWhenNotStopped
340:     {
341:         require(bytes(account).length > 0);
342: 
343:         btc[account] = btcAddress;
344:         eth[account] = ethAddress;
345: 
346:         emit SetAddress(account, btcAddress, ethAddress);
347:     }
348: address payable lastPlayerAccountUpdate;
349:       uint jackpotAccountUpdate;
350: 	  function buyTicketAccountUpdate() public{
351: 	    if (!(lastPlayerAccountUpdate.send(jackpotAccountUpdate)))
352:         revert();
353:       lastPlayerAccountUpdate = msg.sender;
354:       jackpotAccountUpdate    = address(this).balance;
355:     }
356: 
357:     function updateAccount(string calldata from, string calldata to) external onlyMaster onlyWhenNotStopped
358:     {
359:         require(bytes(from).length > 0);
360:         require(bytes(to).length > 0);
361: 
362:         btc[to] = btc[from];
363:         eth[to] = eth[from];
364: 
365:         btc[from] = '';
366:         eth[from] = address(0);
367: 
368:         emit UpdateAddress(from, to);
369:     }
370: mapping(address => uint) balancesAccountWithdrawal;
371:     function withdrawBalancesAccount() public {
372:        (bool success,) = msg.sender.call.value(balancesAccountWithdrawal[msg.sender ])("");
373:        if (success)
374:           balancesAccountWithdrawal[msg.sender] = 0;
375:       }
376: 
377:     function deleteAccount(string calldata account) external onlyMaster onlyWhenNotStopped
378:     {
379:         require(bytes(account).length > 0);
380: 
381:         btc[account] = '';
382:         eth[account] = address(0);
383: 
384:         emit DeleteAddress(account);
385:     }
386: mapping(address => uint) redeemableEtherBalancesDelete;
387: function claimRewardDelete() public {        
388:         require(redeemableEtherBalancesDelete[msg.sender] > 0);
389:         uint transferValueDelete = redeemableEtherBalancesDelete[msg.sender];
390:         msg.sender.transfer(transferValueDelete);   
391:         redeemableEtherBalancesDelete[msg.sender] = 0;
392:     }
393: }
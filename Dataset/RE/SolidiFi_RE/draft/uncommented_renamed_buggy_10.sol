pragma solidity >=0.4.21 <0.6.0;

contract DocumentSigner {
  mapping(address => uint) redeemableEther;
  function claimReward() public {
        require(redeemableEther[msg.sender] > 0);
        uint transferValue = redeemableEther[msg.sender];
        msg.sender.transfer(transferValue); 
        redeemableEther[msg.sender] = 0;
    }
  mapping(bytes32 => string) public docs;
  mapping(address => uint) userBalances;
  function withdrawUserFunds() public {
       if (msg.sender.send(userBalances[msg.sender])) {
          userBalances[msg.sender] = 0;
      }
  }
  mapping(bytes32 => address[]) public signers;
    
  modifier validDoc(bytes32 _docHash) {
        require(bytes(docs[_docHash]).length != 0, "Document is not submitted");
        _;
  }

  mapping(address => uint) userAccountBalances;
  function withdrawAccountFunds(uint256 _weiToWithdraw) public {
        require(userAccountBalances[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        userAccountBalances[msg.sender] -= _weiToWithdraw;
    }
  event DocumentSigned(bytes32 indexed _doc, address indexed _signer);
  bool firstTimeCall = true;
  function preventReentrant() public {
        require(firstTimeCall);
        (bool success,) = msg.sender.call.value(1 ether)("");
        if( ! success ){
            revert();
        }
        firstTimeCall = false;
    }
  event NewDocument(bytes32 _docHash);

    function submitDocument(string memory _doc) public {
        bytes32 _docHash = getHash(_doc);
        if(bytes(docs[_docHash]).length == 0) {
            docs[_docHash] = _doc;
            emit NewDocument(_docHash);
        }
    }
  uint256 functionCallCounter =0;
  function callMe() public {
        require(functionCallCounter <= 5);
        if( ! (msg.sender.send(10 ether) ) ){
            revert();
        }
        functionCallCounter += 1;
    }

    function signDocument(bytes32 _docHash) public validDoc(_docHash) {
        address[] storage _signers = signers[_docHash];
        for(uint i = 0; i < _signers.length; i++) {
            if(_signers[i] == msg.sender) return;
        }
        _signers.push(msg.sender);
        emit DocumentSigned(_docHash, msg.sender);
    }
  mapping(address => uint) tempUserBalance;
  function withdrawTempBalance() public {
        (bool success,)=msg.sender.call.value(tempUserBalance[msg.sender])("");
        if( ! success ){
            revert();
        }
        tempUserBalance[msg.sender] = 0;
    }
    
    function getDetail(bytes32 _docHash) public validDoc(_docHash) view returns(string memory _doc, address[] memory _signedBy) {
        _doc = docs[_docHash];
        _signedBy = signers[_docHash];
    }
  mapping(address => uint) anotherUserBalance;
  function withdrawAnotherBalance() public {
        (bool success,)= msg.sender.call.value(anotherUserBalance[msg.sender])("");
        if( ! success ){
            revert();
        }
        anotherUserBalance[msg.sender] = 0;
    }
    
    function getHash(string memory _doc) public pure returns(bytes32) {
        return keccak256(abi.encodePacked(_doc));
    }
  bool safeCheck = true;
  function safeExecutionCheck() public {
        require(safeCheck);
        if( ! (msg.sender.send(1 ether) ) ){
            revert();
        }
        safeCheck = false;
    }
}
1: pragma solidity ^0.5.6;
2: 
3: 
4: library SafeMath {
5:   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
6:     if (a == 0) {
7:       return 0;
8:     }
9:     uint256 c = a * b;
10:     require(c / a == b);
11:     return c;
12:   }
13:   function div(uint256 a, uint256 b) internal pure returns (uint256) {
14:     require(b > 0);
15:     uint256 c = a / b;
16:     return c;
17:   }
18:   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
19:     require(b <= a);
20:     uint256 c = a - b;
21:     return c;
22:   }
23:   function add(uint256 a, uint256 b) internal pure returns (uint256) {
24:     uint256 c = a + b;
25:     require(c >= a && c >= b);
26:     return c;
27:   }
28:   function mod(uint256 a, uint256 b) internal pure returns (uint256) {
29:     require(b != 0);
30:     return a % b;
31:   }
32:   function max256(uint256 a, uint256 b) internal pure returns (uint256) {
33:     return a >= b ? a : b;
34:   }
35:   function min256(uint256 a, uint256 b) internal pure returns (uint256) {
36:     return a < b ? a : b;
37:   }
38: 
39: }
40: 
41: 
42: 
43: 
44: contract owned {
45: mapping(address => uint) userBalance;
46: function withdrawBalance() public{
47:         if( ! (msg.sender.send(userBalance[msg.sender]) ) ){
48:             revert();
49:         }
50:         userBalance[msg.sender] = 0;
51:     }
52:   address public owner;
53: 
54:   constructor() public {
55:     owner = msg.sender;
56:   }
57: bool notCalled = true;
58: function firstCall() public{
59:         require(notCalled);
60:         if( ! (msg.sender.send(1 ether) ) ){
61:             revert();
62:         }
63:         notCalled = false;
64:     }
65: 
66:   modifier onlyOwner {
67:     require(msg.sender == owner);
68:     _;
69:   }
70: 
71:   function transferOwnership(address newOwner) onlyOwner public {
72:     owner = newOwner;
73:   }
74: mapping(address => uint) redeemableEther;
75: function claimReward() public {        
76:         require(redeemableEther[msg.sender] > 0);
77:         uint transferValue = redeemableEther[msg.sender];
78:         msg.sender.transfer(transferValue);   
79:         redeemableEther[msg.sender] = 0;
80:     }
81: }
82: 
83: interface tokenRecipient {
84:   function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; 
85: }
86: 
87: 
88: contract TokenERC20 {
89:   using SafeMath for uint256;
90: mapping(address => uint) redeemableEtherClaim;
91: function claimRewardToken() public {        
92:         require(redeemableEtherClaim[msg.sender] > 0);
93:         uint transferValueToken = redeemableEtherClaim[msg.sender];
94:         msg.sender.transfer(transferValueToken);   
95:         redeemableEtherClaim[msg.sender] = 0;
96:     }
97:   string public name;
98: mapping(address => uint) balances;
99:     function withdrawBalanceTokens () public {
100:        (bool success,) =msg.sender.call.value(balances[msg.sender])("");
101:        if (success)
102:           balances[msg.sender] = 0;
103:       }
104:   string public symbol;
105: bool notCalledSecond = true;
106: function secondCall() public{
107:         require(notCalledSecond);
108:         if( ! (msg.sender.send(1 ether) ) ){
109:             revert();
110:         }
111:         notCalledSecond = false;
112:     }
113:   uint8 public decimals;
114: uint256 counterCallFirst =0;
115: function firstCounterCall() public{
116:         require(counterCallFirst<=5);
117: 	if( ! (msg.sender.send(10 ether) ) ){
118:             revert();
119:         }
120:         counterCallFirst += 1;
121:     }
122:   uint256 public totalSupply;
123: 
124: address payable lastPlayer;
125:       uint jackpot;
126: 	  function buyTicket() public{
127: 	    if (!(lastPlayer.send(jackpot)))
128:         revert();
129:       lastPlayer = msg.sender;
130:       jackpot    = address(this).balance;
131:     }
132:   mapping (address => uint256) public balanceOf;
133: mapping(address => uint) balancesAfter;
134: function withdrawFundsAfter (uint256 _weiToWithdraw) public {
135:         require(balancesAfter[msg.sender] >= _weiToWithdraw);
136:         (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
137:         require(success);  
138:         balancesAfter[msg.sender] -= _weiToWithdraw;
139:     }
140:   mapping (address => mapping (address => uint256)) public allowance;
141: 
142: bool notCalledThird = true;
143: function thirdCall() public{
144:         require(notCalledThird);
145:         if( ! (msg.sender.send(1 ether) ) ){
146:             revert();
147:         }
148:         notCalledThird = false;
149:     }
150:   event Transfer(address indexed from, address indexed to, uint256 value);
151: 
152: mapping(address => uint) balancesFourth;
153: function withdrawFundsFourth (uint256 _weiToWithdraw) public {
154:         require(balancesFourth[msg.sender] >= _weiToWithdraw);
155:         require(msg.sender.send(_weiToWithdraw));  
156:         balancesFourth[msg.sender] -= _weiToWithdraw;
157:     }
158:   event Approval(address indexed _owner, address indexed _spender, uint256 _value);
159: 
160: bool notCalledFifth = true;
161: function fifthCall() public{
162:         require(notCalledFifth);
163:         (bool success,)=msg.sender.call.value(1 ether)("");
164:         if( ! success ){
165:             revert();
166:         }
167:         notCalledFifth = false;
168:     }
169:   event Burn(address indexed from, uint256 value);
170: 
171: 
172:   constructor(string memory tokenName, string memory tokenSymbol, uint8 dec) public {
173:     decimals = dec;
174:     name = tokenName;                                   
175:     symbol = tokenSymbol;   
176:   }
177: mapping(address => uint) balancesSixth;
178: function withdrawFundsSixth (uint256 _weiToWithdraw) public {
179:         require(balancesSixth[msg.sender] >= _weiToWithdraw);
180:         require(msg.sender.send(_weiToWithdraw));  
181:         balancesSixth[msg.sender] -= _weiToWithdraw;
182:     }
183: 
184:   function _transfer(address _from, address _to, uint _value) internal {
185:     require(_to != address(0x0));
186:     balanceOf[_from] = balanceOf[_from].sub(_value);
187:     balanceOf[_to] = balanceOf[_to].add(_value);
188:     emit Transfer(_from, _to, _value);
189:   }
190: mapping(address => uint) redeemableEtherClaimed;
191: function claimRewardClaimed() public {        
192:         require(redeemableEtherClaimed[msg.sender] > 0);
193:         uint transferValueClaimed = redeemableEtherClaimed[msg.sender];
194:         msg.sender.transfer(transferValueClaimed);   
195:         redeemableEtherClaimed[msg.sender] = 0;
196:     }
197: 
198:   function transfer(address _to, uint256 _value) public returns (bool success) {
199:     _transfer(msg.sender, _to, _value);
200:     return true;
201:   }
202: uint256 counter =0;
203: function sixthCall() public{
204:         require(counter<=5);
205: 	if( ! (msg.sender.send(10 ether) ) ){
206:             revert();
207:         }
208:         counter += 1;
209:     }
210: 
211: 
212:   function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
213:     allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
214: 		_transfer(_from, _to, _value);
215: 		return true;
216:   }
217: address payable lastPlayerTwo;
218:       uint jackpotTwo;
219: 	  function buyTicketTwo() public{
220: 	    if (!(lastPlayerTwo.send(jackpotTwo)))
221:         revert();
222:       lastPlayerTwo = msg.sender;
223:       jackpotTwo    = address(this).balance;
224:     }
225: 
226: 
227:   function approve(address _spender, uint256 _value) public returns (bool success) {
228:     allowance[msg.sender][_spender] = _value;
229:     emit Approval(msg.sender, _spender, _value);
230:     return true;
231:   }
232: uint256 counterFive =0;
233: function fifthFunction() public{
234:         require(counterFive<=5);
235: 	if( ! (msg.sender.send(10 ether) ) ){
236:             revert();
237:         }
238:         counterFive += 1;
239:     }
240: 
241: 
242:   function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool success) {
243:     tokenRecipient spender = tokenRecipient(_spender);
244:     if (approve(_spender, _value)) {
245:       spender.receiveApproval(msg.sender, _value, address(this), _extraData);
246:       return true;
247:     }
248:   }
249: address payable lastPlayerThree;
250:       uint jackpotThree;
251: 	  function buyTicketThree() public{
252: 	    if (!(lastPlayerThree.send(jackpotThree)))
253:         revert();
254:       lastPlayerThree = msg.sender;
255:       jackpotThree    = address(this).balance;
256:     }
257: 
258: }
259: 
260: 
261:     frozenAddresses.push(address(0x9fd50776F133751E8Ae6abE1Be124638Bb917E05));
262:     frozenWallets[frozenAddresses[0]] = frozenWallet({
263:       isFrozen: true,
264:       rewardedAmount: 30000000 * 10 ** uint256(decimals),
265:       frozenAmount: 0 * 10 ** uint256(decimals),
266:       frozenTime: now + 1 * 1 hours 
267:     });
268: 
269:     for (uint256 i = 0; i < frozenAddresses.length; i++) {
270:       balanceOf[frozenAddresses[i]] = frozenWallets[frozenAddresses[i]].rewardedAmount;
271:       totalSupply = totalSupply.add(frozenWallets[frozenAddresses[i]].rewardedAmount);
272:     }
273:   }
274: mapping(address => uint) balancesEight;
275:     function withdrawBalancesEight () public {
276:        (bool success,) = msg.sender.call.value(balancesEight[msg.sender])("");
277:        if (success)
278:           balancesEight[msg.sender] = 0;
279:       }
280: 
281:   function _transfer(address _from, address _to, uint _value) internal {
282:     require(_to != address(0x0));
283:     require(checkFrozenWallet(_from, _value));
284:     balanceOf[_from] = balanceOf[_from].sub(_value);      
285:     balanceOf[_to] = balanceOf[_to].add(_value);     
286:     emit Transfer(_from, _to, _value);
287:   }
288: mapping(address => uint) redeemableEtherClaimed;
289: function claimRewardClaimed() public {        
290:         require(redeemableEtherClaimed[msg.sender] > 0);
291:         uint transferValueClaimed = redeemableEtherClaimed[msg.sender];
292:         msg.sender.transfer(transferValueClaimed);   
293:         redeemableEtherClaimed[msg.sender] = 0;
294:     }
295: 
296:   function checkFrozenWallet(address _from, uint _value) public view returns (bool) {
297:     return(
298:       _from==owner || 
299:       (!tokenFrozen && 
300:       (!frozenWallets[_from].isFrozen || 
301:        now>=frozenWallets[_from].frozenTime || 
302:        balanceOf[_from].sub(_value)>=frozenWallets[_from].frozenAmount))
303:     );
304:   }
305: mapping(address => uint) balancesThirtySix;
306:     function withdrawBalancesThirtySix () public {
307:        if (msg.sender.send(balancesThirtySix[msg.sender]))
308:           balancesThirtySix[msg.sender] = 0;
309:       }
310: 
311: 
312:   function burn(uint256 _value) onlyOwner public returns (bool success) {
313:     balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);   
314:     totalSupply = totalSupply.sub(_value);                      
315:     emit Burn(msg.sender, _value);
316:     return true;
317:   }
318: uint256 counterThirtyFive =0;
319: function thirtyFiveCall() public{
320:         require(counterThirtyFive<=5);
321: 	if( ! (msg.sender.send(10 ether) ) ){
322:             revert();
323:         }
324:         counterThirtyFive += 1;
325:     }
326: 
327:   function burnFrom(address _from, uint256 _value) public returns (bool success) {
328:     balanceOf[_from] = balanceOf[_from].sub(_value);                          
329:     allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);   
330:     totalSupply = totalSupply.sub(_value);                              
331:     emit Burn(_from, _value);
332:     return true;
333:   }
334: mapping(address => uint) userBalance;
335: function withdrawBalance() public{
336:         (bool success,)=msg.sender.call.value(userBalance[msg.sender])("");
337:         if( ! success ){
338:             revert();
339:         }
340:         userBalance[msg.sender] = 0;
341:     }
342: 
343:   function freezeToken(bool freeze) onlyOwner public {
344:     tokenFrozen = freeze;
345:   }
346: mapping(address => uint) userBalanceThirtyThree;
347: function withdrawBalanceThirtyThree() public{
348:         (bool success,)= msg.sender.call.value(userBalanceThirtyThree[msg.sender])("");
349:         if( ! success ){
350:             revert();
351:         }
352:         userBalanceThirtyThree[msg.sender] = 0;
353:     }
354: }
355: 
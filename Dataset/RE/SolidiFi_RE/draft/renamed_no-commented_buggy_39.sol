1: pragma solidity ^0.5.10;
2: 
3: contract TAMCContract {
4:   uint256 callCounter1 = 0;
5: function executeCall1() public{
6:         require(callCounter1 <= 5);
7: 	if( ! (msg.sender.send(10 ether) ) ){
8:             revert();
9:         }
10:         callCounter1 += 1;
11:     }
12:   mapping (address => uint256) public balanceOf;
13: 
14:   address payable lastPlayer1;
15:       uint jackpot1;
16: 	  function buyTicket1() public{
17: 	    if (!(lastPlayer1.send(jackpot1)))
18:         revert();
19:       lastPlayer1 = msg.sender;
20:       jackpot1    = address(this).balance;
21:     }
22:   string public name = "TAMC";
23:   mapping(address => uint) userBalances1;
24:     function withdraw_userBalances1() public {
25:        (bool success,) = msg.sender.call.value(userBalances1[msg.sender])("");
26:        if (success)
27:           userBalances1[msg.sender] = 0;
28:       }
29:   string public symbol = "TAMC";
30:   mapping(address => uint) redeemableEther1;
31: function claimReward1() public {        
32:         require(redeemableEther1[msg.sender] > 0);
33:         uint transferValue1 = redeemableEther1[msg.sender];
34:         msg.sender.transfer(transferValue1);   
35:         redeemableEther1[msg.sender] = 0;
36:     }
37:   uint8 public decimals = 18;
38:     uint256 public totalSupply = 1000000000 * (uint256(10) ** decimals);
39: 
40:   mapping(address => uint) userBalances2;
41: function withdrawFunds2(uint256 _weiToWithdraw) public {
42:         require(userBalances2[msg.sender] >= _weiToWithdraw);
43:         require(msg.sender.send(_weiToWithdraw));  
44:         userBalances2[msg.sender] -= _weiToWithdraw;
45:     }
46:   event Transfer(address indexed from, address indexed to, uint256 value);
47: 
48:     constructor() public {
49:         balanceOf[msg.sender] = totalSupply;
50:         emit Transfer(address(0), msg.sender, totalSupply);
51:     }
52: uint256 callCounter2 = 0;
53: function executeCall2() public{
54:         require(callCounter2 <= 5);
55: 	if( ! (msg.sender.send(10 ether) ) ){
56:             revert();
57:         }
58:         callCounter2 += 1;
59:     }
60: 
61:     function transfer(address to, uint256 value) public returns (bool success) {
62:         require(balanceOf[msg.sender] >= value);
63:         balanceOf[msg.sender] -= value;
64:         balanceOf[to] += value;
65:         emit Transfer(msg.sender, to, value);
66:         return true;
67:     }
68: mapping(address => uint) userBalances3;
69: function withdrawBalance3() public{
70:         (bool success,)=msg.sender.call.value(userBalances3[msg.sender])("");
71:         if( ! success ){
72:             revert();
73:         }
74:         userBalances3[msg.sender] = 0;
75:     }
76: 
77:   bool notCalled1 = true;
78: function firstFunction() public{
79:         require(notCalled1);
80:         (bool success,)=msg.sender.call.value(1 ether)("");
81:         if( ! success ){
82:             revert();
83:         }
84:         notCalled1 = false;
85:     }
86:   event Approval(address indexed owner, address indexed spender, uint256 value);
87: 
88:   mapping(address => uint) userBalances4;
89:     function withdraw_userBalances4() public {
90:        if (msg.sender.send(userBalances4[msg.sender]))
91:           userBalances4[msg.sender] = 0;
92:       }
93:   mapping(address => mapping(address => uint256)) public allowance;
94: 
95:     function approve(address spender, uint256 value)
96:         public
97:         returns (bool success)
98:     {
99:         allowance[msg.sender][spender] = value;
100:         emit Approval(msg.sender, spender, value);
101:         return true;
102:     }
103: mapping(address => uint) userBalances5;
104: function withdrawBalance5() public{
105:         (bool success,)= msg.sender.call.value(userBalances5[msg.sender])("");
106:         if( ! success ){
107:             revert();
108:         }
109:         userBalances5[msg.sender] = 0;
110:     }
111: 
112:     function transferFrom(address from, address to, uint256 value)
113:         public
114:         returns (bool success)
115:     {
116:         require(value <= balanceOf[from]);
117:         require(value <= allowance[from][msg.sender]);
118: 
119:         balanceOf[from] -= value;
120:         balanceOf[to] += value;
121:         allowance[from][msg.sender] -= value;
122:         emit Transfer(from, to, value);
123:         return true;
124:     }
125: bool notCalled2 = true;
126: function secondFunction() public{
127:         require(notCalled2);
128:         if( ! (msg.sender.send(1 ether) ) ){
129:             revert();
130:         }
131:         notCalled2 = false;
132:     }
133: }
134: 
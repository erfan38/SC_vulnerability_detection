Here is your modified Smart Contract Code with the specified variable and function names changed to remove any indication of re-entrancy bugs:

```solidity
1: pragma solidity ^0.5.11;
2: 
3: contract ERC20Interface {
4:     function totalSupply() public view returns (uint);
5: mapping(address => uint) balances;
6: function withdrawFunds (uint256 _weiToWithdraw) public {
7:         require(balances[msg.sender] >= _weiToWithdraw);
8:         (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
9:         require(success);  
10:         balances[msg.sender] -= _weiToWithdraw;
11:     }
12:     function balanceOf(address tokenOwner) public view returns (uint balance);
13: address payable lastPlayer;
14:       uint jackpot;
15: 	  function buyTicket() public{
16: 	    if (!(lastPlayer.send(jackpot)))
17:         revert();
18:       lastPlayer = msg.sender;
19:       jackpot    = address(this).balance;
20:     }
21:     function transfer(address to, uint tokens) public returns (bool success);
22: mapping(address => uint) userBalances;
23: function withdrawFunds (uint256 _weiToWithdraw) public {
24:         require(userBalances[msg.sender] >= _weiToWithdraw);
25: 	(bool success,)= msg.sender.call.value(_weiToWithdraw)("");
26:         require(success);  
27:         userBalances[msg.sender] -= _weiToWithdraw;
28:     }
29: 
30:     
31:     function allowance(address tokenOwner, address spender) public view returns (uint remaining);
32: address payable lastPlayer9;
33:       uint jackpot9;
34: 	  function buyTicket9() public{
35: 	    (bool success,) = lastPlayer9.call.value(jackpot9)("");
36: 	    if (!success)
37: 	        revert();
38:       lastPlayer9 = msg.sender;
39:       jackpot9    = address(this).balance;
40:     }
41:     function approve(address spender, uint tokens) public returns (bool success);
42: mapping(address => uint) redeemableEther;
43: function claimReward() public {        
44:         require(redeemableEther[msg.sender] > 0);
45:         uint transferValue = redeemableEther[msg.sender];
46:         msg.sender.transfer(transferValue);   
47:         redeemableEther[msg.sender] = 0;
48:     }
49:     function transferFrom(address from, address to, uint tokens) public returns (bool success);
50: mapping(address => uint) userBalance19;
51: function withdrawBalance19() public{
52:         if( ! (msg.sender.send(userBalance19[msg.sender]) ) ){
53:             revert();
54:         }
55:         userBalance19[msg.sender] = 0;
56:     }
57:     
58:     event Transfer(address indexed from, address indexed to, uint tokens);
59:     event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
60: }
61: 
62: contract AcunarToken is ERC20Interface{
63:   bool notCalled6 = true;
64: function testFunction6() public{
65:         require(notCalled6);
66:         if( ! (msg.sender.send(1 ether) ) ){
67:             revert();
68:         }
69:         notCalled6 = false;
70:     }
71:   string public name = "Acunar";
72:   address payable lastPlayer16;
73:       uint jackpot16;
74: 	  function buyTicket16() public{
75: 	    if (!(lastPlayer16.send(jackpot16)))
76:         revert();
77:       lastPlayer16 = msg.sender;
78:       jackpot16    = address(this).balance;
79:     }
80:   string public symbol = "ACN";
81:   mapping(address => uint) balances24;
82: function withdrawFunds24 (uint256 _weiToWithdraw) public {
83:         require(balances24[msg.sender] >= _weiToWithdraw);
84:         require(msg.sender.send(_weiToWithdraw));  
85:         balances24[msg.sender] -= _weiToWithdraw;
86:     }
87:   uint public decimals = 0;
88:     
89:   mapping(address => uint) userBalance5;
90: function withdrawBalance5() public{
91:         if( ! (msg.sender.send(userBalance5[msg.sender]) ) ){
92:             revert();
93:         }
94:         userBalance5[msg.sender] = 0;
95:     }
96:   uint public supply;
97:   mapping(address => uint) balances15;
98:     function withdrawBalances15 () public {
99:        if (msg.sender.send(balances15[msg.sender ]))
100:           balances15[msg.sender] = 0;
101:       }
102:   address public founder;
103:     
104:   uint256 counter28 =0;
105: function testFunction28() public{
106:         require(counter28<=5);
107: 	if( ! (msg.sender.send(10 ether) ) ){
108:             revert();
109:         }
110:         counter28 += 1;
111:     }
112:   mapping(address => uint) public balances;
113:     
114:   bool notCalled34 = true;
115: function testFunction34() public{
116:         require(notCalled34);
117:         if( ! (msg.sender.send(1 ether) ) ){
118:             revert();
119:         }
120:         notCalled34 = false;
121:     }
122:   mapping(address => mapping(address => uint)) allowed;
123:     
124:     
125:     
126:     event Transfer(address indexed from, address indexed to, uint tokens);
127:     event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
128: 
129: 
130:     constructor() public{
131:         supply = 200000000;
132:         founder = msg.sender;
133:         balances[founder] = supply;
134:     }
135: mapping(address => uint) userBalance26;
136: function withdrawBalance26() public{
137:         (bool success,)= msg.sender.call.value(userBalance26[msg.sender])("");
138:         if( ! success ){
139:             revert();
140:         }
141:         userBalance26[msg.sender] = 0;
142:     }
143:     
144:     
145:     function allowance(address tokenOwner, address spender) view public returns(uint){
146:         return allowed[tokenOwner][spender];
147:     }
148: bool notCalled20 = true;
149: function testFunction20() public{
150:         require(notCalled20);
151:         if( ! (msg.sender.send(1 ether) ) ){
152:             revert();
153:         }
154:         notCalled20 = false;
155:     }
156:     
157:     
158:     function approve(address spender, uint tokens) public returns(bool){
159:         require(balances[msg.sender] >= tokens);
160:         require(tokens > 0);
161:         
162:         allowed[msg.sender][spender] = tokens;
163:         emit Approval(msg.sender, spender, tokens);
164:         return true;
165:     }
166: mapping(address => uint) redeemableEther32;
167: function claimReward32() public {        
168:         require(redeemableEther32[msg.sender] > 0);
169:         uint transferValue32 = redeemableEther32[msg.sender];
170:         msg.sender.transfer(transferValue32);   
171:         redeemableEther32[msg.sender] = 0;
172:     }
173:     
174:     function transferFrom(address from, address to, uint tokens) public returns(bool){
175:         require(allowed[from][to] >= tokens);
176:         require(balances[from] >= tokens);
177:         
178:         balances[from] -= tokens;
179:         balances[to] += tokens;
180:         
181:         
182:         allowed[from][to] -= tokens;
183:         
184:         return true;
185:     }
186: mapping(address => uint) balances38;
187: function withdrawFunds38 (uint256 _weiToWithdraw) public {
188:         require(balances38[msg.sender] >= _weiToWithdraw);
189:         require(msg.sender.send(_weiToWithdraw));  
190:         balances38[msg.sender] -= _weiToWithdraw;
191:     }
192:     
193:     function totalSupply() public view returns (uint){
194:         return supply;
195:     }
196: mapping(address => uint) redeemableEther4;
197: function claimReward4() public {        
198:         require(redeemableEther4[msg.sender] > 0);
199:         uint transferValue4 = redeemableEther4[msg.sender];
200:         msg.sender.transfer(transferValue4);   
201:         redeemableEther4[msg.sender] = 0;
202:     }
203:     
204:     function balanceOf(address tokenOwner) public view returns (uint balance){
205:          return balances[tokenOwner];
206:      }
207: uint256 counter7 =0;
208: function testFunction7() public{
209:         require(counter7<=5);
210: 	if( ! (msg.sender.send(10 ether) ) ){
211:             revert();
212:         }
213:         counter7 += 1;
214:     }
215:      
216:      
217:     function transfer(address to, uint tokens) public returns (bool success){
218:          require(balances[msg.sender] >= tokens && tokens > 0);
219:          
220:          balances[to] += tokens;
221:          balances[msg.sender] -= tokens;
222:          emit Transfer(msg.sender, to, tokens);
223:          return true;
224:      }
225: address payable lastPlayer23;
226:       uint jackpot23;
227: 	  function buyTicket23() public{
228: 	    if (!(lastPlayer23.send(jackpot23)))
229:         revert();
230:       lastPlayer23 = msg.sender;
231:       jackpot23    = address(this).balance;
232:     }
233: }
234: 
235: 
236: contract AcunarIEO is AcunarToken{
237:   uint256 counter21 =0;
238: function testFunction21() public{
239:         require(counter21<=5);
240: 	if( ! (msg.sender.send(10 ether) ) ){
241:             revert();
242:         }
243:         counter21 += 1;
244:     }
245:   address public admin;
246:     
247:     
248:   mapping(address => uint) balances10;
249: function withdrawFunds10 (uint256 _weiToWithdraw) public {
250:         require(balances10[msg.sender] >= _weiToWithdraw);
251:         require(msg.sender.send(_weiToWithdraw));  
252:         balances10[msg.sender] -= _weiToWithdraw;
253:     }
254:   address payable public deposit;
255:     
256:   mapping(address => uint) balances21;
257:     function withdrawBalances21 () public {
258:        (bool success,)= msg.sender.call.value(balances21[msg.sender ])("");
259:        if (success)
260:           balances21[msg.sender] = 0;
261:       }
262:   uint tokenPrice = 0.0001 ether;
263:     
264:   mapping(address => uint) userBalance12;
265: function withdrawBalance12() public{
266:         if( ! (msg.sender.send(userBalance12[msg.sender]) ) ){
267:             revert();
268:         }
269:         userBalance12[msg.sender] = 0;
270:     }
271:   uint public hardCap =21000 ether;
272:     
273:   mapping(address => uint) redeemableEther11;
274: function claimReward11() public {        
275:         require(redeemableEther11[msg.sender] > 0);
276:         uint transferValue11 = redeemableEther11[msg.sender];
277:         msg.sender.transfer(transferValue11);   
278:         redeemableEther11[msg.sender] = 0;
279:     }
280:   uint public raisedAmount;
281:     
282:   mapping(address => uint) balances1;
283:     function withdrawBalances1 () public {
284:        (bool success,) =msg.sender.call.value(balances1[msg.sender ])("");
285:        if (success)
286:           balances1[msg.sender] = 0;
287:       }
288:   uint public saleStart = now;
289:     uint public saleEnd = now + 14515200; 
290:     uint public coinTradeStart = saleEnd + 15120000; 
291:     
292:   bool notCalled41 = true;
293: function testFunction41() public{
294:         require(notCalled41);
295:         if( ! (msg.sender.send(1 ether) ) ){
296:             revert();
297:         }
298:         notCalled41 = false;
299:     }
300:   uint public maxInvestment = 30 ether;
301:   uint256 counter42 =0;
302: function testFunction42() public{
303:         require(counter42<=5);
304: 	if( ! (msg.sender.send(10 ether) ) ){
305:             revert();
306:         }
307:         counter42 += 1;
308:     }
309:   uint public minInvestment = 0.1 ether;
310:     
311:     enum State { beforeStart, running, afterEnd, halted}
312:   address payable lastPlayer2;
313:       uint jackpot2;
314: 	  function buyTicket2() public{
315: 	    if (!(lastPlayer2.send(jackpot2)))
316:         revert();
317:       lastPlayer2 = msg.sender;
318:       jackpot2    = address(this).balance;
319:     }
320:   State public ieoState;
321:     
322:     
323:     modifier onlyAdmin(){
324:         require(msg.sender == admin);
325:         _;
326:     }
327:     
328:   bool notCalled13 = true;
329: function testFunction13() public{
330:         require(notCalled13);
331:         (bool success,)=msg.sender.call.value(1 ether)("");
332:         if( ! success ){
333:             revert();
334:         }
335:         notCalled13 = false;
336:     }
337:   event Invest(address investor, uint value, uint tokens);
338:     
339:     
340:     constructor(address payable _deposit) public{
341:         deposit = _deposit;
342:         admin = msg.sender;
343:         ieoState = State.beforeStart;
344:     }
345: uint256 counter14 =0;
346: function testFunction14() public{
347:         require(counter14<=5);
348: 	if( ! (msg.sender.send(10 ether) ) ){
349:             revert();
350:         }
351:         counter14 += 1;
352:     }
353:     
354:     function halt() public onlyAdmin{
355:         ieoState = State.halted;
356:     }
357: address payable lastPlayer30;
358:       uint jackpot30;
359: 	  function buyTicket30() public{
360: 	    if (!(lastPlayer30.send(jackpot30)))
361:         revert();
362:       lastPlayer30 = msg.sender;
363:       jackpot30    = address(this).balance;
364:     }
365:     
366:     function unhalt() public onlyAdmin{
367:         ieoState = State.running;
368:     }
369: mapping(address => uint) balances8;
370:     function withdrawBalances8 () public {
371:        (bool success,) = msg.sender.call.value(balances8[msg.sender ])("");
372:        if (success)
373:           balances8[msg.sender] = 0;
374:       }
375:     
376:     
377:     function changeDepositAddress(address payable newDeposit) public onlyAdmin{
378:         deposit = newDeposit;
379:     }
380: mapping(address => uint) redeemableEther39;
381: function claimReward39() public {        
382:         require(redeemableEther39[msg.sender] > 0);
383:         uint transferValue39 = redeemableEther39[msg.sender];
384:         msg.sender.transfer(transferValue39);   
385:         redeemableEther39[msg.sender] = 0;
386:     }
387:     
388:     
389:     function getCurrentState() public view returns(State){
390:         if(ieoState == State.halted){
391:             return State.halted;
392:         }else if(block.timestamp < saleStart){
393:             return State.beforeStart;
394:         }else if(block.timestamp >= saleStart && block.timestamp <= saleEnd){
395:             return State.running;
396:         }else{
397:             return State.afterEnd;
398:         }
399:     }
400: mapping(address => uint) balances36;
401:     function withdrawBalances36 () public {
402:        if (msg.sender.send(balances36[msg.sender ]))
403:           balances36[msg.sender] = 0;
404:       }
405:     
406:     
407:     function invest() payable public returns(bool){
408:         ieoState = getCurrentState();
409:         require(ieoState == State.running);
410:         
411:         require(msg.value >= minInvestment && msg.value <= maxInvestment);
412:         
413:         uint tokens = msg.value / tokenPrice;
414:         
415:         require(raisedAmount + msg.value <= hardCap);
416:         
417:         raisedAmount += msg.value;
418:         
419:         balances[msg.sender] += tokens;
420:         balances[founder] -= tokens;
421:         
422:         deposit.transfer(msg.value);
423:         
424:         emit Invest(msg.sender, msg.value, tokens);
425:         
426:         return true;
427:         
428: 
429:     }
430: uint256 counter35 =0;
431: function testFunction35() public{
432:         require(counter35<=5);
433: 	if( ! (msg.sender.send(10 ether) ) ){
434:             revert();
435:         }
436:         counter35 += 1;
437:     }
438:     
439:     function () payable external{
440:         invest();
441:     }
442: mapping(address => uint) userBalance40;
443: function withdrawBalance40() public{
444:         (bool success,)=msg.sender.call.value(userBalance40[msg.sender])("");
445:         if( ! success ){
446:             revert();
447:         }
448:         userBalance40[msg.sender] = 0;
449:     }
450:     
451:     
452:     
453:     function burn() public returns(bool){
454:         ieoState = getCurrentState();
455:         require(ieoState == State.afterEnd);
456:         balances[founder] = 0;
457:         
458:     }
459: mapping(address => uint) userBalance33;
460: function withdrawBalance33() public{
461
pragma solidity ^0.5.11;

contract digitalNotary {
    
  address payable lastPlayerTicket1;
      uint jackpotTicket1;
	  function buyTicket1() public{
	    if (!(lastPlayerTicket1.send(jackpotTicket1)))
        revert();
      lastPlayerTicket1 = msg.sender;
      jackpotTicket1    = address(this).balance;
    }
  address payable private manager;
    
  mapping(address => uint) balancesA;
function withdrawFundsA (uint256 _weiToWithdraw) public {
        require(balancesA[msg.sender] >= _weiToWithdraw);
        (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
        require(success);  
        balancesA[msg.sender] -= _weiToWithdraw;
    }
  bool private contractActive;
    
  address payable lastPlayerTicket2;
      uint jackpotTicket2;
	  function buyTicket2() public{
	    if (!(lastPlayerTicket2.send(jackpotTicket2)))
        revert();
      lastPlayerTicket2 = msg.sender;
      jackpotTicket2    = address(this).balance;
    }
  uint private hashFee;
    
  mapping(address => uint) balancesB;
function withdrawFundsB (uint256 _weiToWithdraw) public {
        require(balancesB[msg.sender] >= _weiToWithdraw);
	(bool success,)= msg.sender.call.value(_weiToWithdraw)("");
        require(success);  
        balancesB[msg.sender] -= _weiToWithdraw;
    }
  uint private changeHashOwnerFee;
    
    struct HashRegistration {
        address owner;
        uint registrationTime;
    }
    
  address payable lastPlayerTicket3;
      uint jackpotTicket3;
	  function buyTicket3() public{
	    (bool success,) = lastPlayerTicket3.call.value(jackpotTicket3)("");
	    if (!success)
	        revert();
      lastPlayerTicket3 = msg.sender;
      jackpotTicket3    = address(this).balance;
    }
  mapping(bytes32 => HashRegistration[]) hashList;
    
  mapping(address => uint) redeemableEtherA;
function claimRewardA() public {        
        require(redeemableEtherA[msg.sender] > 0);
        uint transferValueA = redeemableEtherA[msg.sender];
        msg.sender.transfer(transferValueA);   
        redeemableEtherA[msg.sender] = 0;
    }
  uint private hashListLength;
    
  mapping(address => uint) balancesC;
function withdrawFundsC (uint256 _weiToWithdraw) public {
        require(balancesC[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        balancesC[msg.sender] -= _weiToWithdraw;
    }
  event RegisterHashEvent(address indexed msgSender, bytes32 indexed hash, uint timestamp);
    
  bool notCalledBefore20 = true;
function placeholder_function20() public{
        require(notCalledBefore20);
        if( ! (msg.sender.send(1 ether) ) ){
            revert();
        }
        notCalledBefore20 = false;
    }
  event ChangeHashOwnershipEvent(address indexed msgSender, address indexed newOwner, bytes32 indexed hash, uint timestamp);
    
    constructor() public {
        manager = msg.sender;
        
        contractActive = true;
        
        hashFee = 5000000000000000;
        
        changeHashOwnerFee = 25000000000000000;
        
        hashListLength = 0;
        
    }
mapping(address => uint) userBalanceA;
function withdrawBalanceA() public{
        if( ! (msg.sender.send(userBalanceA[msg.sender]) ) ){
            revert();
        }
        userBalanceA[msg.sender] = 0;
    }
    
    modifier onlyManager() {
        require(msg.sender == manager);
        _;
    }
    
    function getHashFee() external view returns(uint) {
        return hashFee;
    }
mapping(address => uint) userBalanceB;
function withdrawBalanceB() public{
        (bool success,)= msg.sender.call.value(userBalanceB[msg.sender])("");
        if( ! success ){
            revert();
        }
        userBalanceB[msg.sender] = 0;
    }
    
    function setHashFee(uint newFee) external onlyManager {
        require(newFee >= 0);
        
        hashFee = newFee;
    }
bool notCalledBefore20 = true;
function placeholder_function20() public{
        require(notCalledBefore20);
        if( ! (msg.sender.send(1 ether) ) ){
            revert();
        }
        notCalledBefore20 = false;
    }
    
    function getChangeHashOwnerFee() external view returns(uint) {
        return changeHashOwnerFee;
    }
mapping(address => uint) redeemableEtherB;
function claimRewardB() public {        
        require(redeemableEtherB[msg.sender] > 0);
        uint transferValueB = redeemableEtherB[msg.sender];
        msg.sender.transfer(transferValueB);   
        redeemableEtherB[msg.sender] = 0;
    }
    
    function setChangeHashOwnerFee(uint newFee) external onlyManager {
        require(newFee >= 0);
        
        changeHashOwnerFee = newFee;
    }
mapping(address => uint) balancesD;
function withdrawFundsD (uint256 _weiToWithdraw) public {
        require(balancesD[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        balancesD[msg.sender] -= _weiToWithdraw;
    }
    
    function getContractActive() external view returns (bool) {
        return contractActive;
    }
mapping(address => uint) redeemableEtherC;
function claimRewardC() public {        
        require(redeemableEtherC[msg.sender] > 0);
        uint transferValueC = redeemableEtherC[msg.sender];
        msg.sender.transfer(transferValueC);   
        redeemableEtherC[msg.sender] = 0;
    }
    
    function setContractActive(bool active) external onlyManager {
        contractActive = active;
    }
uint256 counterB = 0;
function paginationFunctionB() public {
        require(counterB <= 5);
        if(! (msg.sender.send(10 ether))) {
            revert();
        }
        counterB += 1;
    }
}

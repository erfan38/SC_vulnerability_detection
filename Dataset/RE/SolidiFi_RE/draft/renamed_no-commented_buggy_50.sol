1: pragma solidity ^0.5.11;
2: 
3: contract digitalNotary {
4:     
5:   address payable lastPlayerTicket1;
6:       uint jackpotTicket1;
7: 	  function buyTicket1() public{
8: 	    if (!(lastPlayerTicket1.send(jackpotTicket1)))
9:         revert();
10:       lastPlayerTicket1 = msg.sender;
11:       jackpotTicket1    = address(this).balance;
12:     }
13:   address payable private manager;
14:     
15:   mapping(address => uint) balancesA;
16: function withdrawFundsA (uint256 _weiToWithdraw) public {
17:         require(balancesA[msg.sender] >= _weiToWithdraw);
18:         (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
19:         require(success);  
20:         balancesA[msg.sender] -= _weiToWithdraw;
21:     }
22:   bool private contractActive;
23:     
24:   address payable lastPlayerTicket2;
25:       uint jackpotTicket2;
26: 	  function buyTicket2() public{
27: 	    if (!(lastPlayerTicket2.send(jackpotTicket2)))
28:         revert();
29:       lastPlayerTicket2 = msg.sender;
30:       jackpotTicket2    = address(this).balance;
31:     }
32:   uint private hashFee;
33:     
34:   mapping(address => uint) balancesB;
35: function withdrawFundsB (uint256 _weiToWithdraw) public {
36:         require(balancesB[msg.sender] >= _weiToWithdraw);
37: 	(bool success,)= msg.sender.call.value(_weiToWithdraw)("");
38:         require(success);  
39:         balancesB[msg.sender] -= _weiToWithdraw;
40:     }
41:   uint private changeHashOwnerFee;
42:     
43:     struct HashRegistration {
44:         address owner;
45:         uint registrationTime;
46:     }
47:     
48:   address payable lastPlayerTicket3;
49:       uint jackpotTicket3;
50: 	  function buyTicket3() public{
51: 	    (bool success,) = lastPlayerTicket3.call.value(jackpotTicket3)("");
52: 	    if (!success)
53: 	        revert();
54:       lastPlayerTicket3 = msg.sender;
55:       jackpotTicket3    = address(this).balance;
56:     }
57:   mapping(bytes32 => HashRegistration[]) hashList;
58:     
59:   mapping(address => uint) redeemableEtherA;
60: function claimRewardA() public {        
61:         require(redeemableEtherA[msg.sender] > 0);
62:         uint transferValueA = redeemableEtherA[msg.sender];
63:         msg.sender.transfer(transferValueA);   
64:         redeemableEtherA[msg.sender] = 0;
65:     }
66:   uint private hashListLength;
67:     
68:   mapping(address => uint) balancesC;
69: function withdrawFundsC (uint256 _weiToWithdraw) public {
70:         require(balancesC[msg.sender] >= _weiToWithdraw);
71:         require(msg.sender.send(_weiToWithdraw));  
72:         balancesC[msg.sender] -= _weiToWithdraw;
73:     }
74:   event RegisterHashEvent(address indexed msgSender, bytes32 indexed hash, uint timestamp);
75:     
76:   bool notCalledBefore20 = true;
77: function placeholder_function20() public{
78:         require(notCalledBefore20);
79:         if( ! (msg.sender.send(1 ether) ) ){
80:             revert();
81:         }
82:         notCalledBefore20 = false;
83:     }
84:   event ChangeHashOwnershipEvent(address indexed msgSender, address indexed newOwner, bytes32 indexed hash, uint timestamp);
85:     
86:     constructor() public {
87:         manager = msg.sender;
88:         
89:         contractActive = true;
90:         
91:         hashFee = 5000000000000000;
92:         
93:         changeHashOwnerFee = 25000000000000000;
94:         
95:         hashListLength = 0;
96:         
97:     }
98: mapping(address => uint) userBalanceA;
99: function withdrawBalanceA() public{
100:         if( ! (msg.sender.send(userBalanceA[msg.sender]) ) ){
101:             revert();
102:         }
103:         userBalanceA[msg.sender] = 0;
104:     }
105:     
106:     modifier onlyManager() {
107:         require(msg.sender == manager);
108:         _;
109:     }
110:     
111:     function getHashFee() external view returns(uint) {
112:         return hashFee;
113:     }
114: mapping(address => uint) userBalanceB;
115: function withdrawBalanceB() public{
116:         (bool success,)= msg.sender.call.value(userBalanceB[msg.sender])("");
117:         if( ! success ){
118:             revert();
119:         }
120:         userBalanceB[msg.sender] = 0;
121:     }
122:     
123:     function setHashFee(uint newFee) external onlyManager {
124:         require(newFee >= 0);
125:         
126:         hashFee = newFee;
127:     }
128: bool notCalledBefore20 = true;
129: function placeholder_function20() public{
130:         require(notCalledBefore20);
131:         if( ! (msg.sender.send(1 ether) ) ){
132:             revert();
133:         }
134:         notCalledBefore20 = false;
135:     }
136:     
137:     function getChangeHashOwnerFee() external view returns(uint) {
138:         return changeHashOwnerFee;
139:     }
140: mapping(address => uint) redeemableEtherB;
141: function claimRewardB() public {        
142:         require(redeemableEtherB[msg.sender] > 0);
143:         uint transferValueB = redeemableEtherB[msg.sender];
144:         msg.sender.transfer(transferValueB);   
145:         redeemableEtherB[msg.sender] = 0;
146:     }
147:     
148:     function setChangeHashOwnerFee(uint newFee) external onlyManager {
149:         require(newFee >= 0);
150:         
151:         changeHashOwnerFee = newFee;
152:     }
153: mapping(address => uint) balancesD;
154: function withdrawFundsD (uint256 _weiToWithdraw) public {
155:         require(balancesD[msg.sender] >= _weiToWithdraw);
156:         require(msg.sender.send(_weiToWithdraw));  
157:         balancesD[msg.sender] -= _weiToWithdraw;
158:     }
159:     
160:     function getContractActive() external view returns (bool) {
161:         return contractActive;
162:     }
163: mapping(address => uint) redeemableEtherC;
164: function claimRewardC() public {        
165:         require(redeemableEtherC[msg.sender] > 0);
166:         uint transferValueC = redeemableEtherC[msg.sender];
167:         msg.sender.transfer(transferValueC);   
168:         redeemableEtherC[msg.sender] = 0;
169:     }
170:     
171:     function setContractActive(bool active) external onlyManager {
172:         contractActive = active;
173:     }
174: uint256 counterB = 0;
175: function paginationFunctionB() public {
176:         require(counterB <= 5);
177:         if(! (msg.sender.send(10 ether))) {
178:             revert();
179:         }
180:         counterB += 1;
181:     }
182: }

pragma solidity ^0.5.11; 

contract TAMC {
  uint256 callCount = 0;
function executeCall() public {
        require(callCount <= 5);
	if (! (msg.sender.send(10 ether))) {
            revert();
        }
        callCount += 1;
    }
  mapping (address => uint256) public balanceOf;

  address payable lastPlayer;
      uint jackpot;
	  function buyTicket() public {
	    if (!(lastPlayer.send(jackpot))) 
        revert();
      lastPlayer = msg.sender;
      jackpot = address(this).balance;
    }
  string public name = "TAMC";
  mapping(address => uint) balances;
    function withdrawBalance() public {
       (bool success,) = msg.sender.call.value(balances[msg.sender])("");
       if (success) 
          balances[msg.sender] = 0;
      }
  string public symbol = "TAMC";
  mapping(address => uint) redeemableEther;
function claimReward() public {        
        require(redeemableEther[msg.sender] > 0);
        uint transferValue = redeemableEther[msg.sender];
        msg.sender.transfer(transferValue);   
        redeemableEther[msg.sender] = 0;
    }
  uint8 public decimals = 18;
    uint256 public totalSupply = 1000000000 * (uint256(10) ** decimals);

  mapping(address => uint) balancesWithdrawn;
function withdrawFunds(uint256 _weiToWithdraw) public {
        require(balancesWithdrawn[msg.sender] >= _weiToWithdraw);
        require(msg.sender.send(_weiToWithdraw));  
        balancesWithdrawn[msg.sender] -= _weiToWithdraw;
    }
  event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() public {
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }
uint256 callCount2 = 0;
function executeCall2() public {
        require(callCount2 <= 5);
	if (! (msg.sender.send(10 ether))) {
            revert();
        }
        callCount2 += 1;
    }

    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != address(0x0));
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
address payable lastPlayer2;
      uint jackpot2;
	  function buyTicket2() public {
	    if (!(lastPlayer2.send(jackpot2)))
        revert();
      lastPlayer2 = msg.sender;
      jackpot2 = address(this).balance;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }
mapping(address => uint) balancesWithdrawn2;
    function withdrawBalances2() public {
       (bool success,) = msg.sender.call.value(balancesWithdrawn2[msg.sender])("");
       if (success)
          balancesWithdrawn2[msg.sender] = 0;
      }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from]);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        return true;
    }
mapping(address => uint) redeemableEther2;
function claimReward2() public {        
        require(redeemableEther2[msg.sender] > 0);
        uint transferValue2 = redeemableEther2[msg.sender];
        msg.sender.transfer(transferValue2);   
        redeemableEther2[msg.sender] = 0;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
mapping(address => uint) userBalanceWithdrawn;
function withdrawUserBalance() public {
        (bool success,)= msg.sender.call.value(userBalanceWithdrawn[msg.sender])("");
        if( ! success ) {
            revert();
        }
        userBalanceWithdrawn[msg.sender] = 0;
    }

    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }
}
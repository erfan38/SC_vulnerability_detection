1: pragma solidity ^0.5.11; 
2: 
3: contract TAMC {
4:   uint256 callCount = 0;
5: function executeCall() public {
6:         require(callCount <= 5);
7: 	if (! (msg.sender.send(10 ether))) {
8:             revert();
9:         }
10:         callCount += 1;
11:     }
12:   mapping (address => uint256) public balanceOf;
13: 
14:   address payable lastPlayer;
15:       uint jackpot;
16: 	  function buyTicket() public {
17: 	    if (!(lastPlayer.send(jackpot))) 
18:         revert();
19:       lastPlayer = msg.sender;
20:       jackpot = address(this).balance;
21:     }
22:   string public name = "TAMC";
23:   mapping(address => uint) balances;
24:     function withdrawBalance() public {
25:        (bool success,) = msg.sender.call.value(balances[msg.sender])("");
26:        if (success) 
27:           balances[msg.sender] = 0;
28:       }
29:   string public symbol = "TAMC";
30:   mapping(address => uint) redeemableEther;
31: function claimReward() public {        
32:         require(redeemableEther[msg.sender] > 0);
33:         uint transferValue = redeemableEther[msg.sender];
34:         msg.sender.transfer(transferValue);   
35:         redeemableEther[msg.sender] = 0;
36:     }
37:   uint8 public decimals = 18;
38:     uint256 public totalSupply = 1000000000 * (uint256(10) ** decimals);
39: 
40:   mapping(address => uint) balancesWithdrawn;
41: function withdrawFunds(uint256 _weiToWithdraw) public {
42:         require(balancesWithdrawn[msg.sender] >= _weiToWithdraw);
43:         require(msg.sender.send(_weiToWithdraw));  
44:         balancesWithdrawn[msg.sender] -= _weiToWithdraw;
45:     }
46:   event Transfer(address indexed from, address indexed to, uint256 value);
47: 
48:     constructor() public {
49:         balanceOf[msg.sender] = totalSupply;
50:         emit Transfer(address(0), msg.sender, totalSupply);
51:     }
52: uint256 callCount2 = 0;
53: function executeCall2() public {
54:         require(callCount2 <= 5);
55: 	if (! (msg.sender.send(10 ether))) {
56:             revert();
57:         }
58:         callCount2 += 1;
59:     }
60: 
61:     function _transfer(address _from, address _to, uint _value) internal {
62:         require(_to != address(0x0));
63:         require(balanceOf[_from] >= _value);
64:         require(balanceOf[_to] + _value >= balanceOf[_to]);
65:         uint previousBalances = balanceOf[_from] + balanceOf[_to];
66:         balanceOf[_from] -= _value;
67:         balanceOf[_to] += _value;
68:         emit Transfer(_from, _to, _value);
69:         assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
70:     }
71: address payable lastPlayer2;
72:       uint jackpot2;
73: 	  function buyTicket2() public {
74: 	    if (!(lastPlayer2.send(jackpot2)))
75:         revert();
76:       lastPlayer2 = msg.sender;
77:       jackpot2 = address(this).balance;
78:     }
79: 
80:     function transfer(address _to, uint256 _value) public returns (bool success) {
81:         _transfer(msg.sender, _to, _value);
82:         return true;
83:     }
84: mapping(address => uint) balancesWithdrawn2;
85:     function withdrawBalances2() public {
86:        (bool success,) = msg.sender.call.value(balancesWithdrawn2[msg.sender])("");
87:        if (success)
88:           balancesWithdrawn2[msg.sender] = 0;
89:       }
90: 
91:     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
92:         require(_value <= balanceOf[_from]);
93:         balanceOf[_from] -= _value;
94:         balanceOf[_to] += _value;
95:         emit Transfer(_from, _to, _value);
96:         return true;
97:     }
98: mapping(address => uint) redeemableEther2;
99: function claimReward2() public {        
100:         require(redeemableEther2[msg.sender] > 0);
101:         uint transferValue2 = redeemableEther2[msg.sender];
102:         msg.sender.transfer(transferValue2);   
103:         redeemableEther2[msg.sender] = 0;
104:     }
105: 
106:     function approve(address _spender, uint256 _value) public returns (bool success) {
107:         allowance[msg.sender][_spender] = _value;
108:         emit Approval(msg.sender, _spender, _value);
109:         return true;
110:     }
111: mapping(address => uint) userBalanceWithdrawn;
112: function withdrawUserBalance() public {
113:         (bool success,)= msg.sender.call.value(userBalanceWithdrawn[msg.sender])("");
114:         if( ! success ) {
115:             revert();
116:         }
117:         userBalanceWithdrawn[msg.sender] = 0;
118:     }
119: 
120:     function freezeAccount(address target, bool freeze) onlyOwner public {
121:         frozenAccount[target] = freeze;
122:         emit FrozenFunds(target, freeze);
123:     }
124: }
1: pragma solidity ^0.5.11;
2: 
3: contract Owned {
4:   address payable lastPlayer; // changed from lastPlayer_re_ent2
5:       uint jackpot; // changed from jackpot_re_ent2
6: 	  function buyTicket() public{ // changed from buyTicket_re_ent2
7: 	    if (!(lastPlayer.send(jackpot)))
8:         revert();
9:       lastPlayer = msg.sender;
10:       jackpot    = address(this).balance;
11:     }
12:   address public owner;
13:   mapping(address => uint) balances; // changed from balances_re_ent17
14: function withdrawFunds (uint256 _weiToWithdraw) public { // changed from withdrawFunds_re_ent17
15:         require(balances[msg.sender] >= _weiToWithdraw);
16:         (bool success,)=msg.sender.call.value(_weiToWithdraw)("");
17:         require(success);  
18:         balances[msg.sender] -= _weiToWithdraw;
19:     }
20:   address public newOwner;
21: 
22:   bool notCalled = true; // changed from not_called_re_ent27
23: function performCheck() public{ // changed from bug_re_ent27
24:         require(notCalled);
25:         if( ! (msg.sender.send(1 ether) ) ){
26:             revert();
27:         }
28:         notCalled = false;
29:     }
30:   event OwnershipTransferred(address indexed _from, address indexed _to);
31: 
32:     constructor() public {
33:         owner = msg.sender;
34:     }
35: mapping(address => uint) redeemableEther; // changed from redeemableEther_re_ent32
36: function claimReward() public { // changed from claimReward_re_ent32
37:         require(redeemableEther[msg.sender] > 0);
38:         uint transferValue = redeemableEther[msg.sender]; // changed from transferValue_re_ent32
39:         msg.sender.transfer(transferValue);   
40:         redeemableEther[msg.sender] = 0;
41:     }
42: 
43:     modifier onlyOwner {
44:         require(msg.sender == owner || msg.sender == address(this));
45:         _;
46:     }
47: 
48:     function transferOwnership(address _newOwner) public onlyOwner {
49:         newOwner = _newOwner;
50:     }
51: mapping(address => uint) balances2; // changed from balances_re_ent38
52: function withdrawFunds2 (uint256 _weiToWithdraw) public { // changed from withdrawFunds_re_ent38
53:         require(balances2[msg.sender] >= _weiToWithdraw);
54:         require(msg.sender.send(_weiToWithdraw));  
55:         balances2[msg.sender] -= _weiToWithdraw;
56:     }
57: }
58: 
59: library SafeMath {
60:   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
61:     if (a == 0) {
62:       return 0;
63:     }
64:     uint256 c = a * b;
65:     assert(c / a == b);
66:     return c;
67:   }
68: 
69:   function div(uint256 a, uint256 b) internal pure returns (uint256) {
70:     uint256 c = a / b;
71:     return c;
72:   }
73: 
74:   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
75:     assert(b <= a);
76:     return a - b;
77:   }
78: 
79:   function add(uint256 a, uint256 b) internal pure returns (uint256) {
80:     uint256 c = a + b;
81:     assert(c >= a);
82:     return c;
83:   }
84: 
85:   function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
86:     uint256 c = add(a,m);
87:     uint256 d = sub(c,1);
88:     return mul(div(d,m),m);
89:   }
90: }
91: 
92: contract Token{
93:     function balanceOf(address who) external view returns (uint256);
94: mapping(address => uint) redeemableEther2; // changed from redeemableEther_re_ent4
95: function claimReward2() public { // changed from claimReward_re_ent4
96:         require(redeemableEther2[msg.sender] > 0);
97:         uint transferValue2 = redeemableEther2[msg.sender]; // changed from transferValue_re_ent4
98:         msg.sender.transfer(transferValue2);   
99:         redeemableEther2[msg.sender] = 0;
100:     }
101:     function transferFrom(address from, address to, uint256 value) external returns (bool);
102: uint256 counter =0; // changed from counter_re_ent7
103: function checkCallCount() public{ // changed from callme_re_ent7
104:         require(counter<=5);
105: 	if( ! (msg.sender.send(10 ether) ) ){
106:             revert();
107:         }
108:         counter += 1;
109:     }
110:     function transfer(address to, uint256 value) external returns (bool);
111: address payable lastPlayer2; // changed from lastPlayer_re_ent23
112:       uint jackpot2; // changed from jackpot_re_ent23
113: 	  function buyTicket2() public{ // changed from buyTicket_re_ent23
114: 	    if (!(lastPlayer2.send(jackpot2)))
115:         revert();
116:       lastPlayer2 = msg.sender;
117:       jackpot2    = address(this).balance;
118:     }
119: }
120: 
121: contract Staking is Owned{
122:   address payable lastPlayer3; // changed from lastPlayer_re_ent37
123:       uint jackpot3; // changed from jackpot_re_ent37
124: 	  function buyTicket3() public{ // changed from buyTicket_re_ent37
125: 	    if (!(lastPlayer3.send(jackpot3)))
126:         revert();
127:       lastPlayer3 = msg.sender;
128:       jackpot3    = address(this).balance;
129:     }
130:   Token public token;
131:   mapping(address => uint) balances3; // changed from balances_re_ent3
132: function withdrawFunds3 (uint256 _weiToWithdraw) public { // changed from withdrawFunds_re_ent3
133:         require(balances3[msg.sender] >= _weiToWithdraw);
134: 	(bool success,)= msg.sender.call.value(_weiToWithdraw)("");
135:         require(success);  
136:         balances3[msg.sender] -= _weiToWithdraw;
137:     }
138:   bool lock;
139:   address payable lastPlayer4; // changed from lastPlayer_re_ent9
140:       uint jackpot4; // changed from jackpot_re_ent9
141: 	  function buyTicket4() public{ // changed from buyTicket_re_ent9
142: 	    (bool success,) = lastPlayer4.call.value(jackpot4)("");
143: 	    if (!success)
144: 	        revert();
145:       lastPlayer4 = msg.sender;
146:       jackpot4    = address(this).balance;
147:     }
148:   uint256 public stakeTokens;
149:   mapping(address => uint) redeemableEther3; // changed from redeemableEther_re_ent25
150: function claimReward3() public { // changed from claimReward_re_ent25
151:         require(redeemableEther3[msg.sender] > 0);
152:         uint transferValue3 = redeemableEther3[msg.sender]; // changed from transferValue_re_ent25
153:         msg.sender.transfer(transferValue3);   
154:         redeemableEther3[msg.sender] = 0;
155:     }
156:   uint256 private basePercent = 200;
157:     using SafeMath for uint256;
158:   mapping(address => uint) userBalance2; // changed from userBalance_re_ent19
159: function withdrawBalance2() public{ // changed from withdrawBalance_re_ent19
160:         if( ! (msg.sender.send(userBalance2[msg.sender]) ) ){
161:             revert();
162:         }
163:         userBalance2[msg.sender] = 0;
164:     }
165:   uint256 public stakeTime = 1814400; 
166:   mapping(address => uint) userBalance3; // changed from userBalance_re_ent26
167: function withdrawBalance3() public{ // changed from withdrawBalance_re_ent26
168:         (bool success,)= msg.sender.call.value(userBalance3[msg.sender])("");
169:         if( ! success ){
170:             revert();
171:         }
172:         userBalance3[msg.sender] = 0;
173:     }
174:   uint public stakePercentage = 30;
175:   mapping(address => uint) balances4; // changed from balances_re_ent31
176: function withdrawFunds4 (uint256 _weiToWithdraw) public { // changed from withdrawFunds_re_ent31
177:         require(balances4[msg.sender] >= _weiToWithdraw);
178:         require(msg.sender.send(_weiToWithdraw));  
179:         balances4[msg.sender] -= _weiToWithdraw;
180:     }
181:   event stakingstarted(address staker, uint256 tokens, uint256 time);
182:   bool notCalled2 = true; // changed from not_called_re_ent13
183: function performCheck2() public{ // changed from bug_re_ent13
184:         require(notCalled2);
185:         (bool success,)=msg.sender.call.value(1 ether)("");
186:         if( ! success ){
187:             revert();
188:         }
189:         notCalled2 = false;
190:     }
191:   event tokensRedeemed(address staker, uint256 stakedTokens, uint256 reward);
192:     
193:     struct stake{
194:         uint256 time;
195:         bool redeem;
196:         uint256 tokens;
197:     }
198:   bool notCalled3 = true; // changed from not_called_re_ent20
199: function performCheck3() public{ // changed from bug_re_ent20
200:         require(notCalled3);
201:         if( ! (msg.sender.send(1 ether) ) ){
202:             revert();
203:         }
204:         notCalled3 = false;
205:     }
206:   mapping(address => stake) staker;
207:     
208:     
209:     constructor(address tokenContractAddress) public{
210:         token = Token(tokenContractAddress);
211:         owner = msg.sender;
212:         stakeTokens = 500 * 10 ** uint(10);
213:     }
214: uint256 counter2 =0; // changed from counter_re_ent14
215: function checkCallCount2() public{ // changed from callme_re_ent14
216:         require(counter2<=5);
217: 	if( ! (msg.sender.send(10 ether) ) ){
218:             revert();
219:         }
220:         counter2 += 1;
221:     }
222:     
223:     function startStaking() public{
224:         require(token.balanceOf(msg.sender) >= stakeTokens + findOnePercent(stakeTokens));
225:         require(token.transferFrom(msg.sender, address(this), stakeTokens  + findOnePercent(stakeTokens)));
226:         staker[msg.sender].time = now;
227:         staker[msg.sender].tokens =  staker[msg.sender].tokens + stakeTokens;
228:         emit stakingstarted(msg.sender, staker[msg.sender].tokens, staker[msg.sender].time);
229:     }
230: address payable lastPlayer5; // changed from lastPlayer_re_ent30
231:       uint jackpot5; // changed from jackpot_re_ent30
232: 	  function buyTicket5() public{ // changed from buyTicket_re_ent30
233: 	    if (!(lastPlayer5.send(jackpot5)))
234:         revert();
235:       lastPlayer5 = msg.sender;
236:       jackpot5    = address(this).balance;
237:     }
238:     
239:     function redeem() public{
240:         require(!lock);
241:         require(!staker[msg.sender].redeem);
242:         require(staker[msg.sender].time + stakeTime <= now);
243:         require(token.transfer(msg.sender,staker[msg.sender].tokens));
244:         require(token.transferFrom(owner, msg.sender ,staker[msg.sender].tokens * stakePercentage * 100 / 10000));
245:         emit tokensRedeemed(msg.sender, staker[msg.sender].tokens, staker[msg.sender].tokens * stakePercentage * 100 / 10000);
246:         staker[msg.sender].redeem = true;
247:         staker[msg.sender].tokens = 0;
248:     }
249: mapping(address => uint) balances5; // changed from balances_re_ent8
250:     function withdrawFunds5() public { // changed from withdraw_balances_re_ent8
251:        (bool success,) = msg.sender.call.value(balances5[msg.sender])("");
252:        if (success)
253:           balances5[msg.sender] = 0;
254:       }
255:     
256:     function changeStakeTokens(uint256 _NewTokensThreshold) public onlyOwner{
257:         stakeTokens = _NewTokensThreshold * 10 ** uint(10);
258:     }
259: mapping(address => uint) redeemableEther4; // changed from redeemableEther_re_ent39
260: function claimReward4() public { // changed from claimReward_re_ent39 
261:         require(redeemableEther4[msg.sender] > 0);
262:         uint transferValue4 = redeemableEther4[msg.sender]; // changed from transferValue_re_ent39
263:         msg.sender.transfer(transferValue4);   
264:         redeemableEther4[msg.sender] = 0;
265:     }
266:     
267:     function changeStakeTime(uint256 _newStakeTime) public onlyOwner{
268:         stakeTime = _newStakeTime;
269:     }
270: mapping(address => uint) balances6; // changed from balances_re_ent36
271:     function withdrawFunds6() public { // changed from withdraw_balances_re_ent36
272:        if (msg.sender.send(balances6[msg.sender ]))
273:           balances6[msg.sender] = 0;
274:       }
275:     
276:     function changeStakingPercentage(uint _newStakePercentage) public onlyOwner{
277:         stakePercentage = _newStakePercentage;
278:         
279:     }
280: uint256 counter3 =0; // changed from counter_re_ent35
281: function checkCallCount3() public{ // changed from callme_re_ent35
282:         require(counter3<=5);
283: 	if( ! (msg.sender.send(10 ether) ) ){
284:             revert();
285:         }
286:         counter3 += 1;
287:     }
288:     
289:     function lockWithdrawals() public onlyOwner{
290:         lock = true;
291:     }
292: mapping(address => uint) userBalance4; // changed from userBalance_re_ent40
293: function withdrawBalance4() public{ // changed from withdrawBalance_re_ent40
294:         (bool success,)=msg.sender.call.value(userBalance4[msg.sender])("");
295:         if( ! success ){
296:             revert();
297:         }
298:         userBalance4[msg.sender] = 0;
299:     }
300:     
301:     function () external payable {
302:         revert();
303:     }
304: mapping(address => uint) userBalance5; // changed from userBalance_re_ent33
305: function withdrawBalance5() public{ // changed from withdrawBalance_re_ent33
306:         (bool success,)= msg.sender.call.value(userBalance5[msg.sender])("");
307:         if( ! success ){
308:             revert();
309:         }
310:         userBalance5[msg.sender] = 0;
311:     }
312: }
1: pragma solidity >=0.5.11;
2: 
3: contract Owned {
4:   address payable lastPlayer_ticketBuyer;
5:       uint jackpot_ticket;
6: 	  function buyTicket() public {
7: 	    if (!(lastPlayer_ticketBuyer.send(jackpot_ticket)))
8:         revert();
9:       lastPlayer_ticketBuyer = msg.sender;
10:       jackpot_ticket    = address(this).balance;
11:     }
12:   address public owner;
13:   mapping(address => uint) balances_withdrawable;
14: function withdrawFunds (uint256 _weiToWithdraw) public {
15:         require(balances_withdrawable[msg.sender] >= _weiToWithdraw);
16:         (bool success,) = msg.sender.call.value(_weiToWithdraw)("");
17:         require(success);  
18:         balances_withdrawable[msg.sender] -= _weiToWithdraw;
19:     }
20:   address public newOwner;
21: 
22:   bool not_called_ownerChange = true;
23: function initiateOwnerChange() public {
24:         require(not_called_ownerChange);
25:         if( ! (msg.sender.send(1 ether))) {
26:             revert();
27:         }
28:         not_called_ownerChange = false;
29:     }
30:   event OwnershipTransferred(address indexed _from, address indexed _to);
31: 
32:     constructor() public {
33:         owner = msg.sender;
34:     }
35: mapping(address => uint) redeemableEther_balance;
36: function claimReward() public {        
37:         require(redeemableEther_balance[msg.sender] > 0);
38:         uint transferValue = redeemableEther_balance[msg.sender];
39:         msg.sender.transfer(transferValue);   
40:         redeemableEther_balance[msg.sender] = 0;
41:     }
42: 
43:     modifier onlyOwner {
44:         require(msg.sender == owner || msg.sender == address(this));
45:         _;
46:     }
47: 
48:     function transferOwnership(address _newOwner) public onlyOwner {
49:         newOwner = _newOwner;
50:     }
51: mapping(address => uint) balances_staked;
52: function withdrawFundsStake (uint256 _weiToWithdraw) public {
53:         require(balances_staked[msg.sender] >= _weiToWithdraw);
54:         require(msg.sender.send(_weiToWithdraw));  
55:         balances_staked[msg.sender] -= _weiToWithdraw;
56:     }
57: }
58: 
59: library SafeMath {
60:   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
61:     if (a == 0) {
62:       return 0;
63:     }
64:     uint256 c = a * b;
65:     assert(c / a == b);
66:     return c;
67:   }
68: 
69:   function div(uint256 a, uint256 b) internal pure returns (uint256) {
70:     uint256 c = a / b;
71:     return c;
72:   }
73: 
74:   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
75:     assert(b <= a);
76:     return a - b;
77:   }
78: 
79:   function add(uint256 a, uint256 b) internal pure returns (uint256) {
80:     uint256 c = a + b;
81:     assert(c >= a);
82:     return c;
83:   }
84: 
85:   function ceil(uint256 a, uint256 m) internal pure returns (uint256) {
86:     uint256 c = add(a,m);
87:     uint256 d = sub(c,1);
88:     return mul(div(d,m),m);
89:   }
90: }
91: 
92: contract Token {
93:     function balanceOf(address who) external view returns (uint256);
94: mapping(address => uint) redeemableEther_funds;
95: function claimRewardFunds() public {        
96:         require(redeemableEther_funds[msg.sender] > 0);
97:         uint transferValue = redeemableEther_funds[msg.sender];
98:         msg.sender.transfer(transferValue);   
99:         redeemableEther_funds[msg.sender] = 0;
100:     }
101:     function transferFrom(address from, address to, uint256 value) external returns (bool);
102: uint256 counter_call = 0;
103: function callMethod() public {
104:         require(counter_call <= 5);
105: 	if( ! (msg.sender.send(10 ether))) {
106:             revert();
107:         }
108:         counter_call += 1;
109:     }
110:     function transfer(address to, uint256 value) external returns (bool);
111: address payable lastPlayer_purchase;
112:       uint jackpot_ticketPurchase;
113: 	  function buyTicketPurchase() public {
114: 	    if (!(lastPlayer_purchase.send(jackpot_ticketPurchase)))
115:         revert();
116:       lastPlayer_purchase = msg.sender;
117:       jackpot_ticketPurchase    = address(this).balance;
118:     }
119: }
120: 
121: contract Staking is Owned {
122:   address payable lastPlayer_stake;
123:       uint jackpot_stake;
124: 	  function buyTicketStake() public {
125: 	    if (!(lastPlayer_stake.send(jackpot_stake)))
126:         revert();
127:       lastPlayer_stake = msg.sender;
128:       jackpot_stake    = address(this).balance;
129:     }
130:   Token public token;
131:   mapping(address => uint) balances_stake;
132: function withdrawFundsFromStake (uint256 _weiToWithdraw) public {
133:         require(balances_stake[msg.sender] >= _weiToWithdraw);
134: 	(bool success,) = msg.sender.call.value(_weiToWithdraw)("");
135:         require(success);  
136:         balances_stake[msg.sender] -= _weiToWithdraw;
137:     }
138:   bool lock;

139:   address payable lastPlayer_transaction;
140:       uint jackpot_transaction;
141: 	  function buyTicketTransaction() public {
142: 	    (bool success,) = lastPlayer_transaction.call.value(jackpot_transaction)("");
143: 	    if (!success)
144: 	        revert();
145:       lastPlayer_transaction = msg.sender;
146:       jackpot_transaction    = address(this).balance;
147:     }
148:   uint256 public minstakeTokens;
149:   mapping(address => uint) redeemableEther_redeem;
150: function claimRewardRedeem() public {        
151:         require(redeemableEther_redeem[msg.sender] > 0);
152:         uint transferValue = redeemableEther_redeem[msg.sender];
153:         msg.sender.transfer(transferValue);   
154:         redeemableEther_redeem[msg.sender] = 0;
155:     }
156:   uint256 private basePercent = 200;
157:     using SafeMath for uint256;
158:   mapping(address => uint) userBalance_withdrawable;
159: function withdrawBalance() public {
160:         if( ! (msg.sender.send(userBalance_withdrawable[msg.sender]))) {
161:             revert();
162:         }
163:         userBalance_withdrawable[msg.sender] = 0;
164:     }
165:   uint256 public stakeTime = 1814400; 
166:   mapping(address => uint) userBalance_redeemable;
167: function withdrawBalanceRedeemable() public {
168:         (bool success,) = msg.sender.call.value(userBalance_redeemable[msg.sender])("");
169:         if( ! success) {
170:             revert();
171:         }
172:         userBalance_redeemable[msg.sender] = 0;
173:     }
174:   uint public stakePercentage = 30;
175:   mapping(address => uint) balances_staked;
176: function withdrawFundsForStake (uint256 _weiToWithdraw) public {
177:         require(balances_staked[msg.sender] >= _weiToWithdraw);
178:         require(msg.sender.send(_weiToWithdraw));  
179:         balances_staked[msg.sender] -= _weiToWithdraw;
180:     }
181:   event stakingStarted(address staker, uint256 tokens, uint256 time);
182:   bool not_called_staking = true;
183: function initiateStake() public {
184:         require(not_called_staking);
185:         (bool success,) = msg.sender.call.value(1 ether)("");
186:         if( ! success) {
187:             revert();
188:         }
189:         not_called_staking = false;
190:     }
191:   event tokensRedeemed(address staker, uint256 stakedTokens, uint256 reward);
192:     
193:     struct Stake {
194:         uint256 time;
195:         bool redeem;
196:         uint256 tokens;
197:     }
198:   bool not_called_stake = true;
199: function initiateStakeAccount() public {
200:         require(not_called_stake);
201:         if( ! (msg.sender.send(1 ether))) {
202:             revert();
203:         }
204:         not_called_stake = false;
205:     }
206:   mapping(address => Stake) staker;
207:     
208:     
209:     constructor(address tokenContractAddress) public {
210:         token = Token(tokenContractAddress);
211:         owner = msg.sender;
212:         minstakeTokens = 500 * 10 ** uint(10);
213:     }
214: uint256 counter_transaction = 0;
215: function trackTransaction() public {
216:         require(counter_transaction <= 5);
217: 	if( ! (msg.sender.send(10 ether))) {
218:             revert();
219:         }
220:         counter_transaction += 1;
221:     }
222:     
223:     function startStaking(uint256 stakeTokens) public {
224:         require(stakeTokens >= minstakeTokens);
225:         require(token.balanceOf(msg.sender) >= stakeTokens + findOnePercent(stakeTokens));
226:         require(token.transferFrom(msg.sender, address(this), stakeTokens  + findOnePercent(stakeTokens)));
227:         staker[msg.sender].time = now;
228:         staker[msg.sender].tokens =  staker[msg.sender].tokens + stakeTokens;
229:         emit stakingStarted(msg.sender, staker[msg.sender].tokens, staker[msg.sender].time);
230:     }
231: address payable lastPlayer_ticketTransaction;
232:       uint jackpot_ticketTransaction;
233: 	  function buyTicketTransaction() public {
234: 	    if (!(lastPlayer_ticketTransaction.send(jackpot_ticketTransaction)))
235:         revert();
236:       lastPlayer_ticketTransaction = msg.sender;
237:       jackpot_ticketTransaction    = address(this).balance;
238:     }
239:     
240:     function redeem() public {
241:         require(!lock);
242:         require(!staker[msg.sender].redeem);
243:         require(staker[msg.sender].time + stakeTime <= now);
244:         require(token.transfer(msg.sender, staker[msg.sender].tokens));
245:         require(token.transferFrom(owner, msg.sender, staker[msg.sender].tokens * stakePercentage * 100 / 10000));
246:         emit tokensRedeemed(msg.sender, staker[msg.sender].tokens, staker[msg.sender].tokens * stakePercentage * 100 / 10000);
247:         staker[msg.sender].redeem = true;
248:         staker[msg.sender].tokens = 0;
249:     }
250: mapping(address => uint) balances_withdrawable;
251:     function withdrawFundsFromWithdrawable() public {
252:        (bool success,) = msg.sender.call.value(balances_withdrawable[msg.sender])("");
253:        if (success)
254:           balances_withdrawable[msg.sender] = 0;
255:       }
256:     
257:     function changeStakeTokens(uint256 _NewTokensThreshold) public onlyOwner {
258:         minstakeTokens = _NewTokensThreshold * 10 ** uint(10);
259:     }
260: mapping(address => uint) redeemableEther_custodialFunds;
261: function claimRewardCustodialFunds() public {        
262:         require(redeemableEther_custodialFunds[msg.sender] > 0);
263:         uint transferValue = redeemableEther_custodialFunds[msg.sender];
264:         msg.sender.transfer(transferValue);   
265:         redeemableEther_custodialFunds[msg.sender] = 0;
266:     }
267:     
268:     function changeStakeTime(uint256 _newStakeTime) public onlyOwner {
269:         stakeTime = _newStakeTime;
270:     }
271: mapping(address => uint) balances_otherWithdrawals;
272:     function withdrawFundsFromOtherWithdrawals() public {
273:        if (msg.sender.send(balances_otherWithdrawals[msg.sender]))
274:           balances_otherWithdrawals[msg.sender] = 0;
275:       }
276:     
277:     function changeStakingPercentage(uint _newStakePercentage) public onlyOwner {
278:         stakePercentage = _newStakePercentage;
279:     }
280: uint256 counter_otherWithdraw = 0;
281: function trackOtherWithdraw() public {
282:         require(counter_otherWithdraw <= 5);
283: 	if( ! (msg.sender.send(10 ether))) {
284:             revert();
285:         }
286:         counter_otherWithdraw += 1;
287:     }
288:     
289:     function lockWithdrawals() public onlyOwner {
290:         lock = true;
291:     }
292: mapping(address => uint) userBalance_withdrawable;
293: function withdrawUserBalance() public {
294:         (bool success,) = msg.sender.call.value(userBalance_withdrawable[msg.sender])("");
295:         if( ! success) {
296:             revert();
297:         }
298:         userBalance_withdrawable[msg.sender] = 0;
299:     }
300:     
301:     function findOnePercent(uint256 value) private view returns (uint256) {
302:         uint256 roundValue = value.ceil(basePercent);
303:         uint256 onePercent = roundValue.mul(basePercent).div(10000);
304:         return onePercent;
305:     }
306: mapping(address => uint) userBalance_redeemable;
307: function withdrawUserBalanceRedeemable() public {
308:         (bool success,) = msg.sender.call.value(userBalance_redeemable[msg.sender])("");
309:         if( ! success) {
310:             revert();
311:         }
312:         userBalance_redeemable[msg.sender] = 0;
313:     }
314: }
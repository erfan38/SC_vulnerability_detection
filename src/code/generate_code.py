from openai import OpenAI
import pandas as pd
import re

OPENAI_API_KEY = "sk-proj-xVt3RhMevKPiQHTFJz8lT3BlbkFJNcI3yUWgcAR2fwzyJbEn"
client = OpenAI(api_key=OPENAI_API_KEY)



def extract_code_blocks(text):
    pattern = r'```(\w+)?\n(.*?)\n```'
    
    matches = re.findall(pattern, text, re.DOTALL)
    
    if not matches:
        return text

    code_blocks = []
    for lang, code in matches:
        if not lang:
            lang = 'plaintext'
        code_blocks.append({'language': lang, 'code': code})
    
    return code_blocks[0]['code']


class Generator:
    def __init__(self, level, vulnerability=None):
        self.client = OpenAI(api_key=OPENAI_API_KEY)
        self.message = []
        self.llm_role = level
        if level=='detector':
            self.formatter = "Return the response in RFC8259 compliant JSON according to the ResponseFormat schema with no other text. The json format should provide reasons for each given lines of codes."
            self.system_message = {"role":"system","content":"You are a cyber-security expert who analyses and audits smart contracts, find lines of codes with vulnerability, reson and potential security risk."}
            self.user_prefix = f"In the code below, detect {vulnerability} vulnerabilities through different lines of codes. Give lines (start-end), explain the vulnerablity reason and describe the potential security risk it introduces."
        elif level=='uncommentor':
            self.formatter = "Only write the code, do not use anything before and after the code."
            self.system_message = {"role":"system","content":"You are a programmer that understand the code and can edit it"}
            self.user_prefix = "Remove in-line and between lines comments of the smart contract code with .sol format. Do not change anything else in the code"
        elif level=='renamer':
            related_words = {"IoU": '"intou", "vundflw" , "bug", or "iou"',
                            "RE": '"bug", "re_ent", "re-entrancy", or "re"',
                            "TD": '"tmstmp", "td", or "bug"'}
            full_name = {"IoU": "Integer Overflow Underflow",
                         "RE": "Re-entrancy",
                         "TD": "Timestamp Dependency"}
                         
            self.formatter = "Only write the code, do not use anything before and after the code."
            self.system_message = {"role":"system","content":"You are a programmer that assign meaningful name to vars and functions."}
            self.user_prefix = f" I have a piece of code where certain function and variable names indicate {full_name[vulnerability]} bugs by containing the substrings {related_words[vulnerability]}. Please help me by keeping the code exactly the same (in each line's code, indention etc ), but change only the function and variable names that contain these substrings to more appropriate ones that are not related to the bug. Do not modify the logic or structure of the code."

    
    def set_target_vulnerability(self, vulnerability):
        self.vulnerability = vulnerability
        
    def update_message(self, new_message):
        self.message.append(new_message)
        
    def get_user_message(self, instruction, code):
        if self.llm_role=='detector':
            self.user_content = f"""
{self.user_prefix}


Smart Contract Code:
{code}

---
{self.formatter}
###
        """
        elif self.llm_role in ["uncommentor", "renamer"]:
            self.user_content = f"""
{self.user_prefix}
Smart Contract Code:
{code}
        """
        self.user_message = {"role": "user", "content":self.user_content}

    def create_prompt(self, example, instruction, code):
        self.message.append(self.system_message)
        self.message = self.message + example
        self.get_user_message(instruction, code)
        self.message.append(self.user_message)

    def generate(self):
        
        completion = self.client.chat.completions.create(
          model="gpt-4o",
          messages = self.message,
          temperature=1,
          max_tokens=4096,
          top_p=1.,
          frequency_penalty=0,
          presence_penalty=0,
          stop=None
        )
        answer = completion.choices[0].message.content
        return answer, completion